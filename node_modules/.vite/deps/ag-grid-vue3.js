import {
  createVNode,
  defineComponent,
  getCurrentInstance,
  h,
  markRaw,
  render,
  toRaw
} from "./chunk-ZV5R4Z6I.js";
import "./chunk-RSJERJUL.js";

// node_modules/ag-grid-community/dist/ag-grid-community.auto.esm.js
function makeNull(value) {
  if (value == null || value === "") {
    return null;
  }
  return value;
}
function exists(value, allowEmptyString = false) {
  return value != null && (value !== "" || allowEmptyString);
}
function missing(value) {
  return !exists(value);
}
function missingOrEmpty(value) {
  return value == null || value.length === 0;
}
function toStringOrNull(value) {
  return value != null && typeof value.toString === "function" ? value.toString() : null;
}
function attrToNumber(value) {
  if (value === void 0) {
    return;
  }
  if (value === null || value === "") {
    return null;
  }
  if (typeof value === "number") {
    return isNaN(value) ? void 0 : value;
  }
  const valueParsed = parseInt(value, 10);
  return isNaN(valueParsed) ? void 0 : valueParsed;
}
function attrToBoolean(value) {
  if (value === void 0) {
    return;
  }
  if (value === null || value === "") {
    return false;
  }
  if (typeof value === "boolean") {
    return value;
  }
  return /true/i.test(value);
}
function attrToString(value) {
  if (value == null || value === "") {
    return;
  }
  return value;
}
function referenceCompare(left, right) {
  if (left == null && right == null) {
    return true;
  }
  if (left == null && right != null) {
    return false;
  }
  if (left != null && right == null) {
    return false;
  }
  return left === right;
}
function jsonEquals(val1, val2) {
  const val1Json = val1 ? JSON.stringify(val1) : null;
  const val2Json = val2 ? JSON.stringify(val2) : null;
  return val1Json === val2Json;
}
function defaultComparator(valueA, valueB, accentedCompare = false) {
  const valueAMissing = valueA == null;
  const valueBMissing = valueB == null;
  if (valueA && valueA.toNumber) {
    valueA = valueA.toNumber();
  }
  if (valueB && valueB.toNumber) {
    valueB = valueB.toNumber();
  }
  if (valueAMissing && valueBMissing) {
    return 0;
  }
  if (valueAMissing) {
    return -1;
  }
  if (valueBMissing) {
    return 1;
  }
  function doQuickCompare(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }
  if (typeof valueA !== "string") {
    return doQuickCompare(valueA, valueB);
  }
  if (!accentedCompare) {
    return doQuickCompare(valueA, valueB);
  }
  try {
    return valueA.localeCompare(valueB);
  } catch (e) {
    return doQuickCompare(valueA, valueB);
  }
}
function values(object) {
  if (object instanceof Set || object instanceof Map) {
    const arr = [];
    object.forEach((value) => arr.push(value));
    return arr;
  }
  return Object.values(object);
}
var GenericUtils = Object.freeze({
  __proto__: null,
  makeNull,
  exists,
  missing,
  missingOrEmpty,
  toStringOrNull,
  attrToNumber,
  attrToBoolean,
  attrToString,
  referenceCompare,
  jsonEquals,
  defaultComparator,
  values
});
var ColumnKeyCreator = class {
  constructor() {
    this.existingKeys = {};
  }
  addExistingKeys(keys2) {
    for (let i = 0; i < keys2.length; i++) {
      this.existingKeys[keys2[i]] = true;
    }
  }
  getUniqueKey(colId, colField) {
    colId = toStringOrNull(colId);
    let count = 0;
    while (true) {
      let idToTry;
      if (colId) {
        idToTry = colId;
        if (count !== 0) {
          idToTry += "_" + count;
        }
      } else if (colField) {
        idToTry = colField;
        if (count !== 0) {
          idToTry += "_" + count;
        }
      } else {
        idToTry = "" + count;
      }
      if (!this.existingKeys[idToTry]) {
        this.existingKeys[idToTry] = true;
        return idToTry;
      }
      count++;
    }
  }
};
function iterateObject(object, callback) {
  if (object == null) {
    return;
  }
  if (Array.isArray(object)) {
    object.forEach((value, index) => callback(`${index}`, value));
  } else {
    Object.keys(object).forEach((key) => callback(key, object[key]));
  }
}
function cloneObject(object) {
  const copy = {};
  const keys2 = Object.keys(object);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const value = object[key];
    copy[key] = value;
  }
  return copy;
}
function deepCloneObject(object) {
  return JSON.parse(JSON.stringify(object));
}
function deepCloneDefinition(object, keysToSkip) {
  if (!object) {
    return;
  }
  const obj = object;
  const res = {};
  Object.keys(obj).forEach((key) => {
    if (keysToSkip && keysToSkip.indexOf(key) >= 0) {
      return;
    }
    const value = obj[key];
    const sourceIsSimpleObject = isNonNullObject(value) && value.constructor === Object;
    if (sourceIsSimpleObject) {
      res[key] = deepCloneDefinition(value);
    } else {
      res[key] = value;
    }
  });
  return res;
}
function getProperty(object, key) {
  return object[key];
}
function setProperty(object, key, value) {
  object[key] = value;
}
function copyPropertiesIfPresent(source, target, ...properties) {
  properties.forEach((p) => copyPropertyIfPresent(source, target, p));
}
function copyPropertyIfPresent(source, target, property, transform) {
  const value = getProperty(source, property);
  if (value !== void 0) {
    setProperty(target, property, transform ? transform(value) : value);
  }
}
function getAllKeysInObjects(objects) {
  const allValues = {};
  objects.filter((obj) => obj != null).forEach((obj) => {
    Object.keys(obj).forEach((key) => allValues[key] = null);
  });
  return Object.keys(allValues);
}
function getAllValuesInObject(obj) {
  if (!obj) {
    return [];
  }
  const anyObject = Object;
  if (typeof anyObject.values === "function") {
    return anyObject.values(obj);
  }
  const ret = [];
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && obj.propertyIsEnumerable(key)) {
      ret.push(obj[key]);
    }
  }
  return ret;
}
function mergeDeep(dest, source, copyUndefined = true, makeCopyOfSimpleObjects = false) {
  if (!exists(source)) {
    return;
  }
  iterateObject(source, (key, sourceValue) => {
    let destValue = dest[key];
    if (destValue === sourceValue) {
      return;
    }
    if (makeCopyOfSimpleObjects) {
      const objectIsDueToBeCopied = destValue == null && sourceValue != null;
      if (objectIsDueToBeCopied) {
        const sourceIsSimpleObject = typeof sourceValue === "object" && sourceValue.constructor === Object;
        const dontCopy = sourceIsSimpleObject;
        if (dontCopy) {
          destValue = {};
          dest[key] = destValue;
        }
      }
    }
    if (isNonNullObject(sourceValue) && isNonNullObject(destValue) && !Array.isArray(destValue)) {
      mergeDeep(destValue, sourceValue, copyUndefined, makeCopyOfSimpleObjects);
    } else if (copyUndefined || sourceValue !== void 0) {
      dest[key] = sourceValue;
    }
  });
}
function missingOrEmptyObject(value) {
  return missing(value) || Object.keys(value).length === 0;
}
function get(source, expression, defaultValue) {
  if (source == null) {
    return defaultValue;
  }
  const keys2 = expression.split(".");
  let objectToRead = source;
  while (keys2.length > 1) {
    objectToRead = objectToRead[keys2.shift()];
    if (objectToRead == null) {
      return defaultValue;
    }
  }
  const value = objectToRead[keys2[0]];
  return value != null ? value : defaultValue;
}
function set(target, expression, value) {
  if (target == null) {
    return;
  }
  const keys2 = expression.split(".");
  let objectToUpdate = target;
  keys2.forEach((key, i) => {
    if (!objectToUpdate[key]) {
      objectToUpdate[key] = {};
    }
    if (i < keys2.length - 1) {
      objectToUpdate = objectToUpdate[key];
    }
  });
  objectToUpdate[keys2[keys2.length - 1]] = value;
}
function getValueUsingField(data, field, fieldContainsDots) {
  if (!field || !data) {
    return;
  }
  if (!fieldContainsDots) {
    return data[field];
  }
  const fields = field.split(".");
  let currentObject = data;
  for (let i = 0; i < fields.length; i++) {
    if (currentObject == null) {
      return void 0;
    }
    currentObject = currentObject[fields[i]];
  }
  return currentObject;
}
function removeAllReferences(obj, objectName) {
  Object.keys(obj).forEach((key) => {
    const value = obj[key];
    if (typeof value === "object") {
      obj[key] = void 0;
    }
  });
  const proto = Object.getPrototypeOf(obj);
  const properties = {};
  Object.keys(proto).forEach((key) => {
    const value = proto[key];
    if (typeof value === "function") {
      const func = () => {
        console.warn(`AG Grid: ${objectName} function ${key}() cannot be called as the grid has been destroyed.
                     Please don't call grid API functions on destroyed grids - as a matter of fact you shouldn't
                     be keeping the API reference, your application has a memory leak! Remove the API reference
                     when the grid is destroyed.`);
      };
      properties[key] = { value: func, writable: true };
    }
  });
  Object.defineProperties(obj, properties);
}
function isNonNullObject(value) {
  return typeof value === "object" && value !== null;
}
var ObjectUtils = Object.freeze({
  __proto__: null,
  iterateObject,
  cloneObject,
  deepCloneObject,
  deepCloneDefinition,
  getProperty,
  setProperty,
  copyPropertiesIfPresent,
  copyPropertyIfPresent,
  getAllKeysInObjects,
  getAllValuesInObject,
  mergeDeep,
  missingOrEmptyObject,
  get,
  set,
  getValueUsingField,
  removeAllReferences,
  isNonNullObject
});
var doOnceFlags = {};
function doOnce(func, key) {
  if (doOnceFlags[key]) {
    return;
  }
  func();
  doOnceFlags[key] = true;
}
function getFunctionName(funcConstructor) {
  if (funcConstructor.name) {
    return funcConstructor.name;
  }
  const matches = /function\s+([^\(]+)/.exec(funcConstructor.toString());
  return matches && matches.length === 2 ? matches[1].trim() : null;
}
function isFunction(val) {
  return !!(val && val.constructor && val.call && val.apply);
}
function executeInAWhile(funcs) {
  executeAfter(funcs, 400);
}
var executeNextVMTurnFuncs = [];
var executeNextVMTurnPending = false;
function executeNextVMTurn(func) {
  executeNextVMTurnFuncs.push(func);
  if (executeNextVMTurnPending) {
    return;
  }
  executeNextVMTurnPending = true;
  window.setTimeout(() => {
    const funcsCopy = executeNextVMTurnFuncs.slice();
    executeNextVMTurnFuncs.length = 0;
    executeNextVMTurnPending = false;
    funcsCopy.forEach((func2) => func2());
  }, 0);
}
function executeAfter(funcs, milliseconds = 0) {
  if (funcs.length > 0) {
    window.setTimeout(() => funcs.forEach((func) => func()), milliseconds);
  }
}
function debounce(func, delay) {
  let timeout;
  return function(...args) {
    const context = this;
    window.clearTimeout(timeout);
    timeout = window.setTimeout(function() {
      func.apply(context, args);
    }, delay);
  };
}
function throttle(func, wait) {
  let previousCall = 0;
  return function(...args) {
    const context = this;
    const currentCall = new Date().getTime();
    if (currentCall - previousCall < wait) {
      return;
    }
    previousCall = currentCall;
    func.apply(context, args);
  };
}
function waitUntil(condition, callback, timeout = 100, timeoutMessage) {
  const timeStamp = new Date().getTime();
  let interval = null;
  let executed = false;
  const internalCallback = () => {
    const reachedTimeout = new Date().getTime() - timeStamp > timeout;
    if (condition() || reachedTimeout) {
      callback();
      executed = true;
      if (interval != null) {
        window.clearInterval(interval);
        interval = null;
      }
      if (reachedTimeout && timeoutMessage) {
        console.warn(timeoutMessage);
      }
    }
  };
  internalCallback();
  if (!executed) {
    interval = window.setInterval(internalCallback, 10);
  }
}
function compose(...fns) {
  return (arg) => fns.reduce((composed, f) => f(composed), arg);
}
function callIfPresent(func) {
  if (func) {
    func();
  }
}
var noop = () => {
  return;
};
var FunctionUtils = Object.freeze({
  __proto__: null,
  doOnce,
  getFunctionName,
  isFunction,
  executeInAWhile,
  executeNextVMTurn,
  executeAfter,
  debounce,
  throttle,
  waitUntil,
  compose,
  callIfPresent,
  noop
});
var ModuleNames;
(function(ModuleNames2) {
  ModuleNames2["CommunityCoreModule"] = "@ag-grid-community/core";
  ModuleNames2["InfiniteRowModelModule"] = "@ag-grid-community/infinite-row-model";
  ModuleNames2["ClientSideRowModelModule"] = "@ag-grid-community/client-side-row-model";
  ModuleNames2["CsvExportModule"] = "@ag-grid-community/csv-export";
  ModuleNames2["EnterpriseCoreModule"] = "@ag-grid-enterprise/core";
  ModuleNames2["RowGroupingModule"] = "@ag-grid-enterprise/row-grouping";
  ModuleNames2["ColumnsToolPanelModule"] = "@ag-grid-enterprise/column-tool-panel";
  ModuleNames2["FiltersToolPanelModule"] = "@ag-grid-enterprise/filter-tool-panel";
  ModuleNames2["MenuModule"] = "@ag-grid-enterprise/menu";
  ModuleNames2["SetFilterModule"] = "@ag-grid-enterprise/set-filter";
  ModuleNames2["MultiFilterModule"] = "@ag-grid-enterprise/multi-filter";
  ModuleNames2["StatusBarModule"] = "@ag-grid-enterprise/status-bar";
  ModuleNames2["SideBarModule"] = "@ag-grid-enterprise/side-bar";
  ModuleNames2["RangeSelectionModule"] = "@ag-grid-enterprise/range-selection";
  ModuleNames2["MasterDetailModule"] = "@ag-grid-enterprise/master-detail";
  ModuleNames2["RichSelectModule"] = "@ag-grid-enterprise/rich-select";
  ModuleNames2["GridChartsModule"] = "@ag-grid-enterprise/charts";
  ModuleNames2["ViewportRowModelModule"] = "@ag-grid-enterprise/viewport-row-model";
  ModuleNames2["ServerSideRowModelModule"] = "@ag-grid-enterprise/server-side-row-model";
  ModuleNames2["ExcelExportModule"] = "@ag-grid-enterprise/excel-export";
  ModuleNames2["ClipboardModule"] = "@ag-grid-enterprise/clipboard";
  ModuleNames2["SparklinesModule"] = "@ag-grid-enterprise/sparklines";
  ModuleNames2["AngularModule"] = "@ag-grid-community/angular";
  ModuleNames2["ReactModule"] = "@ag-grid-community/react";
  ModuleNames2["VueModule"] = "@ag-grid-community/vue";
})(ModuleNames || (ModuleNames = {}));
var ModuleRegistry = class {
  static register(module, moduleBased = true, gridId = void 0) {
    ModuleRegistry.runVersionChecks(module);
    if (gridId !== void 0) {
      ModuleRegistry.areGridScopedModules = true;
      if (ModuleRegistry.gridModulesMap[gridId] === void 0) {
        ModuleRegistry.gridModulesMap[gridId] = {};
      }
      ModuleRegistry.gridModulesMap[gridId][module.moduleName] = module;
    } else {
      ModuleRegistry.globalModulesMap[module.moduleName] = module;
    }
    ModuleRegistry.setModuleBased(moduleBased);
  }
  static unRegisterGridModules(gridId) {
    delete ModuleRegistry.gridModulesMap[gridId];
  }
  static registerModules(modules, moduleBased = true, gridId = void 0) {
    ModuleRegistry.setModuleBased(moduleBased);
    if (!modules) {
      return;
    }
    modules.forEach((module) => ModuleRegistry.register(module, moduleBased, gridId));
  }
  static isValidModuleVersion(module) {
    const [moduleMajor, moduleMinor] = module.version.split(".") || [];
    const [currentModuleMajor, currentModuleMinor] = ModuleRegistry.currentModuleVersion.split(".") || [];
    return moduleMajor === currentModuleMajor && moduleMinor === currentModuleMinor;
  }
  static runVersionChecks(module) {
    if (!ModuleRegistry.currentModuleVersion) {
      ModuleRegistry.currentModuleVersion = module.version;
    }
    if (!module.version) {
      console.error(`AG Grid: You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. '${module.moduleName}' is incompatible. Please update all modules to the same version.`);
    } else if (!ModuleRegistry.isValidModuleVersion(module)) {
      console.error(`AG Grid: You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. '${module.moduleName}' is version ${module.version} but the other modules are version ${this.currentModuleVersion}. Please update all modules to the same version.`);
    }
    if (module.validate) {
      const result = module.validate();
      if (!result.isValid) {
        const errorResult = result;
        console.error(`AG Grid: ${errorResult.message}`);
      }
    }
  }
  static setModuleBased(moduleBased) {
    if (ModuleRegistry.moduleBased === void 0) {
      ModuleRegistry.moduleBased = moduleBased;
    } else {
      if (ModuleRegistry.moduleBased !== moduleBased) {
        doOnce(() => {
          console.warn(`AG Grid: You are mixing modules (i.e. @ag-grid-community/core) and packages (ag-grid-community) - you can only use one or the other of these mechanisms.`);
          console.warn("Please see https://www.ag-grid.com/javascript-grid/packages-modules/ for more information.");
        }, "ModulePackageCheck");
      }
    }
  }
  static setIsBundled() {
    ModuleRegistry.isBundled = true;
  }
  static assertRegistered(moduleName, reason, gridId) {
    var _a;
    if (this.isRegistered(moduleName, gridId)) {
      return true;
    }
    const warningKey = reason + moduleName;
    let warningMessage;
    if (ModuleRegistry.isBundled) {
      {
        warningMessage = `AG Grid: unable to use ${reason} as 'ag-grid-enterprise' has not been loaded. Check you are using the Enterprise bundle:
        
        <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@AG_GRID_VERSION/dist/ag-grid-enterprise.min.js"><\/script>
        
For more info see: https://ag-grid.com/javascript-data-grid/getting-started/#getting-started-with-ag-grid-enterprise`;
      }
    } else if (ModuleRegistry.moduleBased || ModuleRegistry.moduleBased === void 0) {
      let modName = (_a = Object.entries(ModuleNames).find(([k, v]) => v === moduleName)) === null || _a === void 0 ? void 0 : _a[0];
      warningMessage = `AG Grid: unable to use ${reason} as the ${modName} is not registered${ModuleRegistry.areGridScopedModules ? ` for gridId: ${gridId}` : ""}. Check if you have registered the module:
           
    import { ModuleRegistry } from '@ag-grid-community/core';
    import { ${modName} } from '${moduleName}';
    
    ModuleRegistry.registerModules([ ${modName} ]);

For more info see: https://www.ag-grid.com/javascript-grid/modules/`;
    } else {
      warningMessage = `AG Grid: unable to use ${reason} as package 'ag-grid-enterprise' has not been imported. Check that you have imported the package:
            
    import 'ag-grid-enterprise';
            
For more info see: https://www.ag-grid.com/javascript-grid/packages/`;
    }
    doOnce(() => {
      console.warn(warningMessage);
    }, warningKey);
    return false;
  }
  static isRegistered(moduleName, gridId) {
    var _a;
    return !!ModuleRegistry.globalModulesMap[moduleName] || !!((_a = ModuleRegistry.gridModulesMap[gridId]) === null || _a === void 0 ? void 0 : _a[moduleName]);
  }
  static getRegisteredModules(gridId) {
    return [...values(ModuleRegistry.globalModulesMap), ...values(ModuleRegistry.gridModulesMap[gridId] || {})];
  }
  static isPackageBased() {
    return !ModuleRegistry.moduleBased;
  }
};
ModuleRegistry.globalModulesMap = {};
ModuleRegistry.gridModulesMap = {};
ModuleRegistry.areGridScopedModules = false;
var Context = class {
  constructor(params, logger) {
    this.beanWrappers = {};
    this.destroyed = false;
    if (!params || !params.beanClasses) {
      return;
    }
    this.contextParams = params;
    this.logger = logger;
    this.logger.log(">> creating ag-Application Context");
    this.createBeans();
    const beanInstances = this.getBeanInstances();
    this.wireBeans(beanInstances);
    this.logger.log(">> ag-Application Context ready - component is alive");
  }
  getBeanInstances() {
    return values(this.beanWrappers).map((beanEntry) => beanEntry.beanInstance);
  }
  createBean(bean, afterPreCreateCallback) {
    if (!bean) {
      throw Error(`Can't wire to bean since it is null`);
    }
    this.wireBeans([bean], afterPreCreateCallback);
    return bean;
  }
  wireBeans(beanInstances, afterPreCreateCallback) {
    this.autoWireBeans(beanInstances);
    this.methodWireBeans(beanInstances);
    this.callLifeCycleMethods(beanInstances, "preConstructMethods");
    if (exists(afterPreCreateCallback)) {
      beanInstances.forEach(afterPreCreateCallback);
    }
    this.callLifeCycleMethods(beanInstances, "postConstructMethods");
  }
  createBeans() {
    this.contextParams.beanClasses.forEach(this.createBeanWrapper.bind(this));
    iterateObject(this.beanWrappers, (key, beanEntry) => {
      let constructorParamsMeta;
      if (beanEntry.bean.__agBeanMetaData && beanEntry.bean.__agBeanMetaData.autowireMethods && beanEntry.bean.__agBeanMetaData.autowireMethods.agConstructor) {
        constructorParamsMeta = beanEntry.bean.__agBeanMetaData.autowireMethods.agConstructor;
      }
      const constructorParams = this.getBeansForParameters(constructorParamsMeta, beanEntry.bean.name);
      const newInstance = new (beanEntry.bean.bind.apply(beanEntry.bean, [null, ...constructorParams]))();
      beanEntry.beanInstance = newInstance;
    });
    const createdBeanNames = Object.keys(this.beanWrappers).join(", ");
    this.logger.log(`created beans: ${createdBeanNames}`);
  }
  createBeanWrapper(BeanClass) {
    const metaData = BeanClass.__agBeanMetaData;
    if (!metaData) {
      let beanName;
      if (BeanClass.prototype.constructor) {
        beanName = getFunctionName(BeanClass.prototype.constructor);
      } else {
        beanName = "" + BeanClass;
      }
      console.error(`Context item ${beanName} is not a bean`);
      return;
    }
    const beanEntry = {
      bean: BeanClass,
      beanInstance: null,
      beanName: metaData.beanName
    };
    this.beanWrappers[metaData.beanName] = beanEntry;
  }
  autoWireBeans(beanInstances) {
    beanInstances.forEach((beanInstance) => {
      this.forEachMetaDataInHierarchy(beanInstance, (metaData, beanName) => {
        const attributes = metaData.agClassAttributes;
        if (!attributes) {
          return;
        }
        attributes.forEach((attribute) => {
          const otherBean = this.lookupBeanInstance(beanName, attribute.beanName, attribute.optional);
          beanInstance[attribute.attributeName] = otherBean;
        });
      });
    });
  }
  methodWireBeans(beanInstances) {
    beanInstances.forEach((beanInstance) => {
      this.forEachMetaDataInHierarchy(beanInstance, (metaData, beanName) => {
        iterateObject(metaData.autowireMethods, (methodName, wireParams) => {
          if (methodName === "agConstructor") {
            return;
          }
          const initParams = this.getBeansForParameters(wireParams, beanName);
          beanInstance[methodName].apply(beanInstance, initParams);
        });
      });
    });
  }
  forEachMetaDataInHierarchy(beanInstance, callback) {
    let prototype = Object.getPrototypeOf(beanInstance);
    while (prototype != null) {
      const constructor = prototype.constructor;
      if (constructor.hasOwnProperty("__agBeanMetaData")) {
        const metaData = constructor.__agBeanMetaData;
        const beanName = this.getBeanName(constructor);
        callback(metaData, beanName);
      }
      prototype = Object.getPrototypeOf(prototype);
    }
  }
  getBeanName(constructor) {
    if (constructor.__agBeanMetaData && constructor.__agBeanMetaData.beanName) {
      return constructor.__agBeanMetaData.beanName;
    }
    const constructorString = constructor.toString();
    const beanName = constructorString.substring(9, constructorString.indexOf("("));
    return beanName;
  }
  getBeansForParameters(parameters, beanName) {
    const beansList = [];
    if (parameters) {
      iterateObject(parameters, (paramIndex, otherBeanName) => {
        const otherBean = this.lookupBeanInstance(beanName, otherBeanName);
        beansList[Number(paramIndex)] = otherBean;
      });
    }
    return beansList;
  }
  lookupBeanInstance(wiringBean, beanName, optional = false) {
    if (this.destroyed) {
      this.logger.log(`AG Grid: bean reference ${beanName} is used after the grid is destroyed!`);
      return null;
    }
    if (beanName === "context") {
      return this;
    }
    if (this.contextParams.providedBeanInstances && this.contextParams.providedBeanInstances.hasOwnProperty(beanName)) {
      return this.contextParams.providedBeanInstances[beanName];
    }
    const beanEntry = this.beanWrappers[beanName];
    if (beanEntry) {
      return beanEntry.beanInstance;
    }
    if (!optional) {
      console.error(`AG Grid: unable to find bean reference ${beanName} while initialising ${wiringBean}`);
    }
    return null;
  }
  callLifeCycleMethods(beanInstances, lifeCycleMethod) {
    beanInstances.forEach((beanInstance) => this.callLifeCycleMethodsOnBean(beanInstance, lifeCycleMethod));
  }
  callLifeCycleMethodsOnBean(beanInstance, lifeCycleMethod, methodToIgnore) {
    const allMethods = {};
    this.forEachMetaDataInHierarchy(beanInstance, (metaData) => {
      const methods = metaData[lifeCycleMethod];
      if (methods) {
        methods.forEach((methodName) => {
          if (methodName != methodToIgnore) {
            allMethods[methodName] = true;
          }
        });
      }
    });
    const allMethodsList = Object.keys(allMethods);
    allMethodsList.forEach((methodName) => beanInstance[methodName]());
  }
  getBean(name) {
    return this.lookupBeanInstance("getBean", name, true);
  }
  destroy() {
    if (this.destroyed) {
      return;
    }
    this.logger.log(">> Shutting down ag-Application Context");
    const beanInstances = this.getBeanInstances();
    this.destroyBeans(beanInstances);
    this.contextParams.providedBeanInstances = null;
    ModuleRegistry.unRegisterGridModules(this.contextParams.gridId);
    this.destroyed = true;
    this.logger.log(">> ag-Application Context shut down - component is dead");
  }
  destroyBean(bean) {
    if (!bean) {
      return;
    }
    this.destroyBeans([bean]);
  }
  destroyBeans(beans) {
    if (!beans) {
      return [];
    }
    beans.forEach((bean) => {
      this.callLifeCycleMethodsOnBean(bean, "preDestroyMethods", "destroy");
      const beanAny = bean;
      if (typeof beanAny.destroy === "function") {
        beanAny.destroy();
      }
    });
    return [];
  }
  isDestroyed() {
    return this.destroyed;
  }
  getGridId() {
    return this.contextParams.gridId;
  }
};
function PreConstruct(target, methodName, descriptor) {
  const props2 = getOrCreateProps$1(target.constructor);
  if (!props2.preConstructMethods) {
    props2.preConstructMethods = [];
  }
  props2.preConstructMethods.push(methodName);
}
function PostConstruct(target, methodName, descriptor) {
  const props2 = getOrCreateProps$1(target.constructor);
  if (!props2.postConstructMethods) {
    props2.postConstructMethods = [];
  }
  props2.postConstructMethods.push(methodName);
}
function PreDestroy(target, methodName, descriptor) {
  const props2 = getOrCreateProps$1(target.constructor);
  if (!props2.preDestroyMethods) {
    props2.preDestroyMethods = [];
  }
  props2.preDestroyMethods.push(methodName);
}
function Bean(beanName) {
  return (classConstructor) => {
    const props2 = getOrCreateProps$1(classConstructor);
    props2.beanName = beanName;
  };
}
function Autowired(name) {
  return (target, propertyKey, descriptor) => {
    autowiredFunc(target, name, false, target, propertyKey, null);
  };
}
function Optional(name) {
  return (target, propertyKey, descriptor) => {
    autowiredFunc(target, name, true, target, propertyKey, null);
  };
}
function autowiredFunc(target, name, optional, classPrototype, methodOrAttributeName, index) {
  if (name === null) {
    console.error("AG Grid: Autowired name should not be null");
    return;
  }
  if (typeof index === "number") {
    console.error("AG Grid: Autowired should be on an attribute");
    return;
  }
  const props2 = getOrCreateProps$1(target.constructor);
  if (!props2.agClassAttributes) {
    props2.agClassAttributes = [];
  }
  props2.agClassAttributes.push({
    attributeName: methodOrAttributeName,
    beanName: name,
    optional
  });
}
function Qualifier(name) {
  return (classPrototype, methodOrAttributeName, index) => {
    const constructor = typeof classPrototype == "function" ? classPrototype : classPrototype.constructor;
    let props2;
    if (typeof index === "number") {
      let methodName;
      if (methodOrAttributeName) {
        props2 = getOrCreateProps$1(constructor);
        methodName = methodOrAttributeName;
      } else {
        props2 = getOrCreateProps$1(constructor);
        methodName = "agConstructor";
      }
      if (!props2.autowireMethods) {
        props2.autowireMethods = {};
      }
      if (!props2.autowireMethods[methodName]) {
        props2.autowireMethods[methodName] = {};
      }
      props2.autowireMethods[methodName][index] = name;
    }
  };
}
function getOrCreateProps$1(target) {
  if (!target.hasOwnProperty("__agBeanMetaData")) {
    target.__agBeanMetaData = {};
  }
  return target.__agBeanMetaData;
}
var __decorate$2E = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$a = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var EventService = class EventService2 {
  constructor() {
    this.allSyncListeners = /* @__PURE__ */ new Map();
    this.allAsyncListeners = /* @__PURE__ */ new Map();
    this.globalSyncListeners = /* @__PURE__ */ new Set();
    this.globalAsyncListeners = /* @__PURE__ */ new Set();
    this.asyncFunctionsQueue = [];
    this.scheduled = false;
    this.firedEvents = {};
  }
  setBeans(loggerFactory, gridOptionsService, frameworkOverrides, globalEventListener = null) {
    this.frameworkOverrides = frameworkOverrides;
    this.gridOptionsService = gridOptionsService;
    if (globalEventListener) {
      const async = gridOptionsService.useAsyncEvents();
      this.addGlobalListener(globalEventListener, async);
    }
  }
  getListeners(eventType, async, autoCreateListenerCollection) {
    const listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;
    let listeners = listenerMap.get(eventType);
    if (!listeners && autoCreateListenerCollection) {
      listeners = /* @__PURE__ */ new Set();
      listenerMap.set(eventType, listeners);
    }
    return listeners;
  }
  noRegisteredListenersExist() {
    return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
  }
  addEventListener(eventType, listener, async = false) {
    this.getListeners(eventType, async, true).add(listener);
  }
  removeEventListener(eventType, listener, async = false) {
    const listeners = this.getListeners(eventType, async, false);
    if (!listeners) {
      return;
    }
    listeners.delete(listener);
    if (listeners.size === 0) {
      const listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;
      listenerMap.delete(eventType);
    }
  }
  addGlobalListener(listener, async = false) {
    (async ? this.globalAsyncListeners : this.globalSyncListeners).add(listener);
  }
  removeGlobalListener(listener, async = false) {
    (async ? this.globalAsyncListeners : this.globalSyncListeners).delete(listener);
  }
  dispatchEvent(event) {
    let agEvent = event;
    if (this.gridOptionsService) {
      const { api, columnApi, context } = this.gridOptionsService;
      agEvent.api = api;
      agEvent.columnApi = columnApi;
      agEvent.context = context;
    }
    this.dispatchToListeners(agEvent, true);
    this.dispatchToListeners(agEvent, false);
    this.firedEvents[agEvent.type] = true;
  }
  dispatchEventOnce(event) {
    if (!this.firedEvents[event.type]) {
      this.dispatchEvent(event);
    }
  }
  dispatchToListeners(event, async) {
    const eventType = event.type;
    if (async && "event" in event) {
      const browserEvent = event.event;
      if (browserEvent instanceof Event) {
        event.eventPath = browserEvent.composedPath();
      }
    }
    const processEventListeners = (listeners2) => listeners2.forEach((listener) => {
      if (async) {
        this.dispatchAsync(() => listener(event));
      } else {
        listener(event);
      }
    });
    const listeners = new Set(this.getListeners(eventType, async, false));
    if (listeners) {
      processEventListeners(listeners);
    }
    const globalListeners = new Set(async ? this.globalAsyncListeners : this.globalSyncListeners);
    globalListeners.forEach((listener) => {
      if (async) {
        this.dispatchAsync(() => this.frameworkOverrides.dispatchEvent(eventType, () => listener(eventType, event), true));
      } else {
        this.frameworkOverrides.dispatchEvent(eventType, () => listener(eventType, event), true);
      }
    });
  }
  dispatchAsync(func) {
    this.asyncFunctionsQueue.push(func);
    if (!this.scheduled) {
      window.setTimeout(this.flushAsyncQueue.bind(this), 0);
      this.scheduled = true;
    }
  }
  flushAsyncQueue() {
    this.scheduled = false;
    const queueCopy = this.asyncFunctionsQueue.slice();
    this.asyncFunctionsQueue = [];
    queueCopy.forEach((func) => func());
  }
};
__decorate$2E([
  __param$a(0, Qualifier("loggerFactory")),
  __param$a(1, Qualifier("gridOptionsService")),
  __param$a(2, Qualifier("frameworkOverrides")),
  __param$a(3, Qualifier("globalEventListener"))
], EventService.prototype, "setBeans", null);
EventService = __decorate$2E([
  Bean("eventService")
], EventService);
var __decorate$2D = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var instanceIdSequence$4 = 0;
function getNextColInstanceId() {
  return instanceIdSequence$4++;
}
var Column = class {
  constructor(colDef, userProvidedColDef, colId, primary) {
    this.instanceId = getNextColInstanceId();
    this.autoHeaderHeight = null;
    this.moving = false;
    this.menuVisible = false;
    this.filterActive = false;
    this.eventService = new EventService();
    this.tooltipEnabled = false;
    this.rowGroupActive = false;
    this.pivotActive = false;
    this.aggregationActive = false;
    this.colDef = colDef;
    this.userProvidedColDef = userProvidedColDef;
    this.colId = colId;
    this.primary = primary;
    this.setState(colDef);
  }
  getInstanceId() {
    return this.instanceId;
  }
  setState(colDef) {
    if (colDef.sort !== void 0) {
      if (colDef.sort === "asc" || colDef.sort === "desc") {
        this.sort = colDef.sort;
      }
    } else {
      if (colDef.initialSort === "asc" || colDef.initialSort === "desc") {
        this.sort = colDef.initialSort;
      }
    }
    const sortIndex = attrToNumber(colDef.sortIndex);
    const initialSortIndex = attrToNumber(colDef.initialSortIndex);
    if (sortIndex !== void 0) {
      if (sortIndex !== null) {
        this.sortIndex = sortIndex;
      }
    } else {
      if (initialSortIndex !== null) {
        this.sortIndex = initialSortIndex;
      }
    }
    const hide = attrToBoolean(colDef.hide);
    const initialHide = attrToBoolean(colDef.initialHide);
    if (hide !== void 0) {
      this.visible = !hide;
    } else {
      this.visible = !initialHide;
    }
    if (colDef.pinned !== void 0) {
      this.setPinned(colDef.pinned);
    } else {
      this.setPinned(colDef.initialPinned);
    }
    const flex = attrToNumber(colDef.flex);
    const initialFlex = attrToNumber(colDef.initialFlex);
    if (flex !== void 0) {
      this.flex = flex;
    } else if (initialFlex !== void 0) {
      this.flex = initialFlex;
    }
  }
  setColDef(colDef, userProvidedColDef) {
    this.colDef = colDef;
    this.userProvidedColDef = userProvidedColDef;
    this.initMinAndMaxWidths();
    this.initDotNotation();
    this.eventService.dispatchEvent(this.createColumnEvent("colDefChanged", "api"));
  }
  getUserProvidedColDef() {
    return this.userProvidedColDef;
  }
  setParent(parent) {
    this.parent = parent;
  }
  getParent() {
    return this.parent;
  }
  setOriginalParent(originalParent) {
    this.originalParent = originalParent;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  initialise() {
    this.initMinAndMaxWidths();
    this.resetActualWidth("gridInitializing");
    this.initDotNotation();
    this.initTooltip();
    this.validate();
  }
  initDotNotation() {
    const suppressDotNotation = this.gridOptionsService.is("suppressFieldDotNotation");
    this.fieldContainsDots = exists(this.colDef.field) && this.colDef.field.indexOf(".") >= 0 && !suppressDotNotation;
    this.tooltipFieldContainsDots = exists(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf(".") >= 0 && !suppressDotNotation;
  }
  initMinAndMaxWidths() {
    const colDef = this.colDef;
    this.minWidth = this.columnUtils.calculateColMinWidth(colDef);
    this.maxWidth = this.columnUtils.calculateColMaxWidth(colDef);
  }
  initTooltip() {
    this.tooltipEnabled = exists(this.colDef.tooltipField) || exists(this.colDef.tooltipValueGetter) || exists(this.colDef.tooltipComponent);
  }
  resetActualWidth(source = "api") {
    const initialWidth = this.columnUtils.calculateColInitialWidth(this.colDef);
    this.setActualWidth(initialWidth, source, true);
  }
  isEmptyGroup() {
    return false;
  }
  isRowGroupDisplayed(colId) {
    if (missing(this.colDef) || missing(this.colDef.showRowGroup)) {
      return false;
    }
    const showingAllGroups = this.colDef.showRowGroup === true;
    const showingThisGroup = this.colDef.showRowGroup === colId;
    return showingAllGroups || showingThisGroup;
  }
  isPrimary() {
    return this.primary;
  }
  isFilterAllowed() {
    const filterDefined = !!this.colDef.filter;
    return filterDefined;
  }
  isFieldContainsDots() {
    return this.fieldContainsDots;
  }
  isTooltipEnabled() {
    return this.tooltipEnabled;
  }
  isTooltipFieldContainsDots() {
    return this.tooltipFieldContainsDots;
  }
  validate() {
    const colDefAny = this.colDef;
    function warnOnce(msg, key, obj) {
      doOnce(() => {
        if (obj) {
          console.warn(msg, obj);
        } else {
          doOnce(() => console.warn(msg), key);
        }
      }, key);
    }
    const usingCSRM = this.gridOptionsService.isRowModelType("clientSide");
    if (usingCSRM && !ModuleRegistry.isRegistered(ModuleNames.RowGroupingModule, this.gridOptionsService.getGridId())) {
      const rowGroupingItems = ["enableRowGroup", "rowGroup", "rowGroupIndex", "enablePivot", "enableValue", "pivot", "pivotIndex", "aggFunc"];
      const itemsUsed = rowGroupingItems.filter((x) => exists(colDefAny[x]));
      if (itemsUsed.length > 0) {
        ModuleRegistry.assertRegistered(ModuleNames.RowGroupingModule, itemsUsed.map((i) => "colDef." + i).join(", "), this.gridOptionsService.getGridId());
      }
    }
    if (this.colDef.cellEditor === "agRichSelect" || this.colDef.cellEditor === "agRichSelectCellEditor") {
      ModuleRegistry.assertRegistered(ModuleNames.RichSelectModule, this.colDef.cellEditor, this.gridOptionsService.getGridId());
    }
    if (this.gridOptionsService.isTreeData()) {
      const itemsNotAllowedWithTreeData = ["rowGroup", "rowGroupIndex", "pivot", "pivotIndex"];
      const itemsUsed = itemsNotAllowedWithTreeData.filter((x) => exists(colDefAny[x]));
      if (itemsUsed.length > 0) {
        warnOnce(`AG Grid: ${itemsUsed.join()} is not possible when doing tree data, your column definition should not have ${itemsUsed.join()}`, "TreeDataCannotRowGroup");
      }
    }
    if (exists(colDefAny.menuTabs)) {
      if (Array.isArray(colDefAny.menuTabs)) {
        const communityMenuTabs = ["filterMenuTab"];
        const enterpriseMenuTabs = ["columnsMenuTab", "generalMenuTab"];
        const itemsUsed = enterpriseMenuTabs.filter((x) => colDefAny.menuTabs.includes(x));
        if (itemsUsed.length > 0) {
          ModuleRegistry.assertRegistered(ModuleNames.MenuModule, `menuTab(s): ${itemsUsed.map((t) => `'${t}'`).join()}`, this.gridOptionsService.getGridId());
        }
        colDefAny.menuTabs.forEach((tab) => {
          if (!enterpriseMenuTabs.includes(tab) && !communityMenuTabs.includes(tab)) {
            warnOnce(`AG Grid: '${tab}' is not valid for 'colDef.menuTabs'. Valid values are: ${[...communityMenuTabs, ...enterpriseMenuTabs].map((t) => `'${t}'`).join()}.`, "wrongValue_menuTabs_" + tab);
          }
        });
      } else {
        warnOnce(`AG Grid: The typeof 'colDef.menuTabs' should be an array not:` + typeof colDefAny.menuTabs, "wrongType_menuTabs");
      }
    }
    if (exists(colDefAny.columnsMenuParams)) {
      ModuleRegistry.assertRegistered(ModuleNames.MenuModule, "columnsMenuParams", this.gridOptionsService.getGridId());
    }
    if (exists(colDefAny.columnsMenuParams)) {
      ModuleRegistry.assertRegistered(ModuleNames.ColumnsToolPanelModule, "columnsMenuParams", this.gridOptionsService.getGridId());
    }
    if (exists(this.colDef.width) && typeof this.colDef.width !== "number") {
      warnOnce("AG Grid: colDef.width should be a number, not " + typeof this.colDef.width, "ColumnCheck");
    }
    if (exists(colDefAny.columnGroupShow) && colDefAny.columnGroupShow !== "closed" && colDefAny.columnGroupShow !== "open") {
      warnOnce(`AG Grid: '${colDefAny.columnGroupShow}' is not valid for columnGroupShow. Valid values are 'open', 'closed', undefined, null`, "columnGroupShow_invalid");
    }
  }
  addEventListener(eventType, listener) {
    this.eventService.addEventListener(eventType, listener);
  }
  removeEventListener(eventType, listener) {
    this.eventService.removeEventListener(eventType, listener);
  }
  createColumnFunctionCallbackParams(rowNode) {
    return {
      node: rowNode,
      data: rowNode.data,
      column: this,
      colDef: this.colDef,
      context: this.gridOptionsService.context,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi
    };
  }
  isSuppressNavigable(rowNode) {
    if (typeof this.colDef.suppressNavigable === "boolean") {
      return this.colDef.suppressNavigable;
    }
    if (typeof this.colDef.suppressNavigable === "function") {
      const params = this.createColumnFunctionCallbackParams(rowNode);
      const userFunc = this.colDef.suppressNavigable;
      return userFunc(params);
    }
    return false;
  }
  isCellEditable(rowNode) {
    if (rowNode.group && !this.gridOptionsService.is("enableGroupEdit")) {
      return false;
    }
    return this.isColumnFunc(rowNode, this.colDef.editable);
  }
  isSuppressFillHandle() {
    return !!attrToBoolean(this.colDef.suppressFillHandle);
  }
  isAutoHeight() {
    return !!attrToBoolean(this.colDef.autoHeight);
  }
  isAutoHeaderHeight() {
    return !!attrToBoolean(this.colDef.autoHeaderHeight);
  }
  isRowDrag(rowNode) {
    return this.isColumnFunc(rowNode, this.colDef.rowDrag);
  }
  isDndSource(rowNode) {
    return this.isColumnFunc(rowNode, this.colDef.dndSource);
  }
  isCellCheckboxSelection(rowNode) {
    return this.isColumnFunc(rowNode, this.colDef.checkboxSelection);
  }
  isSuppressPaste(rowNode) {
    return this.isColumnFunc(rowNode, this.colDef ? this.colDef.suppressPaste : null);
  }
  isResizable() {
    return !!attrToBoolean(this.colDef.resizable);
  }
  isColumnFunc(rowNode, value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "function") {
      const params = this.createColumnFunctionCallbackParams(rowNode);
      const editableFunc = value;
      return editableFunc(params);
    }
    return false;
  }
  setMoving(moving, source = "api") {
    this.moving = moving;
    this.eventService.dispatchEvent(this.createColumnEvent("movingChanged", source));
  }
  createColumnEvent(type, source) {
    return {
      type,
      column: this,
      columns: [this],
      source,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    };
  }
  isMoving() {
    return this.moving;
  }
  getSort() {
    return this.sort;
  }
  setSort(sort, source = "api") {
    if (this.sort !== sort) {
      this.sort = sort;
      this.eventService.dispatchEvent(this.createColumnEvent("sortChanged", source));
    }
  }
  setMenuVisible(visible, source = "api") {
    if (this.menuVisible !== visible) {
      this.menuVisible = visible;
      this.eventService.dispatchEvent(this.createColumnEvent("menuVisibleChanged", source));
    }
  }
  isMenuVisible() {
    return this.menuVisible;
  }
  isSortAscending() {
    return this.sort === "asc";
  }
  isSortDescending() {
    return this.sort === "desc";
  }
  isSortNone() {
    return missing(this.sort);
  }
  isSorting() {
    return exists(this.sort);
  }
  getSortIndex() {
    return this.sortIndex;
  }
  setSortIndex(sortOrder) {
    this.sortIndex = sortOrder;
  }
  setAggFunc(aggFunc) {
    this.aggFunc = aggFunc;
  }
  getAggFunc() {
    return this.aggFunc;
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  getRight() {
    return this.left + this.actualWidth;
  }
  setLeft(left, source = "api") {
    this.oldLeft = this.left;
    if (this.left !== left) {
      this.left = left;
      this.eventService.dispatchEvent(this.createColumnEvent("leftChanged", source));
    }
  }
  isFilterActive() {
    return this.filterActive;
  }
  setFilterActive(active, source = "api", additionalEventAttributes) {
    if (this.filterActive !== active) {
      this.filterActive = active;
      this.eventService.dispatchEvent(this.createColumnEvent("filterActiveChanged", source));
    }
    const filterChangedEvent = this.createColumnEvent("filterChanged", source);
    if (additionalEventAttributes) {
      mergeDeep(filterChangedEvent, additionalEventAttributes);
    }
    this.eventService.dispatchEvent(filterChangedEvent);
  }
  isHovered() {
    return this.columnHoverService.isHovered(this);
  }
  setPinned(pinned) {
    if (pinned === true || pinned === "left") {
      this.pinned = "left";
    } else if (pinned === "right") {
      this.pinned = "right";
    } else {
      this.pinned = null;
    }
  }
  setFirstRightPinned(firstRightPinned, source = "api") {
    if (this.firstRightPinned !== firstRightPinned) {
      this.firstRightPinned = firstRightPinned;
      this.eventService.dispatchEvent(this.createColumnEvent("firstRightPinnedChanged", source));
    }
  }
  setLastLeftPinned(lastLeftPinned, source = "api") {
    if (this.lastLeftPinned !== lastLeftPinned) {
      this.lastLeftPinned = lastLeftPinned;
      this.eventService.dispatchEvent(this.createColumnEvent("lastLeftPinnedChanged", source));
    }
  }
  isFirstRightPinned() {
    return this.firstRightPinned;
  }
  isLastLeftPinned() {
    return this.lastLeftPinned;
  }
  isPinned() {
    return this.pinned === "left" || this.pinned === "right";
  }
  isPinnedLeft() {
    return this.pinned === "left";
  }
  isPinnedRight() {
    return this.pinned === "right";
  }
  getPinned() {
    return this.pinned;
  }
  setVisible(visible, source = "api") {
    const newValue = visible === true;
    if (this.visible !== newValue) {
      this.visible = newValue;
      this.eventService.dispatchEvent(this.createColumnEvent("visibleChanged", source));
    }
  }
  isVisible() {
    return this.visible;
  }
  isSpanHeaderHeight() {
    const colDef = this.getColDef();
    return !colDef.suppressSpanHeaderHeight && !colDef.autoHeaderHeight;
  }
  getColDef() {
    return this.colDef;
  }
  getColumnGroupShow() {
    return this.colDef.columnGroupShow;
  }
  getColId() {
    return this.colId;
  }
  getId() {
    return this.colId;
  }
  getUniqueId() {
    return this.colId;
  }
  getDefinition() {
    return this.colDef;
  }
  getActualWidth() {
    return this.actualWidth;
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  setAutoHeaderHeight(height) {
    const changed = height !== this.autoHeaderHeight;
    this.autoHeaderHeight = height;
    return changed;
  }
  createBaseColDefParams(rowNode) {
    const params = {
      node: rowNode,
      data: rowNode.data,
      colDef: this.colDef,
      column: this,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    };
    return params;
  }
  getColSpan(rowNode) {
    if (missing(this.colDef.colSpan)) {
      return 1;
    }
    const params = this.createBaseColDefParams(rowNode);
    const colSpan = this.colDef.colSpan(params);
    return Math.max(colSpan, 1);
  }
  getRowSpan(rowNode) {
    if (missing(this.colDef.rowSpan)) {
      return 1;
    }
    const params = this.createBaseColDefParams(rowNode);
    const rowSpan = this.colDef.rowSpan(params);
    return Math.max(rowSpan, 1);
  }
  setActualWidth(actualWidth, source = "api", silent = false) {
    if (this.minWidth != null) {
      actualWidth = Math.max(actualWidth, this.minWidth);
    }
    if (this.maxWidth != null) {
      actualWidth = Math.min(actualWidth, this.maxWidth);
    }
    if (this.actualWidth !== actualWidth) {
      this.actualWidth = actualWidth;
      if (this.flex && source !== "flex" && source !== "gridInitializing") {
        this.flex = null;
      }
      if (!silent) {
        this.fireColumnWidthChangedEvent(source);
      }
    }
  }
  fireColumnWidthChangedEvent(source) {
    this.eventService.dispatchEvent(this.createColumnEvent("widthChanged", source));
  }
  isGreaterThanMax(width) {
    if (this.maxWidth != null) {
      return width > this.maxWidth;
    }
    return false;
  }
  getMinWidth() {
    return this.minWidth;
  }
  getMaxWidth() {
    return this.maxWidth;
  }
  getFlex() {
    return this.flex || 0;
  }
  setFlex(flex) {
    if (this.flex !== flex) {
      this.flex = flex;
    }
  }
  setMinimum(source = "api") {
    if (exists(this.minWidth)) {
      this.setActualWidth(this.minWidth, source);
    }
  }
  setRowGroupActive(rowGroup, source = "api") {
    if (this.rowGroupActive !== rowGroup) {
      this.rowGroupActive = rowGroup;
      this.eventService.dispatchEvent(this.createColumnEvent("columnRowGroupChanged", source));
    }
  }
  isRowGroupActive() {
    return this.rowGroupActive;
  }
  setPivotActive(pivot, source = "api") {
    if (this.pivotActive !== pivot) {
      this.pivotActive = pivot;
      this.eventService.dispatchEvent(this.createColumnEvent("columnPivotChanged", source));
    }
  }
  isPivotActive() {
    return this.pivotActive;
  }
  isAnyFunctionActive() {
    return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
  }
  isAnyFunctionAllowed() {
    return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
  }
  setValueActive(value, source = "api") {
    if (this.aggregationActive !== value) {
      this.aggregationActive = value;
      this.eventService.dispatchEvent(this.createColumnEvent("columnValueChanged", source));
    }
  }
  isValueActive() {
    return this.aggregationActive;
  }
  isAllowPivot() {
    return this.colDef.enablePivot === true;
  }
  isAllowValue() {
    return this.colDef.enableValue === true;
  }
  isAllowRowGroup() {
    return this.colDef.enableRowGroup === true;
  }
  getMenuTabs(defaultValues) {
    let menuTabs = this.getColDef().menuTabs;
    if (menuTabs == null) {
      menuTabs = defaultValues;
    }
    return menuTabs;
  }
};
Column.EVENT_MOVING_CHANGED = "movingChanged";
Column.EVENT_LEFT_CHANGED = "leftChanged";
Column.EVENT_WIDTH_CHANGED = "widthChanged";
Column.EVENT_LAST_LEFT_PINNED_CHANGED = "lastLeftPinnedChanged";
Column.EVENT_FIRST_RIGHT_PINNED_CHANGED = "firstRightPinnedChanged";
Column.EVENT_VISIBLE_CHANGED = "visibleChanged";
Column.EVENT_FILTER_CHANGED = "filterChanged";
Column.EVENT_FILTER_ACTIVE_CHANGED = "filterActiveChanged";
Column.EVENT_SORT_CHANGED = "sortChanged";
Column.EVENT_COL_DEF_CHANGED = "colDefChanged";
Column.EVENT_MENU_VISIBLE_CHANGED = "menuVisibleChanged";
Column.EVENT_ROW_GROUP_CHANGED = "columnRowGroupChanged";
Column.EVENT_PIVOT_CHANGED = "columnPivotChanged";
Column.EVENT_VALUE_CHANGED = "columnValueChanged";
__decorate$2D([
  Autowired("gridOptionsService")
], Column.prototype, "gridOptionsService", void 0);
__decorate$2D([
  Autowired("columnUtils")
], Column.prototype, "columnUtils", void 0);
__decorate$2D([
  Autowired("columnHoverService")
], Column.prototype, "columnHoverService", void 0);
__decorate$2D([
  PostConstruct
], Column.prototype, "initialise", null);
var __decorate$2C = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ProvidedColumnGroup = class {
  constructor(colGroupDef, groupId, padding, level) {
    this.localEventService = new EventService();
    this.expandable = false;
    this.instanceId = getNextColInstanceId();
    this.expandableListenerRemoveCallback = null;
    this.colGroupDef = colGroupDef;
    this.groupId = groupId;
    this.expanded = !!colGroupDef && !!colGroupDef.openByDefault;
    this.padding = padding;
    this.level = level;
  }
  destroy() {
    if (this.expandableListenerRemoveCallback) {
      this.reset(null, void 0);
    }
  }
  reset(colGroupDef, level) {
    this.colGroupDef = colGroupDef;
    this.level = level;
    this.originalParent = null;
    if (this.expandableListenerRemoveCallback) {
      this.expandableListenerRemoveCallback();
    }
    this.children = void 0;
    this.expandable = void 0;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setOriginalParent(originalParent) {
    this.originalParent = originalParent;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  getLevel() {
    return this.level;
  }
  isVisible() {
    if (this.children) {
      return this.children.some((child) => child.isVisible());
    }
    return false;
  }
  isPadding() {
    return this.padding;
  }
  setExpanded(expanded) {
    this.expanded = expanded === void 0 ? false : expanded;
    const event = {
      type: ProvidedColumnGroup.EVENT_EXPANDED_CHANGED
    };
    this.localEventService.dispatchEvent(event);
  }
  isExpandable() {
    return this.expandable;
  }
  isExpanded() {
    return this.expanded;
  }
  getGroupId() {
    return this.groupId;
  }
  getId() {
    return this.getGroupId();
  }
  setChildren(children) {
    this.children = children;
  }
  getChildren() {
    return this.children;
  }
  getColGroupDef() {
    return this.colGroupDef;
  }
  getLeafColumns() {
    const result = [];
    this.addLeafColumns(result);
    return result;
  }
  addLeafColumns(leafColumns) {
    if (!this.children) {
      return;
    }
    this.children.forEach((child) => {
      if (child instanceof Column) {
        leafColumns.push(child);
      } else if (child instanceof ProvidedColumnGroup) {
        child.addLeafColumns(leafColumns);
      }
    });
  }
  getColumnGroupShow() {
    const colGroupDef = this.colGroupDef;
    if (!colGroupDef) {
      return;
    }
    return colGroupDef.columnGroupShow;
  }
  setupExpandable() {
    this.setExpandable();
    if (this.expandableListenerRemoveCallback) {
      this.expandableListenerRemoveCallback();
    }
    const listener = this.onColumnVisibilityChanged.bind(this);
    this.getLeafColumns().forEach((col) => col.addEventListener("visibleChanged", listener));
    this.expandableListenerRemoveCallback = () => {
      this.getLeafColumns().forEach((col) => col.removeEventListener("visibleChanged", listener));
      this.expandableListenerRemoveCallback = null;
    };
  }
  setExpandable() {
    if (this.isPadding()) {
      return;
    }
    let atLeastOneShowingWhenOpen = false;
    let atLeastOneShowingWhenClosed = false;
    let atLeastOneChangeable = false;
    const children = this.findChildrenRemovingPadding();
    for (let i = 0, j = children.length; i < j; i++) {
      const abstractColumn = children[i];
      if (!abstractColumn.isVisible()) {
        continue;
      }
      const headerGroupShow = abstractColumn.getColumnGroupShow();
      if (headerGroupShow === "open") {
        atLeastOneShowingWhenOpen = true;
        atLeastOneChangeable = true;
      } else if (headerGroupShow === "closed") {
        atLeastOneShowingWhenClosed = true;
        atLeastOneChangeable = true;
      } else {
        atLeastOneShowingWhenOpen = true;
        atLeastOneShowingWhenClosed = true;
      }
    }
    const expandable = atLeastOneShowingWhenOpen && atLeastOneShowingWhenClosed && atLeastOneChangeable;
    if (this.expandable !== expandable) {
      this.expandable = expandable;
      const event = {
        type: ProvidedColumnGroup.EVENT_EXPANDABLE_CHANGED
      };
      this.localEventService.dispatchEvent(event);
    }
  }
  findChildrenRemovingPadding() {
    const res = [];
    const process = (items) => {
      items.forEach((item) => {
        const skipBecausePadding = item instanceof ProvidedColumnGroup && item.isPadding();
        if (skipBecausePadding) {
          process(item.children);
        } else {
          res.push(item);
        }
      });
    };
    process(this.children);
    return res;
  }
  onColumnVisibilityChanged() {
    this.setExpandable();
  }
  addEventListener(eventType, listener) {
    this.localEventService.addEventListener(eventType, listener);
  }
  removeEventListener(eventType, listener) {
    this.localEventService.removeEventListener(eventType, listener);
  }
};
ProvidedColumnGroup.EVENT_EXPANDED_CHANGED = "expandedChanged";
ProvidedColumnGroup.EVENT_EXPANDABLE_CHANGED = "expandableChanged";
__decorate$2C([
  PreDestroy
], ProvidedColumnGroup.prototype, "destroy", null);
var DefaultColumnTypes = {
  numericColumn: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  },
  rightAligned: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  }
};
function firstExistingValue(...values2) {
  for (let i = 0; i < values2.length; i++) {
    const value = values2[i];
    if (exists(value)) {
      return value;
    }
  }
  return null;
}
function existsAndNotEmpty(value) {
  return value != null && value.length > 0;
}
function last(arr) {
  if (!arr || !arr.length) {
    return;
  }
  return arr[arr.length - 1];
}
function areEqual(a, b, comparator) {
  if (a == null && b == null) {
    return true;
  }
  return a != null && b != null && a.length === b.length && a.every((value, index) => comparator ? comparator(value, b[index]) : b[index] === value);
}
function shallowCompare(arr1, arr2) {
  return areEqual(arr1, arr2);
}
function sortNumerically(array) {
  return array.sort((a, b) => a - b);
}
function removeRepeatsFromArray(array, object) {
  if (!array) {
    return;
  }
  for (let index = array.length - 2; index >= 0; index--) {
    const thisOneMatches = array[index] === object;
    const nextOneMatches = array[index + 1] === object;
    if (thisOneMatches && nextOneMatches) {
      array.splice(index + 1, 1);
    }
  }
}
function removeFromArray(array, object) {
  const index = array.indexOf(object);
  if (index >= 0) {
    array.splice(index, 1);
  }
}
function removeAllFromArray(array, toRemove) {
  toRemove.forEach((item) => removeFromArray(array, item));
}
function insertIntoArray(array, object, toIndex) {
  array.splice(toIndex, 0, object);
}
function insertArrayIntoArray(dest, src, toIndex) {
  if (dest == null || src == null) {
    return;
  }
  for (let i = src.length - 1; i >= 0; i--) {
    const item = src[i];
    insertIntoArray(dest, item, toIndex);
  }
}
function moveInArray(array, objectsToMove, toIndex) {
  removeAllFromArray(array, objectsToMove);
  objectsToMove.slice().reverse().forEach((obj) => insertIntoArray(array, obj, toIndex));
}
function includes(array, value) {
  return array.indexOf(value) > -1;
}
function flatten(arrayOfArrays) {
  return [].concat.apply([], arrayOfArrays);
}
function pushAll(target, source) {
  if (source == null || target == null) {
    return;
  }
  source.forEach((value) => target.push(value));
}
function toStrings(array) {
  return array.map(toStringOrNull);
}
function forEachReverse(list, action) {
  if (list == null) {
    return;
  }
  for (let i = list.length - 1; i >= 0; i--) {
    action(list[i], i);
  }
}
var ArrayUtils = Object.freeze({
  __proto__: null,
  firstExistingValue,
  existsAndNotEmpty,
  last,
  areEqual,
  shallowCompare,
  sortNumerically,
  removeRepeatsFromArray,
  removeFromArray,
  removeAllFromArray,
  insertIntoArray,
  insertArrayIntoArray,
  moveInArray,
  includes,
  flatten,
  pushAll,
  toStrings,
  forEachReverse
});
var AG_GRID_STOP_PROPAGATION = "__ag_Grid_Stop_Propagation";
var PASSIVE_EVENTS$1 = ["touchstart", "touchend", "touchmove", "touchcancel", "scroll"];
var supports = {};
function stopPropagationForAgGrid(event) {
  event[AG_GRID_STOP_PROPAGATION] = true;
}
function isStopPropagationForAgGrid(event) {
  return event[AG_GRID_STOP_PROPAGATION] === true;
}
var isEventSupported = (() => {
  const tags = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  const eventChecker = (eventName) => {
    if (typeof supports[eventName] === "boolean") {
      return supports[eventName];
    }
    const el = document.createElement(tags[eventName] || "div");
    eventName = "on" + eventName;
    return supports[eventName] = eventName in el;
  };
  return eventChecker;
})();
function getCtrlForEventTarget(gridOptionsService, eventTarget, type) {
  let sourceElement = eventTarget;
  while (sourceElement) {
    const renderedComp = gridOptionsService.getDomData(sourceElement, type);
    if (renderedComp) {
      return renderedComp;
    }
    sourceElement = sourceElement.parentElement;
  }
  return null;
}
function isElementInEventPath(element, event) {
  if (!event || !element) {
    return false;
  }
  return getEventPath(event).indexOf(element) >= 0;
}
function createEventPath(event) {
  const res = [];
  let pointer = event.target;
  while (pointer) {
    res.push(pointer);
    pointer = pointer.parentElement;
  }
  return res;
}
function getEventPath(event) {
  const eventNoType = event;
  if (eventNoType.path) {
    return eventNoType.path;
  }
  if (eventNoType.composedPath) {
    return eventNoType.composedPath();
  }
  return createEventPath(eventNoType);
}
function addSafePassiveEventListener(frameworkOverrides, eElement, event, listener) {
  const isPassive = includes(PASSIVE_EVENTS$1, event);
  const options = isPassive ? { passive: true } : void 0;
  if (frameworkOverrides && frameworkOverrides.addEventListener) {
    frameworkOverrides.addEventListener(eElement, event, listener, options);
  }
}
var EventUtils = Object.freeze({
  __proto__: null,
  stopPropagationForAgGrid,
  isStopPropagationForAgGrid,
  isEventSupported,
  getCtrlForEventTarget,
  isElementInEventPath,
  createEventPath,
  getEventPath,
  addSafePassiveEventListener
});
var __decorate$2B = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BeanStub = class {
  constructor() {
    this.destroyFunctions = [];
    this.destroyed = false;
    this.__v_skip = true;
    this.isAlive = () => !this.destroyed;
  }
  getFrameworkOverrides() {
    return this.frameworkOverrides;
  }
  getContext() {
    return this.context;
  }
  destroy() {
    this.destroyFunctions.forEach((func) => func());
    this.destroyFunctions.length = 0;
    this.destroyed = true;
    this.dispatchEvent({ type: BeanStub.EVENT_DESTROYED });
  }
  addEventListener(eventType, listener) {
    if (!this.localEventService) {
      this.localEventService = new EventService();
    }
    this.localEventService.addEventListener(eventType, listener);
  }
  removeEventListener(eventType, listener) {
    if (this.localEventService) {
      this.localEventService.removeEventListener(eventType, listener);
    }
  }
  dispatchEventAsync(event) {
    window.setTimeout(() => this.dispatchEvent(event), 0);
  }
  dispatchEvent(event) {
    if (this.localEventService) {
      this.localEventService.dispatchEvent(event);
    }
  }
  addManagedListener(object, event, listener) {
    if (this.destroyed) {
      return;
    }
    if (object instanceof HTMLElement) {
      addSafePassiveEventListener(this.getFrameworkOverrides(), object, event, listener);
    } else {
      object.addEventListener(event, listener);
    }
    const destroyFunc = () => {
      object.removeEventListener(event, listener);
      this.destroyFunctions = this.destroyFunctions.filter((fn) => fn !== destroyFunc);
      return null;
    };
    this.destroyFunctions.push(destroyFunc);
    return destroyFunc;
  }
  addManagedPropertyListener(event, listener) {
    if (this.destroyed) {
      return;
    }
    this.gridOptionsService.addEventListener(event, listener);
    const destroyFunc = () => {
      this.gridOptionsService.removeEventListener(event, listener);
      this.destroyFunctions = this.destroyFunctions.filter((fn) => fn !== destroyFunc);
      return null;
    };
    this.destroyFunctions.push(destroyFunc);
    return destroyFunc;
  }
  addDestroyFunc(func) {
    if (this.isAlive()) {
      this.destroyFunctions.push(func);
    } else {
      func();
    }
  }
  createManagedBean(bean, context) {
    const res = this.createBean(bean, context);
    this.addDestroyFunc(this.destroyBean.bind(this, bean, context));
    return res;
  }
  createBean(bean, context, afterPreCreateCallback) {
    return (context || this.getContext()).createBean(bean, afterPreCreateCallback);
  }
  destroyBean(bean, context) {
    return (context || this.getContext()).destroyBean(bean);
  }
  destroyBeans(beans, context) {
    if (beans) {
      beans.forEach((bean) => this.destroyBean(bean, context));
    }
    return [];
  }
};
BeanStub.EVENT_DESTROYED = "destroyed";
__decorate$2B([
  Autowired("frameworkOverrides")
], BeanStub.prototype, "frameworkOverrides", void 0);
__decorate$2B([
  Autowired("context")
], BeanStub.prototype, "context", void 0);
__decorate$2B([
  Autowired("eventService")
], BeanStub.prototype, "eventService", void 0);
__decorate$2B([
  Autowired("gridOptionsService")
], BeanStub.prototype, "gridOptionsService", void 0);
__decorate$2B([
  Autowired("localeService")
], BeanStub.prototype, "localeService", void 0);
__decorate$2B([
  Autowired("environment")
], BeanStub.prototype, "environment", void 0);
__decorate$2B([
  PreDestroy
], BeanStub.prototype, "destroy", null);
var __decorate$2A = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$9 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ColumnFactory = class ColumnFactory2 extends BeanStub {
  setBeans(loggerFactory) {
    this.logger = loggerFactory.create("ColumnFactory");
  }
  createColumnTree(defs, primaryColumns, existingTree) {
    const columnKeyCreator = new ColumnKeyCreator();
    const { existingCols, existingGroups, existingColKeys } = this.extractExistingTreeData(existingTree);
    columnKeyCreator.addExistingKeys(existingColKeys);
    const unbalancedTree = this.recursivelyCreateColumns(defs, 0, primaryColumns, existingCols, columnKeyCreator, existingGroups);
    const treeDept = this.findMaxDept(unbalancedTree, 0);
    this.logger.log("Number of levels for grouped columns is " + treeDept);
    const columnTree = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);
    const deptFirstCallback = (child, parent) => {
      if (child instanceof ProvidedColumnGroup) {
        child.setupExpandable();
      }
      child.setOriginalParent(parent);
    };
    this.columnUtils.depthFirstOriginalTreeSearch(null, columnTree, deptFirstCallback);
    return {
      columnTree,
      treeDept
    };
  }
  extractExistingTreeData(existingTree) {
    const existingCols = [];
    const existingGroups = [];
    const existingColKeys = [];
    if (existingTree) {
      this.columnUtils.depthFirstOriginalTreeSearch(null, existingTree, (item) => {
        if (item instanceof ProvidedColumnGroup) {
          const group = item;
          existingGroups.push(group);
        } else {
          const col = item;
          existingColKeys.push(col.getId());
          existingCols.push(col);
        }
      });
    }
    return { existingCols, existingGroups, existingColKeys };
  }
  createForAutoGroups(autoGroupCols, gridBalancedTree) {
    return autoGroupCols.map((col) => this.createAutoGroupTreeItem(gridBalancedTree, col));
  }
  createAutoGroupTreeItem(balancedColumnTree, column) {
    const dept = this.findDepth(balancedColumnTree);
    let nextChild = column;
    for (let i = dept - 1; i >= 0; i--) {
      const autoGroup = new ProvidedColumnGroup(null, `FAKE_PATH_${column.getId()}}_${i}`, true, i);
      this.createBean(autoGroup);
      autoGroup.setChildren([nextChild]);
      nextChild.setOriginalParent(autoGroup);
      nextChild = autoGroup;
    }
    return nextChild;
  }
  findDepth(balancedColumnTree) {
    let dept = 0;
    let pointer = balancedColumnTree;
    while (pointer && pointer[0] && pointer[0] instanceof ProvidedColumnGroup) {
      dept++;
      pointer = pointer[0].getChildren();
    }
    return dept;
  }
  balanceColumnTree(unbalancedTree, currentDept, columnDept, columnKeyCreator) {
    const result = [];
    for (let i = 0; i < unbalancedTree.length; i++) {
      const child = unbalancedTree[i];
      if (child instanceof ProvidedColumnGroup) {
        const originalGroup = child;
        const newChildren = this.balanceColumnTree(originalGroup.getChildren(), currentDept + 1, columnDept, columnKeyCreator);
        originalGroup.setChildren(newChildren);
        result.push(originalGroup);
      } else {
        let firstPaddedGroup;
        let currentPaddedGroup;
        for (let j = columnDept - 1; j >= currentDept; j--) {
          const newColId = columnKeyCreator.getUniqueKey(null, null);
          const colGroupDefMerged = this.createMergedColGroupDef(null);
          const paddedGroup = new ProvidedColumnGroup(colGroupDefMerged, newColId, true, currentDept);
          this.createBean(paddedGroup);
          if (currentPaddedGroup) {
            currentPaddedGroup.setChildren([paddedGroup]);
          }
          currentPaddedGroup = paddedGroup;
          if (!firstPaddedGroup) {
            firstPaddedGroup = currentPaddedGroup;
          }
        }
        if (firstPaddedGroup && currentPaddedGroup) {
          result.push(firstPaddedGroup);
          const hasGroups = unbalancedTree.some((leaf) => leaf instanceof ProvidedColumnGroup);
          if (hasGroups) {
            currentPaddedGroup.setChildren([child]);
            continue;
          } else {
            currentPaddedGroup.setChildren(unbalancedTree);
            break;
          }
        }
        result.push(child);
      }
    }
    return result;
  }
  findMaxDept(treeChildren, dept) {
    let maxDeptThisLevel = dept;
    for (let i = 0; i < treeChildren.length; i++) {
      const abstractColumn = treeChildren[i];
      if (abstractColumn instanceof ProvidedColumnGroup) {
        const originalGroup = abstractColumn;
        const newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);
        if (maxDeptThisLevel < newDept) {
          maxDeptThisLevel = newDept;
        }
      }
    }
    return maxDeptThisLevel;
  }
  recursivelyCreateColumns(defs, level, primaryColumns, existingColsCopy, columnKeyCreator, existingGroups) {
    return (defs || []).map((def) => {
      if (this.isColumnGroup(def)) {
        return this.createColumnGroup(primaryColumns, def, level, existingColsCopy, columnKeyCreator, existingGroups);
      } else {
        return this.createColumn(primaryColumns, def, existingColsCopy, columnKeyCreator);
      }
    });
  }
  createColumnGroup(primaryColumns, colGroupDef, level, existingColumns, columnKeyCreator, existingGroups) {
    const colGroupDefMerged = this.createMergedColGroupDef(colGroupDef);
    const groupId = columnKeyCreator.getUniqueKey(colGroupDefMerged.groupId || null, null);
    const providedGroup = new ProvidedColumnGroup(colGroupDefMerged, groupId, false, level);
    this.createBean(providedGroup);
    const existingGroup = this.findExistingGroup(colGroupDef, existingGroups);
    if (existingGroup) {
      removeFromArray(existingGroups, existingGroup);
    }
    if (existingGroup && existingGroup.isExpanded()) {
      providedGroup.setExpanded(true);
    }
    const children = this.recursivelyCreateColumns(colGroupDefMerged.children, level + 1, primaryColumns, existingColumns, columnKeyCreator, existingGroups);
    providedGroup.setChildren(children);
    return providedGroup;
  }
  createMergedColGroupDef(colGroupDef) {
    const colGroupDefMerged = {};
    Object.assign(colGroupDefMerged, this.gridOptionsService.get("defaultColGroupDef"));
    Object.assign(colGroupDefMerged, colGroupDef);
    return colGroupDefMerged;
  }
  createColumn(primaryColumns, colDef, existingColsCopy, columnKeyCreator) {
    let column = this.findExistingColumn(colDef, existingColsCopy);
    if (existingColsCopy && column) {
      removeFromArray(existingColsCopy, column);
    }
    if (!column) {
      const colId = columnKeyCreator.getUniqueKey(colDef.colId, colDef.field);
      const colDefMerged = this.mergeColDefs(colDef, colId);
      column = new Column(colDefMerged, colDef, colId, primaryColumns);
      this.context.createBean(column);
    } else {
      const colDefMerged = this.mergeColDefs(colDef, column.getColId());
      column.setColDef(colDefMerged, colDef);
      this.applyColumnState(column, colDefMerged);
    }
    return column;
  }
  applyColumnState(column, colDef) {
    const flex = attrToNumber(colDef.flex);
    if (flex !== void 0) {
      column.setFlex(flex);
    }
    const noFlexThisCol = column.getFlex() <= 0;
    if (noFlexThisCol) {
      const width = attrToNumber(colDef.width);
      if (width != null) {
        column.setActualWidth(width);
      } else {
        const widthBeforeUpdate = column.getActualWidth();
        column.setActualWidth(widthBeforeUpdate);
      }
    }
    if (colDef.sort !== void 0) {
      if (colDef.sort == "asc" || colDef.sort == "desc") {
        column.setSort(colDef.sort);
      } else {
        column.setSort(void 0);
      }
    }
    const sortIndex = attrToNumber(colDef.sortIndex);
    if (sortIndex !== void 0) {
      column.setSortIndex(sortIndex);
    }
    const hide = attrToBoolean(colDef.hide);
    if (hide !== void 0) {
      column.setVisible(!hide);
    }
    if (colDef.pinned !== void 0) {
      column.setPinned(colDef.pinned);
    }
  }
  findExistingColumn(newColDef, existingColsCopy) {
    return (existingColsCopy || []).find((existingCol) => {
      const existingColDef = existingCol.getUserProvidedColDef();
      if (!existingColDef) {
        return false;
      }
      const newHasId = newColDef.colId != null;
      const newHasField = newColDef.field != null;
      if (newHasId) {
        return existingCol.getId() === newColDef.colId;
      }
      if (newHasField) {
        return existingColDef.field === newColDef.field;
      }
      if (existingColDef === newColDef) {
        return true;
      }
      return false;
    });
  }
  findExistingGroup(newGroupDef, existingGroups) {
    return existingGroups.find((existingGroup) => {
      const existingDef = existingGroup.getColGroupDef();
      if (!existingDef) {
        return false;
      }
      const newHasId = newGroupDef.groupId != null;
      if (newHasId) {
        return existingGroup.getId() === newGroupDef.groupId;
      }
      return false;
    });
  }
  mergeColDefs(colDef, colId) {
    const colDefMerged = {};
    const defaultColDef = this.gridOptionsService.get("defaultColDef");
    mergeDeep(colDefMerged, defaultColDef, false, true);
    const columnType = this.dataTypeService.updateColDefAndGetColumnType(colDefMerged, colDef, colId);
    if (columnType) {
      this.assignColumnTypes(columnType, colDefMerged);
    }
    mergeDeep(colDefMerged, colDef, false, true);
    const autoGroupColDef = this.gridOptionsService.get("autoGroupColumnDef");
    const isSortingCoupled = this.gridOptionsService.isColumnsSortingCoupledToGroup();
    if (colDef.rowGroup && autoGroupColDef && isSortingCoupled) {
      mergeDeep(colDefMerged, { sort: autoGroupColDef.sort, initialSort: autoGroupColDef.initialSort }, false, true);
    }
    this.dataTypeService.validateColDef(colDefMerged);
    return colDefMerged;
  }
  assignColumnTypes(typeKeys, colDefMerged) {
    if (!typeKeys.length) {
      return;
    }
    const allColumnTypes = Object.assign({}, DefaultColumnTypes);
    const userTypes = this.gridOptionsService.get("columnTypes") || {};
    iterateObject(userTypes, (key, value) => {
      if (key in allColumnTypes) {
        console.warn(`AG Grid: the column type '${key}' is a default column type and cannot be overridden.`);
      } else {
        allColumnTypes[key] = value;
      }
    });
    typeKeys.forEach((t) => {
      const typeColDef = allColumnTypes[t.trim()];
      if (typeColDef) {
        mergeDeep(colDefMerged, typeColDef, false, true);
      } else {
        console.warn("AG Grid: colDef.type '" + t + "' does not correspond to defined gridOptions.columnTypes");
      }
    });
  }
  isColumnGroup(abstractColDef) {
    return abstractColDef.children !== void 0;
  }
};
__decorate$2A([
  Autowired("columnUtils")
], ColumnFactory.prototype, "columnUtils", void 0);
__decorate$2A([
  Autowired("dataTypeService")
], ColumnFactory.prototype, "dataTypeService", void 0);
__decorate$2A([
  __param$9(0, Qualifier("loggerFactory"))
], ColumnFactory.prototype, "setBeans", null);
ColumnFactory = __decorate$2A([
  Bean("columnFactory")
], ColumnFactory);
var __decorate$2z = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ColumnGroup = class {
  constructor(providedColumnGroup, groupId, partId, pinned) {
    this.displayedChildren = [];
    this.localEventService = new EventService();
    this.groupId = groupId;
    this.partId = partId;
    this.providedColumnGroup = providedColumnGroup;
    this.pinned = pinned;
  }
  static createUniqueId(groupId, instanceId) {
    return groupId + "_" + instanceId;
  }
  reset() {
    this.parent = null;
    this.children = null;
    this.displayedChildren = null;
  }
  getParent() {
    return this.parent;
  }
  setParent(parent) {
    this.parent = parent;
  }
  getUniqueId() {
    return ColumnGroup.createUniqueId(this.groupId, this.partId);
  }
  isEmptyGroup() {
    return this.displayedChildren.length === 0;
  }
  isMoving() {
    const allLeafColumns = this.getProvidedColumnGroup().getLeafColumns();
    if (!allLeafColumns || allLeafColumns.length === 0) {
      return false;
    }
    return allLeafColumns.every((col) => col.isMoving());
  }
  checkLeft() {
    this.displayedChildren.forEach((child) => {
      if (child instanceof ColumnGroup) {
        child.checkLeft();
      }
    });
    if (this.displayedChildren.length > 0) {
      if (this.gridOptionsService.is("enableRtl")) {
        const lastChild = last(this.displayedChildren);
        const lastChildLeft = lastChild.getLeft();
        this.setLeft(lastChildLeft);
      } else {
        const firstChildLeft = this.displayedChildren[0].getLeft();
        this.setLeft(firstChildLeft);
      }
    } else {
      this.setLeft(null);
    }
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  setLeft(left) {
    this.oldLeft = left;
    if (this.left !== left) {
      this.left = left;
      this.localEventService.dispatchEvent(this.createAgEvent(ColumnGroup.EVENT_LEFT_CHANGED));
    }
  }
  getPinned() {
    return this.pinned;
  }
  createAgEvent(type) {
    return { type };
  }
  addEventListener(eventType, listener) {
    this.localEventService.addEventListener(eventType, listener);
  }
  removeEventListener(eventType, listener) {
    this.localEventService.removeEventListener(eventType, listener);
  }
  getGroupId() {
    return this.groupId;
  }
  getPartId() {
    return this.partId;
  }
  isChildInThisGroupDeepSearch(wantedChild) {
    let result = false;
    this.children.forEach((foundChild) => {
      if (wantedChild === foundChild) {
        result = true;
      }
      if (foundChild instanceof ColumnGroup) {
        if (foundChild.isChildInThisGroupDeepSearch(wantedChild)) {
          result = true;
        }
      }
    });
    return result;
  }
  getActualWidth() {
    let groupActualWidth = 0;
    if (this.displayedChildren) {
      this.displayedChildren.forEach((child) => {
        groupActualWidth += child.getActualWidth();
      });
    }
    return groupActualWidth;
  }
  isResizable() {
    if (!this.displayedChildren) {
      return false;
    }
    let result = false;
    this.displayedChildren.forEach((child) => {
      if (child.isResizable()) {
        result = true;
      }
    });
    return result;
  }
  getMinWidth() {
    let result = 0;
    this.displayedChildren.forEach((groupChild) => {
      result += groupChild.getMinWidth() || 0;
    });
    return result;
  }
  addChild(child) {
    if (!this.children) {
      this.children = [];
    }
    this.children.push(child);
  }
  getDisplayedChildren() {
    return this.displayedChildren;
  }
  getLeafColumns() {
    const result = [];
    this.addLeafColumns(result);
    return result;
  }
  getDisplayedLeafColumns() {
    const result = [];
    this.addDisplayedLeafColumns(result);
    return result;
  }
  getDefinition() {
    return this.providedColumnGroup.getColGroupDef();
  }
  getColGroupDef() {
    return this.providedColumnGroup.getColGroupDef();
  }
  isPadding() {
    return this.providedColumnGroup.isPadding();
  }
  isExpandable() {
    return this.providedColumnGroup.isExpandable();
  }
  isExpanded() {
    return this.providedColumnGroup.isExpanded();
  }
  setExpanded(expanded) {
    this.providedColumnGroup.setExpanded(expanded);
  }
  addDisplayedLeafColumns(leafColumns) {
    this.displayedChildren.forEach((child) => {
      if (child instanceof Column) {
        leafColumns.push(child);
      } else if (child instanceof ColumnGroup) {
        child.addDisplayedLeafColumns(leafColumns);
      }
    });
  }
  addLeafColumns(leafColumns) {
    this.children.forEach((child) => {
      if (child instanceof Column) {
        leafColumns.push(child);
      } else if (child instanceof ColumnGroup) {
        child.addLeafColumns(leafColumns);
      }
    });
  }
  getChildren() {
    return this.children;
  }
  getColumnGroupShow() {
    return this.providedColumnGroup.getColumnGroupShow();
  }
  getProvidedColumnGroup() {
    return this.providedColumnGroup;
  }
  getPaddingLevel() {
    const parent = this.getParent();
    if (!this.isPadding() || !parent || !parent.isPadding()) {
      return 0;
    }
    return 1 + parent.getPaddingLevel();
  }
  calculateDisplayedColumns() {
    this.displayedChildren = [];
    let parentWithExpansion = this;
    while (parentWithExpansion != null && parentWithExpansion.isPadding()) {
      parentWithExpansion = parentWithExpansion.getParent();
    }
    const isExpandable = parentWithExpansion ? parentWithExpansion.providedColumnGroup.isExpandable() : false;
    if (!isExpandable) {
      this.displayedChildren = this.children;
      this.localEventService.dispatchEvent(this.createAgEvent(ColumnGroup.EVENT_DISPLAYED_CHILDREN_CHANGED));
      return;
    }
    this.children.forEach((child) => {
      const emptyGroup = child instanceof ColumnGroup && (!child.displayedChildren || !child.displayedChildren.length);
      if (emptyGroup) {
        return;
      }
      const headerGroupShow = child.getColumnGroupShow();
      switch (headerGroupShow) {
        case "open":
          if (parentWithExpansion.providedColumnGroup.isExpanded()) {
            this.displayedChildren.push(child);
          }
          break;
        case "closed":
          if (!parentWithExpansion.providedColumnGroup.isExpanded()) {
            this.displayedChildren.push(child);
          }
          break;
        default:
          this.displayedChildren.push(child);
          break;
      }
    });
    this.localEventService.dispatchEvent(this.createAgEvent(ColumnGroup.EVENT_DISPLAYED_CHILDREN_CHANGED));
  }
};
ColumnGroup.EVENT_LEFT_CHANGED = "leftChanged";
ColumnGroup.EVENT_DISPLAYED_CHILDREN_CHANGED = "displayedChildrenChanged";
__decorate$2z([
  Autowired("gridOptionsService")
], ColumnGroup.prototype, "gridOptionsService", void 0);
var Events = class {
};
Events.EVENT_COLUMN_EVERYTHING_CHANGED = "columnEverythingChanged";
Events.EVENT_NEW_COLUMNS_LOADED = "newColumnsLoaded";
Events.EVENT_COLUMN_PIVOT_MODE_CHANGED = "columnPivotModeChanged";
Events.EVENT_COLUMN_ROW_GROUP_CHANGED = "columnRowGroupChanged";
Events.EVENT_EXPAND_COLLAPSE_ALL = "expandOrCollapseAll";
Events.EVENT_COLUMN_PIVOT_CHANGED = "columnPivotChanged";
Events.EVENT_GRID_COLUMNS_CHANGED = "gridColumnsChanged";
Events.EVENT_COLUMN_VALUE_CHANGED = "columnValueChanged";
Events.EVENT_COLUMN_MOVED = "columnMoved";
Events.EVENT_COLUMN_VISIBLE = "columnVisible";
Events.EVENT_COLUMN_PINNED = "columnPinned";
Events.EVENT_COLUMN_GROUP_OPENED = "columnGroupOpened";
Events.EVENT_COLUMN_RESIZED = "columnResized";
Events.EVENT_DISPLAYED_COLUMNS_CHANGED = "displayedColumnsChanged";
Events.EVENT_VIRTUAL_COLUMNS_CHANGED = "virtualColumnsChanged";
Events.EVENT_ASYNC_TRANSACTIONS_FLUSHED = "asyncTransactionsFlushed";
Events.EVENT_ROW_GROUP_OPENED = "rowGroupOpened";
Events.EVENT_ROW_DATA_CHANGED = "rowDataChanged";
Events.EVENT_ROW_DATA_UPDATED = "rowDataUpdated";
Events.EVENT_PINNED_ROW_DATA_CHANGED = "pinnedRowDataChanged";
Events.EVENT_RANGE_SELECTION_CHANGED = "rangeSelectionChanged";
Events.EVENT_CHART_CREATED = "chartCreated";
Events.EVENT_CHART_RANGE_SELECTION_CHANGED = "chartRangeSelectionChanged";
Events.EVENT_CHART_OPTIONS_CHANGED = "chartOptionsChanged";
Events.EVENT_CHART_DESTROYED = "chartDestroyed";
Events.EVENT_TOOL_PANEL_VISIBLE_CHANGED = "toolPanelVisibleChanged";
Events.EVENT_TOOL_PANEL_SIZE_CHANGED = "toolPanelSizeChanged";
Events.EVENT_COLUMN_PANEL_ITEM_DRAG_START = "columnPanelItemDragStart";
Events.EVENT_COLUMN_PANEL_ITEM_DRAG_END = "columnPanelItemDragEnd";
Events.EVENT_MODEL_UPDATED = "modelUpdated";
Events.EVENT_CUT_START = "cutStart";
Events.EVENT_CUT_END = "cutEnd";
Events.EVENT_PASTE_START = "pasteStart";
Events.EVENT_PASTE_END = "pasteEnd";
Events.EVENT_FILL_START = "fillStart";
Events.EVENT_FILL_END = "fillEnd";
Events.EVENT_RANGE_DELETE_START = "rangeDeleteStart";
Events.EVENT_RANGE_DELETE_END = "rangeDeleteEnd";
Events.EVENT_UNDO_STARTED = "undoStarted";
Events.EVENT_UNDO_ENDED = "undoEnded";
Events.EVENT_REDO_STARTED = "redoStarted";
Events.EVENT_REDO_ENDED = "redoEnded";
Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_START = "keyShortcutChangedCellStart";
Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_END = "keyShortcutChangedCellEnd";
Events.EVENT_CELL_CLICKED = "cellClicked";
Events.EVENT_CELL_DOUBLE_CLICKED = "cellDoubleClicked";
Events.EVENT_CELL_MOUSE_DOWN = "cellMouseDown";
Events.EVENT_CELL_CONTEXT_MENU = "cellContextMenu";
Events.EVENT_CELL_VALUE_CHANGED = "cellValueChanged";
Events.EVENT_CELL_EDIT_REQUEST = "cellEditRequest";
Events.EVENT_ROW_VALUE_CHANGED = "rowValueChanged";
Events.EVENT_CELL_FOCUSED = "cellFocused";
Events.EVENT_CELL_FOCUS_CLEARED = "cellFocusCleared";
Events.EVENT_FULL_WIDTH_ROW_FOCUSED = "fullWidthRowFocused";
Events.EVENT_ROW_SELECTED = "rowSelected";
Events.EVENT_SELECTION_CHANGED = "selectionChanged";
Events.EVENT_CELL_KEY_DOWN = "cellKeyDown";
Events.EVENT_CELL_MOUSE_OVER = "cellMouseOver";
Events.EVENT_CELL_MOUSE_OUT = "cellMouseOut";
Events.EVENT_FILTER_CHANGED = "filterChanged";
Events.EVENT_FILTER_MODIFIED = "filterModified";
Events.EVENT_FILTER_OPENED = "filterOpened";
Events.EVENT_SORT_CHANGED = "sortChanged";
Events.EVENT_VIRTUAL_ROW_REMOVED = "virtualRowRemoved";
Events.EVENT_ROW_CLICKED = "rowClicked";
Events.EVENT_ROW_DOUBLE_CLICKED = "rowDoubleClicked";
Events.EVENT_GRID_READY = "gridReady";
Events.EVENT_GRID_SIZE_CHANGED = "gridSizeChanged";
Events.EVENT_VIEWPORT_CHANGED = "viewportChanged";
Events.EVENT_SCROLLBAR_WIDTH_CHANGED = "scrollbarWidthChanged";
Events.EVENT_FIRST_DATA_RENDERED = "firstDataRendered";
Events.EVENT_DRAG_STARTED = "dragStarted";
Events.EVENT_DRAG_STOPPED = "dragStopped";
Events.EVENT_CHECKBOX_CHANGED = "checkboxChanged";
Events.EVENT_ROW_EDITING_STARTED = "rowEditingStarted";
Events.EVENT_ROW_EDITING_STOPPED = "rowEditingStopped";
Events.EVENT_CELL_EDITING_STARTED = "cellEditingStarted";
Events.EVENT_CELL_EDITING_STOPPED = "cellEditingStopped";
Events.EVENT_BODY_SCROLL = "bodyScroll";
Events.EVENT_BODY_SCROLL_END = "bodyScrollEnd";
Events.EVENT_HEIGHT_SCALE_CHANGED = "heightScaleChanged";
Events.EVENT_PAGINATION_CHANGED = "paginationChanged";
Events.EVENT_COMPONENT_STATE_CHANGED = "componentStateChanged";
Events.EVENT_STORE_REFRESHED = "storeRefreshed";
Events.EVENT_BODY_HEIGHT_CHANGED = "bodyHeightChanged";
Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED = "displayedColumnsWidthChanged";
Events.EVENT_SCROLL_VISIBILITY_CHANGED = "scrollVisibilityChanged";
Events.EVENT_COLUMN_HOVER_CHANGED = "columnHoverChanged";
Events.EVENT_FLASH_CELLS = "flashCells";
Events.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED = "paginationPixelOffsetChanged";
Events.EVENT_DISPLAYED_ROWS_CHANGED = "displayedRowsChanged";
Events.EVENT_LEFT_PINNED_WIDTH_CHANGED = "leftPinnedWidthChanged";
Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED = "rightPinnedWidthChanged";
Events.EVENT_ROW_CONTAINER_HEIGHT_CHANGED = "rowContainerHeightChanged";
Events.EVENT_HEADER_HEIGHT_CHANGED = "headerHeightChanged";
Events.EVENT_COLUMN_HEADER_HEIGHT_CHANGED = "columnHeaderHeightChanged";
Events.EVENT_ROW_DRAG_ENTER = "rowDragEnter";
Events.EVENT_ROW_DRAG_MOVE = "rowDragMove";
Events.EVENT_ROW_DRAG_LEAVE = "rowDragLeave";
Events.EVENT_ROW_DRAG_END = "rowDragEnd";
Events.EVENT_GRID_STYLES_CHANGED = "gridStylesChanged";
Events.EVENT_POPUP_TO_FRONT = "popupToFront";
Events.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST = "columnRowGroupChangeRequest";
Events.EVENT_COLUMN_PIVOT_CHANGE_REQUEST = "columnPivotChangeRequest";
Events.EVENT_COLUMN_VALUE_CHANGE_REQUEST = "columnValueChangeRequest";
Events.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST = "columnAggFuncChangeRequest";
Events.EVENT_KEYBOARD_FOCUS = "keyboardFocus";
Events.EVENT_MOUSE_FOCUS = "mouseFocus";
Events.EVENT_STORE_UPDATED = "storeUpdated";
Events.EVENT_FILTER_DESTROYED = "filterDestroyed";
var GroupInstanceIdCreator = class {
  constructor() {
    this.existingIds = {};
  }
  getInstanceIdForKey(key) {
    const lastResult = this.existingIds[key];
    let result;
    if (typeof lastResult !== "number") {
      result = 0;
    } else {
      result = lastResult + 1;
    }
    this.existingIds[key] = result;
    return result;
  }
};
var __decorate$2y = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GROUP_AUTO_COLUMN_ID = "ag-Grid-AutoColumn";
var AutoGroupColService = class AutoGroupColService2 extends BeanStub {
  createAutoGroupColumns(existingCols, rowGroupColumns) {
    const groupAutoColumns = [];
    const doingTreeData = this.gridOptionsService.isTreeData();
    let doingMultiAutoColumn = this.gridOptionsService.isGroupMultiAutoColumn();
    if (doingTreeData && doingMultiAutoColumn) {
      console.warn('AG Grid: you cannot mix groupDisplayType = "multipleColumns" with treeData, only one column can be used to display groups when doing tree data');
      doingMultiAutoColumn = false;
    }
    if (doingMultiAutoColumn) {
      rowGroupColumns.forEach((rowGroupCol, index) => {
        groupAutoColumns.push(this.createOneAutoGroupColumn(existingCols, rowGroupCol, index));
      });
    } else {
      groupAutoColumns.push(this.createOneAutoGroupColumn(existingCols));
    }
    return groupAutoColumns;
  }
  createOneAutoGroupColumn(existingCols, rowGroupCol, index) {
    let defaultAutoColDef = this.generateDefaultColDef(rowGroupCol);
    let colId;
    if (rowGroupCol) {
      colId = `${GROUP_AUTO_COLUMN_ID}-${rowGroupCol.getId()}`;
    } else {
      colId = GROUP_AUTO_COLUMN_ID;
    }
    const userAutoColDef = this.gridOptionsService.get("autoGroupColumnDef");
    mergeDeep(defaultAutoColDef, userAutoColDef);
    defaultAutoColDef = this.columnFactory.mergeColDefs(defaultAutoColDef, colId);
    defaultAutoColDef.colId = colId;
    if (!this.gridOptionsService.isTreeData()) {
      const noFieldOrValueGetter = missing(defaultAutoColDef.field) && missing(defaultAutoColDef.valueGetter) && missing(defaultAutoColDef.filterValueGetter) && defaultAutoColDef.filter !== "agGroupColumnFilter";
      if (noFieldOrValueGetter) {
        defaultAutoColDef.filter = false;
      }
    }
    if (index && index > 0) {
      defaultAutoColDef.headerCheckboxSelection = false;
    }
    const existingCol = existingCols.find((col) => col.getId() == colId);
    const isSortingCoupled = this.gridOptionsService.isColumnsSortingCoupledToGroup();
    if (existingCol) {
      if (isSortingCoupled) {
        defaultAutoColDef.sort = void 0;
        defaultAutoColDef.sortIndex = void 0;
      }
      existingCol.setColDef(defaultAutoColDef, null);
      this.columnFactory.applyColumnState(existingCol, defaultAutoColDef);
      return existingCol;
    }
    if (isSortingCoupled && (defaultAutoColDef.sort || defaultAutoColDef.initialSort || "sortIndex" in defaultAutoColDef) && !defaultAutoColDef.field) {
      defaultAutoColDef.sort = null;
      defaultAutoColDef.sortIndex = null;
      defaultAutoColDef.initialSort = null;
    }
    const newCol = new Column(defaultAutoColDef, null, colId, true);
    this.context.createBean(newCol);
    return newCol;
  }
  generateDefaultColDef(rowGroupCol) {
    const userDef = this.gridOptionsService.get("autoGroupColumnDef");
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    const res = {
      headerName: localeTextFunc("group", "Group")
    };
    const userHasProvidedGroupCellRenderer = userDef && (userDef.cellRenderer || userDef.cellRendererSelector);
    if (!userHasProvidedGroupCellRenderer) {
      res.cellRenderer = "agGroupCellRenderer";
    }
    if (rowGroupCol) {
      const colDef = rowGroupCol.getColDef();
      Object.assign(res, {
        headerName: this.columnModel.getDisplayNameForColumn(rowGroupCol, "header"),
        headerValueGetter: colDef.headerValueGetter
      });
      if (colDef.cellRenderer) {
        Object.assign(res, {
          cellRendererParams: {
            innerRenderer: colDef.cellRenderer,
            innerRendererParams: colDef.cellRendererParams
          }
        });
      }
      res.showRowGroup = rowGroupCol.getColId();
    } else {
      res.showRowGroup = true;
    }
    return res;
  }
};
__decorate$2y([
  Autowired("columnModel")
], AutoGroupColService.prototype, "columnModel", void 0);
__decorate$2y([
  Autowired("columnFactory")
], AutoGroupColService.prototype, "columnFactory", void 0);
AutoGroupColService = __decorate$2y([
  Bean("autoGroupColService")
], AutoGroupColService);
var reUnescapedHtml = /[&<>"']/g;
var HTML_ESCAPES = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function utf8_encode(s) {
  const stringFromCharCode = String.fromCharCode;
  function ucs2decode(string) {
    const output = [];
    if (!string) {
      return [];
    }
    const len = string.length;
    let counter = 0;
    let value;
    let extra;
    while (counter < len) {
      value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < len) {
        extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  function checkScalarValue(point) {
    if (point >= 55296 && point <= 57343) {
      throw Error("Lone surrogate U+" + point.toString(16).toUpperCase() + " is not a scalar value");
    }
  }
  function createByte(point, shift) {
    return stringFromCharCode(point >> shift & 63 | 128);
  }
  function encodeCodePoint(point) {
    if (point >= 0 && point <= 31 && point !== 10) {
      const convertedCode = point.toString(16).toUpperCase();
      const paddedCode = convertedCode.padStart(4, "0");
      return `_x${paddedCode}_`;
    }
    if ((point & 4294967168) == 0) {
      return stringFromCharCode(point);
    }
    let symbol = "";
    if ((point & 4294965248) == 0) {
      symbol = stringFromCharCode(point >> 6 & 31 | 192);
    } else if ((point & 4294901760) == 0) {
      checkScalarValue(point);
      symbol = stringFromCharCode(point >> 12 & 15 | 224);
      symbol += createByte(point, 6);
    } else if ((point & 4292870144) == 0) {
      symbol = stringFromCharCode(point >> 18 & 7 | 240);
      symbol += createByte(point, 12);
      symbol += createByte(point, 6);
    }
    symbol += stringFromCharCode(point & 63 | 128);
    return symbol;
  }
  const codePoints = ucs2decode(s);
  const length = codePoints.length;
  let index = -1;
  let codePoint;
  let byteString = "";
  while (++index < length) {
    codePoint = codePoints[index];
    byteString += encodeCodePoint(codePoint);
  }
  return byteString;
}
function capitalise(str) {
  return str[0].toUpperCase() + str.substr(1).toLowerCase();
}
function escapeString(toEscape, skipEscapingHtmlChars) {
  if (toEscape == null) {
    return null;
  }
  const stringResult = toEscape.toString().toString();
  if (skipEscapingHtmlChars) {
    return stringResult;
  }
  return stringResult.replace(reUnescapedHtml, (chr) => HTML_ESCAPES[chr]);
}
function camelCaseToHumanText(camelCase) {
  if (!camelCase || camelCase == null) {
    return null;
  }
  const rex = /([a-z])([A-Z])/g;
  const rexCaps = /([A-Z]+)([A-Z])([a-z])/g;
  const words = camelCase.replace(rex, "$1 $2").replace(rexCaps, "$1 $2$3").replace(/\./g, " ").split(" ");
  return words.map((word) => word.substring(0, 1).toUpperCase() + (word.length > 1 ? word.substring(1, word.length) : "")).join(" ");
}
function camelCaseToHyphenated(camelCase) {
  return camelCase.replace(/[A-Z]/g, (s) => `-${s.toLocaleLowerCase()}`);
}
var StringUtils = Object.freeze({
  __proto__: null,
  utf8_encode,
  capitalise,
  escapeString,
  camelCaseToHumanText,
  camelCaseToHyphenated
});
function convertToMap(arr) {
  const map = /* @__PURE__ */ new Map();
  arr.forEach((pair) => map.set(pair[0], pair[1]));
  return map;
}
function mapById(arr, callback) {
  const map = /* @__PURE__ */ new Map();
  arr.forEach((item) => map.set(callback(item), item));
  return map;
}
function keys(map) {
  const arr = [];
  map.forEach((_2, key) => arr.push(key));
  return arr;
}
var MapUtils = Object.freeze({
  __proto__: null,
  convertToMap,
  mapById,
  keys
});
var ColDefUtil = class {
};
ColDefUtil.ColDefPropertyMap = {
  headerName: void 0,
  columnGroupShow: void 0,
  headerClass: void 0,
  toolPanelClass: void 0,
  headerValueGetter: void 0,
  pivotKeys: void 0,
  groupId: void 0,
  colId: void 0,
  sort: void 0,
  initialSort: void 0,
  field: void 0,
  type: void 0,
  cellDataType: void 0,
  tooltipComponent: void 0,
  tooltipField: void 0,
  headerTooltip: void 0,
  cellClass: void 0,
  showRowGroup: void 0,
  filter: void 0,
  initialAggFunc: void 0,
  defaultAggFunc: void 0,
  aggFunc: void 0,
  pinned: void 0,
  initialPinned: void 0,
  chartDataType: void 0,
  cellEditorPopupPosition: void 0,
  headerGroupComponent: void 0,
  headerGroupComponentParams: void 0,
  cellStyle: void 0,
  cellRenderer: void 0,
  cellRendererParams: void 0,
  cellEditor: void 0,
  cellEditorParams: void 0,
  filterParams: void 0,
  pivotValueColumn: void 0,
  headerComponent: void 0,
  headerComponentParams: void 0,
  floatingFilterComponent: void 0,
  floatingFilterComponentParams: void 0,
  tooltipComponentParams: void 0,
  refData: void 0,
  columnsMenuParams: void 0,
  children: void 0,
  sortingOrder: void 0,
  allowedAggFuncs: void 0,
  menuTabs: void 0,
  pivotTotalColumnIds: void 0,
  cellClassRules: void 0,
  icons: void 0,
  sortIndex: void 0,
  initialSortIndex: void 0,
  flex: void 0,
  initialFlex: void 0,
  width: void 0,
  initialWidth: void 0,
  minWidth: void 0,
  maxWidth: void 0,
  rowGroupIndex: void 0,
  initialRowGroupIndex: void 0,
  pivotIndex: void 0,
  initialPivotIndex: void 0,
  suppressCellFlash: void 0,
  suppressColumnsToolPanel: void 0,
  suppressFiltersToolPanel: void 0,
  openByDefault: void 0,
  marryChildren: void 0,
  suppressStickyLabel: void 0,
  hide: void 0,
  initialHide: void 0,
  rowGroup: void 0,
  initialRowGroup: void 0,
  pivot: void 0,
  initialPivot: void 0,
  checkboxSelection: void 0,
  showDisabledCheckboxes: void 0,
  headerCheckboxSelection: void 0,
  headerCheckboxSelectionFilteredOnly: void 0,
  headerCheckboxSelectionCurrentPageOnly: void 0,
  suppressMenu: void 0,
  suppressMovable: void 0,
  lockPosition: void 0,
  lockVisible: void 0,
  lockPinned: void 0,
  unSortIcon: void 0,
  suppressSizeToFit: void 0,
  suppressAutoSize: void 0,
  enableRowGroup: void 0,
  enablePivot: void 0,
  enableValue: void 0,
  editable: void 0,
  suppressPaste: void 0,
  suppressNavigable: void 0,
  enableCellChangeFlash: void 0,
  rowDrag: void 0,
  dndSource: void 0,
  autoHeight: void 0,
  wrapText: void 0,
  sortable: void 0,
  resizable: void 0,
  singleClickEdit: void 0,
  floatingFilter: void 0,
  cellEditorPopup: void 0,
  suppressFillHandle: void 0,
  wrapHeaderText: void 0,
  autoHeaderHeight: void 0,
  dndSourceOnRowDrag: void 0,
  valueGetter: void 0,
  valueSetter: void 0,
  filterValueGetter: void 0,
  keyCreator: void 0,
  valueFormatter: void 0,
  valueParser: void 0,
  comparator: void 0,
  equals: void 0,
  pivotComparator: void 0,
  suppressKeyboardEvent: void 0,
  suppressHeaderKeyboardEvent: void 0,
  colSpan: void 0,
  rowSpan: void 0,
  getQuickFilterText: void 0,
  onCellValueChanged: void 0,
  onCellClicked: void 0,
  onCellDoubleClicked: void 0,
  onCellContextMenu: void 0,
  rowDragText: void 0,
  tooltipValueGetter: void 0,
  cellRendererSelector: void 0,
  cellEditorSelector: void 0,
  suppressSpanHeaderHeight: void 0,
  useValueFormatterForExport: void 0,
  useValueParserForImport: void 0
};
ColDefUtil.ALL_PROPERTIES = Object.keys(ColDefUtil.ColDefPropertyMap);
var PropertyKeys = class {
};
PropertyKeys.STRING_PROPERTIES = [
  "rowSelection",
  "overlayLoadingTemplate",
  "overlayNoRowsTemplate",
  "gridId",
  "quickFilterText",
  "rowModelType",
  "editType",
  "domLayout",
  "clipboardDelimiter",
  "rowGroupPanelShow",
  "multiSortKey",
  "pivotColumnGroupTotals",
  "pivotRowTotals",
  "pivotPanelShow",
  "fillHandleDirection",
  "serverSideStoreType",
  "groupDisplayType",
  "treeDataDisplayType",
  "colResizeDefault"
];
PropertyKeys.OBJECT_PROPERTIES = [
  "components",
  "rowStyle",
  "context",
  "autoGroupColumnDef",
  "localeText",
  "icons",
  "datasource",
  "serverSideDatasource",
  "viewportDatasource",
  "groupRowRendererParams",
  "aggFuncs",
  "fullWidthCellRendererParams",
  "defaultColGroupDef",
  "defaultColDef",
  "defaultCsvExportParams",
  "defaultExcelExportParams",
  "columnTypes",
  "rowClassRules",
  "detailCellRendererParams",
  "loadingCellRendererParams",
  "loadingOverlayComponentParams",
  "noRowsOverlayComponentParams",
  "popupParent",
  "statusBar",
  "sideBar",
  "chartThemeOverrides",
  "customChartThemes",
  "chartToolPanelsDef",
  "dataTypeDefinitions"
];
PropertyKeys.ARRAY_PROPERTIES = [
  "sortingOrder",
  "alignedGrids",
  "rowData",
  "columnDefs",
  "excelStyles",
  "pinnedTopRowData",
  "pinnedBottomRowData",
  "chartThemes",
  "rowClass"
];
PropertyKeys.NUMBER_PROPERTIES = [
  "rowHeight",
  "detailRowHeight",
  "rowBuffer",
  "headerHeight",
  "groupHeaderHeight",
  "floatingFiltersHeight",
  "pivotHeaderHeight",
  "pivotGroupHeaderHeight",
  "groupDefaultExpanded",
  "viewportRowModelPageSize",
  "viewportRowModelBufferSize",
  "autoSizePadding",
  "maxBlocksInCache",
  "maxConcurrentDatasourceRequests",
  "tooltipShowDelay",
  "tooltipHideDelay",
  "cacheOverflowSize",
  "paginationPageSize",
  "cacheBlockSize",
  "infiniteInitialRowCount",
  "serverSideInitialRowCount",
  "scrollbarWidth",
  "asyncTransactionWaitMillis",
  "blockLoadDebounceMillis",
  "keepDetailRowsCount",
  "undoRedoCellEditingLimit",
  "cellFlashDelay",
  "cellFadeDelay",
  "tabIndex"
];
PropertyKeys.BOOLEAN_PROPERTIES = [
  "suppressMakeColumnVisibleAfterUnGroup",
  "suppressRowClickSelection",
  "suppressCellFocus",
  "suppressHorizontalScroll",
  "alwaysShowHorizontalScroll",
  "alwaysShowVerticalScroll",
  "debug",
  "enableBrowserTooltips",
  "enableCellExpressions",
  "groupSelectsChildren",
  "groupIncludeFooter",
  "groupIncludeTotalFooter",
  "groupSuppressBlankHeader",
  "suppressMenuHide",
  "suppressRowDeselection",
  "unSortIcon",
  "suppressMultiSort",
  "alwaysMultiSort",
  "singleClickEdit",
  "suppressLoadingOverlay",
  "suppressNoRowsOverlay",
  "suppressAutoSize",
  "skipHeaderOnAutoSize",
  "suppressParentsInRowNodes",
  "suppressColumnMoveAnimation",
  "suppressMovableColumns",
  "suppressFieldDotNotation",
  "enableRangeSelection",
  "enableRangeHandle",
  "enableFillHandle",
  "suppressClearOnFillReduction",
  "deltaSort",
  "suppressTouch",
  "suppressAsyncEvents",
  "allowContextMenuWithControlKey",
  "suppressContextMenu",
  "rememberGroupStateWhenNewData",
  "enableCellChangeFlash",
  "suppressDragLeaveHidesColumns",
  "suppressRowGroupHidesColumns",
  "suppressMiddleClickScrolls",
  "suppressPreventDefaultOnMouseWheel",
  "suppressCopyRowsToClipboard",
  "copyHeadersToClipboard",
  "copyGroupHeadersToClipboard",
  "pivotMode",
  "suppressAggFuncInHeader",
  "suppressColumnVirtualisation",
  "alwaysAggregateAtRootLevel",
  "suppressAggAtRootLevel",
  "suppressFocusAfterRefresh",
  "functionsPassive",
  "functionsReadOnly",
  "animateRows",
  "groupSelectsFiltered",
  "groupRemoveSingleChildren",
  "groupRemoveLowestSingleChildren",
  "enableRtl",
  "suppressClickEdit",
  "rowDragEntireRow",
  "rowDragManaged",
  "suppressRowDrag",
  "suppressMoveWhenRowDragging",
  "rowDragMultiRow",
  "enableGroupEdit",
  "embedFullWidthRows",
  "suppressPaginationPanel",
  "groupHideOpenParents",
  "groupAllowUnbalanced",
  "pagination",
  "paginationAutoPageSize",
  "suppressScrollOnNewData",
  "suppressScrollWhenPopupsAreOpen",
  "purgeClosedRowNodes",
  "cacheQuickFilter",
  "includeHiddenColumnsInQuickFilter",
  "excludeHiddenColumnsFromQuickFilter",
  "ensureDomOrder",
  "accentedSort",
  "suppressChangeDetection",
  "valueCache",
  "valueCacheNeverExpires",
  "aggregateOnlyChangedColumns",
  "suppressAnimationFrame",
  "suppressExcelExport",
  "suppressCsvExport",
  "treeData",
  "masterDetail",
  "suppressMultiRangeSelection",
  "enterMovesDown",
  "enterMovesDownAfterEdit",
  "enterNavigatesVerticallyAfterEdit",
  "enterNavigatesVertically",
  "suppressPropertyNamesCheck",
  "rowMultiSelectWithClick",
  "suppressRowHoverHighlight",
  "suppressRowTransform",
  "suppressClipboardPaste",
  "suppressLastEmptyLineOnPaste",
  "enableCharts",
  "enableChartToolPanelsButton",
  "suppressChartToolPanelsButton",
  "suppressMaintainUnsortedOrder",
  "enableCellTextSelection",
  "suppressBrowserResizeObserver",
  "suppressMaxRenderedRowRestriction",
  "excludeChildrenWhenTreeDataFiltering",
  "tooltipMouseTrack",
  "keepDetailRows",
  "paginateChildRows",
  "preventDefaultOnContextMenu",
  "undoRedoCellEditing",
  "allowDragFromColumnsToolPanel",
  "pivotSuppressAutoColumn",
  "suppressExpandablePivotGroups",
  "debounceVerticalScrollbar",
  "detailRowAutoHeight",
  "serverSideFilteringAlwaysResets",
  "serverSideFilterAllLevels",
  "serverSideSortingAlwaysResets",
  "serverSideSortAllLevels",
  "serverSideOnlyRefreshFilteredGroups",
  "serverSideSortOnServer",
  "serverSideFilterOnServer",
  "suppressAggFilteredOnly",
  "showOpenedGroup",
  "suppressClipboardApi",
  "suppressModelUpdateAfterUpdateTransaction",
  "stopEditingWhenCellsLoseFocus",
  "maintainColumnOrder",
  "groupMaintainOrder",
  "columnHoverHighlight",
  "suppressReactUi",
  "readOnlyEdit",
  "suppressRowVirtualisation",
  "enableCellEditingOnBackspace",
  "resetRowDataOnUpdate",
  "removePivotHeaderRowWhenSingleValueColumn",
  "suppressCopySingleCellRanges",
  "suppressGroupRowsSticky",
  "suppressServerSideInfiniteScroll",
  "rowGroupPanelSuppressSort",
  "allowShowChangeAfterFilter",
  "suppressCutToClipboard"
];
PropertyKeys.FUNCTIONAL_PROPERTIES = [
  "doesExternalFilterPass",
  "processSecondaryColDef",
  "processSecondaryColGroupDef",
  "processPivotResultColDef",
  "processPivotResultColGroupDef",
  "getBusinessKeyForNode",
  "isRowSelectable",
  "rowDragText",
  "groupRowRenderer",
  "fullWidthCellRenderer",
  "loadingCellRenderer",
  "loadingOverlayComponent",
  "noRowsOverlayComponent",
  "detailCellRenderer"
];
PropertyKeys.CALLBACK_PROPERTIES = [
  "getLocaleText",
  "isExternalFilterPresent",
  "getRowHeight",
  "getRowClass",
  "getRowStyle",
  "getContextMenuItems",
  "getMainMenuItems",
  "processRowPostCreate",
  "processCellForClipboard",
  "getGroupRowAgg",
  "isFullWidthRow",
  "sendToClipboard",
  "navigateToNextHeader",
  "tabToNextHeader",
  "navigateToNextCell",
  "tabToNextCell",
  "processCellFromClipboard",
  "getDocument",
  "postProcessPopup",
  "getChildCount",
  "getDataPath",
  "isRowMaster",
  "postSortRows",
  "processHeaderForClipboard",
  "processGroupHeaderForClipboard",
  "paginationNumberFormatter",
  "processDataFromClipboard",
  "getServerSideGroupKey",
  "isServerSideGroup",
  "createChartContainer",
  "getChartToolbarItems",
  "fillOperation",
  "isApplyServerSideTransaction",
  "getServerSideStoreParams",
  "getServerSideGroupLevelParams",
  "isServerSideGroupOpenByDefault",
  "isGroupOpenByDefault",
  "initialGroupOrderComparator",
  "loadingCellRendererSelector",
  "getRowId",
  "groupAggFiltering"
];
PropertyKeys.FUNCTION_PROPERTIES = [
  ...PropertyKeys.FUNCTIONAL_PROPERTIES,
  ...PropertyKeys.CALLBACK_PROPERTIES
];
PropertyKeys.ALL_PROPERTIES = [
  ...PropertyKeys.ARRAY_PROPERTIES,
  ...PropertyKeys.OBJECT_PROPERTIES,
  ...PropertyKeys.STRING_PROPERTIES,
  ...PropertyKeys.NUMBER_PROPERTIES,
  ...PropertyKeys.FUNCTION_PROPERTIES,
  ...PropertyKeys.BOOLEAN_PROPERTIES
];
var ComponentUtil = class {
  static getCallbackForEvent(eventName) {
    if (!eventName || eventName.length < 2) {
      return eventName;
    }
    return "on" + eventName[0].toUpperCase() + eventName.substr(1);
  }
  static getCoercionLookup() {
    let coercionLookup = {};
    [
      ...ComponentUtil.ARRAY_PROPERTIES,
      ...ComponentUtil.OBJECT_PROPERTIES,
      ...ComponentUtil.STRING_PROPERTIES,
      ...ComponentUtil.FUNCTION_PROPERTIES,
      ...ComponentUtil.EVENT_CALLBACKS
    ].forEach((key) => coercionLookup[key] = "none");
    ComponentUtil.BOOLEAN_PROPERTIES.forEach((key) => coercionLookup[key] = "boolean");
    ComponentUtil.NUMBER_PROPERTIES.forEach((key) => coercionLookup[key] = "number");
    return coercionLookup;
  }
  static getValue(key, rawValue) {
    const coercionStep = ComponentUtil.coercionLookup[key];
    if (coercionStep) {
      let newValue = rawValue;
      switch (coercionStep) {
        case "number": {
          newValue = ComponentUtil.toNumber(rawValue);
          break;
        }
        case "boolean": {
          newValue = ComponentUtil.toBoolean(rawValue);
          break;
        }
        case "none": {
          if (key === "groupAggFiltering" && typeof rawValue !== "function") {
            newValue = ComponentUtil.toBoolean(rawValue);
          }
          break;
        }
      }
      return newValue;
    }
    return void 0;
  }
  static getGridOptionKeys(component, isVue) {
    return isVue ? Object.keys(ComponentUtil.coercionLookup) : Object.keys(component);
  }
  static copyAttributesToGridOptions(gridOptions, component, isVue = false) {
    if (typeof gridOptions !== "object") {
      gridOptions = {};
    }
    const pGridOptions = gridOptions;
    const keys2 = ComponentUtil.getGridOptionKeys(component, isVue);
    keys2.forEach((key) => {
      const value = component[key];
      if (typeof value !== "undefined") {
        const coercedValue = ComponentUtil.getValue(key, value);
        if (coercedValue !== void 0) {
          pGridOptions[key] = coercedValue;
        }
      }
    });
    return gridOptions;
  }
  static processOnChange(changes, api) {
    if (!changes || Object.keys(changes).length === 0) {
      return;
    }
    const changesToApply = Object.assign({}, changes);
    if (changesToApply.columnTypes) {
      api.setColumnTypes(changesToApply.columnTypes.currentValue, "gridOptionsChanged");
      delete changesToApply.columnTypes;
    }
    if (changesToApply.autoGroupColumnDef) {
      api.setAutoGroupColumnDef(changesToApply.autoGroupColumnDef.currentValue, "gridOptionsChanged");
      delete changesToApply.autoGroupColumnDef;
    }
    if (changesToApply.defaultColDef) {
      api.setDefaultColDef(changesToApply.defaultColDef.currentValue, "gridOptionsChanged");
      delete changesToApply.defaultColDef;
    }
    if (changesToApply.columnDefs) {
      api.setColumnDefs(changesToApply.columnDefs.currentValue, "gridOptionsChanged");
      delete changesToApply.columnDefs;
    }
    Object.keys(changesToApply).forEach((key) => {
      const gridKey = key;
      const coercedValue = ComponentUtil.getValue(gridKey, changesToApply[gridKey].currentValue);
      api.__setProperty(gridKey, coercedValue);
    });
    const event = {
      type: Events.EVENT_COMPONENT_STATE_CHANGED
    };
    iterateObject(changes, (key, value) => {
      event[key] = value;
    });
    api.dispatchEvent(event);
  }
  static toBoolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      return value.toUpperCase() === "TRUE" || value == "";
    }
    return false;
  }
  static toNumber(value) {
    if (typeof value === "number") {
      return value;
    }
    if (typeof value === "string") {
      return Number(value);
    }
  }
};
ComponentUtil.EVENTS = values(Events);
ComponentUtil.EXCLUDED_INTERNAL_EVENTS = [
  Events.EVENT_SCROLLBAR_WIDTH_CHANGED,
  Events.EVENT_CHECKBOX_CHANGED,
  Events.EVENT_HEIGHT_SCALE_CHANGED,
  Events.EVENT_BODY_HEIGHT_CHANGED,
  Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,
  Events.EVENT_SCROLL_VISIBILITY_CHANGED,
  Events.EVENT_COLUMN_HOVER_CHANGED,
  Events.EVENT_FLASH_CELLS,
  Events.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED,
  Events.EVENT_DISPLAYED_ROWS_CHANGED,
  Events.EVENT_LEFT_PINNED_WIDTH_CHANGED,
  Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED,
  Events.EVENT_ROW_CONTAINER_HEIGHT_CHANGED,
  Events.EVENT_POPUP_TO_FRONT,
  Events.EVENT_KEYBOARD_FOCUS,
  Events.EVENT_MOUSE_FOCUS,
  Events.EVENT_STORE_UPDATED,
  Events.EVENT_COLUMN_PANEL_ITEM_DRAG_START,
  Events.EVENT_COLUMN_PANEL_ITEM_DRAG_END,
  Events.EVENT_FILL_START,
  Events.EVENT_FILL_END,
  Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_START,
  Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_END,
  Events.EVENT_FULL_WIDTH_ROW_FOCUSED,
  Events.EVENT_HEADER_HEIGHT_CHANGED,
  Events.EVENT_COLUMN_HEADER_HEIGHT_CHANGED,
  Events.EVENT_CELL_FOCUS_CLEARED,
  Events.EVENT_GRID_STYLES_CHANGED,
  Events.EVENT_FILTER_DESTROYED
];
ComponentUtil.PUBLIC_EVENTS = ComponentUtil.EVENTS.filter((e) => !includes(ComponentUtil.EXCLUDED_INTERNAL_EVENTS, e));
ComponentUtil.EVENT_CALLBACKS = ComponentUtil.EVENTS.map((event) => ComponentUtil.getCallbackForEvent(event));
ComponentUtil.STRING_PROPERTIES = PropertyKeys.STRING_PROPERTIES;
ComponentUtil.OBJECT_PROPERTIES = PropertyKeys.OBJECT_PROPERTIES;
ComponentUtil.ARRAY_PROPERTIES = PropertyKeys.ARRAY_PROPERTIES;
ComponentUtil.NUMBER_PROPERTIES = PropertyKeys.NUMBER_PROPERTIES;
ComponentUtil.BOOLEAN_PROPERTIES = PropertyKeys.BOOLEAN_PROPERTIES;
ComponentUtil.FUNCTION_PROPERTIES = PropertyKeys.FUNCTION_PROPERTIES;
ComponentUtil.ALL_PROPERTIES = PropertyKeys.ALL_PROPERTIES;
ComponentUtil.ALL_PROPERTIES_SET = new Set(PropertyKeys.ALL_PROPERTIES);
ComponentUtil.coercionLookup = ComponentUtil.getCoercionLookup();
function fuzzyCheckStrings(inputValues, validValues, allSuggestions) {
  const fuzzyMatches = {};
  const invalidInputs = inputValues.filter((inputValue) => !validValues.some((validValue) => validValue === inputValue));
  if (invalidInputs.length > 0) {
    invalidInputs.forEach((invalidInput) => fuzzyMatches[invalidInput] = fuzzySuggestions(invalidInput, allSuggestions));
  }
  return fuzzyMatches;
}
function fuzzySuggestions(inputValue, allSuggestions, hideIrrelevant, filterByPercentageOfBestMatch) {
  let thisSuggestions = allSuggestions.map((text) => ({
    value: text,
    relevance: stringWeightedDistances(inputValue.toLowerCase(), text.toLocaleLowerCase())
  }));
  thisSuggestions.sort((a, b) => b.relevance - a.relevance);
  if (hideIrrelevant) {
    thisSuggestions = thisSuggestions.filter((suggestion) => suggestion.relevance !== 0);
  }
  if (filterByPercentageOfBestMatch && filterByPercentageOfBestMatch > 0) {
    const bestMatch = thisSuggestions[0].relevance;
    const limit = bestMatch * filterByPercentageOfBestMatch;
    thisSuggestions = thisSuggestions.filter((suggestion) => limit - suggestion.relevance < 0);
  }
  return thisSuggestions.map((suggestion) => suggestion.value);
}
function stringWeightedDistances(str1, str2) {
  const a = str1.replace(/\s/g, "");
  const b = str2.replace(/\s/g, "");
  let weight = 0;
  let lastIndex = -1;
  for (let i = 0; i < a.length; i++) {
    const idx = b.indexOf(a[i], lastIndex + 1);
    if (idx === -1) {
      continue;
    }
    lastIndex = idx;
    weight += 100 - lastIndex * 100 / 1e4 * 100;
  }
  return weight;
}
var FuzzyMatchUtils = Object.freeze({
  __proto__: null,
  fuzzyCheckStrings,
  fuzzySuggestions
});
var __decorate$2x = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function logDeprecation(version, oldProp, newProp, message) {
  const newPropMsg = newProp ? `Please use '${newProp}' instead. ` : "";
  doOnce(() => console.warn(`AG Grid: since v${version}, '${oldProp}' is deprecated. ${newPropMsg}${message !== null && message !== void 0 ? message : ""}`), `Deprecated_${oldProp}`);
}
var VUE_FRAMEWORK_PROPS = ["__ob__", "__v_skip", "__metadata__"];
var GridOptionsValidator = class GridOptionsValidator2 {
  constructor() {
    this.deprecatedProperties = {
      rememberGroupStateWhenNewData: { version: "24", message: "Now that transaction updates are possible and they keep group state, this feature is no longer needed." },
      serverSideFilteringAlwaysResets: { version: "28.0", newProp: "serverSideOnlyRefreshFilteredGroups", copyToNewProp: true },
      serverSideSortingAlwaysResets: { version: "28.0", newProp: "serverSideSortAllLevels", copyToNewProp: true },
      suppressReactUi: { version: "28", message: "The legacy React rendering engine is deprecated and will be removed in the next major version of the grid." },
      processSecondaryColDef: { version: "28", newProp: "processPivotResultColDef", copyToNewProp: true },
      processSecondaryColGroupDef: { version: "28", newProp: "processPivotResultColGroupDef", copyToNewProp: true },
      getServerSideStoreParams: { version: "28", newProp: "getServerSideGroupLevelParams", copyToNewProp: true },
      serverSideInfiniteScroll: { version: "29", message: "Infinite Scrolling is now the default behaviour. This can be suppressed with `suppressServerSideInfiniteScroll`." },
      enableChartToolPanelsButton: { version: "29", message: "The Chart Tool Panels button is now enabled by default. To hide the Chart Tool Panels button and display the hamburger button instead, set suppressChartToolPanelsButton=true." },
      functionsPassive: { version: "29.2" },
      onColumnRowGroupChangeRequest: { version: "29.2" },
      onColumnPivotChangeRequest: { version: "29.2" },
      onColumnValueChangeRequest: { version: "29.2" },
      onColumnAggFuncChangeRequest: { version: "29.2" },
      serverSideFilterAllLevels: { version: "30", message: "All server-side group levels are now filtered by default. This can be toggled using `serverSideOnlyRefreshFilteredGroups`." },
      suppressAggAtRootLevel: { version: "30", message: "The root level aggregation is now suppressed by default. This can be toggled using  `alwaysAggregateAtRootLevel`." },
      excludeHiddenColumnsFromQuickFilter: { version: "30", message: "Hidden columns are now excluded from the Quick Filter by default. This can be toggled using `includeHiddenColumnsInQuickFilter`." },
      enterMovesDown: { version: "30", newProp: "enterNavigatesVertically", copyToNewProp: true },
      enterMovesDownAfterEdit: { version: "30", newProp: "enterNavigatesVerticallyAfterEdit", copyToNewProp: true }
    };
  }
  pickOneWarning(prop1, prop2) {
    console.warn(`AG Grid: ${prop1} and ${prop2} do not work with each other, you need to pick one.`);
  }
  init() {
    this.checkForDeprecated();
    this.checkForViolations();
    if (this.gridOptions.suppressPropertyNamesCheck !== true) {
      this.checkGridOptionsProperties();
      this.checkColumnDefProperties();
    }
    this.checkColumnDefViolations();
    if (this.gridOptionsService.is("groupSelectsChildren") && this.gridOptionsService.is("suppressParentsInRowNodes")) {
      console.warn("AG Grid: 'groupSelectsChildren' does not work with 'suppressParentsInRowNodes', this selection method needs the part in rowNode to work");
    }
    if (this.gridOptionsService.is("groupSelectsChildren")) {
      if (this.gridOptionsService.get("rowSelection") !== "multiple") {
        console.warn("AG Grid: rowSelection must be 'multiple' for groupSelectsChildren to make sense");
      }
    }
    if (this.gridOptionsService.is("groupRemoveSingleChildren") && this.gridOptionsService.is("groupHideOpenParents")) {
      this.pickOneWarning("groupRemoveSingleChildren", "groupHideOpenParents");
    }
    if (this.gridOptionsService.get("domLayout") === "autoHeight" && !this.gridOptionsService.isRowModelType("clientSide")) {
      if (!this.gridOptionsService.is("pagination")) {
        console.warn(`AG Grid: domLayout='autoHeight' was ignored as it is only supported by the Client-Side row model, unless using pagination.`);
        this.gridOptions.domLayout = "normal";
      }
    }
    if (this.gridOptionsService.isRowModelType("serverSide")) {
      const msg = (prop, alt) => `AG Grid: '${prop}' is not supported on the Server-Side Row Model.` + (alt ? ` Please use ${alt} instead.` : "");
      if (this.gridOptionsService.exists("groupDefaultExpanded")) {
        console.warn(msg("groupDefaultExpanded", "isServerSideGroupOpenByDefault callback"));
      }
      if (this.gridOptionsService.exists("groupIncludeFooter") && this.gridOptionsService.is("suppressServerSideInfiniteScroll")) {
        console.warn(msg("groupIncludeFooter"));
      }
      if (this.gridOptionsService.exists("groupIncludeTotalFooter")) {
        console.warn(msg("groupIncludeTotalFooter"));
      }
    }
    if (this.gridOptionsService.is("enableRangeSelection")) {
      ModuleRegistry.assertRegistered(ModuleNames.RangeSelectionModule, "enableRangeSelection", this.gridOptionsService.getGridId());
    } else if (this.gridOptionsService.is("enableRangeHandle") || this.gridOptionsService.is("enableFillHandle")) {
      console.warn("AG Grid: 'enableRangeHandle' or 'enableFillHandle' will not work unless 'enableRangeSelection' is set to true");
    }
    const validateRegistered = (prop, module) => this.gridOptionsService.exists(prop) && ModuleRegistry.assertRegistered(module, prop, this.gridOptionsService.getGridId());
    validateRegistered("sideBar", ModuleNames.SideBarModule);
    validateRegistered("statusBar", ModuleNames.StatusBarModule);
    validateRegistered("enableCharts", ModuleNames.GridChartsModule);
    validateRegistered("getMainMenuItems", ModuleNames.MenuModule);
    validateRegistered("getContextMenuItems", ModuleNames.MenuModule);
    validateRegistered("allowContextMenuWithControlKey", ModuleNames.MenuModule);
  }
  checkColumnDefProperties() {
    if (this.gridOptions.columnDefs == null) {
      return;
    }
    const validProperties = ColDefUtil.ALL_PROPERTIES;
    const validateColDef = (colDef, propertyName) => {
      const userProperties = Object.getOwnPropertyNames(colDef);
      this.checkProperties(userProperties, [...validProperties, ...VUE_FRAMEWORK_PROPS], validProperties, propertyName, "https://www.ag-grid.com/javascript-data-grid/column-properties/");
      if (colDef.children) {
        colDef.children.forEach((child) => validateColDef(child, "columnDefs.children"));
      }
    };
    this.gridOptions.columnDefs.forEach((colDef) => validateColDef(colDef, "columnDefs"));
    if (this.gridOptions.defaultColDef) {
      validateColDef(this.gridOptions.defaultColDef, "defaultColDef");
    }
  }
  checkColumnDefViolations() {
    var _a;
    const rowModel = (_a = this.gridOptionsService.get("rowModelType")) !== null && _a !== void 0 ? _a : "clientSide";
    const unsupportedPropertiesMap = {
      infinite: ["headerCheckboxSelection", "headerCheckboxSelectionFilteredOnly", "headerCheckboxSelectionCurrentPageOnly"],
      viewport: ["headerCheckboxSelection", "headerCheckboxSelectionFilteredOnly", "headerCheckboxSelectionCurrentPageOnly"],
      serverSide: ["headerCheckboxSelectionFilteredOnly", "headerCheckboxSelectionCurrentPageOnly"],
      clientSide: []
    };
    const unsupportedProperties = unsupportedPropertiesMap[rowModel];
    if (!(unsupportedProperties === null || unsupportedProperties === void 0 ? void 0 : unsupportedProperties.length)) {
      return;
    }
    const validateColDef = (colDef) => {
      unsupportedProperties.forEach((property) => {
        if (property in colDef && !!colDef[property]) {
          console.warn(`AG Grid: Column property ${property} is not supported with the row model type ${rowModel}.`);
        }
      });
    };
    if (this.gridOptions.columnDefs != null) {
      this.gridOptions.columnDefs.forEach((colDef) => validateColDef(colDef));
    }
    if (this.gridOptions.autoGroupColumnDef != null) {
      validateColDef(this.gridOptions.autoGroupColumnDef);
    }
    if (this.gridOptions.defaultColDef != null) {
      validateColDef(this.gridOptions.defaultColDef);
    }
  }
  checkGridOptionsProperties() {
    const userProperties = Object.getOwnPropertyNames(this.gridOptions);
    const validProperties = [
      ...PropertyKeys.ALL_PROPERTIES,
      ...ComponentUtil.EVENT_CALLBACKS
    ];
    const validPropertiesAndExceptions = [...validProperties, "api", "columnApi", ...VUE_FRAMEWORK_PROPS, ...Object.keys(this.deprecatedProperties)];
    this.checkProperties(userProperties, validPropertiesAndExceptions, validProperties, "gridOptions", "https://www.ag-grid.com/javascript-data-grid/grid-options/");
  }
  checkProperties(userProperties, validPropertiesAndExceptions, validProperties, containerName, docsUrl) {
    const invalidProperties = fuzzyCheckStrings(userProperties, validPropertiesAndExceptions, validProperties);
    iterateObject(invalidProperties, (key, value) => {
      doOnce(() => console.warn(`AG Grid: invalid ${containerName} property '${key}' did you mean any of these: ${value.slice(0, 8).join(", ")}`), "invalidProperty" + containerName + key);
    });
    if (Object.keys(invalidProperties).length > 0) {
      doOnce(() => console.warn(`AG Grid: to see all the valid ${containerName} properties please check: ${docsUrl}`), "invalidProperties" + containerName + docsUrl);
    }
  }
  checkForDeprecated() {
    const options = this.gridOptions;
    Object.entries(this.deprecatedProperties).forEach(([oldProp, details]) => {
      var _a;
      const oldPropValue = options[oldProp];
      if (oldPropValue) {
        logDeprecation(details.version, oldProp, details.newProp, details.message);
        if (details.copyToNewProp && details.newProp && options[details.newProp] == null) {
          options[details.newProp] = (_a = details.newPropValue) !== null && _a !== void 0 ? _a : oldPropValue;
        }
      }
    });
    if (options.serverSideStoreType) {
      console.warn("AG Grid: since v29.0, `serverSideStoreType` has been replaced by `suppressServerSideInfiniteScroll`. Set to false to use Partial Store, and true to use Full Store.");
      options.suppressServerSideInfiniteScroll = options.serverSideStoreType !== "partial";
    }
  }
  checkForViolations() {
    if (this.gridOptionsService.is("treeData")) {
      this.treeDataViolations();
    }
  }
  treeDataViolations() {
    if (this.gridOptionsService.isRowModelType("clientSide")) {
      if (!this.gridOptionsService.exists("getDataPath")) {
        console.warn("AG Grid: property usingTreeData=true with rowModel=clientSide, but you did not provide getDataPath function, please provide getDataPath function if using tree data.");
      }
    }
    if (this.gridOptionsService.isRowModelType("serverSide")) {
      if (!this.gridOptionsService.exists("isServerSideGroup")) {
        console.warn("AG Grid: property usingTreeData=true with rowModel=serverSide, but you did not provide isServerSideGroup function, please provide isServerSideGroup function if using tree data.");
      }
      if (!this.gridOptionsService.exists("getServerSideGroupKey")) {
        console.warn("AG Grid: property usingTreeData=true with rowModel=serverSide, but you did not provide getServerSideGroupKey function, please provide getServerSideGroupKey function if using tree data.");
      }
    }
  }
};
__decorate$2x([
  Autowired("gridOptions")
], GridOptionsValidator.prototype, "gridOptions", void 0);
__decorate$2x([
  Autowired("gridOptionsService")
], GridOptionsValidator.prototype, "gridOptionsService", void 0);
__decorate$2x([
  PostConstruct
], GridOptionsValidator.prototype, "init", null);
GridOptionsValidator = __decorate$2x([
  Bean("gridOptionsValidator")
], GridOptionsValidator);
function matchesGroupDisplayType(toMatch, supplied) {
  const groupDisplayTypeValues = ["groupRows", "multipleColumns", "custom", "singleColumn"];
  if (groupDisplayTypeValues.indexOf(supplied) < 0) {
    console.warn(`AG Grid: '${supplied}' is not a valid groupDisplayType value - possible values are: '${groupDisplayTypeValues.join("', '")}'`);
    return false;
  }
  return supplied === toMatch;
}
function matchesTreeDataDisplayType(toMatch, supplied) {
  const treeDataDisplayTypeValues = ["auto", "custom"];
  if (treeDataDisplayTypeValues.indexOf(supplied) < 0) {
    console.warn(`AG Grid: '${supplied}' is not a valid treeDataDisplayType value - possible values are: '${treeDataDisplayTypeValues.join("', '")}'`);
    return false;
  }
  return supplied === toMatch;
}
var __decorate$2w = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$8 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var ColumnModel = class ColumnModel2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.primaryHeaderRowCount = 0;
    this.secondaryHeaderRowCount = 0;
    this.gridHeaderRowCount = 0;
    this.displayedColumnsLeft = [];
    this.displayedColumnsRight = [];
    this.displayedColumnsCenter = [];
    this.displayedColumns = [];
    this.displayedColumnsAndGroupsMap = {};
    this.viewportColumns = [];
    this.viewportColumnsHash = "";
    this.headerViewportColumns = [];
    this.viewportColumnsCenter = [];
    this.headerViewportColumnsCenter = [];
    this.autoHeightActiveAtLeastOnce = false;
    this.rowGroupColumns = [];
    this.valueColumns = [];
    this.pivotColumns = [];
    this.ready = false;
    this.autoGroupsNeedBuilding = false;
    this.forceRecreateAutoGroups = false;
    this.pivotMode = false;
    this.bodyWidth = 0;
    this.leftWidth = 0;
    this.rightWidth = 0;
    this.bodyWidthDirty = true;
  }
  init() {
    this.suppressColumnVirtualisation = this.gridOptionsService.is("suppressColumnVirtualisation");
    const pivotMode = this.gridOptionsService.is("pivotMode");
    if (this.isPivotSettingAllowed(pivotMode)) {
      this.pivotMode = pivotMode;
    }
    this.usingTreeData = this.gridOptionsService.isTreeData();
    this.addManagedPropertyListener("groupDisplayType", () => this.onAutoGroupColumnDefChanged());
    this.addManagedPropertyListener("autoGroupColumnDef", () => this.onAutoGroupColumnDefChanged());
    this.addManagedPropertyListener("defaultColDef", (params) => this.onSharedColDefChanged(params.source));
    this.addManagedPropertyListener("columnTypes", (params) => this.onSharedColDefChanged(params.source));
  }
  onAutoGroupColumnDefChanged() {
    this.autoGroupsNeedBuilding = true;
    this.forceRecreateAutoGroups = true;
    this.updateGridColumns();
    this.updateDisplayedColumns("gridOptionsChanged");
  }
  onSharedColDefChanged(source = "api") {
    this.forceRecreateAutoGroups = true;
    this.createColumnsFromColumnDefs(true, source);
  }
  setColumnDefs(columnDefs, source = "api") {
    const colsPreviouslyExisted = !!this.columnDefs;
    this.columnDefs = columnDefs;
    this.createColumnsFromColumnDefs(colsPreviouslyExisted, source);
  }
  recreateColumnDefs(source = "api") {
    this.onSharedColDefChanged(source);
  }
  destroyOldColumns(oldTree, newTree) {
    const oldObjectsById = {};
    if (!oldTree) {
      return;
    }
    this.columnUtils.depthFirstOriginalTreeSearch(null, oldTree, (child) => {
      oldObjectsById[child.getInstanceId()] = child;
    });
    if (newTree) {
      this.columnUtils.depthFirstOriginalTreeSearch(null, newTree, (child) => {
        oldObjectsById[child.getInstanceId()] = null;
      });
    }
    const colsToDestroy = Object.values(oldObjectsById).filter((item) => item != null);
    this.destroyBeans(colsToDestroy);
  }
  destroyColumns() {
    this.destroyOldColumns(this.primaryColumnTree);
    this.destroyOldColumns(this.secondaryBalancedTree);
    this.destroyOldColumns(this.groupAutoColsBalancedTree);
  }
  createColumnsFromColumnDefs(colsPreviouslyExisted, source = "api") {
    const dispatchEventsFunc = colsPreviouslyExisted ? this.compareColumnStatesAndDispatchEvents(source) : void 0;
    this.valueCache.expire();
    this.autoGroupsNeedBuilding = true;
    const oldPrimaryColumns = this.primaryColumns;
    const oldPrimaryTree = this.primaryColumnTree;
    const balancedTreeResult = this.columnFactory.createColumnTree(this.columnDefs, true, oldPrimaryTree);
    this.destroyOldColumns(this.primaryColumnTree, balancedTreeResult.columnTree);
    this.primaryColumnTree = balancedTreeResult.columnTree;
    this.primaryHeaderRowCount = balancedTreeResult.treeDept + 1;
    this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);
    this.primaryColumnsMap = {};
    this.primaryColumns.forEach((col) => this.primaryColumnsMap[col.getId()] = col);
    this.extractRowGroupColumns(source, oldPrimaryColumns);
    this.extractPivotColumns(source, oldPrimaryColumns);
    this.extractValueColumns(source, oldPrimaryColumns);
    this.ready = true;
    const gridColsNotProcessed = this.gridColsArePrimary === void 0;
    const processGridCols = this.gridColsArePrimary || gridColsNotProcessed;
    if (processGridCols) {
      this.updateGridColumns();
      if (colsPreviouslyExisted && !this.gridOptionsService.is("maintainColumnOrder")) {
        this.orderGridColumnsLikePrimary();
      }
      this.updateDisplayedColumns(source);
      this.checkViewportColumns();
    }
    this.dispatchEverythingChanged(source);
    if (dispatchEventsFunc) {
      dispatchEventsFunc();
    }
    this.dispatchNewColumnsLoaded();
  }
  dispatchNewColumnsLoaded() {
    const newColumnsLoadedEvent = {
      type: Events.EVENT_NEW_COLUMNS_LOADED
    };
    this.eventService.dispatchEvent(newColumnsLoadedEvent);
  }
  dispatchEverythingChanged(source = "api") {
    const eventEverythingChanged = {
      type: Events.EVENT_COLUMN_EVERYTHING_CHANGED,
      source
    };
    this.eventService.dispatchEvent(eventEverythingChanged);
  }
  orderGridColumnsLikePrimary() {
    const primaryColumns = this.primaryColumns;
    if (!primaryColumns) {
      return;
    }
    this.gridColumns.sort((colA, colB) => {
      const primaryIndexA = primaryColumns.indexOf(colA);
      const primaryIndexB = primaryColumns.indexOf(colB);
      const indexAPresent = primaryIndexA >= 0;
      const indexBPresent = primaryIndexB >= 0;
      if (indexAPresent && indexBPresent) {
        return primaryIndexA - primaryIndexB;
      }
      if (indexAPresent) {
        return 1;
      }
      if (indexBPresent) {
        return -1;
      }
      const gridIndexA = this.gridColumns.indexOf(colA);
      const gridIndexB = this.gridColumns.indexOf(colB);
      return gridIndexA - gridIndexB;
    });
    this.gridColumns = this.placeLockedColumns(this.gridColumns);
  }
  getAllDisplayedAutoHeightCols() {
    return this.displayedAutoHeightCols;
  }
  setViewport() {
    if (this.gridOptionsService.is("enableRtl")) {
      this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth;
      this.viewportRight = this.bodyWidth - this.scrollPosition;
    } else {
      this.viewportLeft = this.scrollPosition;
      this.viewportRight = this.scrollWidth + this.scrollPosition;
    }
  }
  getDisplayedColumnsStartingAt(column) {
    let currentColumn = column;
    const columns = [];
    while (currentColumn != null) {
      columns.push(currentColumn);
      currentColumn = this.getDisplayedColAfter(currentColumn);
    }
    return columns;
  }
  checkViewportColumns() {
    if (this.displayedColumnsCenter == null) {
      return;
    }
    const viewportColumnsChanged = this.extractViewport();
    if (!viewportColumnsChanged) {
      return;
    }
    const event = {
      type: Events.EVENT_VIRTUAL_COLUMNS_CHANGED
    };
    this.eventService.dispatchEvent(event);
  }
  setViewportPosition(scrollWidth, scrollPosition) {
    if (scrollWidth !== this.scrollWidth || scrollPosition !== this.scrollPosition || this.bodyWidthDirty) {
      this.scrollWidth = scrollWidth;
      this.scrollPosition = scrollPosition;
      this.bodyWidthDirty = true;
      this.setViewport();
      if (this.ready) {
        this.checkViewportColumns();
      }
    }
  }
  isPivotMode() {
    return this.pivotMode;
  }
  isPivotSettingAllowed(pivot) {
    if (pivot && this.gridOptionsService.isTreeData()) {
      console.warn("AG Grid: Pivot mode not available in conjunction Tree Data i.e. 'gridOptions.treeData: true'");
      return false;
    }
    return true;
  }
  setPivotMode(pivotMode, source = "api") {
    if (pivotMode === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode)) {
      return;
    }
    this.pivotMode = pivotMode;
    this.autoGroupsNeedBuilding = true;
    this.updateGridColumns();
    this.updateDisplayedColumns(source);
    const event = {
      type: Events.EVENT_COLUMN_PIVOT_MODE_CHANGED
    };
    this.eventService.dispatchEvent(event);
  }
  getSecondaryPivotColumn(pivotKeys, valueColKey) {
    if (missing(this.secondaryColumns)) {
      return null;
    }
    const valueColumnToFind = this.getPrimaryColumn(valueColKey);
    let foundColumn = null;
    this.secondaryColumns.forEach((column) => {
      const thisPivotKeys = column.getColDef().pivotKeys;
      const pivotValueColumn = column.getColDef().pivotValueColumn;
      const pivotKeyMatches = areEqual(thisPivotKeys, pivotKeys);
      const pivotValueMatches = pivotValueColumn === valueColumnToFind;
      if (pivotKeyMatches && pivotValueMatches) {
        foundColumn = column;
      }
    });
    return foundColumn;
  }
  setBeans(loggerFactory) {
    this.logger = loggerFactory.create("columnModel");
  }
  setFirstRightAndLastLeftPinned(source) {
    let lastLeft;
    let firstRight;
    if (this.gridOptionsService.is("enableRtl")) {
      lastLeft = this.displayedColumnsLeft ? this.displayedColumnsLeft[0] : null;
      firstRight = this.displayedColumnsRight ? last(this.displayedColumnsRight) : null;
    } else {
      lastLeft = this.displayedColumnsLeft ? last(this.displayedColumnsLeft) : null;
      firstRight = this.displayedColumnsRight ? this.displayedColumnsRight[0] : null;
    }
    this.gridColumns.forEach((column) => {
      column.setLastLeftPinned(column === lastLeft, source);
      column.setFirstRightPinned(column === firstRight, source);
    });
  }
  autoSizeColumns(params) {
    const { columns, skipHeader, skipHeaderGroups, stopAtGroup, source = "api" } = params;
    this.animationFrameService.flushAllFrames();
    const columnsAutosized = [];
    let changesThisTimeAround = -1;
    const shouldSkipHeader = skipHeader != null ? skipHeader : this.gridOptionsService.is("skipHeaderOnAutoSize");
    const shouldSkipHeaderGroups = skipHeaderGroups != null ? skipHeaderGroups : shouldSkipHeader;
    while (changesThisTimeAround !== 0) {
      changesThisTimeAround = 0;
      this.actionOnGridColumns(columns, (column) => {
        if (columnsAutosized.indexOf(column) >= 0) {
          return false;
        }
        const preferredWidth = this.autoWidthCalculator.getPreferredWidthForColumn(column, shouldSkipHeader);
        if (preferredWidth > 0) {
          const newWidth = this.normaliseColumnWidth(column, preferredWidth);
          column.setActualWidth(newWidth, source);
          columnsAutosized.push(column);
          changesThisTimeAround++;
        }
        return true;
      }, source);
    }
    if (!shouldSkipHeaderGroups) {
      this.autoSizeColumnGroupsByColumns(columns, source, stopAtGroup);
    }
    this.dispatchColumnResizedEvent(columnsAutosized, true, "autosizeColumns");
  }
  dispatchColumnResizedEvent(columns, finished, source, flexColumns = null) {
    if (columns && columns.length) {
      const event = {
        type: Events.EVENT_COLUMN_RESIZED,
        columns,
        column: columns.length === 1 ? columns[0] : null,
        flexColumns,
        finished,
        source
      };
      this.eventService.dispatchEvent(event);
    }
  }
  dispatchColumnChangedEvent(type, columns, source) {
    const event = {
      type,
      columns,
      column: columns && columns.length == 1 ? columns[0] : null,
      source
    };
    this.eventService.dispatchEvent(event);
  }
  dispatchColumnMovedEvent(params) {
    const { movedColumns, source, toIndex, finished } = params;
    const event = {
      type: Events.EVENT_COLUMN_MOVED,
      columns: movedColumns,
      column: movedColumns && movedColumns.length === 1 ? movedColumns[0] : null,
      toIndex,
      finished,
      source
    };
    this.eventService.dispatchEvent(event);
  }
  dispatchColumnPinnedEvent(changedColumns, source) {
    if (!changedColumns.length) {
      return;
    }
    const column = changedColumns.length === 1 ? changedColumns[0] : null;
    const pinned = this.getCommonValue(changedColumns, (col) => col.getPinned());
    const event = {
      type: Events.EVENT_COLUMN_PINNED,
      pinned: pinned != null ? pinned : null,
      columns: changedColumns,
      column,
      source
    };
    this.eventService.dispatchEvent(event);
  }
  dispatchColumnVisibleEvent(changedColumns, source) {
    if (!changedColumns.length) {
      return;
    }
    const column = changedColumns.length === 1 ? changedColumns[0] : null;
    const visible = this.getCommonValue(changedColumns, (col) => col.isVisible());
    const event = {
      type: Events.EVENT_COLUMN_VISIBLE,
      visible,
      columns: changedColumns,
      column,
      source
    };
    this.eventService.dispatchEvent(event);
  }
  autoSizeColumn(key, skipHeader, source = "api") {
    if (key) {
      this.autoSizeColumns({ columns: [key], skipHeader, skipHeaderGroups: true, source });
    }
  }
  autoSizeColumnGroupsByColumns(keys2, source, stopAtGroup) {
    const columnGroups = /* @__PURE__ */ new Set();
    const columns = this.getGridColumns(keys2);
    columns.forEach((col) => {
      let parent = col.getParent();
      while (parent && parent != stopAtGroup) {
        if (!parent.isPadding()) {
          columnGroups.add(parent);
        }
        parent = parent.getParent();
      }
    });
    let headerGroupCtrl;
    const resizedColumns = [];
    for (const columnGroup of columnGroups) {
      for (const headerContainerCtrl of this.ctrlsService.getHeaderRowContainerCtrls()) {
        headerGroupCtrl = headerContainerCtrl.getHeaderCtrlForColumn(columnGroup);
        if (headerGroupCtrl) {
          break;
        }
      }
      if (headerGroupCtrl) {
        headerGroupCtrl.resizeLeafColumnsToFit(source);
      }
    }
    return resizedColumns;
  }
  autoSizeAllColumns(skipHeader, source = "api") {
    const allDisplayedColumns = this.getAllDisplayedColumns();
    this.autoSizeColumns({ columns: allDisplayedColumns, skipHeader, source });
  }
  getColumnsFromTree(rootColumns) {
    const result = [];
    const recursiveFindColumns = (childColumns) => {
      for (let i = 0; i < childColumns.length; i++) {
        const child = childColumns[i];
        if (child instanceof Column) {
          result.push(child);
        } else if (child instanceof ProvidedColumnGroup) {
          recursiveFindColumns(child.getChildren());
        }
      }
    };
    recursiveFindColumns(rootColumns);
    return result;
  }
  getAllDisplayedTrees() {
    if (this.displayedTreeLeft && this.displayedTreeRight && this.displayedTreeCentre) {
      return this.displayedTreeLeft.concat(this.displayedTreeCentre).concat(this.displayedTreeRight);
    }
    return null;
  }
  getPrimaryColumnTree() {
    return this.primaryColumnTree;
  }
  getHeaderRowCount() {
    return this.gridHeaderRowCount;
  }
  getDisplayedTreeLeft() {
    return this.displayedTreeLeft;
  }
  getDisplayedTreeRight() {
    return this.displayedTreeRight;
  }
  getDisplayedTreeCentre() {
    return this.displayedTreeCentre;
  }
  isColumnDisplayed(column) {
    return this.getAllDisplayedColumns().indexOf(column) >= 0;
  }
  getAllDisplayedColumns() {
    return this.displayedColumns;
  }
  getViewportColumns() {
    return this.viewportColumns;
  }
  getDisplayedLeftColumnsForRow(rowNode) {
    if (!this.colSpanActive) {
      return this.displayedColumnsLeft;
    }
    return this.getDisplayedColumnsForRow(rowNode, this.displayedColumnsLeft);
  }
  getDisplayedRightColumnsForRow(rowNode) {
    if (!this.colSpanActive) {
      return this.displayedColumnsRight;
    }
    return this.getDisplayedColumnsForRow(rowNode, this.displayedColumnsRight);
  }
  isColSpanActive() {
    return this.colSpanActive;
  }
  getDisplayedColumnsForRow(rowNode, displayedColumns, filterCallback, emptySpaceBeforeColumn) {
    const result = [];
    let lastConsideredCol = null;
    for (let i = 0; i < displayedColumns.length; i++) {
      const col = displayedColumns[i];
      const maxAllowedColSpan = displayedColumns.length - i;
      const colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);
      const columnsToCheckFilter = [col];
      if (colSpan > 1) {
        const colsToRemove = colSpan - 1;
        for (let j = 1; j <= colsToRemove; j++) {
          columnsToCheckFilter.push(displayedColumns[i + j]);
        }
        i += colsToRemove;
      }
      let filterPasses;
      if (filterCallback) {
        filterPasses = false;
        columnsToCheckFilter.forEach((colForFilter) => {
          if (filterCallback(colForFilter)) {
            filterPasses = true;
          }
        });
      } else {
        filterPasses = true;
      }
      if (filterPasses) {
        if (result.length === 0 && lastConsideredCol) {
          const gapBeforeColumn = emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false;
          if (gapBeforeColumn) {
            result.push(lastConsideredCol);
          }
        }
        result.push(col);
      }
      lastConsideredCol = col;
    }
    return result;
  }
  getViewportCenterColumnsForRow(rowNode) {
    if (!this.colSpanActive) {
      return this.viewportColumnsCenter;
    }
    const emptySpaceBeforeColumn = (col) => {
      const left = col.getLeft();
      return exists(left) && left > this.viewportLeft;
    };
    const filterCallback = this.suppressColumnVirtualisation ? null : this.isColumnInRowViewport.bind(this);
    return this.getDisplayedColumnsForRow(rowNode, this.displayedColumnsCenter, filterCallback, emptySpaceBeforeColumn);
  }
  getAriaColumnIndex(col) {
    return this.getAllGridColumns().indexOf(col) + 1;
  }
  isColumnInHeaderViewport(col) {
    if (col.isAutoHeaderHeight()) {
      return true;
    }
    return this.isColumnInRowViewport(col);
  }
  isColumnInRowViewport(col) {
    if (col.isAutoHeight()) {
      return true;
    }
    const columnLeft = col.getLeft() || 0;
    const columnRight = columnLeft + col.getActualWidth();
    const leftBounds = this.viewportLeft - 200;
    const rightBounds = this.viewportRight + 200;
    const columnToMuchLeft = columnLeft < leftBounds && columnRight < leftBounds;
    const columnToMuchRight = columnLeft > rightBounds && columnRight > rightBounds;
    return !columnToMuchLeft && !columnToMuchRight;
  }
  getDisplayedColumnsLeftWidth() {
    return this.getWidthOfColsInList(this.displayedColumnsLeft);
  }
  getDisplayedColumnsRightWidth() {
    return this.getWidthOfColsInList(this.displayedColumnsRight);
  }
  updatePrimaryColumnList(keys2, masterList, actionIsAdd, columnCallback, eventType, source = "api") {
    if (!keys2 || missingOrEmpty(keys2)) {
      return;
    }
    let atLeastOne = false;
    keys2.forEach((key) => {
      const columnToAdd = this.getPrimaryColumn(key);
      if (!columnToAdd) {
        return;
      }
      if (actionIsAdd) {
        if (masterList.indexOf(columnToAdd) >= 0) {
          return;
        }
        masterList.push(columnToAdd);
      } else {
        if (masterList.indexOf(columnToAdd) < 0) {
          return;
        }
        removeFromArray(masterList, columnToAdd);
      }
      columnCallback(columnToAdd);
      atLeastOne = true;
    });
    if (!atLeastOne) {
      return;
    }
    if (this.autoGroupsNeedBuilding) {
      this.updateGridColumns();
    }
    this.updateDisplayedColumns(source);
    const event = {
      type: eventType,
      columns: masterList,
      column: masterList.length === 1 ? masterList[0] : null,
      source
    };
    this.eventService.dispatchEvent(event);
  }
  setRowGroupColumns(colKeys, source = "api") {
    this.autoGroupsNeedBuilding = true;
    this.setPrimaryColumnList(colKeys, this.rowGroupColumns, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.setRowGroupActive.bind(this), source);
  }
  setRowGroupActive(active, column, source) {
    if (active === column.isRowGroupActive()) {
      return;
    }
    column.setRowGroupActive(active, source);
    if (active && !this.gridOptionsService.is("suppressRowGroupHidesColumns")) {
      this.setColumnVisible(column, false, source);
    }
    if (!active && !this.gridOptionsService.is("suppressMakeColumnVisibleAfterUnGroup")) {
      this.setColumnVisible(column, true, source);
    }
  }
  addRowGroupColumn(key, source = "api") {
    if (key) {
      this.addRowGroupColumns([key], source);
    }
  }
  addRowGroupColumns(keys2, source = "api") {
    this.autoGroupsNeedBuilding = true;
    this.updatePrimaryColumnList(keys2, this.rowGroupColumns, true, this.setRowGroupActive.bind(this, true), Events.EVENT_COLUMN_ROW_GROUP_CHANGED, source);
  }
  removeRowGroupColumns(keys2, source = "api") {
    this.autoGroupsNeedBuilding = true;
    this.updatePrimaryColumnList(keys2, this.rowGroupColumns, false, this.setRowGroupActive.bind(this, false), Events.EVENT_COLUMN_ROW_GROUP_CHANGED, source);
  }
  removeRowGroupColumn(key, source = "api") {
    if (key) {
      this.removeRowGroupColumns([key], source);
    }
  }
  addPivotColumns(keys2, source = "api") {
    this.updatePrimaryColumnList(keys2, this.pivotColumns, true, (column) => column.setPivotActive(true, source), Events.EVENT_COLUMN_PIVOT_CHANGED, source);
  }
  setPivotColumns(colKeys, source = "api") {
    this.setPrimaryColumnList(colKeys, this.pivotColumns, Events.EVENT_COLUMN_PIVOT_CHANGED, (added, column) => {
      column.setPivotActive(added, source);
    }, source);
  }
  addPivotColumn(key, source = "api") {
    this.addPivotColumns([key], source);
  }
  removePivotColumns(keys2, source = "api") {
    this.updatePrimaryColumnList(keys2, this.pivotColumns, false, (column) => column.setPivotActive(false, source), Events.EVENT_COLUMN_PIVOT_CHANGED, source);
  }
  removePivotColumn(key, source = "api") {
    this.removePivotColumns([key], source);
  }
  setPrimaryColumnList(colKeys, masterList, eventName, columnCallback, source) {
    masterList.length = 0;
    if (exists(colKeys)) {
      colKeys.forEach((key) => {
        const column = this.getPrimaryColumn(key);
        if (column) {
          masterList.push(column);
        }
      });
    }
    (this.primaryColumns || []).forEach((column) => {
      const added = masterList.indexOf(column) >= 0;
      columnCallback(added, column);
    });
    if (this.autoGroupsNeedBuilding) {
      this.updateGridColumns();
    }
    this.updateDisplayedColumns(source);
    this.dispatchColumnChangedEvent(eventName, masterList, source);
  }
  setValueColumns(colKeys, source = "api") {
    this.setPrimaryColumnList(colKeys, this.valueColumns, Events.EVENT_COLUMN_VALUE_CHANGED, this.setValueActive.bind(this), source);
  }
  setValueActive(active, column, source) {
    if (active === column.isValueActive()) {
      return;
    }
    column.setValueActive(active, source);
    if (active && !column.getAggFunc()) {
      const initialAggFunc = this.aggFuncService.getDefaultAggFunc(column);
      column.setAggFunc(initialAggFunc);
    }
  }
  addValueColumns(keys2, source = "api") {
    this.updatePrimaryColumnList(keys2, this.valueColumns, true, this.setValueActive.bind(this, true), Events.EVENT_COLUMN_VALUE_CHANGED, source);
  }
  addValueColumn(colKey, source = "api") {
    if (colKey) {
      this.addValueColumns([colKey], source);
    }
  }
  removeValueColumn(colKey, source = "api") {
    this.removeValueColumns([colKey], source);
  }
  removeValueColumns(keys2, source = "api") {
    this.updatePrimaryColumnList(keys2, this.valueColumns, false, this.setValueActive.bind(this, false), Events.EVENT_COLUMN_VALUE_CHANGED, source);
  }
  normaliseColumnWidth(column, newWidth) {
    const minWidth = column.getMinWidth();
    if (exists(minWidth) && newWidth < minWidth) {
      newWidth = minWidth;
    }
    const maxWidth = column.getMaxWidth();
    if (exists(maxWidth) && column.isGreaterThanMax(newWidth)) {
      newWidth = maxWidth;
    }
    return newWidth;
  }
  getPrimaryOrGridColumn(key) {
    const column = this.getPrimaryColumn(key);
    return column || this.getGridColumn(key);
  }
  setColumnWidths(columnWidths, shiftKey, finished, source = "api") {
    const sets = [];
    columnWidths.forEach((columnWidth) => {
      const col = this.getPrimaryOrGridColumn(columnWidth.key);
      if (!col) {
        return;
      }
      sets.push({
        width: columnWidth.newWidth,
        ratios: [1],
        columns: [col]
      });
      const defaultIsShift = this.gridOptionsService.get("colResizeDefault") === "shift";
      if (defaultIsShift) {
        shiftKey = !shiftKey;
      }
      if (shiftKey) {
        const otherCol = this.getDisplayedColAfter(col);
        if (!otherCol) {
          return;
        }
        const widthDiff = col.getActualWidth() - columnWidth.newWidth;
        const otherColWidth = otherCol.getActualWidth() + widthDiff;
        sets.push({
          width: otherColWidth,
          ratios: [1],
          columns: [otherCol]
        });
      }
    });
    if (sets.length === 0) {
      return;
    }
    this.resizeColumnSets({
      resizeSets: sets,
      finished,
      source
    });
  }
  checkMinAndMaxWidthsForSet(columnResizeSet) {
    const { columns, width } = columnResizeSet;
    let minWidthAccumulated = 0;
    let maxWidthAccumulated = 0;
    let maxWidthActive = true;
    columns.forEach((col) => {
      const minWidth = col.getMinWidth();
      minWidthAccumulated += minWidth || 0;
      const maxWidth = col.getMaxWidth();
      if (exists(maxWidth) && maxWidth > 0) {
        maxWidthAccumulated += maxWidth;
      } else {
        maxWidthActive = false;
      }
    });
    const minWidthPasses = width >= minWidthAccumulated;
    const maxWidthPasses = !maxWidthActive || width <= maxWidthAccumulated;
    return minWidthPasses && maxWidthPasses;
  }
  resizeColumnSets(params) {
    const { resizeSets, finished, source } = params;
    const passMinMaxCheck = !resizeSets || resizeSets.every((columnResizeSet) => this.checkMinAndMaxWidthsForSet(columnResizeSet));
    if (!passMinMaxCheck) {
      if (finished) {
        const columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;
        this.dispatchColumnResizedEvent(columns, finished, source);
      }
      return;
    }
    const changedCols = [];
    const allResizedCols = [];
    resizeSets.forEach((set2) => {
      const { width, columns, ratios } = set2;
      const newWidths = {};
      const finishedCols = {};
      columns.forEach((col) => allResizedCols.push(col));
      let finishedColsGrew = true;
      let loopCount = 0;
      while (finishedColsGrew) {
        loopCount++;
        if (loopCount > 1e3) {
          console.error("AG Grid: infinite loop in resizeColumnSets");
          break;
        }
        finishedColsGrew = false;
        const subsetCols = [];
        let subsetRatioTotal = 0;
        let pixelsToDistribute = width;
        columns.forEach((col, index) => {
          const thisColFinished = finishedCols[col.getId()];
          if (thisColFinished) {
            pixelsToDistribute -= newWidths[col.getId()];
          } else {
            subsetCols.push(col);
            const ratioThisCol = ratios[index];
            subsetRatioTotal += ratioThisCol;
          }
        });
        const ratioScale = 1 / subsetRatioTotal;
        subsetCols.forEach((col, index) => {
          const lastCol = index === subsetCols.length - 1;
          let colNewWidth;
          if (lastCol) {
            colNewWidth = pixelsToDistribute;
          } else {
            colNewWidth = Math.round(ratios[index] * width * ratioScale);
            pixelsToDistribute -= colNewWidth;
          }
          const minWidth = col.getMinWidth();
          const maxWidth = col.getMaxWidth();
          if (exists(minWidth) && colNewWidth < minWidth) {
            colNewWidth = minWidth;
            finishedCols[col.getId()] = true;
            finishedColsGrew = true;
          } else if (exists(maxWidth) && maxWidth > 0 && colNewWidth > maxWidth) {
            colNewWidth = maxWidth;
            finishedCols[col.getId()] = true;
            finishedColsGrew = true;
          }
          newWidths[col.getId()] = colNewWidth;
        });
      }
      columns.forEach((col) => {
        const newWidth = newWidths[col.getId()];
        const actualWidth = col.getActualWidth();
        if (actualWidth !== newWidth) {
          col.setActualWidth(newWidth, source);
          changedCols.push(col);
        }
      });
    });
    const atLeastOneColChanged = changedCols.length > 0;
    let flexedCols = [];
    if (atLeastOneColChanged) {
      flexedCols = this.refreshFlexedColumns({ resizingCols: allResizedCols, skipSetLeft: true });
      this.setLeftValues(source);
      this.updateBodyWidths();
      this.checkViewportColumns();
    }
    const colsForEvent = allResizedCols.concat(flexedCols);
    if (atLeastOneColChanged || finished) {
      this.dispatchColumnResizedEvent(colsForEvent, finished, source, flexedCols);
    }
  }
  setColumnAggFunc(key, aggFunc, source = "api") {
    if (!key) {
      return;
    }
    const column = this.getPrimaryColumn(key);
    if (!column) {
      return;
    }
    column.setAggFunc(aggFunc);
    this.dispatchColumnChangedEvent(Events.EVENT_COLUMN_VALUE_CHANGED, [column], source);
  }
  moveRowGroupColumn(fromIndex, toIndex, source = "api") {
    const column = this.rowGroupColumns[fromIndex];
    this.rowGroupColumns.splice(fromIndex, 1);
    this.rowGroupColumns.splice(toIndex, 0, column);
    const event = {
      type: Events.EVENT_COLUMN_ROW_GROUP_CHANGED,
      columns: this.rowGroupColumns,
      column: this.rowGroupColumns.length === 1 ? this.rowGroupColumns[0] : null,
      source
    };
    this.eventService.dispatchEvent(event);
  }
  moveColumns(columnsToMoveKeys, toIndex, source = "api", finished = true) {
    this.columnAnimationService.start();
    if (toIndex > this.gridColumns.length - columnsToMoveKeys.length) {
      console.warn("AG Grid: tried to insert columns in invalid location, toIndex = " + toIndex);
      console.warn("AG Grid: remember that you should not count the moving columns when calculating the new index");
      return;
    }
    const movedColumns = this.getGridColumns(columnsToMoveKeys);
    const failedRules = !this.doesMovePassRules(movedColumns, toIndex);
    if (failedRules) {
      return;
    }
    moveInArray(this.gridColumns, movedColumns, toIndex);
    this.updateDisplayedColumns(source);
    this.dispatchColumnMovedEvent({ movedColumns, source, toIndex, finished });
    this.columnAnimationService.finish();
  }
  doesMovePassRules(columnsToMove, toIndex) {
    const proposedColumnOrder = this.getProposedColumnOrder(columnsToMove, toIndex);
    return this.doesOrderPassRules(proposedColumnOrder);
  }
  doesOrderPassRules(gridOrder) {
    if (!this.doesMovePassMarryChildren(gridOrder)) {
      return false;
    }
    if (!this.doesMovePassLockedPositions(gridOrder)) {
      return false;
    }
    return true;
  }
  getProposedColumnOrder(columnsToMove, toIndex) {
    const proposedColumnOrder = this.gridColumns.slice();
    moveInArray(proposedColumnOrder, columnsToMove, toIndex);
    return proposedColumnOrder;
  }
  sortColumnsLikeGridColumns(cols) {
    if (!cols || cols.length <= 1) {
      return;
    }
    const notAllColsInGridColumns = cols.filter((c) => this.gridColumns.indexOf(c) < 0).length > 0;
    if (notAllColsInGridColumns) {
      return;
    }
    cols.sort((a, b) => {
      const indexA = this.gridColumns.indexOf(a);
      const indexB = this.gridColumns.indexOf(b);
      return indexA - indexB;
    });
  }
  doesMovePassLockedPositions(proposedColumnOrder) {
    let lastPlacement = 0;
    let rulePassed = true;
    const lockPositionToPlacement = (position) => {
      if (!position) {
        return 1;
      }
      if (position === true) {
        return 0;
      }
      return position === "left" ? 0 : 2;
    };
    proposedColumnOrder.forEach((col) => {
      const placement = lockPositionToPlacement(col.getColDef().lockPosition);
      if (placement < lastPlacement) {
        rulePassed = false;
      }
      lastPlacement = placement;
    });
    return rulePassed;
  }
  doesMovePassMarryChildren(allColumnsCopy) {
    let rulePassed = true;
    this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, (child) => {
      if (!(child instanceof ProvidedColumnGroup)) {
        return;
      }
      const columnGroup = child;
      const colGroupDef = columnGroup.getColGroupDef();
      const marryChildren = colGroupDef && colGroupDef.marryChildren;
      if (!marryChildren) {
        return;
      }
      const newIndexes = [];
      columnGroup.getLeafColumns().forEach((col) => {
        const newColIndex = allColumnsCopy.indexOf(col);
        newIndexes.push(newColIndex);
      });
      const maxIndex = Math.max.apply(Math, newIndexes);
      const minIndex = Math.min.apply(Math, newIndexes);
      const spread = maxIndex - minIndex;
      const maxSpread = columnGroup.getLeafColumns().length - 1;
      if (spread > maxSpread) {
        rulePassed = false;
      }
    });
    return rulePassed;
  }
  moveColumn(key, toIndex, source = "api") {
    this.moveColumns([key], toIndex, source);
  }
  moveColumnByIndex(fromIndex, toIndex, source = "api") {
    const column = this.gridColumns[fromIndex];
    this.moveColumn(column, toIndex, source);
  }
  getColumnDefs() {
    if (!this.primaryColumns) {
      return;
    }
    const cols = this.primaryColumns.slice();
    if (this.gridColsArePrimary) {
      cols.sort((a, b) => this.gridColumns.indexOf(a) - this.gridColumns.indexOf(b));
    } else if (this.lastPrimaryOrder) {
      cols.sort((a, b) => this.lastPrimaryOrder.indexOf(a) - this.lastPrimaryOrder.indexOf(b));
    }
    return this.columnDefFactory.buildColumnDefs(cols, this.rowGroupColumns, this.pivotColumns);
  }
  getBodyContainerWidth() {
    return this.bodyWidth;
  }
  getContainerWidth(pinned) {
    switch (pinned) {
      case "left":
        return this.leftWidth;
      case "right":
        return this.rightWidth;
      default:
        return this.bodyWidth;
    }
  }
  updateBodyWidths() {
    const newBodyWidth = this.getWidthOfColsInList(this.displayedColumnsCenter);
    const newLeftWidth = this.getWidthOfColsInList(this.displayedColumnsLeft);
    const newRightWidth = this.getWidthOfColsInList(this.displayedColumnsRight);
    this.bodyWidthDirty = this.bodyWidth !== newBodyWidth;
    const atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;
    if (atLeastOneChanged) {
      this.bodyWidth = newBodyWidth;
      this.leftWidth = newLeftWidth;
      this.rightWidth = newRightWidth;
      const event = {
        type: Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED
      };
      this.eventService.dispatchEvent(event);
    }
  }
  getValueColumns() {
    return this.valueColumns ? this.valueColumns : [];
  }
  getPivotColumns() {
    return this.pivotColumns ? this.pivotColumns : [];
  }
  isPivotActive() {
    return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;
  }
  getRowGroupColumns() {
    return this.rowGroupColumns ? this.rowGroupColumns : [];
  }
  getDisplayedCenterColumns() {
    return this.displayedColumnsCenter;
  }
  getDisplayedLeftColumns() {
    return this.displayedColumnsLeft;
  }
  getDisplayedRightColumns() {
    return this.displayedColumnsRight;
  }
  getDisplayedColumns(type) {
    switch (type) {
      case "left":
        return this.getDisplayedLeftColumns();
      case "right":
        return this.getDisplayedRightColumns();
      default:
        return this.getDisplayedCenterColumns();
    }
  }
  getAllPrimaryColumns() {
    return this.primaryColumns ? this.primaryColumns.slice() : null;
  }
  getSecondaryColumns() {
    return this.secondaryColumns ? this.secondaryColumns.slice() : null;
  }
  getAllColumnsForQuickFilter() {
    return this.columnsForQuickFilter;
  }
  getAllGridColumns() {
    return this.gridColumns;
  }
  isEmpty() {
    return missingOrEmpty(this.gridColumns);
  }
  isRowGroupEmpty() {
    return missingOrEmpty(this.rowGroupColumns);
  }
  setColumnVisible(key, visible, source = "api") {
    this.setColumnsVisible([key], visible, source);
  }
  setColumnsVisible(keys2, visible = false, source = "api") {
    this.applyColumnState({
      state: keys2.map((key) => ({
        colId: typeof key === "string" ? key : key.getColId(),
        hide: !visible
      }))
    }, source);
  }
  setColumnPinned(key, pinned, source = "api") {
    if (key) {
      this.setColumnsPinned([key], pinned, source);
    }
  }
  setColumnsPinned(keys2, pinned, source = "api") {
    if (this.gridOptionsService.isDomLayout("print")) {
      console.warn(`AG Grid: Changing the column pinning status is not allowed with domLayout='print'`);
      return;
    }
    this.columnAnimationService.start();
    let actualPinned;
    if (pinned === true || pinned === "left") {
      actualPinned = "left";
    } else if (pinned === "right") {
      actualPinned = "right";
    } else {
      actualPinned = null;
    }
    this.actionOnGridColumns(keys2, (col) => {
      if (col.getPinned() !== actualPinned) {
        col.setPinned(actualPinned);
        return true;
      }
      return false;
    }, source, () => {
      const event = {
        type: Events.EVENT_COLUMN_PINNED,
        pinned: actualPinned,
        column: null,
        columns: null,
        source
      };
      return event;
    });
    this.columnAnimationService.finish();
  }
  actionOnGridColumns(keys2, action, source, createEvent) {
    if (missingOrEmpty(keys2)) {
      return;
    }
    const updatedColumns = [];
    keys2.forEach((key) => {
      const column = this.getGridColumn(key);
      if (!column) {
        return;
      }
      const resultOfAction = action(column);
      if (resultOfAction !== false) {
        updatedColumns.push(column);
      }
    });
    if (!updatedColumns.length) {
      return;
    }
    this.updateDisplayedColumns(source);
    if (exists(createEvent) && createEvent) {
      const event = createEvent();
      event.columns = updatedColumns;
      event.column = updatedColumns.length === 1 ? updatedColumns[0] : null;
      this.eventService.dispatchEvent(event);
    }
  }
  getDisplayedColBefore(col) {
    const allDisplayedColumns = this.getAllDisplayedColumns();
    const oldIndex = allDisplayedColumns.indexOf(col);
    if (oldIndex > 0) {
      return allDisplayedColumns[oldIndex - 1];
    }
    return null;
  }
  getDisplayedColAfter(col) {
    const allDisplayedColumns = this.getAllDisplayedColumns();
    const oldIndex = allDisplayedColumns.indexOf(col);
    if (oldIndex < allDisplayedColumns.length - 1) {
      return allDisplayedColumns[oldIndex + 1];
    }
    return null;
  }
  getDisplayedGroupAfter(columnGroup) {
    return this.getDisplayedGroupAtDirection(columnGroup, "After");
  }
  getDisplayedGroupBefore(columnGroup) {
    return this.getDisplayedGroupAtDirection(columnGroup, "Before");
  }
  getDisplayedGroupAtDirection(columnGroup, direction) {
    const requiredLevel = columnGroup.getProvidedColumnGroup().getLevel() + columnGroup.getPaddingLevel();
    const colGroupLeafColumns = columnGroup.getDisplayedLeafColumns();
    const col = direction === "After" ? last(colGroupLeafColumns) : colGroupLeafColumns[0];
    const getDisplayColMethod = `getDisplayedCol${direction}`;
    while (true) {
      const column = this[getDisplayColMethod](col);
      if (!column) {
        return null;
      }
      const groupPointer = this.getColumnGroupAtLevel(column, requiredLevel);
      if (groupPointer !== columnGroup) {
        return groupPointer;
      }
    }
  }
  getColumnGroupAtLevel(column, level) {
    let groupPointer = column.getParent();
    let originalGroupLevel;
    let groupPointerLevel;
    while (true) {
      const groupPointerProvidedColumnGroup = groupPointer.getProvidedColumnGroup();
      originalGroupLevel = groupPointerProvidedColumnGroup.getLevel();
      groupPointerLevel = groupPointer.getPaddingLevel();
      if (originalGroupLevel + groupPointerLevel <= level) {
        break;
      }
      groupPointer = groupPointer.getParent();
    }
    return groupPointer;
  }
  isPinningLeft() {
    return this.displayedColumnsLeft.length > 0;
  }
  isPinningRight() {
    return this.displayedColumnsRight.length > 0;
  }
  getPrimaryAndSecondaryAndAutoColumns() {
    return [].concat(...[
      this.primaryColumns || [],
      this.groupAutoColumns || [],
      this.secondaryColumns || []
    ]);
  }
  createStateItemFromColumn(column) {
    const rowGroupIndex = column.isRowGroupActive() ? this.rowGroupColumns.indexOf(column) : null;
    const pivotIndex = column.isPivotActive() ? this.pivotColumns.indexOf(column) : null;
    const aggFunc = column.isValueActive() ? column.getAggFunc() : null;
    const sort = column.getSort() != null ? column.getSort() : null;
    const sortIndex = column.getSortIndex() != null ? column.getSortIndex() : null;
    const flex = column.getFlex() != null && column.getFlex() > 0 ? column.getFlex() : null;
    const res = {
      colId: column.getColId(),
      width: column.getActualWidth(),
      hide: !column.isVisible(),
      pinned: column.getPinned(),
      sort,
      sortIndex,
      aggFunc,
      rowGroup: column.isRowGroupActive(),
      rowGroupIndex,
      pivot: column.isPivotActive(),
      pivotIndex,
      flex
    };
    return res;
  }
  getColumnState() {
    if (missing(this.primaryColumns) || !this.isAlive()) {
      return [];
    }
    const colsForState = this.getPrimaryAndSecondaryAndAutoColumns();
    const res = colsForState.map(this.createStateItemFromColumn.bind(this));
    this.orderColumnStateList(res);
    return res;
  }
  orderColumnStateList(columnStateList) {
    const colIdToGridIndexMap = convertToMap(this.gridColumns.map((col, index) => [col.getColId(), index]));
    columnStateList.sort((itemA, itemB) => {
      const posA = colIdToGridIndexMap.has(itemA.colId) ? colIdToGridIndexMap.get(itemA.colId) : -1;
      const posB = colIdToGridIndexMap.has(itemB.colId) ? colIdToGridIndexMap.get(itemB.colId) : -1;
      return posA - posB;
    });
  }
  resetColumnState(source = "api") {
    const primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);
    const columnStates = [];
    let letRowGroupIndex = 1e3;
    let letPivotIndex = 1e3;
    let colsToProcess = [];
    if (this.groupAutoColumns) {
      colsToProcess = colsToProcess.concat(this.groupAutoColumns);
    }
    if (primaryColumns) {
      colsToProcess = colsToProcess.concat(primaryColumns);
    }
    colsToProcess.forEach((column) => {
      const getValueOrNull = (a, b) => a != null ? a : b != null ? b : null;
      const colDef = column.getColDef();
      const sort = getValueOrNull(colDef.sort, colDef.initialSort);
      const sortIndex = getValueOrNull(colDef.sortIndex, colDef.initialSortIndex);
      const hide = getValueOrNull(colDef.hide, colDef.initialHide);
      const pinned = getValueOrNull(colDef.pinned, colDef.initialPinned);
      const width = getValueOrNull(colDef.width, colDef.initialWidth);
      const flex = getValueOrNull(colDef.flex, colDef.initialFlex);
      let rowGroupIndex = getValueOrNull(colDef.rowGroupIndex, colDef.initialRowGroupIndex);
      let rowGroup = getValueOrNull(colDef.rowGroup, colDef.initialRowGroup);
      if (rowGroupIndex == null && (rowGroup == null || rowGroup == false)) {
        rowGroupIndex = null;
        rowGroup = null;
      }
      let pivotIndex = getValueOrNull(colDef.pivotIndex, colDef.initialPivotIndex);
      let pivot = getValueOrNull(colDef.pivot, colDef.initialPivot);
      if (pivotIndex == null && (pivot == null || pivot == false)) {
        pivotIndex = null;
        pivot = null;
      }
      const aggFunc = getValueOrNull(colDef.aggFunc, colDef.initialAggFunc);
      const stateItem = {
        colId: column.getColId(),
        sort,
        sortIndex,
        hide,
        pinned,
        width,
        flex,
        rowGroup,
        rowGroupIndex,
        pivot,
        pivotIndex,
        aggFunc
      };
      if (missing(rowGroupIndex) && rowGroup) {
        stateItem.rowGroupIndex = letRowGroupIndex++;
      }
      if (missing(pivotIndex) && pivot) {
        stateItem.pivotIndex = letPivotIndex++;
      }
      columnStates.push(stateItem);
    });
    this.applyColumnState({ state: columnStates, applyOrder: true }, source);
  }
  applyColumnState(params, source) {
    if (missingOrEmpty(this.primaryColumns)) {
      return false;
    }
    if (params && params.state && !params.state.forEach) {
      console.warn("AG Grid: applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state.");
      return false;
    }
    const applyStates = (states, existingColumns, getById) => {
      const dispatchEventsFunc = this.compareColumnStatesAndDispatchEvents(source);
      this.autoGroupsNeedBuilding = true;
      const columnsWithNoState = existingColumns.slice();
      const rowGroupIndexes = {};
      const pivotIndexes = {};
      const autoGroupColumnStates = [];
      const unmatchedAndAutoStates2 = [];
      let unmatchedCount2 = 0;
      const previousRowGroupCols = this.rowGroupColumns.slice();
      const previousPivotCols = this.pivotColumns.slice();
      states.forEach((state) => {
        const colId = state.colId || "";
        const isAutoGroupColumn = colId.startsWith(GROUP_AUTO_COLUMN_ID);
        if (isAutoGroupColumn) {
          autoGroupColumnStates.push(state);
          unmatchedAndAutoStates2.push(state);
          return;
        }
        const column = getById(colId);
        if (!column) {
          unmatchedAndAutoStates2.push(state);
          unmatchedCount2 += 1;
        } else {
          this.syncColumnWithStateItem(column, state, params.defaultState, rowGroupIndexes, pivotIndexes, false, source);
          removeFromArray(columnsWithNoState, column);
        }
      });
      const applyDefaultsFunc = (col) => this.syncColumnWithStateItem(col, null, params.defaultState, rowGroupIndexes, pivotIndexes, false, source);
      columnsWithNoState.forEach(applyDefaultsFunc);
      const comparator = (indexes, oldList, colA, colB) => {
        const indexA = indexes[colA.getId()];
        const indexB = indexes[colB.getId()];
        const aHasIndex = indexA != null;
        const bHasIndex = indexB != null;
        if (aHasIndex && bHasIndex) {
          return indexA - indexB;
        }
        if (aHasIndex) {
          return -1;
        }
        if (bHasIndex) {
          return 1;
        }
        const oldIndexA = oldList.indexOf(colA);
        const oldIndexB = oldList.indexOf(colB);
        const aHasOldIndex = oldIndexA >= 0;
        const bHasOldIndex = oldIndexB >= 0;
        if (aHasOldIndex && bHasOldIndex) {
          return oldIndexA - oldIndexB;
        }
        if (aHasOldIndex) {
          return -1;
        }
        return 1;
      };
      this.rowGroupColumns.sort(comparator.bind(this, rowGroupIndexes, previousRowGroupCols));
      this.pivotColumns.sort(comparator.bind(this, pivotIndexes, previousPivotCols));
      this.updateGridColumns();
      const autoGroupColsCopy = this.groupAutoColumns ? this.groupAutoColumns.slice() : [];
      autoGroupColumnStates.forEach((stateItem) => {
        const autoCol = this.getAutoColumn(stateItem.colId);
        removeFromArray(autoGroupColsCopy, autoCol);
        this.syncColumnWithStateItem(autoCol, stateItem, params.defaultState, null, null, true, source);
      });
      autoGroupColsCopy.forEach(applyDefaultsFunc);
      this.applyOrderAfterApplyState(params);
      this.updateDisplayedColumns(source);
      this.dispatchEverythingChanged(source);
      dispatchEventsFunc();
      return { unmatchedAndAutoStates: unmatchedAndAutoStates2, unmatchedCount: unmatchedCount2 };
    };
    this.columnAnimationService.start();
    let { unmatchedAndAutoStates, unmatchedCount } = applyStates(params.state || [], this.primaryColumns || [], (id) => this.getPrimaryColumn(id));
    if (unmatchedAndAutoStates.length > 0 || exists(params.defaultState)) {
      unmatchedCount = applyStates(unmatchedAndAutoStates, this.secondaryColumns || [], (id) => this.getSecondaryColumn(id)).unmatchedCount;
    }
    this.columnAnimationService.finish();
    return unmatchedCount === 0;
  }
  applyOrderAfterApplyState(params) {
    if (!params.applyOrder || !params.state) {
      return;
    }
    let newOrder = [];
    const processedColIds = {};
    params.state.forEach((item) => {
      if (!item.colId || processedColIds[item.colId]) {
        return;
      }
      const col = this.gridColumnsMap[item.colId];
      if (col) {
        newOrder.push(col);
        processedColIds[item.colId] = true;
      }
    });
    let autoGroupInsertIndex = 0;
    this.gridColumns.forEach((col) => {
      const colId = col.getColId();
      const alreadyProcessed = processedColIds[colId] != null;
      if (alreadyProcessed) {
        return;
      }
      const isAutoGroupCol = colId.startsWith(GROUP_AUTO_COLUMN_ID);
      if (isAutoGroupCol) {
        insertIntoArray(newOrder, col, autoGroupInsertIndex++);
      } else {
        newOrder.push(col);
      }
    });
    newOrder = this.placeLockedColumns(newOrder);
    if (!this.doesMovePassMarryChildren(newOrder)) {
      console.warn("AG Grid: Applying column order broke a group where columns should be married together. Applying new order has been discarded.");
      return;
    }
    this.gridColumns = newOrder;
  }
  compareColumnStatesAndDispatchEvents(source) {
    const startState = {
      rowGroupColumns: this.rowGroupColumns.slice(),
      pivotColumns: this.pivotColumns.slice(),
      valueColumns: this.valueColumns.slice()
    };
    const columnStateBefore = this.getColumnState();
    const columnStateBeforeMap = {};
    columnStateBefore.forEach((col) => {
      columnStateBeforeMap[col.colId] = col;
    });
    return () => {
      const colsForState = this.getPrimaryAndSecondaryAndAutoColumns();
      const dispatchWhenListsDifferent = (eventType, colsBefore, colsAfter, idMapper) => {
        const beforeList = colsBefore.map(idMapper);
        const afterList = colsAfter.map(idMapper);
        const unchanged = areEqual(beforeList, afterList);
        if (unchanged) {
          return;
        }
        const event = {
          type: eventType,
          columns: colsAfter,
          column: colsAfter.length === 1 ? colsAfter[0] : null,
          source
        };
        this.eventService.dispatchEvent(event);
      };
      const getChangedColumns = (changedPredicate) => {
        const changedColumns = [];
        colsForState.forEach((column) => {
          const colStateBefore = columnStateBeforeMap[column.getColId()];
          if (colStateBefore && changedPredicate(colStateBefore, column)) {
            changedColumns.push(column);
          }
        });
        return changedColumns;
      };
      const columnIdMapper = (c) => c.getColId();
      dispatchWhenListsDifferent(Events.EVENT_COLUMN_ROW_GROUP_CHANGED, startState.rowGroupColumns, this.rowGroupColumns, columnIdMapper);
      dispatchWhenListsDifferent(Events.EVENT_COLUMN_PIVOT_CHANGED, startState.pivotColumns, this.pivotColumns, columnIdMapper);
      const valueChangePredicate = (cs, c) => {
        const oldActive = cs.aggFunc != null;
        const activeChanged = oldActive != c.isValueActive();
        const aggFuncChanged = oldActive && cs.aggFunc != c.getAggFunc();
        return activeChanged || aggFuncChanged;
      };
      const changedValues = getChangedColumns(valueChangePredicate);
      if (changedValues.length > 0) {
        this.dispatchColumnChangedEvent(Events.EVENT_COLUMN_VALUE_CHANGED, this.valueColumns, source);
      }
      const resizeChangePredicate = (cs, c) => cs.width != c.getActualWidth();
      this.dispatchColumnResizedEvent(getChangedColumns(resizeChangePredicate), true, source);
      const pinnedChangePredicate = (cs, c) => cs.pinned != c.getPinned();
      this.dispatchColumnPinnedEvent(getChangedColumns(pinnedChangePredicate), source);
      const visibilityChangePredicate = (cs, c) => cs.hide == c.isVisible();
      this.dispatchColumnVisibleEvent(getChangedColumns(visibilityChangePredicate), source);
      const sortChangePredicate = (cs, c) => cs.sort != c.getSort() || cs.sortIndex != c.getSortIndex();
      if (getChangedColumns(sortChangePredicate).length > 0) {
        this.sortController.dispatchSortChangedEvents(source);
      }
      this.normaliseColumnMovedEventForColumnState(columnStateBefore, source);
    };
  }
  getCommonValue(cols, valueGetter) {
    if (!cols || cols.length == 0) {
      return void 0;
    }
    const firstValue = valueGetter(cols[0]);
    for (let i = 1; i < cols.length; i++) {
      if (firstValue !== valueGetter(cols[i])) {
        return void 0;
      }
    }
    return firstValue;
  }
  normaliseColumnMovedEventForColumnState(colStateBefore, source) {
    const colStateAfter = this.getColumnState();
    const colStateAfterMapped = {};
    colStateAfter.forEach((s) => colStateAfterMapped[s.colId] = s);
    const colsIntersectIds = {};
    colStateBefore.forEach((s) => {
      if (colStateAfterMapped[s.colId]) {
        colsIntersectIds[s.colId] = true;
      }
    });
    const beforeFiltered = colStateBefore.filter((c) => colsIntersectIds[c.colId]);
    const afterFiltered = colStateAfter.filter((c) => colsIntersectIds[c.colId]);
    const movedColumns = [];
    afterFiltered.forEach((csAfter, index) => {
      const csBefore = beforeFiltered && beforeFiltered[index];
      if (csBefore && csBefore.colId !== csAfter.colId) {
        const gridCol = this.getGridColumn(csBefore.colId);
        if (gridCol) {
          movedColumns.push(gridCol);
        }
      }
    });
    if (!movedColumns.length) {
      return;
    }
    this.dispatchColumnMovedEvent({ movedColumns, source, finished: true });
  }
  syncColumnWithStateItem(column, stateItem, defaultState, rowGroupIndexes, pivotIndexes, autoCol, source) {
    if (!column) {
      return;
    }
    const getValue = (key1, key2) => {
      const obj = { value1: void 0, value2: void 0 };
      let calculated = false;
      if (stateItem) {
        if (stateItem[key1] !== void 0) {
          obj.value1 = stateItem[key1];
          calculated = true;
        }
        if (exists(key2) && stateItem[key2] !== void 0) {
          obj.value2 = stateItem[key2];
          calculated = true;
        }
      }
      if (!calculated && defaultState) {
        if (defaultState[key1] !== void 0) {
          obj.value1 = defaultState[key1];
        }
        if (exists(key2) && defaultState[key2] !== void 0) {
          obj.value2 = defaultState[key2];
        }
      }
      return obj;
    };
    const hide = getValue("hide").value1;
    if (hide !== void 0) {
      column.setVisible(!hide, source);
    }
    const pinned = getValue("pinned").value1;
    if (pinned !== void 0) {
      column.setPinned(pinned);
    }
    const minColWidth = this.columnUtils.calculateColMinWidth(column.getColDef());
    const flex = getValue("flex").value1;
    if (flex !== void 0) {
      column.setFlex(flex);
    }
    const noFlexThisCol = column.getFlex() <= 0;
    if (noFlexThisCol) {
      const width = getValue("width").value1;
      if (width != null) {
        if (minColWidth != null && width >= minColWidth) {
          column.setActualWidth(width, source);
        }
      }
    }
    const sort = getValue("sort").value1;
    if (sort !== void 0) {
      if (sort === "desc" || sort === "asc") {
        column.setSort(sort, source);
      } else {
        column.setSort(void 0, source);
      }
    }
    const sortIndex = getValue("sortIndex").value1;
    if (sortIndex !== void 0) {
      column.setSortIndex(sortIndex);
    }
    if (autoCol || !column.isPrimary()) {
      return;
    }
    const aggFunc = getValue("aggFunc").value1;
    if (aggFunc !== void 0) {
      if (typeof aggFunc === "string") {
        column.setAggFunc(aggFunc);
        if (!column.isValueActive()) {
          column.setValueActive(true, source);
          this.valueColumns.push(column);
        }
      } else {
        if (exists(aggFunc)) {
          console.warn("AG Grid: stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON.");
        }
        if (column.isValueActive()) {
          column.setValueActive(false, source);
          removeFromArray(this.valueColumns, column);
        }
      }
    }
    const { value1: rowGroup, value2: rowGroupIndex } = getValue("rowGroup", "rowGroupIndex");
    if (rowGroup !== void 0 || rowGroupIndex !== void 0) {
      if (typeof rowGroupIndex === "number" || rowGroup) {
        if (!column.isRowGroupActive()) {
          column.setRowGroupActive(true, source);
          this.rowGroupColumns.push(column);
        }
        if (rowGroupIndexes && typeof rowGroupIndex === "number") {
          rowGroupIndexes[column.getId()] = rowGroupIndex;
        }
      } else {
        if (column.isRowGroupActive()) {
          column.setRowGroupActive(false, source);
          removeFromArray(this.rowGroupColumns, column);
        }
      }
    }
    const { value1: pivot, value2: pivotIndex } = getValue("pivot", "pivotIndex");
    if (pivot !== void 0 || pivotIndex !== void 0) {
      if (typeof pivotIndex === "number" || pivot) {
        if (!column.isPivotActive()) {
          column.setPivotActive(true, source);
          this.pivotColumns.push(column);
        }
        if (pivotIndexes && typeof pivotIndex === "number") {
          pivotIndexes[column.getId()] = pivotIndex;
        }
      } else {
        if (column.isPivotActive()) {
          column.setPivotActive(false, source);
          removeFromArray(this.pivotColumns, column);
        }
      }
    }
  }
  getGridColumns(keys2) {
    return this.getColumns(keys2, this.getGridColumn.bind(this));
  }
  getColumns(keys2, columnLookupCallback) {
    const foundColumns = [];
    if (keys2) {
      keys2.forEach((key) => {
        const column = columnLookupCallback(key);
        if (column) {
          foundColumns.push(column);
        }
      });
    }
    return foundColumns;
  }
  getColumnWithValidation(key) {
    if (key == null) {
      return null;
    }
    const column = this.getGridColumn(key);
    if (!column) {
      console.warn("AG Grid: could not find column " + key);
    }
    return column;
  }
  getPrimaryColumn(key) {
    if (!this.primaryColumns) {
      return null;
    }
    return this.getColumn(key, this.primaryColumns, this.primaryColumnsMap);
  }
  getGridColumn(key) {
    return this.getColumn(key, this.gridColumns, this.gridColumnsMap);
  }
  getSecondaryColumn(key) {
    if (!this.secondaryColumns) {
      return null;
    }
    return this.getColumn(key, this.secondaryColumns, this.secondaryColumnsMap);
  }
  getColumn(key, columnList, columnMap) {
    if (!key) {
      return null;
    }
    if (typeof key == "string" && columnMap[key]) {
      return columnMap[key];
    }
    for (let i = 0; i < columnList.length; i++) {
      if (this.columnsMatch(columnList[i], key)) {
        return columnList[i];
      }
    }
    return this.getAutoColumn(key);
  }
  getSourceColumnsForGroupColumn(groupCol) {
    const sourceColumnId = groupCol.getColDef().showRowGroup;
    if (!sourceColumnId) {
      return null;
    }
    if (sourceColumnId === true) {
      return this.rowGroupColumns.slice(0);
    }
    const column = this.getPrimaryColumn(sourceColumnId);
    return column ? [column] : null;
  }
  getAutoColumn(key) {
    if (!this.groupAutoColumns || !exists(this.groupAutoColumns) || missing(this.groupAutoColumns)) {
      return null;
    }
    return this.groupAutoColumns.find((groupCol) => this.columnsMatch(groupCol, key)) || null;
  }
  columnsMatch(column, key) {
    const columnMatches = column === key;
    const colDefMatches = column.getColDef() === key;
    const idMatches = column.getColId() == key;
    return columnMatches || colDefMatches || idMatches;
  }
  getDisplayNameForColumn(column, location, includeAggFunc = false) {
    if (!column) {
      return null;
    }
    const headerName = this.getHeaderName(column.getColDef(), column, null, null, location);
    if (includeAggFunc) {
      return this.wrapHeaderNameWithAggFunc(column, headerName);
    }
    return headerName;
  }
  getDisplayNameForProvidedColumnGroup(columnGroup, providedColumnGroup, location) {
    const colGroupDef = providedColumnGroup ? providedColumnGroup.getColGroupDef() : null;
    if (colGroupDef) {
      return this.getHeaderName(colGroupDef, null, columnGroup, providedColumnGroup, location);
    }
    return null;
  }
  getDisplayNameForColumnGroup(columnGroup, location) {
    return this.getDisplayNameForProvidedColumnGroup(columnGroup, columnGroup.getProvidedColumnGroup(), location);
  }
  getHeaderName(colDef, column, columnGroup, providedColumnGroup, location) {
    const headerValueGetter = colDef.headerValueGetter;
    if (headerValueGetter) {
      const params = {
        colDef,
        column,
        columnGroup,
        providedColumnGroup,
        location,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      };
      if (typeof headerValueGetter === "function") {
        return headerValueGetter(params);
      } else if (typeof headerValueGetter === "string") {
        return this.expressionService.evaluate(headerValueGetter, params);
      }
      console.warn("AG Grid: headerValueGetter must be a function or a string");
      return "";
    } else if (colDef.headerName != null) {
      return colDef.headerName;
    } else if (colDef.field) {
      return camelCaseToHumanText(colDef.field);
    }
    return "";
  }
  wrapHeaderNameWithAggFunc(column, headerName) {
    if (this.gridOptionsService.is("suppressAggFuncInHeader")) {
      return headerName;
    }
    const pivotValueColumn = column.getColDef().pivotValueColumn;
    const pivotActiveOnThisColumn = exists(pivotValueColumn);
    let aggFunc = null;
    let aggFuncFound;
    if (pivotActiveOnThisColumn) {
      const isCollapsedHeaderEnabled = this.gridOptionsService.is("removePivotHeaderRowWhenSingleValueColumn") && this.valueColumns.length === 1;
      const isTotalColumn = column.getColDef().pivotTotalColumnIds !== void 0;
      if (isCollapsedHeaderEnabled && !isTotalColumn) {
        return headerName;
      }
      aggFunc = pivotValueColumn ? pivotValueColumn.getAggFunc() : null;
      aggFuncFound = true;
    } else {
      const measureActive = column.isValueActive();
      const aggregationPresent = this.pivotMode || !this.isRowGroupEmpty();
      if (measureActive && aggregationPresent) {
        aggFunc = column.getAggFunc();
        aggFuncFound = true;
      } else {
        aggFuncFound = false;
      }
    }
    if (aggFuncFound) {
      const aggFuncString = typeof aggFunc === "string" ? aggFunc : "func";
      const localeTextFunc = this.localeService.getLocaleTextFunc();
      const aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);
      return `${aggFuncStringTranslated}(${headerName})`;
    }
    return headerName;
  }
  getColumnGroup(colId, partId) {
    if (!colId) {
      return null;
    }
    if (colId instanceof ColumnGroup) {
      return colId;
    }
    const allColumnGroups = this.getAllDisplayedTrees();
    const checkPartId = typeof partId === "number";
    let result = null;
    this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, (child) => {
      if (child instanceof ColumnGroup) {
        const columnGroup = child;
        let matched;
        if (checkPartId) {
          matched = colId === columnGroup.getGroupId() && partId === columnGroup.getPartId();
        } else {
          matched = colId === columnGroup.getGroupId();
        }
        if (matched) {
          result = columnGroup;
        }
      }
    });
    return result;
  }
  isReady() {
    return this.ready;
  }
  extractValueColumns(source, oldPrimaryColumns) {
    this.valueColumns = this.extractColumns(
      oldPrimaryColumns,
      this.valueColumns,
      (col, flag) => col.setValueActive(flag, source),
      () => void 0,
      () => void 0,
      (colDef) => {
        const aggFunc = colDef.aggFunc;
        if (aggFunc === null || aggFunc === "") {
          return null;
        }
        if (aggFunc === void 0) {
          return;
        }
        return !!aggFunc;
      },
      (colDef) => {
        return colDef.initialAggFunc != null && colDef.initialAggFunc != "";
      }
    );
    this.valueColumns.forEach((col) => {
      const colDef = col.getColDef();
      if (colDef.aggFunc != null && colDef.aggFunc != "") {
        col.setAggFunc(colDef.aggFunc);
      } else {
        if (!col.getAggFunc()) {
          col.setAggFunc(colDef.initialAggFunc);
        }
      }
    });
  }
  extractRowGroupColumns(source, oldPrimaryColumns) {
    this.rowGroupColumns = this.extractColumns(oldPrimaryColumns, this.rowGroupColumns, (col, flag) => col.setRowGroupActive(flag, source), (colDef) => colDef.rowGroupIndex, (colDef) => colDef.initialRowGroupIndex, (colDef) => colDef.rowGroup, (colDef) => colDef.initialRowGroup);
  }
  extractColumns(oldPrimaryColumns = [], previousCols = [], setFlagFunc, getIndexFunc, getInitialIndexFunc, getValueFunc, getInitialValueFunc) {
    const colsWithIndex = [];
    const colsWithValue = [];
    (this.primaryColumns || []).forEach((col) => {
      const colIsNew = oldPrimaryColumns.indexOf(col) < 0;
      const colDef = col.getColDef();
      const value = attrToBoolean(getValueFunc(colDef));
      const initialValue = attrToBoolean(getInitialValueFunc(colDef));
      const index = attrToNumber(getIndexFunc(colDef));
      const initialIndex = attrToNumber(getInitialIndexFunc(colDef));
      let include;
      const valuePresent = value !== void 0;
      const indexPresent = index !== void 0;
      const initialValuePresent = initialValue !== void 0;
      const initialIndexPresent = initialIndex !== void 0;
      if (valuePresent) {
        include = value;
      } else if (indexPresent) {
        if (index === null) {
          include = false;
        } else {
          include = index >= 0;
        }
      } else {
        if (colIsNew) {
          if (initialValuePresent) {
            include = initialValue;
          } else if (initialIndexPresent) {
            include = initialIndex != null && initialIndex >= 0;
          } else {
            include = false;
          }
        } else {
          include = previousCols.indexOf(col) >= 0;
        }
      }
      if (include) {
        const useIndex = colIsNew ? index != null || initialIndex != null : index != null;
        useIndex ? colsWithIndex.push(col) : colsWithValue.push(col);
      }
    });
    const getIndexForCol = (col) => {
      const index = getIndexFunc(col.getColDef());
      const defaultIndex = getInitialIndexFunc(col.getColDef());
      return index != null ? index : defaultIndex;
    };
    colsWithIndex.sort((colA, colB) => {
      const indexA = getIndexForCol(colA);
      const indexB = getIndexForCol(colB);
      if (indexA === indexB) {
        return 0;
      }
      if (indexA < indexB) {
        return -1;
      }
      return 1;
    });
    const res = [].concat(colsWithIndex);
    previousCols.forEach((col) => {
      if (colsWithValue.indexOf(col) >= 0) {
        res.push(col);
      }
    });
    colsWithValue.forEach((col) => {
      if (res.indexOf(col) < 0) {
        res.push(col);
      }
    });
    previousCols.forEach((col) => {
      if (res.indexOf(col) < 0) {
        setFlagFunc(col, false);
      }
    });
    res.forEach((col) => {
      if (previousCols.indexOf(col) < 0) {
        setFlagFunc(col, true);
      }
    });
    return res;
  }
  extractPivotColumns(source, oldPrimaryColumns) {
    this.pivotColumns = this.extractColumns(oldPrimaryColumns, this.pivotColumns, (col, flag) => col.setPivotActive(flag, source), (colDef) => colDef.pivotIndex, (colDef) => colDef.initialPivotIndex, (colDef) => colDef.pivot, (colDef) => colDef.initialPivot);
  }
  resetColumnGroupState(source = "api") {
    const stateItems = [];
    this.columnUtils.depthFirstOriginalTreeSearch(null, this.primaryColumnTree, (child) => {
      if (child instanceof ProvidedColumnGroup) {
        const colGroupDef = child.getColGroupDef();
        const groupState = {
          groupId: child.getGroupId(),
          open: !colGroupDef ? void 0 : colGroupDef.openByDefault
        };
        stateItems.push(groupState);
      }
    });
    this.setColumnGroupState(stateItems, source);
  }
  getColumnGroupState() {
    const columnGroupState = [];
    this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, (node) => {
      if (node instanceof ProvidedColumnGroup) {
        columnGroupState.push({
          groupId: node.getGroupId(),
          open: node.isExpanded()
        });
      }
    });
    return columnGroupState;
  }
  setColumnGroupState(stateItems, source = "api") {
    this.columnAnimationService.start();
    const impactedGroups = [];
    stateItems.forEach((stateItem) => {
      const groupKey = stateItem.groupId;
      const newValue = stateItem.open;
      const providedColumnGroup = this.getProvidedColumnGroup(groupKey);
      if (!providedColumnGroup) {
        return;
      }
      if (providedColumnGroup.isExpanded() === newValue) {
        return;
      }
      this.logger.log("columnGroupOpened(" + providedColumnGroup.getGroupId() + "," + newValue + ")");
      providedColumnGroup.setExpanded(newValue);
      impactedGroups.push(providedColumnGroup);
    });
    this.updateGroupsAndDisplayedColumns(source);
    this.setFirstRightAndLastLeftPinned(source);
    impactedGroups.forEach((providedColumnGroup) => {
      const event = {
        type: Events.EVENT_COLUMN_GROUP_OPENED,
        columnGroup: providedColumnGroup
      };
      this.eventService.dispatchEvent(event);
    });
    this.columnAnimationService.finish();
  }
  setColumnGroupOpened(key, newValue, source = "api") {
    let keyAsString;
    if (key instanceof ProvidedColumnGroup) {
      keyAsString = key.getId();
    } else {
      keyAsString = key || "";
    }
    this.setColumnGroupState([{ groupId: keyAsString, open: newValue }], source);
  }
  getProvidedColumnGroup(key) {
    if (typeof key !== "string") {
      console.error("AG Grid: group key must be a string");
    }
    let res = null;
    this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, (node) => {
      if (node instanceof ProvidedColumnGroup) {
        if (node.getId() === key) {
          res = node;
        }
      }
    });
    return res;
  }
  calculateColumnsForDisplay() {
    let columnsForDisplay;
    if (this.pivotMode && missing(this.secondaryColumns)) {
      columnsForDisplay = this.gridColumns.filter((column) => {
        const isAutoGroupCol = this.groupAutoColumns && includes(this.groupAutoColumns, column);
        const isValueCol = this.valueColumns && includes(this.valueColumns, column);
        return isAutoGroupCol || isValueCol;
      });
    } else {
      columnsForDisplay = this.gridColumns.filter((column) => {
        const isAutoGroupCol = this.groupAutoColumns && includes(this.groupAutoColumns, column);
        return isAutoGroupCol || column.isVisible();
      });
    }
    return columnsForDisplay;
  }
  checkColSpanActiveInCols(columns) {
    let result = false;
    columns.forEach((col) => {
      if (exists(col.getColDef().colSpan)) {
        result = true;
      }
    });
    return result;
  }
  calculateColumnsForGroupDisplay() {
    this.groupDisplayColumns = [];
    this.groupDisplayColumnsMap = {};
    const checkFunc = (col) => {
      const colDef = col.getColDef();
      const underlyingColumn = colDef.showRowGroup;
      if (colDef && exists(underlyingColumn)) {
        this.groupDisplayColumns.push(col);
        if (typeof underlyingColumn === "string") {
          this.groupDisplayColumnsMap[underlyingColumn] = col;
        } else if (underlyingColumn === true) {
          this.getRowGroupColumns().forEach((rowGroupCol) => {
            this.groupDisplayColumnsMap[rowGroupCol.getId()] = col;
          });
        }
      }
    };
    this.gridColumns.forEach(checkFunc);
  }
  getGroupDisplayColumns() {
    return this.groupDisplayColumns;
  }
  getGroupDisplayColumnForGroup(rowGroupColumnId) {
    return this.groupDisplayColumnsMap[rowGroupColumnId];
  }
  updateDisplayedColumns(source) {
    const columnsForDisplay = this.calculateColumnsForDisplay();
    this.buildDisplayedTrees(columnsForDisplay);
    this.updateGroupsAndDisplayedColumns(source);
    this.setFirstRightAndLastLeftPinned(source);
  }
  isSecondaryColumnsPresent() {
    return exists(this.secondaryColumns);
  }
  setSecondaryColumns(colDefs, source = "api") {
    const newColsPresent = colDefs && colDefs.length > 0;
    if (!newColsPresent && missing(this.secondaryColumns)) {
      return;
    }
    if (newColsPresent) {
      this.processSecondaryColumnDefinitions(colDefs);
      const balancedTreeResult = this.columnFactory.createColumnTree(colDefs, false, this.secondaryBalancedTree || this.previousSecondaryColumns || void 0);
      this.destroyOldColumns(this.secondaryBalancedTree, balancedTreeResult.columnTree);
      this.secondaryBalancedTree = balancedTreeResult.columnTree;
      this.secondaryHeaderRowCount = balancedTreeResult.treeDept + 1;
      this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree);
      this.secondaryColumnsMap = {};
      this.secondaryColumns.forEach((col) => this.secondaryColumnsMap[col.getId()] = col);
      this.previousSecondaryColumns = null;
    } else {
      this.previousSecondaryColumns = this.secondaryBalancedTree;
      this.secondaryBalancedTree = null;
      this.secondaryHeaderRowCount = -1;
      this.secondaryColumns = null;
      this.secondaryColumnsMap = {};
    }
    this.updateGridColumns();
    this.updateDisplayedColumns(source);
  }
  processSecondaryColumnDefinitions(colDefs) {
    const columnCallback = this.gridOptionsService.get("processPivotResultColDef") || this.gridOptionsService.get("processSecondaryColDef");
    const groupCallback = this.gridOptionsService.get("processPivotResultColGroupDef") || this.gridOptionsService.get("processSecondaryColGroupDef");
    if (!columnCallback && !groupCallback) {
      return void 0;
    }
    const searchForColDefs = (colDefs2) => {
      colDefs2.forEach((abstractColDef) => {
        const isGroup = exists(abstractColDef.children);
        if (isGroup) {
          const colGroupDef = abstractColDef;
          if (groupCallback) {
            groupCallback(colGroupDef);
          }
          searchForColDefs(colGroupDef.children);
        } else {
          const colDef = abstractColDef;
          if (columnCallback) {
            columnCallback(colDef);
          }
        }
      });
    };
    if (colDefs) {
      searchForColDefs(colDefs);
    }
  }
  updateGridColumns() {
    const prevGridCols = this.gridBalancedTree;
    if (this.gridColsArePrimary) {
      this.lastPrimaryOrder = this.gridColumns;
    } else {
      this.lastSecondaryOrder = this.gridColumns;
    }
    let sortOrderToRecover;
    if (this.secondaryColumns && this.secondaryBalancedTree) {
      const hasSameColumns = this.secondaryColumns.every((col) => {
        return this.gridColumnsMap[col.getColId()] !== void 0;
      });
      this.gridBalancedTree = this.secondaryBalancedTree.slice();
      this.gridHeaderRowCount = this.secondaryHeaderRowCount;
      this.gridColumns = this.secondaryColumns.slice();
      this.gridColsArePrimary = false;
      if (hasSameColumns) {
        sortOrderToRecover = this.lastSecondaryOrder;
      }
    } else if (this.primaryColumns) {
      this.gridBalancedTree = this.primaryColumnTree.slice();
      this.gridHeaderRowCount = this.primaryHeaderRowCount;
      this.gridColumns = this.primaryColumns.slice();
      this.gridColsArePrimary = true;
      sortOrderToRecover = this.lastPrimaryOrder;
    }
    const areAutoColsChanged = this.createGroupAutoColumnsIfNeeded();
    if (areAutoColsChanged && sortOrderToRecover) {
      const groupAutoColsMap = convertToMap(this.groupAutoColumns.map((col) => [col, true]));
      sortOrderToRecover = sortOrderToRecover.filter((col) => !groupAutoColsMap.has(col));
      sortOrderToRecover = [...this.groupAutoColumns, ...sortOrderToRecover];
    }
    this.addAutoGroupToGridColumns();
    this.orderGridColsLike(sortOrderToRecover);
    this.gridColumns = this.placeLockedColumns(this.gridColumns);
    this.calculateColumnsForGroupDisplay();
    this.refreshQuickFilterColumns();
    this.clearDisplayedAndViewportColumns();
    this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns);
    this.gridColumnsMap = {};
    this.gridColumns.forEach((col) => this.gridColumnsMap[col.getId()] = col);
    this.setAutoHeightActive();
    if (!areEqual(prevGridCols, this.gridBalancedTree)) {
      const event = {
        type: Events.EVENT_GRID_COLUMNS_CHANGED
      };
      this.eventService.dispatchEvent(event);
    }
  }
  setAutoHeightActive() {
    this.autoHeightActive = this.gridColumns.filter((col) => col.isAutoHeight()).length > 0;
    if (this.autoHeightActive) {
      this.autoHeightActiveAtLeastOnce = true;
      const supportedRowModel = this.gridOptionsService.isRowModelType("clientSide") || this.gridOptionsService.isRowModelType("serverSide");
      if (!supportedRowModel) {
        const message = "AG Grid - autoHeight columns only work with Client Side Row Model and Server Side Row Model.";
        doOnce(() => console.warn(message), "autoHeightActive.wrongRowModel");
      }
    }
  }
  orderGridColsLike(colsOrder) {
    if (missing(colsOrder)) {
      return;
    }
    const lastOrderMapped = convertToMap(colsOrder.map((col, index) => [col, index]));
    let noColsFound = true;
    this.gridColumns.forEach((col) => {
      if (lastOrderMapped.has(col)) {
        noColsFound = false;
      }
    });
    if (noColsFound) {
      return;
    }
    const gridColsMap = convertToMap(this.gridColumns.map((col) => [col, true]));
    const oldColsOrdered = colsOrder.filter((col) => gridColsMap.has(col));
    const oldColsMap = convertToMap(oldColsOrdered.map((col) => [col, true]));
    const newColsOrdered = this.gridColumns.filter((col) => !oldColsMap.has(col));
    const newGridColumns = oldColsOrdered.slice();
    newColsOrdered.forEach((newCol) => {
      let parent = newCol.getOriginalParent();
      if (!parent) {
        newGridColumns.push(newCol);
        return;
      }
      const siblings = [];
      while (!siblings.length && parent) {
        const leafCols = parent.getLeafColumns();
        leafCols.forEach((leafCol) => {
          const presentInNewGriColumns = newGridColumns.indexOf(leafCol) >= 0;
          const noYetInSiblings = siblings.indexOf(leafCol) < 0;
          if (presentInNewGriColumns && noYetInSiblings) {
            siblings.push(leafCol);
          }
        });
        parent = parent.getOriginalParent();
      }
      if (!siblings.length) {
        newGridColumns.push(newCol);
        return;
      }
      const indexes = siblings.map((col) => newGridColumns.indexOf(col));
      const lastIndex = Math.max(...indexes);
      insertIntoArray(newGridColumns, newCol, lastIndex + 1);
    });
    this.gridColumns = newGridColumns;
  }
  isPrimaryColumnGroupsPresent() {
    return this.primaryHeaderRowCount > 1;
  }
  refreshQuickFilterColumns() {
    var _a;
    let columnsForQuickFilter = (_a = this.isPivotMode() ? this.secondaryColumns : this.primaryColumns) !== null && _a !== void 0 ? _a : [];
    if (this.groupAutoColumns) {
      columnsForQuickFilter = columnsForQuickFilter.concat(this.groupAutoColumns);
    }
    this.columnsForQuickFilter = this.gridOptionsService.is("includeHiddenColumnsInQuickFilter") ? columnsForQuickFilter : columnsForQuickFilter.filter((col) => col.isVisible() || col.isRowGroupActive());
  }
  placeLockedColumns(cols) {
    const left = [];
    const normal = [];
    const right = [];
    cols.forEach((col) => {
      const position = col.getColDef().lockPosition;
      if (position === "right") {
        right.push(col);
      } else if (position === "left" || position === true) {
        left.push(col);
      } else {
        normal.push(col);
      }
    });
    return [...left, ...normal, ...right];
  }
  addAutoGroupToGridColumns() {
    if (missing(this.groupAutoColumns)) {
      this.destroyOldColumns(this.groupAutoColsBalancedTree);
      this.groupAutoColsBalancedTree = null;
      return;
    }
    this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;
    const newAutoColsTree = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);
    this.destroyOldColumns(this.groupAutoColsBalancedTree, newAutoColsTree);
    this.groupAutoColsBalancedTree = newAutoColsTree;
    this.gridBalancedTree = newAutoColsTree.concat(this.gridBalancedTree);
  }
  clearDisplayedAndViewportColumns() {
    this.viewportRowLeft = {};
    this.viewportRowRight = {};
    this.viewportRowCenter = {};
    this.displayedColumnsLeft = [];
    this.displayedColumnsRight = [];
    this.displayedColumnsCenter = [];
    this.displayedColumns = [];
    this.viewportColumns = [];
    this.headerViewportColumns = [];
    this.viewportColumnsHash = "";
  }
  updateGroupsAndDisplayedColumns(source) {
    this.updateOpenClosedVisibilityInColumnGroups();
    this.deriveDisplayedColumns(source);
    this.refreshFlexedColumns();
    this.extractViewport();
    this.updateBodyWidths();
    const event = {
      type: Events.EVENT_DISPLAYED_COLUMNS_CHANGED
    };
    this.eventService.dispatchEvent(event);
  }
  deriveDisplayedColumns(source) {
    this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeLeft, this.displayedColumnsLeft);
    this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeCentre, this.displayedColumnsCenter);
    this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeRight, this.displayedColumnsRight);
    this.joinDisplayedColumns();
    this.setLeftValues(source);
    this.displayedAutoHeightCols = this.displayedColumns.filter((col) => col.isAutoHeight());
  }
  isAutoRowHeightActive() {
    return this.autoHeightActive;
  }
  wasAutoRowHeightEverActive() {
    return this.autoHeightActiveAtLeastOnce;
  }
  joinDisplayedColumns() {
    if (this.gridOptionsService.is("enableRtl")) {
      this.displayedColumns = this.displayedColumnsRight.concat(this.displayedColumnsCenter).concat(this.displayedColumnsLeft);
    } else {
      this.displayedColumns = this.displayedColumnsLeft.concat(this.displayedColumnsCenter).concat(this.displayedColumnsRight);
    }
  }
  setLeftValues(source) {
    this.setLeftValuesOfColumns(source);
    this.setLeftValuesOfGroups();
  }
  setLeftValuesOfColumns(source) {
    if (!this.primaryColumns) {
      return;
    }
    const allColumns = this.primaryColumns.slice(0);
    const doingRtl = this.gridOptionsService.is("enableRtl");
    [
      this.displayedColumnsLeft,
      this.displayedColumnsRight,
      this.displayedColumnsCenter
    ].forEach((columns) => {
      if (doingRtl) {
        let left = this.getWidthOfColsInList(columns);
        columns.forEach((column) => {
          left -= column.getActualWidth();
          column.setLeft(left, source);
        });
      } else {
        let left = 0;
        columns.forEach((column) => {
          column.setLeft(left, source);
          left += column.getActualWidth();
        });
      }
      removeAllFromArray(allColumns, columns);
    });
    allColumns.forEach((column) => {
      column.setLeft(null, source);
    });
  }
  setLeftValuesOfGroups() {
    [
      this.displayedTreeLeft,
      this.displayedTreeRight,
      this.displayedTreeCentre
    ].forEach((columns) => {
      columns.forEach((column) => {
        if (column instanceof ColumnGroup) {
          const columnGroup = column;
          columnGroup.checkLeft();
        }
      });
    });
  }
  derivedDisplayedColumnsFromDisplayedTree(tree, columns) {
    columns.length = 0;
    this.columnUtils.depthFirstDisplayedColumnTreeSearch(tree, (child) => {
      if (child instanceof Column) {
        columns.push(child);
      }
    });
  }
  extractViewportColumns() {
    if (this.suppressColumnVirtualisation) {
      this.viewportColumnsCenter = this.displayedColumnsCenter;
      this.headerViewportColumnsCenter = this.displayedColumnsCenter;
    } else {
      this.viewportColumnsCenter = this.displayedColumnsCenter.filter(this.isColumnInRowViewport.bind(this));
      this.headerViewportColumnsCenter = this.displayedColumnsCenter.filter(this.isColumnInHeaderViewport.bind(this));
    }
    this.viewportColumns = this.viewportColumnsCenter.concat(this.displayedColumnsLeft).concat(this.displayedColumnsRight);
    this.headerViewportColumns = this.headerViewportColumnsCenter.concat(this.displayedColumnsLeft).concat(this.displayedColumnsRight);
  }
  getVirtualHeaderGroupRow(type, dept) {
    let result;
    switch (type) {
      case "left":
        result = this.viewportRowLeft[dept];
        break;
      case "right":
        result = this.viewportRowRight[dept];
        break;
      default:
        result = this.viewportRowCenter[dept];
        break;
    }
    if (missing(result)) {
      result = [];
    }
    return result;
  }
  calculateHeaderRows() {
    this.viewportRowLeft = {};
    this.viewportRowRight = {};
    this.viewportRowCenter = {};
    const virtualColIds = {};
    this.headerViewportColumns.forEach((col) => virtualColIds[col.getId()] = true);
    const testGroup = (children, result, dept) => {
      let returnValue = false;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        let addThisItem = false;
        if (child instanceof Column) {
          addThisItem = virtualColIds[child.getId()] === true;
        } else {
          const columnGroup = child;
          const displayedChildren = columnGroup.getDisplayedChildren();
          if (displayedChildren) {
            addThisItem = testGroup(displayedChildren, result, dept + 1);
          }
        }
        if (addThisItem) {
          returnValue = true;
          if (!result[dept]) {
            result[dept] = [];
          }
          result[dept].push(child);
        }
      }
      return returnValue;
    };
    testGroup(this.displayedTreeLeft, this.viewportRowLeft, 0);
    testGroup(this.displayedTreeRight, this.viewportRowRight, 0);
    testGroup(this.displayedTreeCentre, this.viewportRowCenter, 0);
  }
  extractViewport() {
    const hashColumn = (c) => `${c.getId()}-${c.getPinned() || "normal"}`;
    this.extractViewportColumns();
    const newHash = this.viewportColumns.map(hashColumn).join("#");
    const changed = this.viewportColumnsHash !== newHash;
    if (changed) {
      this.viewportColumnsHash = newHash;
      this.calculateHeaderRows();
    }
    return changed;
  }
  refreshFlexedColumns(params = {}) {
    const source = params.source ? params.source : "flex";
    if (params.viewportWidth != null) {
      this.flexViewportWidth = params.viewportWidth;
    }
    if (!this.flexViewportWidth) {
      return [];
    }
    let flexAfterDisplayIndex = -1;
    if (params.resizingCols) {
      params.resizingCols.forEach((col) => {
        const indexOfCol = this.displayedColumnsCenter.indexOf(col);
        if (flexAfterDisplayIndex < indexOfCol) {
          flexAfterDisplayIndex = indexOfCol;
        }
      });
    }
    const isColFlex = (col) => {
      const afterResizingCols = this.displayedColumnsCenter.indexOf(col) > flexAfterDisplayIndex;
      return col.getFlex() && afterResizingCols;
    };
    const knownWidthColumns = this.displayedColumnsCenter.filter((col) => !isColFlex(col));
    const flexingColumns = this.displayedColumnsCenter.filter((col) => isColFlex(col));
    const changedColumns = [];
    if (!flexingColumns.length) {
      return [];
    }
    const flexingColumnSizes = [];
    let spaceForFlexingColumns;
    outer:
      while (true) {
        const totalFlex = flexingColumns.reduce((count, col) => count + col.getFlex(), 0);
        spaceForFlexingColumns = this.flexViewportWidth - this.getWidthOfColsInList(knownWidthColumns);
        for (let i = 0; i < flexingColumns.length; i++) {
          const col = flexingColumns[i];
          const widthByFlexRule = spaceForFlexingColumns * col.getFlex() / totalFlex;
          let constrainedWidth = 0;
          const minWidth = col.getMinWidth();
          const maxWidth = col.getMaxWidth();
          if (exists(minWidth) && widthByFlexRule < minWidth) {
            constrainedWidth = minWidth;
          } else if (exists(maxWidth) && widthByFlexRule > maxWidth) {
            constrainedWidth = maxWidth;
          }
          if (constrainedWidth) {
            col.setActualWidth(constrainedWidth, source);
            removeFromArray(flexingColumns, col);
            changedColumns.push(col);
            knownWidthColumns.push(col);
            continue outer;
          }
          flexingColumnSizes[i] = Math.round(widthByFlexRule);
        }
        break;
      }
    let remainingSpace = spaceForFlexingColumns;
    flexingColumns.forEach((col, i) => {
      col.setActualWidth(Math.min(flexingColumnSizes[i], remainingSpace), source);
      changedColumns.push(col);
      remainingSpace -= flexingColumnSizes[i];
    });
    if (!params.skipSetLeft) {
      this.setLeftValues(source);
    }
    if (params.updateBodyWidths) {
      this.updateBodyWidths();
    }
    if (params.fireResizedEvent) {
      this.dispatchColumnResizedEvent(changedColumns, true, source, flexingColumns);
    }
    return flexingColumns;
  }
  sizeColumnsToFit(gridWidth, source = "sizeColumnsToFit", silent, params) {
    var _a, _b, _c, _d, _e;
    const limitsMap = {};
    if (params) {
      (_a = params === null || params === void 0 ? void 0 : params.columnLimits) === null || _a === void 0 ? void 0 : _a.forEach((_a2) => {
        var { key } = _a2, dimensions = __rest(_a2, ["key"]);
        limitsMap[typeof key === "string" ? key : key.getColId()] = dimensions;
      });
    }
    const allDisplayedColumns = this.getAllDisplayedColumns();
    const doColumnsAlreadyFit = gridWidth === this.getWidthOfColsInList(allDisplayedColumns);
    if (gridWidth <= 0 || !allDisplayedColumns.length || doColumnsAlreadyFit) {
      return;
    }
    const colsToSpread = [];
    const colsToNotSpread = [];
    allDisplayedColumns.forEach((column) => {
      if (column.getColDef().suppressSizeToFit === true) {
        colsToNotSpread.push(column);
      } else {
        colsToSpread.push(column);
      }
    });
    const colsToDispatchEventFor = colsToSpread.slice(0);
    let finishedResizing = false;
    const moveToNotSpread = (column) => {
      removeFromArray(colsToSpread, column);
      colsToNotSpread.push(column);
    };
    colsToSpread.forEach((column) => column.resetActualWidth(source));
    while (!finishedResizing) {
      finishedResizing = true;
      const availablePixels = gridWidth - this.getWidthOfColsInList(colsToNotSpread);
      if (availablePixels <= 0) {
        colsToSpread.forEach((column) => {
          var _a2, _b2;
          const widthOverride = (_b2 = (_a2 = limitsMap === null || limitsMap === void 0 ? void 0 : limitsMap[column.getId()]) === null || _a2 === void 0 ? void 0 : _a2.minWidth) !== null && _b2 !== void 0 ? _b2 : params === null || params === void 0 ? void 0 : params.defaultMinWidth;
          if (typeof widthOverride === "number") {
            column.setActualWidth(widthOverride);
            return;
          }
          column.setMinimum(source);
        });
      } else {
        const scale = availablePixels / this.getWidthOfColsInList(colsToSpread);
        let pixelsForLastCol = availablePixels;
        for (let i = colsToSpread.length - 1; i >= 0; i--) {
          const column = colsToSpread[i];
          const widthOverride = limitsMap === null || limitsMap === void 0 ? void 0 : limitsMap[column.getId()];
          const minOverride = (_b = widthOverride === null || widthOverride === void 0 ? void 0 : widthOverride.minWidth) !== null && _b !== void 0 ? _b : params === null || params === void 0 ? void 0 : params.defaultMinWidth;
          const maxOverride = (_c = widthOverride === null || widthOverride === void 0 ? void 0 : widthOverride.maxWidth) !== null && _c !== void 0 ? _c : params === null || params === void 0 ? void 0 : params.defaultMaxWidth;
          const colMinWidth = (_d = column.getMinWidth()) !== null && _d !== void 0 ? _d : 0;
          const colMaxWidth = (_e = column.getMaxWidth()) !== null && _e !== void 0 ? _e : Number.MAX_VALUE;
          const minWidth = typeof minOverride === "number" && minOverride > colMinWidth ? minOverride : column.getMinWidth();
          const maxWidth = typeof maxOverride === "number" && maxOverride < colMaxWidth ? maxOverride : column.getMaxWidth();
          let newWidth = Math.round(column.getActualWidth() * scale);
          if (exists(minWidth) && newWidth < minWidth) {
            newWidth = minWidth;
            moveToNotSpread(column);
            finishedResizing = false;
          } else if (exists(maxWidth) && newWidth > maxWidth) {
            newWidth = maxWidth;
            moveToNotSpread(column);
            finishedResizing = false;
          } else if (i === 0) {
            newWidth = pixelsForLastCol;
          }
          column.setActualWidth(newWidth, source, true);
          pixelsForLastCol -= newWidth;
        }
      }
    }
    colsToDispatchEventFor.forEach((col) => {
      col.fireColumnWidthChangedEvent(source);
    });
    this.setLeftValues(source);
    this.updateBodyWidths();
    if (silent) {
      return;
    }
    this.dispatchColumnResizedEvent(colsToDispatchEventFor, true, source);
  }
  buildDisplayedTrees(visibleColumns) {
    const leftVisibleColumns = [];
    const rightVisibleColumns = [];
    const centerVisibleColumns = [];
    visibleColumns.forEach((column) => {
      switch (column.getPinned()) {
        case "left":
          leftVisibleColumns.push(column);
          break;
        case "right":
          rightVisibleColumns.push(column);
          break;
        default:
          centerVisibleColumns.push(column);
          break;
      }
    });
    const groupInstanceIdCreator = new GroupInstanceIdCreator();
    this.displayedTreeLeft = this.displayedGroupCreator.createDisplayedGroups(leftVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, "left", this.displayedTreeLeft);
    this.displayedTreeRight = this.displayedGroupCreator.createDisplayedGroups(rightVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, "right", this.displayedTreeRight);
    this.displayedTreeCentre = this.displayedGroupCreator.createDisplayedGroups(centerVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, null, this.displayedTreeCentre);
    this.updateDisplayedMap();
  }
  updateDisplayedMap() {
    this.displayedColumnsAndGroupsMap = {};
    const func = (child) => {
      this.displayedColumnsAndGroupsMap[child.getUniqueId()] = child;
    };
    this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeCentre, func);
    this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeLeft, func);
    this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeRight, func);
  }
  isDisplayed(item) {
    const fromMap = this.displayedColumnsAndGroupsMap[item.getUniqueId()];
    return fromMap === item;
  }
  updateOpenClosedVisibilityInColumnGroups() {
    const allColumnGroups = this.getAllDisplayedTrees();
    this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, (child) => {
      if (child instanceof ColumnGroup) {
        const columnGroup = child;
        columnGroup.calculateDisplayedColumns();
      }
    });
  }
  getGroupAutoColumns() {
    return this.groupAutoColumns;
  }
  createGroupAutoColumnsIfNeeded() {
    const forceRecreateAutoGroups = this.forceRecreateAutoGroups;
    this.forceRecreateAutoGroups = false;
    if (!this.autoGroupsNeedBuilding) {
      return false;
    }
    this.autoGroupsNeedBuilding = false;
    const groupFullWidthRow = this.gridOptionsService.isGroupUseEntireRow(this.pivotMode);
    const suppressAutoColumn = this.pivotMode ? this.gridOptionsService.is("pivotSuppressAutoColumn") : this.isGroupSuppressAutoColumn();
    const groupingActive = this.rowGroupColumns.length > 0 || this.usingTreeData;
    const needAutoColumns = groupingActive && !suppressAutoColumn && !groupFullWidthRow;
    if (needAutoColumns) {
      const existingCols = this.groupAutoColumns || [];
      const newAutoGroupCols = this.autoGroupColService.createAutoGroupColumns(existingCols, this.rowGroupColumns);
      const autoColsDifferent = !this.autoColsEqual(newAutoGroupCols, this.groupAutoColumns);
      if (autoColsDifferent || forceRecreateAutoGroups) {
        this.groupAutoColumns = newAutoGroupCols;
        return true;
      }
    } else {
      this.groupAutoColumns = null;
    }
    return false;
  }
  isGroupSuppressAutoColumn() {
    const groupDisplayType = this.gridOptionsService.get("groupDisplayType");
    const isCustomRowGroups = groupDisplayType ? matchesGroupDisplayType("custom", groupDisplayType) : false;
    if (isCustomRowGroups) {
      return true;
    }
    const treeDataDisplayType = this.gridOptionsService.get("treeDataDisplayType");
    return treeDataDisplayType ? matchesTreeDataDisplayType("custom", treeDataDisplayType) : false;
  }
  autoColsEqual(colsA, colsB) {
    return areEqual(colsA, colsB, (a, b) => a.getColId() === b.getColId());
  }
  getWidthOfColsInList(columnList) {
    return columnList.reduce((width, col) => width + col.getActualWidth(), 0);
  }
  getGridBalancedTree() {
    return this.gridBalancedTree;
  }
  hasFloatingFilters() {
    if (!this.gridColumns) {
      return false;
    }
    const res = this.gridColumns.some((col) => col.getColDef().floatingFilter);
    return res;
  }
  getFirstDisplayedColumn() {
    const isRtl = this.gridOptionsService.is("enableRtl");
    const queryOrder = [
      "getDisplayedLeftColumns",
      "getDisplayedCenterColumns",
      "getDisplayedRightColumns"
    ];
    if (isRtl) {
      queryOrder.reverse();
    }
    for (let i = 0; i < queryOrder.length; i++) {
      const container = this[queryOrder[i]]();
      if (container.length) {
        return isRtl ? last(container) : container[0];
      }
    }
    return null;
  }
  setColumnHeaderHeight(col, height) {
    const changed = col.setAutoHeaderHeight(height);
    if (changed) {
      const event = {
        type: Events.EVENT_COLUMN_HEADER_HEIGHT_CHANGED,
        column: col,
        columns: [col],
        source: "autosizeColumnHeaderHeight"
      };
      this.eventService.dispatchEvent(event);
    }
  }
  getColumnGroupHeaderRowHeight() {
    if (this.isPivotMode()) {
      return this.getPivotGroupHeaderHeight();
    }
    return this.getGroupHeaderHeight();
  }
  getColumnHeaderRowHeight() {
    const defaultHeight = this.isPivotMode() ? this.getPivotHeaderHeight() : this.getHeaderHeight();
    const displayedHeights = this.getAllDisplayedColumns().filter((col) => col.isAutoHeaderHeight()).map((col) => col.getAutoHeaderHeight() || 0);
    return Math.max(defaultHeight, ...displayedHeights);
  }
  getHeaderHeight() {
    var _a;
    return (_a = this.gridOptionsService.getNum("headerHeight")) !== null && _a !== void 0 ? _a : this.environment.getFromTheme(25, "headerHeight");
  }
  getFloatingFiltersHeight() {
    var _a;
    return (_a = this.gridOptionsService.getNum("floatingFiltersHeight")) !== null && _a !== void 0 ? _a : this.getHeaderHeight();
  }
  getGroupHeaderHeight() {
    var _a;
    return (_a = this.gridOptionsService.getNum("groupHeaderHeight")) !== null && _a !== void 0 ? _a : this.getHeaderHeight();
  }
  getPivotHeaderHeight() {
    var _a;
    return (_a = this.gridOptionsService.getNum("pivotHeaderHeight")) !== null && _a !== void 0 ? _a : this.getHeaderHeight();
  }
  getPivotGroupHeaderHeight() {
    var _a;
    return (_a = this.gridOptionsService.getNum("pivotGroupHeaderHeight")) !== null && _a !== void 0 ? _a : this.getGroupHeaderHeight();
  }
};
__decorate$2w([
  Autowired("expressionService")
], ColumnModel.prototype, "expressionService", void 0);
__decorate$2w([
  Autowired("columnFactory")
], ColumnModel.prototype, "columnFactory", void 0);
__decorate$2w([
  Autowired("displayedGroupCreator")
], ColumnModel.prototype, "displayedGroupCreator", void 0);
__decorate$2w([
  Autowired("ctrlsService")
], ColumnModel.prototype, "ctrlsService", void 0);
__decorate$2w([
  Autowired("autoWidthCalculator")
], ColumnModel.prototype, "autoWidthCalculator", void 0);
__decorate$2w([
  Autowired("columnUtils")
], ColumnModel.prototype, "columnUtils", void 0);
__decorate$2w([
  Autowired("columnAnimationService")
], ColumnModel.prototype, "columnAnimationService", void 0);
__decorate$2w([
  Autowired("autoGroupColService")
], ColumnModel.prototype, "autoGroupColService", void 0);
__decorate$2w([
  Optional("aggFuncService")
], ColumnModel.prototype, "aggFuncService", void 0);
__decorate$2w([
  Optional("valueCache")
], ColumnModel.prototype, "valueCache", void 0);
__decorate$2w([
  Optional("animationFrameService")
], ColumnModel.prototype, "animationFrameService", void 0);
__decorate$2w([
  Autowired("sortController")
], ColumnModel.prototype, "sortController", void 0);
__decorate$2w([
  Autowired("columnDefFactory")
], ColumnModel.prototype, "columnDefFactory", void 0);
__decorate$2w([
  PostConstruct
], ColumnModel.prototype, "init", null);
__decorate$2w([
  PreDestroy
], ColumnModel.prototype, "destroyColumns", null);
__decorate$2w([
  __param$8(0, Qualifier("loggerFactory"))
], ColumnModel.prototype, "setBeans", null);
ColumnModel = __decorate$2w([
  Bean("columnModel")
], ColumnModel);
var __decorate$2v = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ColumnUtils = class ColumnUtils2 extends BeanStub {
  calculateColMinWidth(colDef) {
    return colDef.minWidth != null ? colDef.minWidth : this.environment.getMinColWidth();
  }
  calculateColMaxWidth(colDef) {
    return colDef.maxWidth != null ? colDef.maxWidth : Number.MAX_SAFE_INTEGER;
  }
  calculateColInitialWidth(colDef) {
    const minColWidth = this.calculateColMinWidth(colDef);
    const maxColWidth = this.calculateColMaxWidth(colDef);
    let width;
    const colDefWidth = attrToNumber(colDef.width);
    const colDefInitialWidth = attrToNumber(colDef.initialWidth);
    if (colDefWidth != null) {
      width = colDefWidth;
    } else if (colDefInitialWidth != null) {
      width = colDefInitialWidth;
    } else {
      width = 200;
    }
    return Math.max(Math.min(width, maxColWidth), minColWidth);
  }
  getOriginalPathForColumn(column, originalBalancedTree) {
    const result = [];
    let found = false;
    const recursePath = (balancedColumnTree, dept) => {
      for (let i = 0; i < balancedColumnTree.length; i++) {
        if (found) {
          return;
        }
        const node = balancedColumnTree[i];
        if (node instanceof ProvidedColumnGroup) {
          const nextNode = node;
          recursePath(nextNode.getChildren(), dept + 1);
          result[dept] = node;
        } else if (node === column) {
          found = true;
        }
      }
    };
    recursePath(originalBalancedTree, 0);
    return found ? result : null;
  }
  depthFirstOriginalTreeSearch(parent, tree, callback) {
    if (!tree) {
      return;
    }
    tree.forEach((child) => {
      if (child instanceof ProvidedColumnGroup) {
        this.depthFirstOriginalTreeSearch(child, child.getChildren(), callback);
      }
      callback(child, parent);
    });
  }
  depthFirstAllColumnTreeSearch(tree, callback) {
    if (!tree) {
      return;
    }
    tree.forEach((child) => {
      if (child instanceof ColumnGroup) {
        this.depthFirstAllColumnTreeSearch(child.getChildren(), callback);
      }
      callback(child);
    });
  }
  depthFirstDisplayedColumnTreeSearch(tree, callback) {
    if (!tree) {
      return;
    }
    tree.forEach((child) => {
      if (child instanceof ColumnGroup) {
        this.depthFirstDisplayedColumnTreeSearch(child.getDisplayedChildren(), callback);
      }
      callback(child);
    });
  }
};
ColumnUtils = __decorate$2v([
  Bean("columnUtils")
], ColumnUtils);
var __decorate$2u = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DisplayedGroupCreator = class DisplayedGroupCreator2 extends BeanStub {
  createDisplayedGroups(sortedVisibleColumns, balancedColumnTree, groupInstanceIdCreator, pinned, oldDisplayedGroups) {
    const result = [];
    let previousRealPath;
    let previousOriginalPath;
    const oldColumnsMapped = this.mapOldGroupsById(oldDisplayedGroups);
    sortedVisibleColumns.forEach((currentColumn) => {
      const currentOriginalPath = this.getOriginalPathForColumn(balancedColumnTree, currentColumn);
      const currentRealPath = [];
      const firstColumn = !previousOriginalPath;
      for (let i = 0; i < currentOriginalPath.length; i++) {
        if (firstColumn || currentOriginalPath[i] !== previousOriginalPath[i]) {
          const newGroup = this.createColumnGroup(currentOriginalPath[i], groupInstanceIdCreator, oldColumnsMapped, pinned);
          currentRealPath[i] = newGroup;
          if (i == 0) {
            result.push(newGroup);
          } else {
            currentRealPath[i - 1].addChild(newGroup);
          }
        } else {
          currentRealPath[i] = previousRealPath[i];
        }
      }
      const noColumnGroups = currentRealPath.length === 0;
      if (noColumnGroups) {
        result.push(currentColumn);
      } else {
        const leafGroup = last(currentRealPath);
        leafGroup.addChild(currentColumn);
      }
      previousRealPath = currentRealPath;
      previousOriginalPath = currentOriginalPath;
    });
    this.setupParentsIntoColumns(result, null);
    return result;
  }
  createColumnGroup(providedGroup, groupInstanceIdCreator, oldColumnsMapped, pinned) {
    const groupId = providedGroup.getGroupId();
    const instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);
    const uniqueId = ColumnGroup.createUniqueId(groupId, instanceId);
    let columnGroup = oldColumnsMapped[uniqueId];
    if (columnGroup && columnGroup.getProvidedColumnGroup() !== providedGroup) {
      columnGroup = null;
    }
    if (exists(columnGroup)) {
      columnGroup.reset();
    } else {
      columnGroup = new ColumnGroup(providedGroup, groupId, instanceId, pinned);
      this.context.createBean(columnGroup);
    }
    return columnGroup;
  }
  mapOldGroupsById(displayedGroups) {
    const result = {};
    const recursive = (columnsOrGroups) => {
      columnsOrGroups.forEach((columnOrGroup) => {
        if (columnOrGroup instanceof ColumnGroup) {
          const columnGroup = columnOrGroup;
          result[columnOrGroup.getUniqueId()] = columnGroup;
          recursive(columnGroup.getChildren());
        }
      });
    };
    if (displayedGroups) {
      recursive(displayedGroups);
    }
    return result;
  }
  setupParentsIntoColumns(columnsOrGroups, parent) {
    columnsOrGroups.forEach((columnsOrGroup) => {
      columnsOrGroup.setParent(parent);
      if (columnsOrGroup instanceof ColumnGroup) {
        const columnGroup = columnsOrGroup;
        this.setupParentsIntoColumns(columnGroup.getChildren(), columnGroup);
      }
    });
  }
  getOriginalPathForColumn(balancedColumnTree, column) {
    const result = [];
    let found = false;
    const recursePath = (columnTree, dept) => {
      for (let i = 0; i < columnTree.length; i++) {
        if (found) {
          return;
        }
        const node = columnTree[i];
        if (node instanceof ProvidedColumnGroup) {
          recursePath(node.getChildren(), dept + 1);
          result[dept] = node;
        } else if (node === column) {
          found = true;
        }
      }
    };
    recursePath(balancedColumnTree, 0);
    if (found) {
      return result;
    }
    console.warn("AG Grid: could not get path");
    return null;
  }
};
DisplayedGroupCreator = __decorate$2u([
  Bean("displayedGroupCreator")
], DisplayedGroupCreator);
var __decorate$2t = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AgStackComponentsRegistry = class AgStackComponentsRegistry2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.componentsMappedByName = {};
  }
  setupComponents(components) {
    if (components) {
      components.forEach((componentMeta) => this.addComponent(componentMeta));
    }
  }
  addComponent(componentMeta) {
    const classEscaped = componentMeta.componentName.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    const classUpperCase = classEscaped.toUpperCase();
    this.componentsMappedByName[classUpperCase] = componentMeta.componentClass;
  }
  getComponentClass(htmlTag) {
    return this.componentsMappedByName[htmlTag];
  }
};
AgStackComponentsRegistry = __decorate$2t([
  Bean("agStackComponentsRegistry")
], AgStackComponentsRegistry);
function toggleAriaAttribute(element, attribute, value) {
  if (value == null || value == "") {
    removeAriaAttribute(element, attribute);
  } else {
    setAriaAttribute(element, attribute, value);
  }
}
function setAriaAttribute(element, attribute, value) {
  element.setAttribute(ariaAttributeName(attribute), value.toString());
}
function removeAriaAttribute(element, attribute) {
  element.removeAttribute(ariaAttributeName(attribute));
}
function ariaAttributeName(attribute) {
  return `aria-${attribute}`;
}
function setAriaRole(element, role) {
  if (role) {
    element.setAttribute("role", role);
  } else {
    element.removeAttribute("role");
  }
}
function getAriaSortState(sortDirection) {
  let sort;
  if (sortDirection === "asc") {
    sort = "ascending";
  } else if (sortDirection === "desc") {
    sort = "descending";
  } else if (sortDirection === "mixed") {
    sort = "other";
  } else {
    sort = "none";
  }
  return sort;
}
function getAriaLevel(element) {
  return parseInt(element.getAttribute("aria-level"), 10);
}
function getAriaPosInSet(element) {
  return parseInt(element.getAttribute("aria-posinset"), 10);
}
function getAriaDescribedBy(element) {
  return element.getAttribute("aria-describedby") || "";
}
function setAriaLabel(element, label) {
  toggleAriaAttribute(element, "label", label);
}
function setAriaLabelledBy(element, labelledBy) {
  toggleAriaAttribute(element, "labelledby", labelledBy);
}
function setAriaDescription(element, description) {
  toggleAriaAttribute(element, "description", description);
}
function setAriaDescribedBy(element, describedby) {
  toggleAriaAttribute(element, "describedby", describedby);
}
function setAriaLive(element, live) {
  toggleAriaAttribute(element, "live", live);
}
function setAriaLevel(element, level) {
  toggleAriaAttribute(element, "level", level);
}
function setAriaDisabled(element, disabled) {
  toggleAriaAttribute(element, "disabled", disabled);
}
function setAriaHidden(element, hidden) {
  toggleAriaAttribute(element, "hidden", hidden);
}
function setAriaExpanded(element, expanded) {
  setAriaAttribute(element, "expanded", expanded);
}
function removeAriaExpanded(element) {
  removeAriaAttribute(element, "expanded");
}
function setAriaSetSize(element, setsize) {
  setAriaAttribute(element, "setsize", setsize);
}
function setAriaPosInSet(element, position) {
  setAriaAttribute(element, "posinset", position);
}
function setAriaMultiSelectable(element, multiSelectable) {
  setAriaAttribute(element, "multiselectable", multiSelectable);
}
function setAriaRowCount(element, rowCount) {
  setAriaAttribute(element, "rowcount", rowCount);
}
function setAriaRowIndex(element, rowIndex) {
  setAriaAttribute(element, "rowindex", rowIndex);
}
function setAriaColCount(element, colCount) {
  setAriaAttribute(element, "colcount", colCount);
}
function setAriaColIndex(element, colIndex) {
  setAriaAttribute(element, "colindex", colIndex);
}
function setAriaColSpan(element, colSpan) {
  setAriaAttribute(element, "colspan", colSpan);
}
function setAriaSort(element, sort) {
  setAriaAttribute(element, "sort", sort);
}
function removeAriaSort(element) {
  removeAriaAttribute(element, "sort");
}
function setAriaSelected(element, selected) {
  toggleAriaAttribute(element, "selected", selected);
}
function setAriaChecked(element, checked) {
  setAriaAttribute(element, "checked", checked === void 0 ? "mixed" : checked);
}
function setAriaControls(controllerElement, controlledElement) {
  toggleAriaAttribute(controllerElement, "controls", controlledElement.id);
  setAriaLabelledBy(controlledElement, controllerElement.id);
}
function getAriaCheckboxStateName(translate, state) {
  return state === void 0 ? translate("ariaIndeterminate", "indeterminate") : state === true ? translate("ariaChecked", "checked") : translate("ariaUnchecked", "unchecked");
}
var AriaUtils = Object.freeze({
  __proto__: null,
  setAriaRole,
  getAriaSortState,
  getAriaLevel,
  getAriaPosInSet,
  getAriaDescribedBy,
  setAriaLabel,
  setAriaLabelledBy,
  setAriaDescription,
  setAriaDescribedBy,
  setAriaLive,
  setAriaLevel,
  setAriaDisabled,
  setAriaHidden,
  setAriaExpanded,
  removeAriaExpanded,
  setAriaSetSize,
  setAriaPosInSet,
  setAriaMultiSelectable,
  setAriaRowCount,
  setAriaRowIndex,
  setAriaColCount,
  setAriaColIndex,
  setAriaColSpan,
  setAriaSort,
  removeAriaSort,
  setAriaSelected,
  setAriaChecked,
  setAriaControls,
  getAriaCheckboxStateName
});
var isSafari;
var safariVersion;
var isChrome;
var isFirefox;
var isMacOs;
var isIOS;
var invisibleScrollbar;
var browserScrollbarWidth;
function isBrowserSafari() {
  if (isSafari === void 0) {
    isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  }
  return isSafari;
}
function getSafariVersion() {
  if (safariVersion === void 0) {
    if (isBrowserSafari()) {
      const versionMatch = navigator.userAgent.match(/version\/(\d+)/i);
      if (versionMatch) {
        safariVersion = versionMatch[1] != null ? parseFloat(versionMatch[1]) : 0;
      }
    } else {
      safariVersion = 0;
    }
  }
  return safariVersion;
}
function isBrowserChrome() {
  if (isChrome === void 0) {
    const win = window;
    isChrome = !!win.chrome && (!!win.chrome.webstore || !!win.chrome.runtime) || /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
  }
  return isChrome;
}
function isBrowserFirefox() {
  if (isFirefox === void 0) {
    isFirefox = /(firefox)/i.test(navigator.userAgent);
  }
  return isFirefox;
}
function isMacOsUserAgent() {
  if (isMacOs === void 0) {
    isMacOs = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
  }
  return isMacOs;
}
function isIOSUserAgent() {
  if (isIOS === void 0) {
    isIOS = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
  }
  return isIOS;
}
function browserSupportsPreventScroll() {
  return !isBrowserSafari() || getSafariVersion() >= 15;
}
function getTabIndex(el) {
  if (!el) {
    return null;
  }
  const numberTabIndex = el.tabIndex;
  const tabIndex = el.getAttribute("tabIndex");
  if (numberTabIndex === -1 && (tabIndex === null || tabIndex === "" && !isBrowserFirefox())) {
    return null;
  }
  return numberTabIndex.toString();
}
function getMaxDivHeight() {
  if (!document.body) {
    return -1;
  }
  let res = 1e6;
  const testUpTo = navigator.userAgent.toLowerCase().match(/firefox/) ? 6e6 : 1e9;
  const div = document.createElement("div");
  document.body.appendChild(div);
  while (true) {
    const test = res * 2;
    div.style.height = test + "px";
    if (test > testUpTo || div.clientHeight !== test) {
      break;
    } else {
      res = test;
    }
  }
  document.body.removeChild(div);
  return res;
}
function getBodyWidth() {
  var _a, _b, _c;
  return (_b = (_a = document.body) === null || _a === void 0 ? void 0 : _a.clientWidth) !== null && _b !== void 0 ? _b : window.innerHeight || ((_c = document.documentElement) === null || _c === void 0 ? void 0 : _c.clientWidth) || -1;
}
function getBodyHeight() {
  var _a, _b, _c;
  return (_b = (_a = document.body) === null || _a === void 0 ? void 0 : _a.clientHeight) !== null && _b !== void 0 ? _b : window.innerHeight || ((_c = document.documentElement) === null || _c === void 0 ? void 0 : _c.clientHeight) || -1;
}
function getScrollbarWidth() {
  if (browserScrollbarWidth == null) {
    initScrollbarWidthAndVisibility();
  }
  return browserScrollbarWidth;
}
function initScrollbarWidthAndVisibility() {
  const body = document.body;
  const div = document.createElement("div");
  div.style.width = div.style.height = "100px";
  div.style.opacity = "0";
  div.style.overflow = "scroll";
  div.style.msOverflowStyle = "scrollbar";
  div.style.position = "absolute";
  body.appendChild(div);
  let width = div.offsetWidth - div.clientWidth;
  if (width === 0 && div.clientWidth === 0) {
    width = null;
  }
  if (div.parentNode) {
    div.parentNode.removeChild(div);
  }
  if (width != null) {
    browserScrollbarWidth = width;
    invisibleScrollbar = width === 0;
  }
}
function isInvisibleScrollbar() {
  if (invisibleScrollbar == null) {
    initScrollbarWidthAndVisibility();
  }
  return invisibleScrollbar;
}
var BrowserUtils = Object.freeze({
  __proto__: null,
  isBrowserSafari,
  getSafariVersion,
  isBrowserChrome,
  isBrowserFirefox,
  isMacOsUserAgent,
  isIOSUserAgent,
  browserSupportsPreventScroll,
  getTabIndex,
  getMaxDivHeight,
  getBodyWidth,
  getBodyHeight,
  getScrollbarWidth,
  isInvisibleScrollbar
});
function padStartWidthZeros(value, totalStringSize) {
  return value.toString().padStart(totalStringSize, "0");
}
function createArrayOfNumbers(first, last2) {
  const result = [];
  for (let i = first; i <= last2; i++) {
    result.push(i);
  }
  return result;
}
function cleanNumber(value) {
  if (typeof value === "string") {
    value = parseInt(value, 10);
  }
  if (typeof value === "number") {
    return Math.floor(value);
  }
  return null;
}
function decToHex(number, bytes) {
  let hex = "";
  for (let i = 0; i < bytes; i++) {
    hex += String.fromCharCode(number & 255);
    number >>>= 8;
  }
  return hex;
}
function formatNumberTwoDecimalPlacesAndCommas(value, thousandSeparator, decimalSeparator) {
  if (typeof value !== "number") {
    return "";
  }
  return formatNumberCommas(Math.round(value * 100) / 100, thousandSeparator, decimalSeparator);
}
function formatNumberCommas(value, thousandSeparator, decimalSeparator) {
  if (typeof value !== "number") {
    return "";
  }
  return value.toString().replace(".", decimalSeparator).replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${thousandSeparator}`);
}
function sum(values2) {
  return values2 == null ? null : values2.reduce((total, value) => total + value, 0);
}
function zeroOrGreater(value, defaultValue) {
  if (value >= 0) {
    return value;
  }
  return defaultValue;
}
function oneOrGreater(value, defaultValue) {
  const valueNumber = parseInt(value, 10);
  if (!isNaN(valueNumber) && isFinite(valueNumber) && valueNumber > 0) {
    return valueNumber;
  }
  return defaultValue;
}
var NumberUtils = Object.freeze({
  __proto__: null,
  padStartWidthZeros,
  createArrayOfNumbers,
  cleanNumber,
  decToHex,
  formatNumberTwoDecimalPlacesAndCommas,
  formatNumberCommas,
  sum,
  zeroOrGreater,
  oneOrGreater
});
function serialiseDate(date, includeTime = true, separator = "-") {
  if (!date) {
    return null;
  }
  let serialised = [date.getFullYear(), date.getMonth() + 1, date.getDate()].map((part) => padStartWidthZeros(part, 2)).join(separator);
  if (includeTime) {
    serialised += " " + [date.getHours(), date.getMinutes(), date.getSeconds()].map((part) => padStartWidthZeros(part, 2)).join(":");
  }
  return serialised;
}
var calculateOrdinal = (value) => {
  if (value > 3 && value < 21) {
    return "th";
  }
  const remainder = value % 10;
  switch (remainder) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
  }
  return "th";
};
function dateToFormattedString(date, format = "YYYY-MM-DD") {
  const fullYear = padStartWidthZeros(date.getFullYear(), 4);
  const months = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  const days = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ];
  const replace = {
    YYYY: () => fullYear.slice(fullYear.length - 4, fullYear.length),
    YY: () => fullYear.slice(fullYear.length - 2, fullYear.length),
    Y: () => `${date.getFullYear()}`,
    MMMM: () => months[date.getMonth()],
    MMM: () => months[date.getMonth()].slice(0, 3),
    MM: () => padStartWidthZeros(date.getMonth() + 1, 2),
    Mo: () => `${date.getMonth() + 1}${calculateOrdinal(date.getMonth() + 1)}`,
    M: () => `${date.getMonth() + 1}`,
    Do: () => `${date.getDate()}${calculateOrdinal(date.getDate())}`,
    DD: () => padStartWidthZeros(date.getDate(), 2),
    D: () => `${date.getDate()}`,
    dddd: () => days[date.getDay()],
    ddd: () => days[date.getDay()].slice(0, 3),
    dd: () => days[date.getDay()].slice(0, 2),
    do: () => `${date.getDay()}${calculateOrdinal(date.getDay())}`,
    d: () => `${date.getDay()}`
  };
  const regexp = new RegExp(Object.keys(replace).join("|"), "g");
  return format.replace(regexp, (match) => {
    if (match in replace) {
      return replace[match]();
    }
    return match;
  });
}
function parseDateTimeFromString(value) {
  if (!value) {
    return null;
  }
  const [dateStr, timeStr] = value.split(" ");
  if (!dateStr) {
    return null;
  }
  const fields = dateStr.split("-").map((f) => parseInt(f, 10));
  if (fields.filter((f) => !isNaN(f)).length !== 3) {
    return null;
  }
  const [year, month, day] = fields;
  const date = new Date(year, month - 1, day);
  if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
    return null;
  }
  if (!timeStr || timeStr === "00:00:00") {
    return date;
  }
  const [hours, minutes, seconds] = timeStr.split(":").map((part) => parseInt(part, 10));
  if (hours >= 0 && hours < 24) {
    date.setHours(hours);
  }
  if (minutes >= 0 && minutes < 60) {
    date.setMinutes(minutes);
  }
  if (seconds >= 0 && seconds < 60) {
    date.setSeconds(seconds);
  }
  return date;
}
var DateUtils = Object.freeze({
  __proto__: null,
  serialiseDate,
  dateToFormattedString,
  parseDateTimeFromString
});
var rtlNegativeScroll;
function radioCssClass(element, elementClass, otherElementClass) {
  const parent = element.parentElement;
  let sibling = parent && parent.firstChild;
  while (sibling) {
    if (elementClass) {
      sibling.classList.toggle(elementClass, sibling === element);
    }
    if (otherElementClass) {
      sibling.classList.toggle(otherElementClass, sibling !== element);
    }
    sibling = sibling.nextSibling;
  }
}
var FOCUSABLE_SELECTOR = "[tabindex], input, select, button, textarea, [href]";
var FOCUSABLE_EXCLUDE = ".ag-hidden, .ag-hidden *, [disabled], .ag-disabled, .ag-disabled *";
function isFocusableFormField(element) {
  const matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
  const inputSelector = "input, select, button, textarea";
  const isFocusable = matches.call(element, inputSelector);
  const isNotFocusable = matches.call(element, FOCUSABLE_EXCLUDE);
  const isElementVisible = isVisible(element);
  const focusable = isFocusable && !isNotFocusable && isElementVisible;
  return focusable;
}
function setDisplayed(element, displayed, options = {}) {
  const { skipAriaHidden } = options;
  element.classList.toggle("ag-hidden", !displayed);
  if (!skipAriaHidden) {
    setAriaHidden(element, !displayed);
  }
}
function setVisible(element, visible, options = {}) {
  const { skipAriaHidden } = options;
  element.classList.toggle("ag-invisible", !visible);
  if (!skipAriaHidden) {
    setAriaHidden(element, !visible);
  }
}
function setDisabled(element, disabled) {
  const attributeName = "disabled";
  const addOrRemoveDisabledAttribute = disabled ? (e) => e.setAttribute(attributeName, "") : (e) => e.removeAttribute(attributeName);
  addOrRemoveDisabledAttribute(element);
  nodeListForEach(element.querySelectorAll("input"), (input) => addOrRemoveDisabledAttribute(input));
}
function isElementChildOfClass(element, cls, maxNest) {
  let counter = 0;
  while (element) {
    if (element.classList.contains(cls)) {
      return true;
    }
    element = element.parentElement;
    if (typeof maxNest == "number") {
      if (++counter > maxNest) {
        break;
      }
    } else if (element === maxNest) {
      break;
    }
  }
  return false;
}
function getElementSize(el) {
  const { height, width, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth, paddingTop, paddingRight, paddingBottom, paddingLeft, marginTop, marginRight, marginBottom, marginLeft, boxSizing } = window.getComputedStyle(el);
  return {
    height: parseFloat(height),
    width: parseFloat(width),
    borderTopWidth: parseFloat(borderTopWidth),
    borderRightWidth: parseFloat(borderRightWidth),
    borderBottomWidth: parseFloat(borderBottomWidth),
    borderLeftWidth: parseFloat(borderLeftWidth),
    paddingTop: parseFloat(paddingTop),
    paddingRight: parseFloat(paddingRight),
    paddingBottom: parseFloat(paddingBottom),
    paddingLeft: parseFloat(paddingLeft),
    marginTop: parseFloat(marginTop),
    marginRight: parseFloat(marginRight),
    marginBottom: parseFloat(marginBottom),
    marginLeft: parseFloat(marginLeft),
    boxSizing
  };
}
function getInnerHeight(el) {
  const size = getElementSize(el);
  if (size.boxSizing === "border-box") {
    return size.height - size.paddingTop - size.paddingBottom;
  }
  return size.height;
}
function getInnerWidth(el) {
  const size = getElementSize(el);
  if (size.boxSizing === "border-box") {
    return size.width - size.paddingLeft - size.paddingRight;
  }
  return size.width;
}
function getAbsoluteHeight(el) {
  const size = getElementSize(el);
  const marginRight = size.marginBottom + size.marginTop;
  return Math.ceil(el.offsetHeight + marginRight);
}
function getAbsoluteWidth(el) {
  const size = getElementSize(el);
  const marginWidth = size.marginLeft + size.marginRight;
  return Math.ceil(el.offsetWidth + marginWidth);
}
function isRtlNegativeScroll() {
  if (typeof rtlNegativeScroll === "boolean") {
    return rtlNegativeScroll;
  }
  const template = document.createElement("div");
  template.style.direction = "rtl";
  template.style.width = "1px";
  template.style.height = "1px";
  template.style.position = "fixed";
  template.style.top = "0px";
  template.style.overflow = "hidden";
  template.dir = "rtl";
  template.innerHTML = `<div style="width: 2px">
            <span style="display: inline-block; width: 1px"></span>
            <span style="display: inline-block; width: 1px"></span>
        </div>`;
  document.body.appendChild(template);
  template.scrollLeft = 1;
  rtlNegativeScroll = Math.floor(template.scrollLeft) === 0;
  document.body.removeChild(template);
  return rtlNegativeScroll;
}
function getScrollLeft(element, rtl) {
  let scrollLeft = element.scrollLeft;
  if (rtl) {
    scrollLeft = Math.abs(scrollLeft);
    if (isBrowserChrome() && !isRtlNegativeScroll()) {
      scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;
    }
  }
  return scrollLeft;
}
function setScrollLeft(element, value, rtl) {
  if (rtl) {
    if (isRtlNegativeScroll()) {
      value *= -1;
    } else if (isBrowserSafari() || isBrowserChrome()) {
      value = element.scrollWidth - element.clientWidth - value;
    }
  }
  element.scrollLeft = value;
}
function clearElement(el) {
  while (el && el.firstChild) {
    el.removeChild(el.firstChild);
  }
}
function removeElement(parent, cssSelector) {
  removeFromParent(parent.querySelector(cssSelector));
}
function removeFromParent(node) {
  if (node && node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function isVisible(element) {
  return element.offsetParent !== null;
}
function loadTemplate(template) {
  const tempDiv = document.createElement("div");
  tempDiv.innerHTML = (template || "").trim();
  return tempDiv.firstChild;
}
function appendHtml(eContainer, htmlTemplate) {
  if (eContainer.lastChild) {
    eContainer.insertAdjacentHTML("afterbegin", htmlTemplate);
  } else {
    eContainer.innerHTML = htmlTemplate;
  }
}
function getElementAttribute(element, attributeName) {
  if (element.attributes && element.attributes[attributeName]) {
    const attribute = element.attributes[attributeName];
    return attribute.value;
  }
  return null;
}
function offsetHeight(element) {
  return element && element.clientHeight ? element.clientHeight : 0;
}
function offsetWidth(element) {
  return element && element.clientWidth ? element.clientWidth : 0;
}
function ensureDomOrder(eContainer, eChild, eChildBefore) {
  if (eChildBefore && eChildBefore.nextSibling === eChild) {
    return;
  }
  const focusedEl = document.activeElement;
  const eChildHasFocus = eChild.contains(focusedEl);
  if (eChildBefore) {
    if (eChildBefore.nextSibling) {
      eContainer.insertBefore(eChild, eChildBefore.nextSibling);
    } else {
      eContainer.appendChild(eChild);
    }
  } else {
    if (eContainer.firstChild && eContainer.firstChild !== eChild) {
      eContainer.insertAdjacentElement("afterbegin", eChild);
    }
  }
  if (eChildHasFocus && focusedEl && browserSupportsPreventScroll()) {
    focusedEl.focus({ preventScroll: true });
  }
}
function setDomChildOrder(eContainer, orderedChildren) {
  for (let i = 0; i < orderedChildren.length; i++) {
    const correctCellAtIndex = orderedChildren[i];
    const actualCellAtIndex = eContainer.children[i];
    if (actualCellAtIndex !== correctCellAtIndex) {
      eContainer.insertBefore(correctCellAtIndex, actualCellAtIndex);
    }
  }
}
function insertWithDomOrder(eContainer, eToInsert, eChildBefore) {
  if (eChildBefore) {
    eChildBefore.insertAdjacentElement("afterend", eToInsert);
  } else {
    if (eContainer.firstChild) {
      eContainer.insertAdjacentElement("afterbegin", eToInsert);
    } else {
      eContainer.appendChild(eToInsert);
    }
  }
}
function prependDC(parent, documentFragment) {
  if (exists(parent.firstChild)) {
    parent.insertBefore(documentFragment, parent.firstChild);
  } else {
    parent.appendChild(documentFragment);
  }
}
function addStylesToElement(eElement, styles) {
  if (!styles) {
    return;
  }
  for (const [key, value] of Object.entries(styles)) {
    if (!key || !key.length || value == null) {
      continue;
    }
    const parsedKey = camelCaseToHyphenated(key);
    const valueAsString = value.toString();
    const parsedValue = valueAsString.replace(/\s*!important/g, "");
    const priority = parsedValue.length != valueAsString.length ? "important" : void 0;
    eElement.style.setProperty(parsedKey, parsedValue, priority);
  }
}
function isHorizontalScrollShowing(element) {
  return element.clientWidth < element.scrollWidth;
}
function isVerticalScrollShowing(element) {
  return element.clientHeight < element.scrollHeight;
}
function setElementWidth(element, width) {
  if (width === "flex") {
    element.style.removeProperty("width");
    element.style.removeProperty("minWidth");
    element.style.removeProperty("maxWidth");
    element.style.flex = "1 1 auto";
  } else {
    setFixedWidth(element, width);
  }
}
function setFixedWidth(element, width) {
  width = formatSize(width);
  element.style.width = width.toString();
  element.style.maxWidth = width.toString();
  element.style.minWidth = width.toString();
}
function setElementHeight(element, height) {
  if (height === "flex") {
    element.style.removeProperty("height");
    element.style.removeProperty("minHeight");
    element.style.removeProperty("maxHeight");
    element.style.flex = "1 1 auto";
  } else {
    setFixedHeight(element, height);
  }
}
function setFixedHeight(element, height) {
  height = formatSize(height);
  element.style.height = height.toString();
  element.style.maxHeight = height.toString();
  element.style.minHeight = height.toString();
}
function formatSize(size) {
  if (typeof size === "number") {
    return `${size}px`;
  }
  return size;
}
function isNodeOrElement(o) {
  return o instanceof Node || o instanceof HTMLElement;
}
function copyNodeList(nodeList) {
  if (nodeList == null) {
    return [];
  }
  const result = [];
  nodeListForEach(nodeList, (node) => result.push(node));
  return result;
}
function iterateNamedNodeMap(map, callback) {
  if (!map) {
    return;
  }
  for (let i = 0; i < map.length; i++) {
    const attr = map[i];
    callback(attr.name, attr.value);
  }
}
function addOrRemoveAttribute(element, name, value) {
  if (value == null) {
    element.removeAttribute(name);
  } else {
    element.setAttribute(name, value.toString());
  }
}
function nodeListForEach(nodeList, action) {
  if (nodeList == null) {
    return;
  }
  for (let i = 0; i < nodeList.length; i++) {
    action(nodeList[i]);
  }
}
var DomUtils = Object.freeze({
  __proto__: null,
  radioCssClass,
  FOCUSABLE_SELECTOR,
  FOCUSABLE_EXCLUDE,
  isFocusableFormField,
  setDisplayed,
  setVisible,
  setDisabled,
  isElementChildOfClass,
  getElementSize,
  getInnerHeight,
  getInnerWidth,
  getAbsoluteHeight,
  getAbsoluteWidth,
  isRtlNegativeScroll,
  getScrollLeft,
  setScrollLeft,
  clearElement,
  removeElement,
  removeFromParent,
  isVisible,
  loadTemplate,
  appendHtml,
  getElementAttribute,
  offsetHeight,
  offsetWidth,
  ensureDomOrder,
  setDomChildOrder,
  insertWithDomOrder,
  prependDC,
  addStylesToElement,
  isHorizontalScrollShowing,
  isVerticalScrollShowing,
  setElementWidth,
  setFixedWidth,
  setElementHeight,
  setFixedHeight,
  formatSize,
  isNodeOrElement,
  copyNodeList,
  iterateNamedNodeMap,
  addOrRemoveAttribute,
  nodeListForEach
});
var iconNameClassMap = {
  columnGroupOpened: "expanded",
  columnGroupClosed: "contracted",
  columnSelectClosed: "tree-closed",
  columnSelectOpen: "tree-open",
  columnSelectIndeterminate: "tree-indeterminate",
  columnMovePin: "pin",
  columnMoveHide: "eye-slash",
  columnMoveMove: "arrows",
  columnMoveLeft: "left",
  columnMoveRight: "right",
  columnMoveGroup: "group",
  columnMoveValue: "aggregation",
  columnMovePivot: "pivot",
  dropNotAllowed: "not-allowed",
  groupContracted: "tree-closed",
  groupExpanded: "tree-open",
  setFilterGroupClosed: "tree-closed",
  setFilterGroupOpen: "tree-open",
  setFilterGroupIndeterminate: "tree-indeterminate",
  chart: "chart",
  close: "cross",
  cancel: "cancel",
  check: "tick",
  first: "first",
  previous: "previous",
  next: "next",
  last: "last",
  linked: "linked",
  unlinked: "unlinked",
  colorPicker: "color-picker",
  groupLoading: "loading",
  menu: "menu",
  filter: "filter",
  columns: "columns",
  maximize: "maximize",
  minimize: "minimize",
  menuPin: "pin",
  menuValue: "aggregation",
  menuAddRowGroup: "group",
  menuRemoveRowGroup: "group",
  clipboardCopy: "copy",
  clipboardCut: "cut",
  clipboardPaste: "paste",
  pivotPanel: "pivot",
  rowGroupPanel: "group",
  valuePanel: "aggregation",
  columnDrag: "grip",
  rowDrag: "grip",
  save: "save",
  csvExport: "csv",
  excelExport: "excel",
  smallDown: "small-down",
  smallLeft: "small-left",
  smallRight: "small-right",
  smallUp: "small-up",
  sortAscending: "asc",
  sortDescending: "desc",
  sortUnSort: "none"
};
function createIcon(iconName, gridOptionsService, column) {
  const iconContents = createIconNoSpan(iconName, gridOptionsService, column);
  if (iconContents) {
    const { className } = iconContents;
    if (typeof className === "string" && className.indexOf("ag-icon") > -1 || typeof className === "object" && className["ag-icon"]) {
      return iconContents;
    }
  }
  const eResult = document.createElement("span");
  eResult.appendChild(iconContents);
  return eResult;
}
function createIconNoSpan(iconName, gridOptionsService, column, forceCreate) {
  let userProvidedIcon = null;
  const icons = column && column.getColDef().icons;
  if (icons) {
    userProvidedIcon = icons[iconName];
  }
  if (gridOptionsService && !userProvidedIcon) {
    const optionsIcons = gridOptionsService.get("icons");
    if (optionsIcons) {
      userProvidedIcon = optionsIcons[iconName];
    }
  }
  if (userProvidedIcon) {
    let rendererResult;
    if (typeof userProvidedIcon === "function") {
      rendererResult = userProvidedIcon();
    } else if (typeof userProvidedIcon === "string") {
      rendererResult = userProvidedIcon;
    } else {
      throw new Error("icon from grid options needs to be a string or a function");
    }
    if (typeof rendererResult === "string") {
      return loadTemplate(rendererResult);
    }
    if (isNodeOrElement(rendererResult)) {
      return rendererResult;
    }
    console.warn("AG Grid: iconRenderer should return back a string or a dom object");
  } else {
    const span = document.createElement("span");
    let cssClass = iconNameClassMap[iconName];
    if (!cssClass) {
      if (!forceCreate) {
        console.warn(`AG Grid: Did not find icon ${iconName}`);
        cssClass = "";
      } else {
        cssClass = iconName;
      }
    }
    span.setAttribute("class", `ag-icon ag-icon-${cssClass}`);
    span.setAttribute("unselectable", "on");
    setAriaRole(span, "presentation");
    return span;
  }
}
var IconUtils = Object.freeze({
  __proto__: null,
  iconNameClassMap,
  createIcon,
  createIconNoSpan
});
var KeyCode = class {
};
KeyCode.BACKSPACE = "Backspace";
KeyCode.TAB = "Tab";
KeyCode.ENTER = "Enter";
KeyCode.ESCAPE = "Escape";
KeyCode.SPACE = " ";
KeyCode.LEFT = "ArrowLeft";
KeyCode.UP = "ArrowUp";
KeyCode.RIGHT = "ArrowRight";
KeyCode.DOWN = "ArrowDown";
KeyCode.DELETE = "Delete";
KeyCode.F2 = "F2";
KeyCode.PAGE_UP = "PageUp";
KeyCode.PAGE_DOWN = "PageDown";
KeyCode.PAGE_HOME = "Home";
KeyCode.PAGE_END = "End";
KeyCode.A = "KeyA";
KeyCode.C = "KeyC";
KeyCode.D = "KeyD";
KeyCode.V = "KeyV";
KeyCode.X = "KeyX";
KeyCode.Y = "KeyY";
KeyCode.Z = "KeyZ";
var A_KEYCODE = 65;
var C_KEYCODE = 67;
var V_KEYCODE = 86;
var D_KEYCODE = 68;
var Z_KEYCODE = 90;
var Y_KEYCODE = 89;
function isEventFromPrintableCharacter(event) {
  if (event.altKey || event.ctrlKey || event.metaKey) {
    return false;
  }
  const printableCharacter = event.key.length === 1;
  return printableCharacter;
}
function isUserSuppressingKeyboardEvent(gridOptionsService, keyboardEvent, rowNode, column, editing) {
  const colDefFunc = column ? column.getColDef().suppressKeyboardEvent : void 0;
  if (!colDefFunc) {
    return false;
  }
  const params = {
    event: keyboardEvent,
    editing,
    column,
    api: gridOptionsService.api,
    node: rowNode,
    data: rowNode.data,
    colDef: column.getColDef(),
    context: gridOptionsService.context,
    columnApi: gridOptionsService.columnApi
  };
  if (colDefFunc) {
    const colDefFuncResult = colDefFunc(params);
    if (colDefFuncResult) {
      return true;
    }
  }
  return false;
}
function isUserSuppressingHeaderKeyboardEvent(gridOptionsService, keyboardEvent, headerRowIndex, column) {
  const colDef = column.getDefinition();
  const colDefFunc = colDef && colDef.suppressHeaderKeyboardEvent;
  if (!exists(colDefFunc)) {
    return false;
  }
  const params = {
    api: gridOptionsService.api,
    columnApi: gridOptionsService.columnApi,
    context: gridOptionsService.context,
    colDef,
    column,
    headerRowIndex,
    event: keyboardEvent
  };
  return !!colDefFunc(params);
}
function normaliseQwertyAzerty(keyboardEvent) {
  const { keyCode } = keyboardEvent;
  let code;
  switch (keyCode) {
    case A_KEYCODE:
      code = KeyCode.A;
      break;
    case C_KEYCODE:
      code = KeyCode.C;
      break;
    case V_KEYCODE:
      code = KeyCode.V;
      break;
    case D_KEYCODE:
      code = KeyCode.D;
      break;
    case Z_KEYCODE:
      code = KeyCode.Z;
      break;
    case Y_KEYCODE:
      code = KeyCode.Y;
      break;
    default:
      code = keyboardEvent.code;
  }
  return code;
}
function isDeleteKey(key, alwaysReturnFalseOnBackspace = false) {
  if (key === KeyCode.DELETE) {
    return true;
  }
  if (!alwaysReturnFalseOnBackspace && key === KeyCode.BACKSPACE) {
    return isMacOsUserAgent();
  }
  return false;
}
var KeyboardUtils = Object.freeze({
  __proto__: null,
  isEventFromPrintableCharacter,
  isUserSuppressingKeyboardEvent,
  isUserSuppressingHeaderKeyboardEvent,
  normaliseQwertyAzerty,
  isDeleteKey
});
function areEventsNear(e1, e2, pixelCount) {
  if (pixelCount === 0) {
    return false;
  }
  const diffX = Math.abs(e1.clientX - e2.clientX);
  const diffY = Math.abs(e1.clientY - e2.clientY);
  return Math.max(diffX, diffY) <= pixelCount;
}
var MouseUtils = Object.freeze({
  __proto__: null,
  areEventsNear
});
function sortRowNodesByOrder(rowNodes, rowNodeOrder) {
  if (!rowNodes) {
    return false;
  }
  const comparator = (nodeA, nodeB) => {
    const positionA = rowNodeOrder[nodeA.id];
    const positionB = rowNodeOrder[nodeB.id];
    const aHasIndex = positionA !== void 0;
    const bHasIndex = positionB !== void 0;
    const bothNodesAreUserNodes = aHasIndex && bHasIndex;
    const bothNodesAreFillerNodes = !aHasIndex && !bHasIndex;
    if (bothNodesAreUserNodes) {
      return positionA - positionB;
    }
    if (bothNodesAreFillerNodes) {
      return nodeA.__objectId - nodeB.__objectId;
    }
    if (aHasIndex) {
      return 1;
    }
    return -1;
  };
  let rowNodeA;
  let rowNodeB;
  let atLeastOneOutOfOrder = false;
  for (let i = 0; i < rowNodes.length - 1; i++) {
    rowNodeA = rowNodes[i];
    rowNodeB = rowNodes[i + 1];
    if (comparator(rowNodeA, rowNodeB) > 0) {
      atLeastOneOutOfOrder = true;
      break;
    }
  }
  if (atLeastOneOutOfOrder) {
    rowNodes.sort(comparator);
    return true;
  }
  return false;
}
function traverseNodesWithKey(nodes, callback) {
  const keyParts = [];
  recursiveSearchNodes(nodes);
  function recursiveSearchNodes(currentNodes) {
    if (!currentNodes) {
      return;
    }
    currentNodes.forEach((node) => {
      if (node.group || node.hasChildren()) {
        keyParts.push(node.key);
        const key = keyParts.join("|");
        callback(node, key);
        recursiveSearchNodes(node.childrenAfterGroup);
        keyParts.pop();
      }
    });
  }
}
var RowNodeUtils = Object.freeze({
  __proto__: null,
  sortRowNodesByOrder,
  traverseNodesWithKey
});
function convertToSet(list) {
  const set2 = /* @__PURE__ */ new Set();
  list.forEach((x) => set2.add(x));
  return set2;
}
var SetUtils = Object.freeze({
  __proto__: null,
  convertToSet
});
var utils = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, AriaUtils), ArrayUtils), BrowserUtils), DateUtils), DomUtils), EventUtils), FunctionUtils), FuzzyMatchUtils), GenericUtils), IconUtils), KeyboardUtils), MapUtils), MouseUtils), NumberUtils), ObjectUtils), RowNodeUtils), SetUtils), StringUtils);
var _ = utils;
var NumberSequence = class {
  constructor(initValue = 0, step = 1) {
    this.nextValue = initValue;
    this.step = step;
  }
  next() {
    const valToReturn = this.nextValue;
    this.nextValue += this.step;
    return valToReturn;
  }
  peek() {
    return this.nextValue;
  }
  skip(count) {
    this.nextValue += count;
  }
};
var AgPromiseStatus;
(function(AgPromiseStatus2) {
  AgPromiseStatus2[AgPromiseStatus2["IN_PROGRESS"] = 0] = "IN_PROGRESS";
  AgPromiseStatus2[AgPromiseStatus2["RESOLVED"] = 1] = "RESOLVED";
})(AgPromiseStatus || (AgPromiseStatus = {}));
var AgPromise = class {
  constructor(callback) {
    this.status = AgPromiseStatus.IN_PROGRESS;
    this.resolution = null;
    this.waiters = [];
    callback((value) => this.onDone(value), (params) => this.onReject(params));
  }
  static all(promises) {
    return new AgPromise((resolve) => {
      let remainingToResolve = promises.length;
      const combinedValues = new Array(remainingToResolve);
      promises.forEach((promise, index) => {
        promise.then((value) => {
          combinedValues[index] = value;
          remainingToResolve--;
          if (remainingToResolve === 0) {
            resolve(combinedValues);
          }
        });
      });
    });
  }
  static resolve(value = null) {
    return new AgPromise((resolve) => resolve(value));
  }
  then(func) {
    return new AgPromise((resolve) => {
      if (this.status === AgPromiseStatus.RESOLVED) {
        resolve(func(this.resolution));
      } else {
        this.waiters.push((value) => resolve(func(value)));
      }
    });
  }
  resolveNow(ifNotResolvedValue, ifResolved) {
    return this.status === AgPromiseStatus.RESOLVED ? ifResolved(this.resolution) : ifNotResolvedValue;
  }
  onDone(value) {
    this.status = AgPromiseStatus.RESOLVED;
    this.resolution = value;
    this.waiters.forEach((waiter) => waiter(value));
  }
  onReject(params) {
    console.warn("TBI");
  }
};
var __decorate$2s = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TooltipStates;
(function(TooltipStates2) {
  TooltipStates2[TooltipStates2["NOTHING"] = 0] = "NOTHING";
  TooltipStates2[TooltipStates2["WAITING_TO_SHOW"] = 1] = "WAITING_TO_SHOW";
  TooltipStates2[TooltipStates2["SHOWING"] = 2] = "SHOWING";
})(TooltipStates || (TooltipStates = {}));
var CustomTooltipFeature = class extends BeanStub {
  constructor(parentComp) {
    super();
    this.DEFAULT_SHOW_TOOLTIP_DELAY = 2e3;
    this.DEFAULT_HIDE_TOOLTIP_DELAY = 1e4;
    this.SHOW_QUICK_TOOLTIP_DIFF = 1e3;
    this.FADE_OUT_TOOLTIP_TIMEOUT = 1e3;
    this.state = TooltipStates.NOTHING;
    this.tooltipInstanceCount = 0;
    this.tooltipMouseTrack = false;
    this.parentComp = parentComp;
  }
  postConstruct() {
    this.tooltipShowDelay = this.getTooltipDelay("show") || this.DEFAULT_SHOW_TOOLTIP_DELAY;
    this.tooltipHideDelay = this.getTooltipDelay("hide") || this.DEFAULT_HIDE_TOOLTIP_DELAY;
    this.tooltipMouseTrack = this.gridOptionsService.is("tooltipMouseTrack");
    const el = this.parentComp.getGui();
    this.addManagedListener(el, "mouseenter", this.onMouseEnter.bind(this));
    this.addManagedListener(el, "mouseleave", this.onMouseLeave.bind(this));
    this.addManagedListener(el, "mousemove", this.onMouseMove.bind(this));
    this.addManagedListener(el, "mousedown", this.onMouseDown.bind(this));
    this.addManagedListener(el, "keydown", this.onKeyDown.bind(this));
  }
  destroy() {
    this.setToDoNothing();
    super.destroy();
  }
  onMouseEnter(e) {
    if (isIOSUserAgent()) {
      return;
    }
    if (this.state != TooltipStates.NOTHING) {
      return;
    }
    const delay = this.isLastTooltipHiddenRecently() ? 200 : this.tooltipShowDelay;
    this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), delay);
    this.lastMouseEvent = e;
    this.state = TooltipStates.WAITING_TO_SHOW;
  }
  onMouseLeave() {
    this.setToDoNothing();
  }
  onKeyDown() {
    this.setToDoNothing();
  }
  setToDoNothing() {
    if (this.state === TooltipStates.SHOWING) {
      this.hideTooltip();
    }
    this.clearTimeouts();
    this.state = TooltipStates.NOTHING;
  }
  onMouseMove(e) {
    this.lastMouseEvent = e;
    if (this.tooltipMouseTrack && this.state === TooltipStates.SHOWING && this.tooltipComp) {
      this.positionTooltipUnderLastMouseEvent();
    }
  }
  onMouseDown() {
    this.setToDoNothing();
  }
  getTooltipDelay(type) {
    const tooltipShowDelay = this.gridOptionsService.getNum("tooltipShowDelay");
    const tooltipHideDelay = this.gridOptionsService.getNum("tooltipHideDelay");
    const delay = type === "show" ? tooltipShowDelay : tooltipHideDelay;
    const capitalisedType = capitalise(type);
    if (exists(delay)) {
      if (delay < 0) {
        doOnce(() => console.warn(`AG Grid: tooltip${capitalisedType}Delay should not be lower than 0`), `tooltip${capitalisedType}DelayWarn`);
      }
      return Math.max(200, delay);
    }
    return null;
  }
  hideTooltip() {
    if (this.tooltipComp) {
      this.destroyTooltipComp();
      CustomTooltipFeature.lastTooltipHideTime = new Date().getTime();
    }
    this.state = TooltipStates.NOTHING;
  }
  destroyTooltipComp() {
    this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
    const tooltipPopupDestroyFunc = this.tooltipPopupDestroyFunc;
    const tooltipComp = this.tooltipComp;
    window.setTimeout(() => {
      tooltipPopupDestroyFunc();
      this.getContext().destroyBean(tooltipComp);
    }, this.FADE_OUT_TOOLTIP_TIMEOUT);
    this.tooltipPopupDestroyFunc = void 0;
    this.tooltipComp = void 0;
  }
  isLastTooltipHiddenRecently() {
    const now = new Date().getTime();
    const then = CustomTooltipFeature.lastTooltipHideTime;
    return now - then < this.SHOW_QUICK_TOOLTIP_DIFF;
  }
  showTooltip() {
    const params = Object.assign({}, this.parentComp.getTooltipParams());
    if (!exists(params.value)) {
      this.setToDoNothing();
      return;
    }
    this.state = TooltipStates.SHOWING;
    this.tooltipInstanceCount++;
    const callback = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount);
    const userDetails = this.userComponentFactory.getTooltipCompDetails(params);
    userDetails.newAgStackInstance().then(callback);
  }
  newTooltipComponentCallback(tooltipInstanceCopy, tooltipComp) {
    const compNoLongerNeeded = this.state !== TooltipStates.SHOWING || this.tooltipInstanceCount !== tooltipInstanceCopy;
    if (compNoLongerNeeded) {
      this.getContext().destroyBean(tooltipComp);
      return;
    }
    const eGui = tooltipComp.getGui();
    this.tooltipComp = tooltipComp;
    if (!eGui.classList.contains("ag-tooltip")) {
      eGui.classList.add("ag-tooltip-custom");
    }
    const translate = this.localeService.getLocaleTextFunc();
    const addPopupRes = this.popupService.addPopup({
      eChild: eGui,
      ariaLabel: translate("ariaLabelTooltip", "Tooltip")
    });
    if (addPopupRes) {
      this.tooltipPopupDestroyFunc = addPopupRes.hideFunc;
    }
    this.positionTooltipUnderLastMouseEvent();
    this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.tooltipHideDelay);
  }
  positionTooltipUnderLastMouseEvent() {
    this.popupService.positionPopupUnderMouseEvent({
      type: "tooltip",
      mouseEvent: this.lastMouseEvent,
      ePopup: this.tooltipComp.getGui(),
      nudgeY: 18,
      skipObserver: this.tooltipMouseTrack
    });
  }
  clearTimeouts() {
    if (this.showTooltipTimeoutId) {
      window.clearTimeout(this.showTooltipTimeoutId);
      this.showTooltipTimeoutId = void 0;
    }
    if (this.hideTooltipTimeoutId) {
      window.clearTimeout(this.hideTooltipTimeoutId);
      this.hideTooltipTimeoutId = void 0;
    }
  }
};
__decorate$2s([
  Autowired("popupService")
], CustomTooltipFeature.prototype, "popupService", void 0);
__decorate$2s([
  Autowired("userComponentFactory")
], CustomTooltipFeature.prototype, "userComponentFactory", void 0);
__decorate$2s([
  PostConstruct
], CustomTooltipFeature.prototype, "postConstruct", null);
var CssClassManager = class {
  constructor(getGui) {
    this.cssClassStates = {};
    this.getGui = getGui;
  }
  addCssClass(className) {
    const list = (className || "").split(" ");
    if (list.length > 1) {
      list.forEach((cls) => this.addCssClass(cls));
      return;
    }
    const updateNeeded = this.cssClassStates[className] !== true;
    if (updateNeeded && className.length) {
      const eGui = this.getGui();
      if (eGui) {
        eGui.classList.add(className);
      }
      this.cssClassStates[className] = true;
    }
  }
  removeCssClass(className) {
    const list = (className || "").split(" ");
    if (list.length > 1) {
      list.forEach((cls) => this.removeCssClass(cls));
      return;
    }
    const updateNeeded = this.cssClassStates[className] !== false;
    if (updateNeeded && className.length) {
      const eGui = this.getGui();
      if (eGui) {
        eGui.classList.remove(className);
      }
      this.cssClassStates[className] = false;
    }
  }
  containsCssClass(className) {
    const eGui = this.getGui();
    if (!eGui) {
      return false;
    }
    return eGui.classList.contains(className);
  }
  addOrRemoveCssClass(className, addOrRemove) {
    if (!className) {
      return;
    }
    if (className.indexOf(" ") >= 0) {
      const list = (className || "").split(" ");
      if (list.length > 1) {
        list.forEach((cls) => this.addOrRemoveCssClass(cls, addOrRemove));
        return;
      }
    }
    const updateNeeded = this.cssClassStates[className] !== addOrRemove;
    if (updateNeeded && className.length) {
      const eGui = this.getGui();
      if (eGui) {
        eGui.classList.toggle(className, addOrRemove);
      }
      this.cssClassStates[className] = addOrRemove;
    }
  }
};
var __decorate$2r = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var compIdSequence = new NumberSequence();
var Component = class extends BeanStub {
  constructor(template) {
    super();
    this.displayed = true;
    this.visible = true;
    this.compId = compIdSequence.next();
    this.cssClassManager = new CssClassManager(() => this.eGui);
    if (template) {
      this.setTemplate(template);
    }
  }
  preConstructOnComponent() {
    this.usingBrowserTooltips = this.gridOptionsService.is("enableBrowserTooltips");
  }
  getCompId() {
    return this.compId;
  }
  getTooltipParams() {
    return {
      value: this.tooltipText,
      location: "UNKNOWN"
    };
  }
  setTooltip(newTooltipText) {
    const removeTooltip = () => {
      if (this.usingBrowserTooltips) {
        this.getGui().removeAttribute("title");
      } else {
        this.tooltipFeature = this.destroyBean(this.tooltipFeature);
      }
    };
    const addTooltip = () => {
      if (this.usingBrowserTooltips) {
        this.getGui().setAttribute("title", this.tooltipText);
      } else {
        this.tooltipFeature = this.createBean(new CustomTooltipFeature(this));
      }
    };
    if (this.tooltipText != newTooltipText) {
      if (this.tooltipText) {
        removeTooltip();
      }
      if (newTooltipText != null) {
        this.tooltipText = newTooltipText;
        if (this.tooltipText) {
          addTooltip();
        }
      }
    }
  }
  createChildComponentsFromTags(parentNode, paramsMap) {
    const childNodeList = copyNodeList(parentNode.childNodes);
    childNodeList.forEach((childNode) => {
      if (!(childNode instanceof HTMLElement)) {
        return;
      }
      const childComp = this.createComponentFromElement(childNode, (childComp2) => {
        const childGui = childComp2.getGui();
        if (childGui) {
          this.copyAttributesFromNode(childNode, childComp2.getGui());
        }
      }, paramsMap);
      if (childComp) {
        if (childComp.addItems && childNode.children.length) {
          this.createChildComponentsFromTags(childNode, paramsMap);
          const items = Array.prototype.slice.call(childNode.children);
          childComp.addItems(items);
        }
        this.swapComponentForNode(childComp, parentNode, childNode);
      } else if (childNode.childNodes) {
        this.createChildComponentsFromTags(childNode, paramsMap);
      }
    });
  }
  createComponentFromElement(element, afterPreCreateCallback, paramsMap) {
    const key = element.nodeName;
    const componentParams = paramsMap ? paramsMap[element.getAttribute("ref")] : void 0;
    const ComponentClass = this.agStackComponentsRegistry.getComponentClass(key);
    if (ComponentClass) {
      Component.elementGettingCreated = element;
      const newComponent = new ComponentClass(componentParams);
      newComponent.setParentComponent(this);
      this.createBean(newComponent, null, afterPreCreateCallback);
      return newComponent;
    }
    return null;
  }
  copyAttributesFromNode(source, dest) {
    iterateNamedNodeMap(source.attributes, (name, value) => dest.setAttribute(name, value));
  }
  swapComponentForNode(newComponent, parentNode, childNode) {
    const eComponent = newComponent.getGui();
    parentNode.replaceChild(eComponent, childNode);
    parentNode.insertBefore(document.createComment(childNode.nodeName), eComponent);
    this.addDestroyFunc(this.destroyBean.bind(this, newComponent));
    this.swapInComponentForQuerySelectors(newComponent, childNode);
  }
  swapInComponentForQuerySelectors(newComponent, childNode) {
    const thisNoType = this;
    this.iterateOverQuerySelectors((querySelector) => {
      if (thisNoType[querySelector.attributeName] === childNode) {
        thisNoType[querySelector.attributeName] = newComponent;
      }
    });
  }
  iterateOverQuerySelectors(action) {
    let thisPrototype = Object.getPrototypeOf(this);
    while (thisPrototype != null) {
      const metaData = thisPrototype.__agComponentMetaData;
      const currentProtoName = getFunctionName(thisPrototype.constructor);
      if (metaData && metaData[currentProtoName] && metaData[currentProtoName].querySelectors) {
        metaData[currentProtoName].querySelectors.forEach((querySelector) => action(querySelector));
      }
      thisPrototype = Object.getPrototypeOf(thisPrototype);
    }
  }
  setTemplate(template, paramsMap) {
    const eGui = loadTemplate(template);
    this.setTemplateFromElement(eGui, paramsMap);
  }
  setTemplateFromElement(element, paramsMap) {
    this.eGui = element;
    this.eGui.__agComponent = this;
    this.wireQuerySelectors();
    if (!!this.getContext()) {
      this.createChildComponentsFromTags(this.getGui(), paramsMap);
    }
  }
  createChildComponentsPreConstruct() {
    if (!!this.getGui()) {
      this.createChildComponentsFromTags(this.getGui());
    }
  }
  wireQuerySelectors() {
    if (!this.eGui) {
      return;
    }
    const thisNoType = this;
    this.iterateOverQuerySelectors((querySelector) => {
      const setResult = (result) => thisNoType[querySelector.attributeName] = result;
      const topLevelRefMatch = querySelector.refSelector && this.eGui.getAttribute("ref") === querySelector.refSelector;
      if (topLevelRefMatch) {
        setResult(this.eGui);
      } else {
        const resultOfQuery = this.eGui.querySelector(querySelector.querySelector);
        if (resultOfQuery) {
          setResult(resultOfQuery.__agComponent || resultOfQuery);
        }
      }
    });
  }
  getGui() {
    return this.eGui;
  }
  getFocusableElement() {
    return this.eGui;
  }
  setParentComponent(component) {
    this.parentComponent = component;
  }
  getParentComponent() {
    return this.parentComponent;
  }
  setGui(eGui) {
    this.eGui = eGui;
  }
  queryForHtmlElement(cssSelector) {
    return this.eGui.querySelector(cssSelector);
  }
  queryForHtmlInputElement(cssSelector) {
    return this.eGui.querySelector(cssSelector);
  }
  appendChild(newChild, container) {
    if (newChild == null) {
      return;
    }
    if (!container) {
      container = this.eGui;
    }
    if (isNodeOrElement(newChild)) {
      container.appendChild(newChild);
    } else {
      const childComponent = newChild;
      container.appendChild(childComponent.getGui());
    }
  }
  isDisplayed() {
    return this.displayed;
  }
  setVisible(visible, options = {}) {
    if (visible !== this.visible) {
      this.visible = visible;
      const { skipAriaHidden } = options;
      setVisible(this.eGui, visible, { skipAriaHidden });
    }
  }
  setDisplayed(displayed, options = {}) {
    if (displayed !== this.displayed) {
      this.displayed = displayed;
      const { skipAriaHidden } = options;
      setDisplayed(this.eGui, displayed, { skipAriaHidden });
      const event = {
        type: Component.EVENT_DISPLAYED_CHANGED,
        visible: this.displayed
      };
      this.dispatchEvent(event);
    }
  }
  destroy() {
    if (this.tooltipFeature) {
      this.tooltipFeature = this.destroyBean(this.tooltipFeature);
    }
    if (this.parentComponent) {
      this.parentComponent = void 0;
    }
    const eGui = this.eGui;
    if (eGui && eGui.__agComponent) {
      eGui.__agComponent = void 0;
    }
    super.destroy();
  }
  addGuiEventListener(event, listener, options) {
    this.eGui.addEventListener(event, listener, options);
    this.addDestroyFunc(() => this.eGui.removeEventListener(event, listener));
  }
  addCssClass(className) {
    this.cssClassManager.addCssClass(className);
  }
  removeCssClass(className) {
    this.cssClassManager.removeCssClass(className);
  }
  containsCssClass(className) {
    return this.cssClassManager.containsCssClass(className);
  }
  addOrRemoveCssClass(className, addOrRemove) {
    this.cssClassManager.addOrRemoveCssClass(className, addOrRemove);
  }
  getAttribute(key) {
    const { eGui } = this;
    return eGui ? eGui.getAttribute(key) : null;
  }
  getRefElement(refName) {
    return this.queryForHtmlElement(`[ref="${refName}"]`);
  }
};
Component.EVENT_DISPLAYED_CHANGED = "displayedChanged";
__decorate$2r([
  Autowired("agStackComponentsRegistry")
], Component.prototype, "agStackComponentsRegistry", void 0);
__decorate$2r([
  PreConstruct
], Component.prototype, "preConstructOnComponent", null);
__decorate$2r([
  PreConstruct
], Component.prototype, "createChildComponentsPreConstruct", null);
function RefSelector(ref) {
  return querySelectorFunc.bind(this, `[ref=${ref}]`, ref);
}
function querySelectorFunc(selector, refSelector, classPrototype, methodOrAttributeName, index) {
  if (selector === null) {
    console.error("AG Grid: QuerySelector selector should not be null");
    return;
  }
  if (typeof index === "number") {
    console.error("AG Grid: QuerySelector should be on an attribute");
    return;
  }
  addToObjectProps(classPrototype, "querySelectors", {
    attributeName: methodOrAttributeName,
    querySelector: selector,
    refSelector
  });
}
function addToObjectProps(target, key, value) {
  const props2 = getOrCreateProps(target, getFunctionName(target.constructor));
  if (!props2[key]) {
    props2[key] = [];
  }
  props2[key].push(value);
}
function getOrCreateProps(target, instanceName) {
  if (!target.__agComponentMetaData) {
    target.__agComponentMetaData = {};
  }
  if (!target.__agComponentMetaData[instanceName]) {
    target.__agComponentMetaData[instanceName] = {};
  }
  return target.__agComponentMetaData[instanceName];
}
var __decorate$2q = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ReadOnlyFloatingFilter = class extends Component {
  constructor() {
    super(`
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eFloatingFilterText"></ag-input-text-field>
            </div>`);
  }
  destroy() {
    super.destroy();
  }
  init(params) {
    this.params = params;
    const displayName = this.columnModel.getDisplayNameForColumn(params.column, "header", true);
    const translate = this.localeService.getLocaleTextFunc();
    this.eFloatingFilterText.setDisabled(true).setInputAriaLabel(`${displayName} ${translate("ariaFilterInput", "Filter Input")}`);
  }
  onParentModelChanged(parentModel) {
    if (!parentModel) {
      this.eFloatingFilterText.setValue("");
      return;
    }
    this.params.parentFilterInstance((filterInstance) => {
      if (filterInstance.getModelAsString) {
        const modelAsString = filterInstance.getModelAsString(parentModel);
        this.eFloatingFilterText.setValue(modelAsString);
      }
    });
  }
};
__decorate$2q([
  RefSelector("eFloatingFilterText")
], ReadOnlyFloatingFilter.prototype, "eFloatingFilterText", void 0);
__decorate$2q([
  Autowired("columnModel")
], ReadOnlyFloatingFilter.prototype, "columnModel", void 0);
var DateCompWrapper = class {
  constructor(context, userComponentFactory, dateComponentParams, eParent) {
    this.alive = true;
    this.context = context;
    this.eParent = eParent;
    const compDetails = userComponentFactory.getDateCompDetails(dateComponentParams);
    const promise = compDetails.newAgStackInstance();
    promise.then((dateComp) => {
      if (!this.alive) {
        context.destroyBean(dateComp);
        return;
      }
      this.dateComp = dateComp;
      if (!dateComp) {
        return;
      }
      eParent.appendChild(dateComp.getGui());
      if (dateComp.afterGuiAttached) {
        dateComp.afterGuiAttached();
      }
      if (this.tempValue) {
        dateComp.setDate(this.tempValue);
      }
      if (this.disabled != null) {
        this.setDateCompDisabled(this.disabled);
      }
    });
  }
  destroy() {
    this.alive = false;
    this.dateComp = this.context.destroyBean(this.dateComp);
  }
  getDate() {
    return this.dateComp ? this.dateComp.getDate() : this.tempValue;
  }
  setDate(value) {
    if (this.dateComp) {
      this.dateComp.setDate(value);
    } else {
      this.tempValue = value;
    }
  }
  setDisabled(disabled) {
    if (this.dateComp) {
      this.setDateCompDisabled(disabled);
    } else {
      this.disabled = disabled;
    }
  }
  setDisplayed(displayed) {
    setDisplayed(this.eParent, displayed);
  }
  setInputPlaceholder(placeholder) {
    if (this.dateComp && this.dateComp.setInputPlaceholder) {
      this.dateComp.setInputPlaceholder(placeholder);
    }
  }
  setInputAriaLabel(label) {
    if (this.dateComp && this.dateComp.setInputAriaLabel) {
      this.dateComp.setInputAriaLabel(label);
    }
  }
  afterGuiAttached(params) {
    if (this.dateComp && typeof this.dateComp.afterGuiAttached === "function") {
      this.dateComp.afterGuiAttached(params);
    }
  }
  setDateCompDisabled(disabled) {
    if (this.dateComp == null) {
      return;
    }
    if (this.dateComp.setDisabled == null) {
      return;
    }
    this.dateComp.setDisabled(disabled);
  }
};
var OptionsFactory = class {
  constructor() {
    this.customFilterOptions = {};
  }
  init(params, defaultOptions) {
    this.filterOptions = params.filterOptions || defaultOptions;
    this.mapCustomOptions();
    this.selectDefaultItem(params);
  }
  getFilterOptions() {
    return this.filterOptions;
  }
  mapCustomOptions() {
    if (!this.filterOptions) {
      return;
    }
    this.filterOptions.forEach((filterOption) => {
      if (typeof filterOption === "string") {
        return;
      }
      const requiredProperties = [["displayKey"], ["displayName"], ["predicate", "test"]];
      const propertyCheck = (keys2) => {
        if (!keys2.some((key) => filterOption[key] != null)) {
          console.warn(`AG Grid: ignoring FilterOptionDef as it doesn't contain one of '${keys2}'`);
          return false;
        }
        return true;
      };
      if (!requiredProperties.every(propertyCheck)) {
        this.filterOptions = this.filterOptions.filter((v) => v === filterOption) || [];
        return;
      }
      this.customFilterOptions[filterOption.displayKey] = filterOption;
    });
  }
  selectDefaultItem(params) {
    if (params.defaultOption) {
      this.defaultOption = params.defaultOption;
    } else if (this.filterOptions.length >= 1) {
      const firstFilterOption = this.filterOptions[0];
      if (typeof firstFilterOption === "string") {
        this.defaultOption = firstFilterOption;
      } else if (firstFilterOption.displayKey) {
        this.defaultOption = firstFilterOption.displayKey;
      } else {
        console.warn(`AG Grid: invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'`);
      }
    } else {
      console.warn("AG Grid: no filter options for filter");
    }
  }
  getDefaultOption() {
    return this.defaultOption;
  }
  getCustomOption(name) {
    return this.customFilterOptions[name];
  }
};
var DEFAULT_FILTER_LOCALE_TEXT = {
  applyFilter: "Apply",
  clearFilter: "Clear",
  resetFilter: "Reset",
  cancelFilter: "Cancel",
  textFilter: "Text Filter",
  numberFilter: "Number Filter",
  dateFilter: "Date Filter",
  setFilter: "Set Filter",
  filterOoo: "Filter...",
  empty: "Choose One",
  equals: "Equals",
  notEqual: "Not equal",
  lessThan: "Less than",
  greaterThan: "Greater than",
  inRange: "In range",
  inRangeStart: "From",
  inRangeEnd: "To",
  lessThanOrEqual: "Less than or equals",
  greaterThanOrEqual: "Greater than or equals",
  contains: "Contains",
  notContains: "Not contains",
  startsWith: "Starts with",
  endsWith: "Ends with",
  blank: "Blank",
  notBlank: "Not blank",
  andCondition: "AND",
  orCondition: "OR",
  dateFormatOoo: "yyyy-mm-dd"
};
var __decorate$2p = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ManagedFocusFeature = class extends BeanStub {
  constructor(eFocusableElement, callbacks = {}) {
    super();
    this.eFocusableElement = eFocusableElement;
    this.callbacks = callbacks;
    this.callbacks = Object.assign({ shouldStopEventPropagation: () => false, onTabKeyDown: (e) => {
      if (e.defaultPrevented) {
        return;
      }
      const nextRoot = this.focusService.findNextFocusableElement(this.eFocusableElement, false, e.shiftKey);
      if (!nextRoot) {
        return;
      }
      nextRoot.focus();
      e.preventDefault();
    } }, callbacks);
  }
  postConstruct() {
    this.eFocusableElement.classList.add(ManagedFocusFeature.FOCUS_MANAGED_CLASS);
    this.addKeyDownListeners(this.eFocusableElement);
    if (this.callbacks.onFocusIn) {
      this.addManagedListener(this.eFocusableElement, "focusin", this.callbacks.onFocusIn);
    }
    if (this.callbacks.onFocusOut) {
      this.addManagedListener(this.eFocusableElement, "focusout", this.callbacks.onFocusOut);
    }
  }
  addKeyDownListeners(eGui) {
    this.addManagedListener(eGui, "keydown", (e) => {
      if (e.defaultPrevented || isStopPropagationForAgGrid(e)) {
        return;
      }
      if (this.callbacks.shouldStopEventPropagation(e)) {
        stopPropagationForAgGrid(e);
        return;
      }
      if (e.key === KeyCode.TAB) {
        this.callbacks.onTabKeyDown(e);
      } else if (this.callbacks.handleKeyDown) {
        this.callbacks.handleKeyDown(e);
      }
    });
  }
};
ManagedFocusFeature.FOCUS_MANAGED_CLASS = "ag-focus-managed";
__decorate$2p([
  Autowired("focusService")
], ManagedFocusFeature.prototype, "focusService", void 0);
__decorate$2p([
  PostConstruct
], ManagedFocusFeature.prototype, "postConstruct", null);
var __decorate$2o = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RESIZE_CONTAINER_STYLE = "ag-resizer-wrapper";
var RESIZE_TEMPLATE = `<div class="${RESIZE_CONTAINER_STYLE}">
        <div ref="eTopLeftResizer" class="ag-resizer ag-resizer-topLeft"></div>
        <div ref="eTopResizer" class="ag-resizer ag-resizer-top"></div>
        <div ref="eTopRightResizer" class="ag-resizer ag-resizer-topRight"></div>
        <div ref="eRightResizer" class="ag-resizer ag-resizer-right"></div>
        <div ref="eBottomRightResizer" class="ag-resizer ag-resizer-bottomRight"></div>
        <div ref="eBottomResizer" class="ag-resizer ag-resizer-bottom"></div>
        <div ref="eBottomLeftResizer" class="ag-resizer ag-resizer-bottomLeft"></div>
        <div ref="eLeftResizer" class="ag-resizer ag-resizer-left"></div>
    </div>`;
var PositionableFeature = class extends BeanStub {
  constructor(element, config) {
    super();
    this.element = element;
    this.dragStartPosition = {
      x: 0,
      y: 0
    };
    this.position = {
      x: 0,
      y: 0
    };
    this.lastSize = {
      width: -1,
      height: -1
    };
    this.positioned = false;
    this.resizersAdded = false;
    this.resizeListeners = [];
    this.boundaryEl = null;
    this.isResizing = false;
    this.isMoving = false;
    this.resizable = {};
    this.movable = false;
    this.currentResizer = null;
    this.config = Object.assign({}, { popup: false }, config);
  }
  center() {
    const { clientHeight, clientWidth } = this.offsetParent;
    const x = clientWidth / 2 - this.getWidth() / 2;
    const y = clientHeight / 2 - this.getHeight() / 2;
    this.offsetElement(x, y);
  }
  initialisePosition() {
    if (this.positioned) {
      return;
    }
    const { centered, forcePopupParentAsOffsetParent, minWidth, width, minHeight, height, x, y } = this.config;
    if (!this.offsetParent) {
      this.setOffsetParent();
    }
    let computedMinHeight = 0;
    let computedMinWidth = 0;
    const isVisible2 = !!this.element.offsetParent;
    if (isVisible2) {
      const boundaryEl = this.findBoundaryElement();
      const offsetParentComputedStyles = window.getComputedStyle(boundaryEl);
      if (offsetParentComputedStyles.minWidth != null) {
        const paddingWidth = boundaryEl.offsetWidth - this.element.offsetWidth;
        computedMinWidth = parseInt(offsetParentComputedStyles.minWidth, 10) - paddingWidth;
      }
      if (offsetParentComputedStyles.minHeight != null) {
        const paddingHeight = boundaryEl.offsetHeight - this.element.offsetHeight;
        computedMinHeight = parseInt(offsetParentComputedStyles.minHeight, 10) - paddingHeight;
      }
    }
    this.minHeight = minHeight || computedMinHeight;
    this.minWidth = minWidth || computedMinWidth;
    if (width) {
      this.setWidth(width);
    }
    if (height) {
      this.setHeight(height);
    }
    if (!width || !height) {
      this.refreshSize();
    }
    if (centered) {
      this.center();
    } else if (x || y) {
      this.offsetElement(x, y);
    } else if (isVisible2 && forcePopupParentAsOffsetParent && this.boundaryEl) {
      const top = parseFloat(this.boundaryEl.style.top);
      const left = parseFloat(this.boundaryEl.style.left);
      this.offsetElement(isNaN(left) ? 0 : left, isNaN(top) ? 0 : top);
    }
    this.positioned = !!this.offsetParent;
  }
  isPositioned() {
    return this.positioned;
  }
  getPosition() {
    return this.position;
  }
  setMovable(movable, moveElement) {
    if (!this.config.popup || movable === this.movable) {
      return;
    }
    this.movable = movable;
    const params = this.moveElementDragListener || {
      eElement: moveElement,
      onDragStart: this.onMoveStart.bind(this),
      onDragging: this.onMove.bind(this),
      onDragStop: this.onMoveEnd.bind(this)
    };
    if (movable) {
      this.dragService.addDragSource(params);
      this.moveElementDragListener = params;
    } else {
      this.dragService.removeDragSource(params);
      this.moveElementDragListener = void 0;
    }
  }
  setResizable(resizable) {
    this.clearResizeListeners();
    if (resizable) {
      this.addResizers();
    } else {
      this.removeResizers();
    }
    if (typeof resizable === "boolean") {
      if (resizable === false) {
        return;
      }
      resizable = {
        topLeft: resizable,
        top: resizable,
        topRight: resizable,
        right: resizable,
        bottomRight: resizable,
        bottom: resizable,
        bottomLeft: resizable,
        left: resizable
      };
    }
    Object.keys(resizable).forEach((side) => {
      const resizableStructure = resizable;
      const isSideResizable = !!resizableStructure[side];
      const resizerEl = this.getResizerElement(side);
      const params = {
        dragStartPixels: 0,
        eElement: resizerEl,
        onDragStart: (e) => this.onResizeStart(e, side),
        onDragging: this.onResize.bind(this),
        onDragStop: (e) => this.onResizeEnd(e, side)
      };
      if (isSideResizable || !this.isAlive() && !isSideResizable) {
        if (isSideResizable) {
          this.dragService.addDragSource(params);
          this.resizeListeners.push(params);
          resizerEl.style.pointerEvents = "all";
        } else {
          resizerEl.style.pointerEvents = "none";
        }
        this.resizable[side] = isSideResizable;
      }
    });
  }
  removeSizeFromEl() {
    this.element.style.removeProperty("height");
    this.element.style.removeProperty("width");
    this.element.style.removeProperty("flex");
  }
  restoreLastSize() {
    this.element.style.flex = "0 0 auto";
    const { height, width } = this.lastSize;
    if (width !== -1) {
      this.element.style.width = `${width}px`;
    }
    if (height !== -1) {
      this.element.style.height = `${height}px`;
    }
  }
  getHeight() {
    return this.element.offsetHeight;
  }
  setHeight(height) {
    const { popup } = this.config;
    const eGui = this.element;
    let isPercent = false;
    if (typeof height === "string" && height.indexOf("%") !== -1) {
      setFixedHeight(eGui, height);
      height = getAbsoluteHeight(eGui);
      isPercent = true;
    } else {
      height = Math.max(this.minHeight, height);
      if (this.positioned) {
        const availableHeight = this.getAvailableHeight();
        if (availableHeight && height > availableHeight) {
          height = availableHeight;
        }
      }
    }
    if (this.getHeight() === height) {
      return;
    }
    if (!isPercent) {
      if (popup) {
        setFixedHeight(eGui, height);
      } else {
        eGui.style.height = `${height}px`;
        eGui.style.flex = "0 0 auto";
        this.lastSize.height = typeof height === "number" ? height : parseFloat(height);
      }
    } else {
      eGui.style.maxHeight = "unset";
      eGui.style.minHeight = "unset";
    }
  }
  getAvailableHeight() {
    const { popup, forcePopupParentAsOffsetParent } = this.config;
    if (!this.positioned) {
      this.initialisePosition();
    }
    const { clientHeight } = this.offsetParent;
    if (!clientHeight) {
      return null;
    }
    const elRect = this.element.getBoundingClientRect();
    const offsetParentRect = this.offsetParent.getBoundingClientRect();
    const yPosition = popup ? this.position.y : elRect.top;
    const parentTop = popup ? 0 : offsetParentRect.top;
    let additionalHeight = 0;
    if (forcePopupParentAsOffsetParent) {
      const parentEl = this.element.parentElement;
      if (parentEl) {
        const { bottom } = parentEl.getBoundingClientRect();
        additionalHeight = bottom - elRect.bottom;
      }
    }
    const availableHeight = clientHeight + parentTop - yPosition - additionalHeight;
    return availableHeight;
  }
  getWidth() {
    return this.element.offsetWidth;
  }
  setWidth(width) {
    const eGui = this.element;
    const { popup } = this.config;
    let isPercent = false;
    if (typeof width === "string" && width.indexOf("%") !== -1) {
      setFixedWidth(eGui, width);
      width = getAbsoluteWidth(eGui);
      isPercent = true;
    } else if (this.positioned) {
      width = Math.max(this.minWidth, width);
      const { clientWidth } = this.offsetParent;
      const xPosition = popup ? this.position.x : this.element.getBoundingClientRect().left;
      if (clientWidth && width + xPosition > clientWidth) {
        width = clientWidth - xPosition;
      }
    }
    if (this.getWidth() === width) {
      return;
    }
    if (!isPercent) {
      if (this.config.popup) {
        setFixedWidth(eGui, width);
      } else {
        eGui.style.width = `${width}px`;
        eGui.style.flex = " unset";
        this.lastSize.width = typeof width === "number" ? width : parseFloat(width);
      }
    } else {
      eGui.style.maxWidth = "unset";
      eGui.style.minWidth = "unset";
    }
  }
  offsetElement(x = 0, y = 0) {
    const ePopup = this.config.forcePopupParentAsOffsetParent ? this.boundaryEl : this.element;
    this.popupService.positionPopup({
      ePopup,
      keepWithinBounds: true,
      skipObserver: this.movable || this.isResizable(),
      updatePosition: () => ({ x, y })
    });
    this.setPosition(parseFloat(ePopup.style.left), parseFloat(ePopup.style.top));
  }
  constrainSizeToAvailableHeight(constrain) {
    if (!this.config.forcePopupParentAsOffsetParent) {
      return;
    }
    const applyMaxHeightToElement = () => {
      const availableHeight = this.getAvailableHeight();
      this.element.style.setProperty("max-height", `${availableHeight}px`);
    };
    if (constrain) {
      this.resizeObserverSubscriber = this.resizeObserverService.observeResize(this.popupService.getPopupParent(), applyMaxHeightToElement);
    } else {
      this.element.style.removeProperty("max-height");
      if (this.resizeObserverSubscriber) {
        this.resizeObserverSubscriber();
        this.resizeObserverSubscriber = void 0;
      }
    }
  }
  setPosition(x, y) {
    this.position.x = x;
    this.position.y = y;
  }
  updateDragStartPosition(x, y) {
    this.dragStartPosition = { x, y };
  }
  calculateMouseMovement(params) {
    const { e, isLeft, isTop, anywhereWithin, topBuffer } = params;
    const xDiff = e.clientX - this.dragStartPosition.x;
    const yDiff = e.clientY - this.dragStartPosition.y;
    const movementX = this.shouldSkipX(e, !!isLeft, !!anywhereWithin, xDiff) ? 0 : xDiff;
    const movementY = this.shouldSkipY(e, !!isTop, topBuffer, yDiff) ? 0 : yDiff;
    return { movementX, movementY };
  }
  shouldSkipX(e, isLeft, anywhereWithin, diff) {
    const elRect = this.element.getBoundingClientRect();
    const parentRect = this.offsetParent.getBoundingClientRect();
    const boundaryElRect = this.boundaryEl.getBoundingClientRect();
    const xPosition = this.config.popup ? this.position.x : elRect.left;
    let skipX = xPosition <= 0 && parentRect.left >= e.clientX || parentRect.right <= e.clientX && parentRect.right <= boundaryElRect.right;
    if (skipX) {
      return true;
    }
    if (isLeft) {
      skipX = diff < 0 && e.clientX > xPosition + parentRect.left || diff > 0 && e.clientX < xPosition + parentRect.left;
    } else {
      if (anywhereWithin) {
        skipX = diff < 0 && e.clientX > boundaryElRect.right || diff > 0 && e.clientX < xPosition + parentRect.left;
      } else {
        skipX = diff < 0 && e.clientX > boundaryElRect.right || diff > 0 && e.clientX < boundaryElRect.right;
      }
    }
    return skipX;
  }
  shouldSkipY(e, isTop, topBuffer = 0, diff) {
    const elRect = this.element.getBoundingClientRect();
    const parentRect = this.offsetParent.getBoundingClientRect();
    const boundaryElRect = this.boundaryEl.getBoundingClientRect();
    const yPosition = this.config.popup ? this.position.y : elRect.top;
    let skipY = yPosition <= 0 && parentRect.top >= e.clientY || parentRect.bottom <= e.clientY && parentRect.bottom <= boundaryElRect.bottom;
    if (skipY) {
      return true;
    }
    if (isTop) {
      skipY = diff < 0 && e.clientY > yPosition + parentRect.top + topBuffer || diff > 0 && e.clientY < yPosition + parentRect.top;
    } else {
      skipY = diff < 0 && e.clientY > boundaryElRect.bottom || diff > 0 && e.clientY < boundaryElRect.bottom;
    }
    return skipY;
  }
  createResizeMap() {
    const eGui = this.element;
    this.resizerMap = {
      topLeft: { element: eGui.querySelector("[ref=eTopLeftResizer]") },
      top: { element: eGui.querySelector("[ref=eTopResizer]") },
      topRight: { element: eGui.querySelector("[ref=eTopRightResizer]") },
      right: { element: eGui.querySelector("[ref=eRightResizer]") },
      bottomRight: { element: eGui.querySelector("[ref=eBottomRightResizer]") },
      bottom: { element: eGui.querySelector("[ref=eBottomResizer]") },
      bottomLeft: { element: eGui.querySelector("[ref=eBottomLeftResizer]") },
      left: { element: eGui.querySelector("[ref=eLeftResizer]") }
    };
  }
  addResizers() {
    if (this.resizersAdded) {
      return;
    }
    const eGui = this.element;
    if (!eGui) {
      return;
    }
    const parser = new DOMParser();
    const resizers = parser.parseFromString(RESIZE_TEMPLATE, "text/html").body;
    eGui.appendChild(resizers.firstChild);
    this.createResizeMap();
    this.resizersAdded = true;
  }
  removeResizers() {
    this.resizerMap = void 0;
    const resizerEl = this.element.querySelector(`.${RESIZE_CONTAINER_STYLE}`);
    if (resizerEl) {
      this.element.removeChild(resizerEl);
    }
    this.resizersAdded = false;
  }
  getResizerElement(side) {
    return this.resizerMap[side].element;
  }
  onResizeStart(e, side) {
    this.boundaryEl = this.findBoundaryElement();
    if (!this.positioned) {
      this.initialisePosition();
    }
    this.currentResizer = {
      isTop: !!side.match(/top/i),
      isRight: !!side.match(/right/i),
      isBottom: !!side.match(/bottom/i),
      isLeft: !!side.match(/left/i)
    };
    this.element.classList.add("ag-resizing");
    this.resizerMap[side].element.classList.add("ag-active");
    const { popup, forcePopupParentAsOffsetParent } = this.config;
    if (!popup && !forcePopupParentAsOffsetParent) {
      this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop);
    }
    this.isResizing = true;
    this.updateDragStartPosition(e.clientX, e.clientY);
  }
  getSiblings() {
    const element = this.element;
    const parent = element.parentElement;
    if (!parent) {
      return null;
    }
    return Array.prototype.slice.call(parent.children).filter((el) => !el.classList.contains("ag-hidden"));
  }
  getMinSizeOfSiblings() {
    const siblings = this.getSiblings() || [];
    let height = 0;
    let width = 0;
    for (let i = 0; i < siblings.length; i++) {
      const currentEl = siblings[i];
      const isFlex = !!currentEl.style.flex && currentEl.style.flex !== "0 0 auto";
      if (currentEl === this.element) {
        continue;
      }
      let nextHeight = this.minHeight || 0;
      let nextWidth = this.minWidth || 0;
      if (isFlex) {
        const computedStyle = window.getComputedStyle(currentEl);
        if (computedStyle.minHeight) {
          nextHeight = parseInt(computedStyle.minHeight, 10);
        }
        if (computedStyle.minWidth) {
          nextWidth = parseInt(computedStyle.minWidth, 10);
        }
      } else {
        nextHeight = currentEl.offsetHeight;
        nextWidth = currentEl.offsetWidth;
      }
      height += nextHeight;
      width += nextWidth;
    }
    return { height, width };
  }
  applySizeToSiblings(vertical) {
    let containerToFlex = null;
    const siblings = this.getSiblings();
    if (!siblings) {
      return;
    }
    for (let i = 0; i < siblings.length; i++) {
      const el = siblings[i];
      if (el === containerToFlex) {
        continue;
      }
      if (vertical) {
        el.style.height = `${el.offsetHeight}px`;
      } else {
        el.style.width = `${el.offsetWidth}px`;
      }
      el.style.flex = "0 0 auto";
      if (el === this.element) {
        containerToFlex = siblings[i + 1];
      }
    }
    if (containerToFlex) {
      containerToFlex.style.removeProperty("height");
      containerToFlex.style.removeProperty("min-height");
      containerToFlex.style.removeProperty("max-height");
      containerToFlex.style.flex = "1 1 auto";
    }
  }
  isResizable() {
    return Object.values(this.resizable).some((value) => value);
  }
  onResize(e) {
    if (!this.isResizing || !this.currentResizer) {
      return;
    }
    const { popup, forcePopupParentAsOffsetParent } = this.config;
    const { isTop, isRight, isBottom, isLeft } = this.currentResizer;
    const isHorizontal = isRight || isLeft;
    const isVertical = isBottom || isTop;
    const { movementX, movementY } = this.calculateMouseMovement({ e, isLeft, isTop });
    const xPosition = this.position.x;
    const yPosition = this.position.y;
    let offsetLeft = 0;
    let offsetTop = 0;
    if (isHorizontal && movementX) {
      const direction = isLeft ? -1 : 1;
      const oldWidth = this.getWidth();
      const newWidth = oldWidth + movementX * direction;
      let skipWidth = false;
      if (isLeft) {
        offsetLeft = oldWidth - newWidth;
        if (xPosition + offsetLeft <= 0 || newWidth <= this.minWidth) {
          skipWidth = true;
          offsetLeft = 0;
        }
      }
      if (!skipWidth) {
        this.setWidth(newWidth);
      }
    }
    if (isVertical && movementY) {
      const direction = isTop ? -1 : 1;
      const oldHeight = this.getHeight();
      const newHeight = oldHeight + movementY * direction;
      let skipHeight = false;
      if (isTop) {
        offsetTop = oldHeight - newHeight;
        if (yPosition + offsetTop <= 0 || newHeight <= this.minHeight) {
          skipHeight = true;
          offsetTop = 0;
        }
      } else {
        if (!this.config.popup && !this.config.forcePopupParentAsOffsetParent && oldHeight < newHeight && this.getMinSizeOfSiblings().height + newHeight > this.element.parentElement.offsetHeight) {
          skipHeight = true;
        }
      }
      if (!skipHeight) {
        this.setHeight(newHeight);
      }
    }
    this.updateDragStartPosition(e.clientX, e.clientY);
    if ((popup || forcePopupParentAsOffsetParent) && offsetLeft || offsetTop) {
      this.offsetElement(xPosition + offsetLeft, yPosition + offsetTop);
    }
  }
  onResizeEnd(e, side) {
    this.isResizing = false;
    this.currentResizer = null;
    this.boundaryEl = null;
    const params = {
      type: "resize",
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi
    };
    this.element.classList.remove("ag-resizing");
    this.resizerMap[side].element.classList.remove("ag-active");
    this.dispatchEvent(params);
  }
  refreshSize() {
    const eGui = this.element;
    if (this.config.popup) {
      if (!this.config.width) {
        this.setWidth(eGui.offsetWidth);
      }
      if (!this.config.height) {
        this.setHeight(eGui.offsetHeight);
      }
    }
  }
  onMoveStart(e) {
    this.boundaryEl = this.findBoundaryElement();
    if (!this.positioned) {
      this.initialisePosition();
    }
    this.isMoving = true;
    this.element.classList.add("ag-moving");
    this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMove(e) {
    if (!this.isMoving) {
      return;
    }
    const { x, y } = this.position;
    let topBuffer;
    if (this.config.calculateTopBuffer) {
      topBuffer = this.config.calculateTopBuffer();
    }
    const { movementX, movementY } = this.calculateMouseMovement({
      e,
      isTop: true,
      anywhereWithin: true,
      topBuffer
    });
    this.offsetElement(x + movementX, y + movementY);
    this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMoveEnd() {
    this.isMoving = false;
    this.boundaryEl = null;
    this.element.classList.remove("ag-moving");
  }
  setOffsetParent() {
    if (this.config.forcePopupParentAsOffsetParent) {
      this.offsetParent = this.popupService.getPopupParent();
    } else {
      this.offsetParent = this.element.offsetParent;
    }
  }
  findBoundaryElement() {
    let el = this.element;
    while (el) {
      if (window.getComputedStyle(el).position !== "static") {
        return el;
      }
      el = el.parentElement;
    }
    return this.element;
  }
  clearResizeListeners() {
    while (this.resizeListeners.length) {
      const params = this.resizeListeners.pop();
      this.dragService.removeDragSource(params);
    }
  }
  destroy() {
    super.destroy();
    if (this.moveElementDragListener) {
      this.dragService.removeDragSource(this.moveElementDragListener);
    }
    this.constrainSizeToAvailableHeight(false);
    this.clearResizeListeners();
    this.removeResizers();
  }
};
__decorate$2o([
  Autowired("popupService")
], PositionableFeature.prototype, "popupService", void 0);
__decorate$2o([
  Autowired("resizeObserverService")
], PositionableFeature.prototype, "resizeObserverService", void 0);
__decorate$2o([
  Autowired("dragService")
], PositionableFeature.prototype, "dragService", void 0);
var __decorate$2n = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ProvidedFilter = class extends Component {
  constructor(filterNameKey) {
    super();
    this.filterNameKey = filterNameKey;
    this.applyActive = false;
    this.hidePopup = null;
    this.debouncePending = false;
    this.appliedModel = null;
  }
  postConstruct() {
    this.resetTemplate();
    this.createManagedBean(new ManagedFocusFeature(this.getFocusableElement(), {
      handleKeyDown: this.handleKeyDown.bind(this)
    }));
    this.positionableFeature = new PositionableFeature(this.getPositionableElement(), {
      forcePopupParentAsOffsetParent: true
    });
    this.createBean(this.positionableFeature);
  }
  handleKeyDown(e) {
  }
  getFilterTitle() {
    return this.translate(this.filterNameKey);
  }
  isFilterActive() {
    return !!this.appliedModel;
  }
  resetTemplate(paramsMap) {
    let eGui = this.getGui();
    if (eGui) {
      eGui.removeEventListener("submit", this.onFormSubmit);
    }
    const templateString = `
            <form class="ag-filter-wrapper">
                <div class="ag-filter-body-wrapper ag-${this.getCssIdentifier()}-body-wrapper" ref="eFilterBody">
                    ${this.createBodyTemplate()}
                </div>
            </form>`;
    this.setTemplate(templateString, paramsMap);
    eGui = this.getGui();
    if (eGui) {
      eGui.addEventListener("submit", this.onFormSubmit);
    }
  }
  isReadOnly() {
    return !!this.providedFilterParams.readOnly;
  }
  init(params) {
    this.setParams(params);
    this.resetUiToDefaults(true).then(() => {
      this.updateUiVisibility();
      this.setupOnBtApplyDebounce();
    });
  }
  setParams(params) {
    this.providedFilterParams = params;
    this.applyActive = ProvidedFilter.isUseApplyButton(params);
    this.createButtonPanel();
  }
  createButtonPanel() {
    const { buttons } = this.providedFilterParams;
    if (!buttons || buttons.length < 1 || this.isReadOnly()) {
      return;
    }
    const eButtonsPanel = document.createElement("div");
    eButtonsPanel.classList.add("ag-filter-apply-panel");
    const addButton = (type) => {
      let text;
      let clickListener;
      switch (type) {
        case "apply":
          text = this.translate("applyFilter");
          clickListener = (e) => this.onBtApply(false, false, e);
          break;
        case "clear":
          text = this.translate("clearFilter");
          clickListener = () => this.onBtClear();
          break;
        case "reset":
          text = this.translate("resetFilter");
          clickListener = () => this.onBtReset();
          break;
        case "cancel":
          text = this.translate("cancelFilter");
          clickListener = (e) => {
            this.onBtCancel(e);
          };
          break;
        default:
          console.warn("AG Grid: Unknown button type specified");
          return;
      }
      const buttonType = type === "apply" ? "submit" : "button";
      const button = loadTemplate(
        `<button
                    type="${buttonType}"
                    ref="${type}FilterButton"
                    class="ag-button ag-standard-button ag-filter-apply-panel-button"
                >${text}
                </button>`
      );
      eButtonsPanel.appendChild(button);
      this.addManagedListener(button, "click", clickListener);
    };
    convertToSet(buttons).forEach((type) => addButton(type));
    this.getGui().appendChild(eButtonsPanel);
  }
  getDefaultDebounceMs() {
    return 0;
  }
  setupOnBtApplyDebounce() {
    const debounceMs = ProvidedFilter.getDebounceMs(this.providedFilterParams, this.getDefaultDebounceMs());
    const debounceFunc = debounce(this.checkApplyDebounce.bind(this), debounceMs);
    this.onBtApplyDebounce = () => {
      this.debouncePending = true;
      debounceFunc();
    };
  }
  checkApplyDebounce() {
    if (this.debouncePending) {
      this.debouncePending = false;
      this.onBtApply();
    }
  }
  getModel() {
    return this.appliedModel ? this.appliedModel : null;
  }
  setModel(model) {
    const promise = model != null ? this.setModelIntoUi(model) : this.resetUiToDefaults();
    return promise.then(() => {
      this.updateUiVisibility();
      this.applyModel("api");
    });
  }
  onBtCancel(e) {
    this.resetUiToActiveModel(this.getModel(), () => {
      this.handleCancelEnd(e);
    });
  }
  handleCancelEnd(e) {
    if (this.providedFilterParams.closeOnApply) {
      this.close(e);
    }
  }
  resetUiToActiveModel(currentModel, afterUiUpdatedFunc) {
    const afterAppliedFunc = () => {
      this.onUiChanged(false, "prevent");
      afterUiUpdatedFunc === null || afterUiUpdatedFunc === void 0 ? void 0 : afterUiUpdatedFunc();
    };
    if (currentModel != null) {
      this.setModelIntoUi(currentModel).then(afterAppliedFunc);
    } else {
      this.resetUiToDefaults().then(afterAppliedFunc);
    }
  }
  onBtClear() {
    this.resetUiToDefaults().then(() => this.onUiChanged());
  }
  onBtReset() {
    this.onBtClear();
    this.onBtApply();
  }
  applyModel(source = "api") {
    const newModel = this.getModelFromUi();
    if (!this.isModelValid(newModel)) {
      return false;
    }
    const previousModel = this.appliedModel;
    this.appliedModel = newModel;
    return !this.areModelsEqual(previousModel, newModel);
  }
  isModelValid(model) {
    return true;
  }
  onFormSubmit(e) {
    e.preventDefault();
  }
  onBtApply(afterFloatingFilter = false, afterDataChange = false, e) {
    if (e) {
      e.preventDefault();
    }
    if (this.applyModel(afterDataChange ? "rowDataUpdated" : "ui")) {
      this.providedFilterParams.filterChangedCallback({ afterFloatingFilter, afterDataChange });
    }
    const { closeOnApply } = this.providedFilterParams;
    if (closeOnApply && this.applyActive && !afterFloatingFilter && !afterDataChange) {
      this.close(e);
    }
  }
  onNewRowsLoaded() {
  }
  close(e) {
    if (!this.hidePopup) {
      return;
    }
    const keyboardEvent = e;
    const key = keyboardEvent && keyboardEvent.key;
    let params;
    if (key === "Enter" || key === "Space") {
      params = { keyboardEvent };
    }
    this.hidePopup(params);
    this.hidePopup = null;
  }
  onUiChanged(fromFloatingFilter = false, apply) {
    this.updateUiVisibility();
    this.providedFilterParams.filterModifiedCallback();
    if (this.applyActive && !this.isReadOnly()) {
      const isValid = this.isModelValid(this.getModelFromUi());
      setDisabled(this.getRefElement("applyFilterButton"), !isValid);
    }
    if (fromFloatingFilter && !apply || apply === "immediately") {
      this.onBtApply(fromFloatingFilter);
    } else if (!this.applyActive && !apply || apply === "debounce") {
      this.onBtApplyDebounce();
    }
  }
  afterGuiAttached(params) {
    if (params) {
      this.hidePopup = params.hidePopup;
    }
    this.refreshFilterResizer(params === null || params === void 0 ? void 0 : params.container);
  }
  refreshFilterResizer(containerType) {
    if (!this.positionableFeature || containerType === "toolPanel") {
      return;
    }
    const isFloatingFilter = containerType === "floatingFilter";
    const { positionableFeature, gridOptionsService } = this;
    if (isFloatingFilter) {
      positionableFeature.restoreLastSize();
      positionableFeature.setResizable(gridOptionsService.is("enableRtl") ? { bottom: true, bottomLeft: true, left: true } : { bottom: true, bottomRight: true, right: true });
    } else {
      this.positionableFeature.removeSizeFromEl();
      this.positionableFeature.setResizable(false);
    }
    this.positionableFeature.constrainSizeToAvailableHeight(true);
  }
  afterGuiDetached() {
    this.checkApplyDebounce();
    if (this.positionableFeature) {
      this.positionableFeature.constrainSizeToAvailableHeight(false);
    }
  }
  static getDebounceMs(params, debounceDefault) {
    if (ProvidedFilter.isUseApplyButton(params)) {
      if (params.debounceMs != null) {
        console.warn("AG Grid: debounceMs is ignored when apply button is present");
      }
      return 0;
    }
    return params.debounceMs != null ? params.debounceMs : debounceDefault;
  }
  static isUseApplyButton(params) {
    return !!params.buttons && params.buttons.indexOf("apply") >= 0;
  }
  destroy() {
    const eGui = this.getGui();
    if (eGui) {
      eGui.removeEventListener("submit", this.onFormSubmit);
    }
    this.hidePopup = null;
    if (this.positionableFeature) {
      this.positionableFeature = this.destroyBean(this.positionableFeature);
    }
    super.destroy();
  }
  translate(key) {
    const translate = this.localeService.getLocaleTextFunc();
    return translate(key, DEFAULT_FILTER_LOCALE_TEXT[key]);
  }
  getCellValue(rowNode) {
    const { api, colDef, column, columnApi, context } = this.providedFilterParams;
    return this.providedFilterParams.valueGetter({
      api,
      colDef,
      column,
      columnApi,
      context,
      data: rowNode.data,
      getValue: (field) => rowNode.data[field],
      node: rowNode
    });
  }
  getPositionableElement() {
    return this.eFilterBody;
  }
};
__decorate$2n([
  Autowired("rowModel")
], ProvidedFilter.prototype, "rowModel", void 0);
__decorate$2n([
  RefSelector("eFilterBody")
], ProvidedFilter.prototype, "eFilterBody", void 0);
__decorate$2n([
  PostConstruct
], ProvidedFilter.prototype, "postConstruct", null);
var __decorate$2m = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AgAbstractLabel = class extends Component {
  constructor(config, template) {
    super(template);
    this.labelSeparator = "";
    this.labelAlignment = "left";
    this.disabled = false;
    this.label = "";
    this.config = config || {};
  }
  postConstruct() {
    this.addCssClass("ag-labeled");
    this.eLabel.classList.add("ag-label");
    const { labelSeparator, label, labelWidth, labelAlignment } = this.config;
    if (labelSeparator != null) {
      this.setLabelSeparator(labelSeparator);
    }
    if (label != null) {
      this.setLabel(label);
    }
    if (labelWidth != null) {
      this.setLabelWidth(labelWidth);
    }
    this.setLabelAlignment(labelAlignment || this.labelAlignment);
    this.refreshLabel();
  }
  refreshLabel() {
    clearElement(this.eLabel);
    if (typeof this.label === "string") {
      this.eLabel.innerText = this.label + this.labelSeparator;
    } else if (this.label) {
      this.eLabel.appendChild(this.label);
    }
    if (this.label === "") {
      setDisplayed(this.eLabel, false);
      setAriaRole(this.eLabel, "presentation");
    } else {
      setDisplayed(this.eLabel, true);
      setAriaRole(this.eLabel, null);
    }
  }
  setLabelSeparator(labelSeparator) {
    if (this.labelSeparator === labelSeparator) {
      return this;
    }
    this.labelSeparator = labelSeparator;
    if (this.label != null) {
      this.refreshLabel();
    }
    return this;
  }
  getLabelId() {
    this.eLabel.id = this.eLabel.id || `ag-${this.getCompId()}-label`;
    return this.eLabel.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(label) {
    if (this.label === label) {
      return this;
    }
    this.label = label;
    this.refreshLabel();
    return this;
  }
  setLabelAlignment(alignment) {
    const eGui = this.getGui();
    const eGuiClassList = eGui.classList;
    eGuiClassList.toggle("ag-label-align-left", alignment === "left");
    eGuiClassList.toggle("ag-label-align-right", alignment === "right");
    eGuiClassList.toggle("ag-label-align-top", alignment === "top");
    return this;
  }
  setLabelEllipsis(hasEllipsis) {
    this.eLabel.classList.toggle("ag-label-ellipsis", hasEllipsis);
    return this;
  }
  setLabelWidth(width) {
    if (this.label == null) {
      return this;
    }
    setElementWidth(this.eLabel, width);
    return this;
  }
  setDisabled(disabled) {
    disabled = !!disabled;
    const element = this.getGui();
    setDisabled(element, disabled);
    element.classList.toggle("ag-disabled", disabled);
    this.disabled = disabled;
    return this;
  }
  isDisabled() {
    return !!this.disabled;
  }
};
__decorate$2m([
  PostConstruct
], AgAbstractLabel.prototype, "postConstruct", null);
var AgAbstractField = class extends AgAbstractLabel {
  constructor(config, template, className) {
    super(config, template);
    this.className = className;
  }
  postConstruct() {
    super.postConstruct();
    if (this.className) {
      this.addCssClass(this.className);
    }
  }
  onValueChange(callbackFn) {
    this.addManagedListener(this, AgAbstractField.EVENT_CHANGED, () => callbackFn(this.getValue()));
    return this;
  }
  getWidth() {
    return this.getGui().clientWidth;
  }
  setWidth(width) {
    setFixedWidth(this.getGui(), width);
    return this;
  }
  getPreviousValue() {
    return this.previousValue;
  }
  getValue() {
    return this.value;
  }
  setValue(value, silent) {
    if (this.value === value) {
      return this;
    }
    this.previousValue = this.value;
    this.value = value;
    if (!silent) {
      this.dispatchEvent({ type: AgAbstractField.EVENT_CHANGED });
    }
    return this;
  }
};
AgAbstractField.EVENT_CHANGED = "valueChange";
var __decorate$2l = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AgPickerField = class extends AgAbstractField {
  constructor(config, className, pickerIcon, ariaRole) {
    super(
      config,
      `<div class="ag-picker-field" role="presentation">
                <div ref="eLabel"></div>
                <div ref="eWrapper"
                    class="ag-wrapper ag-picker-field-wrapper"
                    tabIndex="-1"
                    aria-expanded="false"
                    ${ariaRole ? `role="${ariaRole}"` : ""}
                >
                    <div ref="eDisplayField" class="ag-picker-field-display"></div>
                    <div ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                </div>
            </div>`,
      className
    );
    this.pickerIcon = pickerIcon;
    this.isPickerDisplayed = false;
    this.isDestroyingPicker = false;
    this.skipClick = false;
  }
  postConstruct() {
    super.postConstruct();
    const displayId = `ag-${this.getCompId()}-display`;
    this.eDisplayField.setAttribute("id", displayId);
    setAriaDescribedBy(this.eWrapper, displayId);
    const clickHandler = () => {
      if (this.skipClick) {
        this.skipClick = false;
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      this.pickerComponent = this.showPicker();
    };
    const eGui = this.getGui();
    this.addManagedListener(eGui, "mousedown", (e) => {
      if (!this.skipClick && this.pickerComponent && this.pickerComponent.isAlive() && isVisible(this.pickerComponent.getGui()) && eGui.contains(e.target)) {
        this.skipClick = true;
      }
    });
    this.addManagedListener(eGui, "keydown", (e) => {
      switch (e.key) {
        case KeyCode.UP:
        case KeyCode.DOWN:
        case KeyCode.ENTER:
        case KeyCode.SPACE:
          clickHandler();
        case KeyCode.ESCAPE:
          if (this.isPickerDisplayed) {
            e.preventDefault();
          }
          break;
      }
    });
    this.addManagedListener(this.eWrapper, "click", clickHandler);
    this.addManagedListener(this.eLabel, "click", clickHandler);
    if (this.pickerIcon) {
      const icon = createIconNoSpan(this.pickerIcon, this.gridOptionsService);
      if (icon) {
        this.eIcon.appendChild(icon);
      }
    }
  }
  refreshLabel() {
    if (exists(this.getLabel())) {
      setAriaLabelledBy(this.eWrapper, this.getLabelId());
    } else {
      this.eWrapper.removeAttribute("aria-labelledby");
    }
    super.refreshLabel();
  }
  setAriaLabel(label) {
    setAriaLabel(this.eWrapper, label);
    return this;
  }
  setInputWidth(width) {
    setElementWidth(this.eWrapper, width);
    return this;
  }
  getFocusableElement() {
    return this.eWrapper;
  }
};
__decorate$2l([
  RefSelector("eLabel")
], AgPickerField.prototype, "eLabel", void 0);
__decorate$2l([
  RefSelector("eWrapper")
], AgPickerField.prototype, "eWrapper", void 0);
__decorate$2l([
  RefSelector("eDisplayField")
], AgPickerField.prototype, "eDisplayField", void 0);
__decorate$2l([
  RefSelector("eIcon")
], AgPickerField.prototype, "eIcon", void 0);
var __decorate$2k = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AgList = class extends Component {
  constructor(cssIdentifier = "default") {
    super(`<div class="ag-list ag-${cssIdentifier}-list" role="listbox"></div>`);
    this.cssIdentifier = cssIdentifier;
    this.options = [];
    this.itemEls = [];
  }
  init() {
    this.addManagedListener(this.getGui(), "keydown", this.handleKeyDown.bind(this));
  }
  handleKeyDown(e) {
    const key = e.key;
    switch (key) {
      case KeyCode.ENTER:
        if (!this.highlightedEl) {
          this.setValue(this.getValue());
        } else {
          const pos = this.itemEls.indexOf(this.highlightedEl);
          this.setValueByIndex(pos);
        }
        break;
      case KeyCode.DOWN:
      case KeyCode.UP:
        const isDown = key === KeyCode.DOWN;
        let itemToHighlight;
        e.preventDefault();
        if (!this.highlightedEl) {
          itemToHighlight = this.itemEls[isDown ? 0 : this.itemEls.length - 1];
        } else {
          const currentIdx = this.itemEls.indexOf(this.highlightedEl);
          let nextPos = currentIdx + (isDown ? 1 : -1);
          nextPos = Math.min(Math.max(nextPos, 0), this.itemEls.length - 1);
          itemToHighlight = this.itemEls[nextPos];
        }
        this.highlightItem(itemToHighlight);
        break;
    }
  }
  addOptions(listOptions) {
    listOptions.forEach((listOption) => this.addOption(listOption));
    return this;
  }
  addOption(listOption) {
    const { value, text } = listOption;
    const sanitisedText = escapeString(text || value);
    this.options.push({ value, text: sanitisedText });
    this.renderOption(value, sanitisedText);
    this.updateIndices();
    return this;
  }
  updateIndices() {
    const options = this.getGui().querySelectorAll(".ag-list-item");
    options.forEach((option, idx) => {
      setAriaPosInSet(option, idx + 1);
      setAriaSetSize(option, options.length);
    });
  }
  renderOption(value, text) {
    const itemEl = document.createElement("div");
    setAriaRole(itemEl, "option");
    itemEl.classList.add("ag-list-item", `ag-${this.cssIdentifier}-list-item`);
    itemEl.innerHTML = `<span>${text}</span>`;
    itemEl.tabIndex = -1;
    this.itemEls.push(itemEl);
    this.addManagedListener(itemEl, "mouseover", () => this.highlightItem(itemEl));
    this.addManagedListener(itemEl, "mouseleave", () => this.clearHighlighted());
    this.addManagedListener(itemEl, "click", () => this.setValue(value));
    this.getGui().appendChild(itemEl);
  }
  setValue(value, silent) {
    if (this.value === value) {
      this.fireItemSelected();
      return this;
    }
    if (value == null) {
      this.reset();
      return this;
    }
    const idx = this.options.findIndex((option) => option.value === value);
    if (idx !== -1) {
      const option = this.options[idx];
      this.value = option.value;
      this.displayValue = option.text != null ? option.text : option.value;
      this.highlightItem(this.itemEls[idx]);
      if (!silent) {
        this.fireChangeEvent();
      }
    }
    return this;
  }
  setValueByIndex(idx) {
    return this.setValue(this.options[idx].value);
  }
  getValue() {
    return this.value;
  }
  getDisplayValue() {
    return this.displayValue;
  }
  refreshHighlighted() {
    this.clearHighlighted();
    const idx = this.options.findIndex((option) => option.value === this.value);
    if (idx !== -1) {
      this.highlightItem(this.itemEls[idx]);
    }
  }
  reset() {
    this.value = null;
    this.displayValue = null;
    this.clearHighlighted();
    this.fireChangeEvent();
  }
  highlightItem(el) {
    if (!el.offsetParent) {
      return;
    }
    this.clearHighlighted();
    this.highlightedEl = el;
    this.highlightedEl.classList.add(AgList.ACTIVE_CLASS);
    setAriaSelected(this.highlightedEl, true);
    this.highlightedEl.focus();
  }
  clearHighlighted() {
    if (!this.highlightedEl || !this.highlightedEl.offsetParent) {
      return;
    }
    this.highlightedEl.classList.remove(AgList.ACTIVE_CLASS);
    setAriaSelected(this.highlightedEl, false);
    this.highlightedEl = null;
  }
  fireChangeEvent() {
    this.dispatchEvent({ type: AgAbstractField.EVENT_CHANGED });
    this.fireItemSelected();
  }
  fireItemSelected() {
    this.dispatchEvent({ type: AgList.EVENT_ITEM_SELECTED });
  }
};
AgList.EVENT_ITEM_SELECTED = "selectedItem";
AgList.ACTIVE_CLASS = "ag-active-item";
__decorate$2k([
  PostConstruct
], AgList.prototype, "init", null);
var __decorate$2j = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AgSelect = class extends AgPickerField {
  constructor(config) {
    super(config, "ag-select", "smallDown", "listbox");
  }
  init() {
    this.listComponent = this.createBean(new AgList("select"));
    this.listComponent.setParentComponent(this);
    this.eWrapper.tabIndex = 0;
    this.listComponent.addManagedListener(this.listComponent, AgList.EVENT_ITEM_SELECTED, () => {
      if (this.hideList) {
        this.hideList();
      }
      this.dispatchEvent({ type: AgSelect.EVENT_ITEM_SELECTED });
    });
    this.listComponent.addManagedListener(this.listComponent, AgAbstractField.EVENT_CHANGED, () => {
      this.setValue(this.listComponent.getValue(), false, true);
      if (this.hideList) {
        this.hideList();
      }
    });
  }
  showPicker() {
    const listGui = this.listComponent.getGui();
    const eDocument = this.gridOptionsService.getDocument();
    const destroyMouseWheelFunc = this.addManagedListener(eDocument.body, "wheel", (e) => {
      if (!listGui.contains(e.target) && this.hideList) {
        this.hideList();
      }
    });
    const destroyFocusOutFunc = this.addManagedListener(listGui, "focusout", (e) => {
      if (!listGui.contains(e.relatedTarget) && this.hideList) {
        this.hideList();
      }
    });
    const translate = this.localeService.getLocaleTextFunc();
    const addPopupRes = this.popupService.addPopup({
      modal: true,
      eChild: listGui,
      closeOnEsc: true,
      closedCallback: () => {
        this.hideList = null;
        this.isPickerDisplayed = false;
        destroyFocusOutFunc();
        destroyMouseWheelFunc();
        if (this.isAlive()) {
          setAriaExpanded(this.eWrapper, false);
          this.getFocusableElement().focus();
        }
      },
      ariaLabel: translate("ariaLabelSelectField", "Select Field")
    });
    if (addPopupRes) {
      this.hideList = addPopupRes.hideFunc;
    }
    this.isPickerDisplayed = true;
    setElementWidth(listGui, getAbsoluteWidth(this.eWrapper));
    setAriaExpanded(this.eWrapper, true);
    listGui.style.maxHeight = getInnerHeight(this.popupService.getPopupParent()) + "px";
    listGui.style.position = "absolute";
    this.popupService.positionPopupByComponent({
      type: "ag-list",
      eventSource: this.eWrapper,
      ePopup: listGui,
      position: "under",
      keepWithinBounds: true
    });
    this.listComponent.refreshHighlighted();
    return this.listComponent;
  }
  addOptions(options) {
    options.forEach((option) => this.addOption(option));
    return this;
  }
  addOption(option) {
    this.listComponent.addOption(option);
    return this;
  }
  setValue(value, silent, fromPicker) {
    if (this.value === value) {
      return this;
    }
    if (!fromPicker) {
      this.listComponent.setValue(value, true);
    }
    const newValue = this.listComponent.getValue();
    if (newValue === this.getValue()) {
      return this;
    }
    this.eDisplayField.innerHTML = this.listComponent.getDisplayValue();
    return super.setValue(value, silent);
  }
  destroy() {
    if (this.hideList) {
      this.hideList();
    }
    this.destroyBean(this.listComponent);
    super.destroy();
  }
};
AgSelect.EVENT_ITEM_SELECTED = "selectedItem";
__decorate$2j([
  Autowired("popupService")
], AgSelect.prototype, "popupService", void 0);
__decorate$2j([
  PostConstruct
], AgSelect.prototype, "init", null);
var __decorate$2i = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AgAbstractInputField = class extends AgAbstractField {
  constructor(config, className, inputType = "text", displayFieldTag = "input") {
    super(config, `
            <div role="presentation">
                <div ref="eLabel" class="ag-input-field-label"></div>
                <div ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <${displayFieldTag} ref="eInput" class="ag-input-field-input"></${displayFieldTag}>
                </div>
            </div>`, className);
    this.inputType = inputType;
    this.displayFieldTag = displayFieldTag;
  }
  postConstruct() {
    super.postConstruct();
    this.setInputType();
    this.eLabel.classList.add(`${this.className}-label`);
    this.eWrapper.classList.add(`${this.className}-input-wrapper`);
    this.eInput.classList.add(`${this.className}-input`);
    this.addCssClass("ag-input-field");
    this.eInput.id = this.eInput.id || `ag-${this.getCompId()}-input`;
    const { width, value } = this.config;
    if (width != null) {
      this.setWidth(width);
    }
    if (value != null) {
      this.setValue(value);
    }
    this.addInputListeners();
  }
  refreshLabel() {
    if (exists(this.getLabel())) {
      setAriaLabelledBy(this.eInput, this.getLabelId());
    } else {
      this.eInput.removeAttribute("aria-labelledby");
    }
    super.refreshLabel();
  }
  addInputListeners() {
    this.addManagedListener(this.eInput, "input", (e) => this.setValue(e.target.value));
  }
  setInputType() {
    if (this.displayFieldTag === "input") {
      this.eInput.setAttribute("type", this.inputType);
    }
  }
  getInputElement() {
    return this.eInput;
  }
  setInputWidth(width) {
    setElementWidth(this.eWrapper, width);
    return this;
  }
  setInputName(name) {
    this.getInputElement().setAttribute("name", name);
    return this;
  }
  getFocusableElement() {
    return this.eInput;
  }
  setMaxLength(length) {
    const eInput = this.eInput;
    eInput.maxLength = length;
    return this;
  }
  setInputPlaceholder(placeholder) {
    addOrRemoveAttribute(this.eInput, "placeholder", placeholder);
    return this;
  }
  setInputAriaLabel(label) {
    setAriaLabel(this.eInput, label);
    return this;
  }
  setDisabled(disabled) {
    setDisabled(this.eInput, disabled);
    return super.setDisabled(disabled);
  }
};
__decorate$2i([
  RefSelector("eLabel")
], AgAbstractInputField.prototype, "eLabel", void 0);
__decorate$2i([
  RefSelector("eWrapper")
], AgAbstractInputField.prototype, "eWrapper", void 0);
__decorate$2i([
  RefSelector("eInput")
], AgAbstractInputField.prototype, "eInput", void 0);
var AgCheckbox = class extends AgAbstractInputField {
  constructor(config, className = "ag-checkbox", inputType = "checkbox") {
    super(config, className, inputType);
    this.labelAlignment = "right";
    this.selected = false;
    this.readOnly = false;
    this.passive = false;
  }
  addInputListeners() {
    this.addManagedListener(this.eInput, "click", this.onCheckboxClick.bind(this));
    this.addManagedListener(this.eLabel, "click", this.toggle.bind(this));
  }
  getNextValue() {
    return this.selected === void 0 ? true : !this.selected;
  }
  setPassive(passive) {
    this.passive = passive;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setReadOnly(readOnly) {
    this.eWrapper.classList.toggle("ag-disabled", readOnly);
    this.eInput.disabled = readOnly;
    this.readOnly = readOnly;
  }
  setDisabled(disabled) {
    this.eWrapper.classList.toggle("ag-disabled", disabled);
    return super.setDisabled(disabled);
  }
  toggle() {
    if (this.eInput.disabled) {
      return;
    }
    const previousValue = this.isSelected();
    const nextValue = this.getNextValue();
    if (this.passive) {
      this.dispatchChange(nextValue, previousValue);
    } else {
      this.setValue(nextValue);
    }
  }
  getValue() {
    return this.isSelected();
  }
  setValue(value, silent) {
    this.refreshSelectedClass(value);
    this.setSelected(value, silent);
    return this;
  }
  setName(name) {
    const input = this.getInputElement();
    input.name = name;
    return this;
  }
  isSelected() {
    return this.selected;
  }
  setSelected(selected, silent) {
    if (this.isSelected() === selected) {
      return;
    }
    this.previousValue = this.isSelected();
    selected = this.selected = typeof selected === "boolean" ? selected : void 0;
    this.eInput.checked = selected;
    this.eInput.indeterminate = selected === void 0;
    if (!silent) {
      this.dispatchChange(this.selected, this.previousValue);
    }
  }
  dispatchChange(selected, previousValue, event) {
    this.dispatchEvent({ type: AgCheckbox.EVENT_CHANGED, selected, previousValue, event });
    const input = this.getInputElement();
    const checkboxChangedEvent = {
      type: Events.EVENT_CHECKBOX_CHANGED,
      id: input.id,
      name: input.name,
      selected,
      previousValue
    };
    this.eventService.dispatchEvent(checkboxChangedEvent);
  }
  onCheckboxClick(e) {
    if (this.passive || this.eInput.disabled) {
      return;
    }
    const previousValue = this.isSelected();
    const selected = this.selected = e.target.checked;
    this.refreshSelectedClass(selected);
    this.dispatchChange(selected, previousValue, e);
  }
  refreshSelectedClass(value) {
    this.eWrapper.classList.toggle("ag-checked", value === true);
    this.eWrapper.classList.toggle("ag-indeterminate", value == null);
  }
};
var AgRadioButton = class extends AgCheckbox {
  constructor(config) {
    super(config, "ag-radio-button", "radio");
  }
  isSelected() {
    return this.eInput.checked;
  }
  toggle() {
    if (this.eInput.disabled) {
      return;
    }
    if (!this.isSelected()) {
      this.setValue(true);
    }
  }
  addInputListeners() {
    super.addInputListeners();
    this.addManagedListener(this.eventService, Events.EVENT_CHECKBOX_CHANGED, this.onChange.bind(this));
  }
  onChange(event) {
    if (event.selected && event.name && this.eInput.name && this.eInput.name === event.name && event.id && this.eInput.id !== event.id) {
      this.setValue(false, true);
    }
  }
};
var SimpleFilterModelFormatter = class {
  constructor(localeService, optionsFactory) {
    this.localeService = localeService;
    this.optionsFactory = optionsFactory;
  }
  getModelAsString(model) {
    if (!model) {
      return null;
    }
    const isCombined = model.operator != null;
    const translate = this.localeService.getLocaleTextFunc();
    if (isCombined) {
      const combinedModel = model;
      let { conditions } = combinedModel;
      if (!conditions) {
        const { condition1, condition2 } = combinedModel;
        conditions = [condition1, condition2];
      }
      const customOptions = conditions.map((condition) => this.getModelAsString(condition));
      const joinOperatorTranslateKey = combinedModel.operator === "AND" ? "andCondition" : "orCondition";
      return customOptions.join(` ${translate(joinOperatorTranslateKey, DEFAULT_FILTER_LOCALE_TEXT[joinOperatorTranslateKey])} `);
    } else if (model.type === SimpleFilter.BLANK || model.type === SimpleFilter.NOT_BLANK) {
      return translate(model.type, model.type);
    } else {
      const condition = model;
      const customOption = this.optionsFactory.getCustomOption(condition.type);
      const { displayKey, displayName, numberOfInputs } = customOption || {};
      if (displayKey && displayName && numberOfInputs === 0) {
        translate(displayKey, displayName);
        return displayName;
      }
      return this.conditionToString(condition, customOption);
    }
  }
};
var SimpleFilter = class extends ProvidedFilter {
  constructor() {
    super(...arguments);
    this.eTypes = [];
    this.eJoinOperatorPanels = [];
    this.eJoinOperatorsAnd = [];
    this.eJoinOperatorsOr = [];
    this.eConditionBodies = [];
    this.listener = () => this.onUiChanged();
    this.lastUiCompletePosition = null;
    this.joinOperatorId = 0;
  }
  getNumberOfInputs(type) {
    const customOpts = this.optionsFactory.getCustomOption(type);
    if (customOpts) {
      const { numberOfInputs } = customOpts;
      return numberOfInputs != null ? numberOfInputs : 1;
    }
    const zeroInputTypes = [
      SimpleFilter.EMPTY,
      SimpleFilter.NOT_BLANK,
      SimpleFilter.BLANK
    ];
    if (type && zeroInputTypes.indexOf(type) >= 0) {
      return 0;
    } else if (type === SimpleFilter.IN_RANGE) {
      return 2;
    }
    return 1;
  }
  onFloatingFilterChanged(type, value) {
    this.setTypeFromFloatingFilter(type);
    this.setValueFromFloatingFilter(value);
    this.onUiChanged(true);
  }
  setTypeFromFloatingFilter(type) {
    this.eTypes.forEach((eType, position) => {
      if (position === 0) {
        eType.setValue(type, true);
      } else {
        eType.setValue(this.optionsFactory.getDefaultOption(), true);
      }
    });
  }
  getModelFromUi() {
    const conditions = this.getUiCompleteConditions();
    if (conditions.length === 0) {
      return null;
    }
    if (this.maxNumConditions > 1 && conditions.length > 1) {
      return {
        filterType: this.getFilterType(),
        operator: this.getJoinOperator(),
        condition1: conditions[0],
        condition2: conditions[1],
        conditions
      };
    }
    return conditions[0];
  }
  getConditionTypes() {
    return this.eTypes.map((eType) => eType.getValue());
  }
  getConditionType(position) {
    return this.eTypes[position].getValue();
  }
  getJoinOperator() {
    if (this.eJoinOperatorsOr.length === 0) {
      return this.defaultJoinOperator;
    }
    return this.eJoinOperatorsOr[0].getValue() === true ? "OR" : "AND";
  }
  areModelsEqual(a, b) {
    if (!a && !b) {
      return true;
    }
    if (!a && b || a && !b) {
      return false;
    }
    const aIsSimple = !a.operator;
    const bIsSimple = !b.operator;
    const oneSimpleOneCombined = !aIsSimple && bIsSimple || aIsSimple && !bIsSimple;
    if (oneSimpleOneCombined) {
      return false;
    }
    let res;
    if (aIsSimple) {
      const aSimple = a;
      const bSimple = b;
      res = this.areSimpleModelsEqual(aSimple, bSimple);
    } else {
      const aCombined = a;
      const bCombined = b;
      res = aCombined.operator === bCombined.operator && areEqual(aCombined.conditions, bCombined.conditions, (aModel, bModel) => this.areSimpleModelsEqual(aModel, bModel));
    }
    return res;
  }
  setModelIntoUi(model) {
    const isCombined = model.operator;
    if (isCombined) {
      let combinedModel = model;
      if (!combinedModel.conditions) {
        combinedModel.conditions = [
          combinedModel.condition1,
          combinedModel.condition2
        ];
      }
      const numConditions = this.validateAndUpdateConditions(combinedModel.conditions);
      const numPrevConditions = this.getNumConditions();
      if (numConditions < numPrevConditions) {
        this.removeConditionsAndOperators(numConditions);
      } else if (numConditions > numPrevConditions) {
        for (let i = numPrevConditions; i < numConditions; i++) {
          this.createJoinOperatorPanel();
          this.createOption();
        }
      }
      const orChecked = combinedModel.operator === "OR";
      this.eJoinOperatorsAnd.forEach((eJoinOperatorAnd) => eJoinOperatorAnd.setValue(!orChecked, true));
      this.eJoinOperatorsOr.forEach((eJoinOperatorOr) => eJoinOperatorOr.setValue(orChecked, true));
      combinedModel.conditions.forEach((condition, position) => {
        this.eTypes[position].setValue(condition.type, true);
        this.setConditionIntoUi(condition, position);
      });
    } else {
      const simpleModel = model;
      if (this.getNumConditions() > 1) {
        this.removeConditionsAndOperators(1);
      }
      this.eTypes[0].setValue(simpleModel.type, true);
      this.setConditionIntoUi(simpleModel, 0);
    }
    this.lastUiCompletePosition = this.getNumConditions() - 1;
    this.createMissingConditionsAndOperators();
    this.onUiChanged();
    return AgPromise.resolve();
  }
  validateAndUpdateConditions(conditions) {
    let numConditions = conditions.length;
    if (numConditions > this.maxNumConditions) {
      conditions.splice(this.maxNumConditions);
      doOnce(() => console.warn('AG Grid: Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.'), "simpleFilterSetModelMaxNumConditions");
      numConditions = this.maxNumConditions;
    }
    return numConditions;
  }
  doesFilterPass(params) {
    var _a;
    const model = this.getModel();
    if (model == null) {
      return true;
    }
    const { operator } = model;
    const models = [];
    if (operator) {
      const combinedModel = model;
      models.push(...(_a = combinedModel.conditions) !== null && _a !== void 0 ? _a : []);
    } else {
      models.push(model);
    }
    const combineFunction = operator && operator === "OR" ? "some" : "every";
    return models[combineFunction]((m) => this.individualConditionPasses(params, m));
  }
  setParams(params) {
    super.setParams(params);
    this.setNumConditions(params);
    this.defaultJoinOperator = this.getDefaultJoinOperator(params.defaultJoinOperator);
    this.filterPlaceholder = params.filterPlaceholder;
    this.optionsFactory = new OptionsFactory();
    this.optionsFactory.init(params, this.getDefaultFilterOptions());
    this.createFilterListOptions();
    this.createOption();
    this.createMissingConditionsAndOperators();
  }
  setNumConditions(params) {
    var _a, _b;
    if (params.suppressAndOrCondition != null) {
      doOnce(() => console.warn('AG Grid: Since v29.2 "filterParams.suppressAndOrCondition" is deprecated. Use "filterParams.maxNumConditions = 1" instead.'), "simpleFilterSuppressAndOrCondition");
    }
    if (params.alwaysShowBothConditions != null) {
      doOnce(() => console.warn('AG Grid: Since v29.2 "filterParams.alwaysShowBothConditions" is deprecated. Use "filterParams.numAlwaysVisibleConditions = 2" instead.'), "simpleFilterAlwaysShowBothConditions");
    }
    this.maxNumConditions = (_a = params.maxNumConditions) !== null && _a !== void 0 ? _a : params.suppressAndOrCondition ? 1 : 2;
    if (this.maxNumConditions < 1) {
      doOnce(() => console.warn('AG Grid: "filterParams.maxNumConditions" must be greater than or equal to zero.'), "simpleFilterMaxNumConditions");
      this.maxNumConditions = 1;
    }
    this.numAlwaysVisibleConditions = (_b = params.numAlwaysVisibleConditions) !== null && _b !== void 0 ? _b : params.alwaysShowBothConditions ? 2 : 1;
    if (this.numAlwaysVisibleConditions < 1) {
      doOnce(() => console.warn('AG Grid: "filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.'), "simpleFilterNumAlwaysVisibleConditions");
      this.numAlwaysVisibleConditions = 1;
    }
    if (this.numAlwaysVisibleConditions > this.maxNumConditions) {
      doOnce(() => console.warn('AG Grid: "filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".'), "simpleFilterNumAlwaysVisibleGreaterThanMaxNumConditions");
      this.numAlwaysVisibleConditions = this.maxNumConditions;
    }
  }
  createOption() {
    const eType = this.createManagedBean(new AgSelect());
    this.eTypes.push(eType);
    eType.addCssClass("ag-filter-select");
    this.eFilterBody.appendChild(eType.getGui());
    const eConditionBody = this.createValueElement();
    this.eConditionBodies.push(eConditionBody);
    this.eFilterBody.appendChild(eConditionBody);
    this.putOptionsIntoDropdown(eType);
    this.resetType(eType);
    const position = this.getNumConditions() - 1;
    this.forEachPositionInput(position, (element) => this.resetInput(element));
    this.addChangedListeners(eType, position);
  }
  createJoinOperatorPanel() {
    const eJoinOperatorPanel = document.createElement("div");
    this.eJoinOperatorPanels.push(eJoinOperatorPanel);
    eJoinOperatorPanel.classList.add("ag-filter-condition");
    const eJoinOperatorAnd = this.createJoinOperator(this.eJoinOperatorsAnd, eJoinOperatorPanel, "and");
    const eJoinOperatorOr = this.createJoinOperator(this.eJoinOperatorsOr, eJoinOperatorPanel, "or");
    this.eFilterBody.appendChild(eJoinOperatorPanel);
    const index = this.eJoinOperatorPanels.length - 1;
    const uniqueGroupId = this.joinOperatorId++;
    this.resetJoinOperatorAnd(eJoinOperatorAnd, index, uniqueGroupId);
    this.resetJoinOperatorOr(eJoinOperatorOr, index, uniqueGroupId);
    if (!this.isReadOnly()) {
      eJoinOperatorAnd.onValueChange(this.listener);
      eJoinOperatorOr.onValueChange(this.listener);
    }
  }
  createJoinOperator(eJoinOperators, eJoinOperatorPanel, andOr) {
    const eJoinOperator = this.createManagedBean(new AgRadioButton());
    eJoinOperators.push(eJoinOperator);
    eJoinOperator.addCssClass("ag-filter-condition-operator");
    eJoinOperator.addCssClass(`ag-filter-condition-operator-${andOr}`);
    eJoinOperatorPanel.appendChild(eJoinOperator.getGui());
    return eJoinOperator;
  }
  getDefaultJoinOperator(defaultJoinOperator) {
    return defaultJoinOperator === "AND" || defaultJoinOperator === "OR" ? defaultJoinOperator : "AND";
  }
  createFilterListOptions() {
    const filterOptions = this.optionsFactory.getFilterOptions();
    this.filterListOptions = filterOptions.map((option) => typeof option === "string" ? this.createBoilerplateListOption(option) : this.createCustomListOption(option));
  }
  putOptionsIntoDropdown(eType) {
    this.filterListOptions.forEach((listOption) => {
      eType.addOption(listOption);
    });
    eType.setDisabled(this.filterListOptions.length <= 1);
  }
  createBoilerplateListOption(option) {
    return { value: option, text: this.translate(option) };
  }
  createCustomListOption(option) {
    const { displayKey } = option;
    const customOption = this.optionsFactory.getCustomOption(option.displayKey);
    return {
      value: displayKey,
      text: customOption ? this.localeService.getLocaleTextFunc()(customOption.displayKey, customOption.displayName) : this.translate(displayKey)
    };
  }
  isAllowTwoConditions() {
    return this.maxNumConditions >= 2;
  }
  createBodyTemplate() {
    return "";
  }
  getCssIdentifier() {
    return "simple-filter";
  }
  updateUiVisibility() {
    const joinOperator = this.getJoinOperator();
    this.updateNumConditions();
    this.updateConditionStatusesAndValues(this.lastUiCompletePosition, joinOperator);
  }
  updateNumConditions() {
    var _a;
    let lastUiCompletePosition = -1;
    let areAllConditionsUiComplete = true;
    for (let position = 0; position < this.getNumConditions(); position++) {
      if (this.isConditionUiComplete(position)) {
        lastUiCompletePosition = position;
      } else {
        areAllConditionsUiComplete = false;
      }
    }
    if (this.shouldAddNewConditionAtEnd(areAllConditionsUiComplete)) {
      this.createJoinOperatorPanel();
      this.createOption();
    } else {
      const activePosition = (_a = this.lastUiCompletePosition) !== null && _a !== void 0 ? _a : this.getNumConditions() - 2;
      if (lastUiCompletePosition < activePosition) {
        this.removeConditionsAndOperators(activePosition + 1);
        const removeStartPosition = lastUiCompletePosition + 1;
        const numConditionsToRemove = activePosition - removeStartPosition;
        if (numConditionsToRemove > 0) {
          this.removeConditionsAndOperators(removeStartPosition, numConditionsToRemove);
        }
        this.createMissingConditionsAndOperators();
      }
    }
    this.lastUiCompletePosition = lastUiCompletePosition;
  }
  updateConditionStatusesAndValues(lastUiCompletePosition, joinOperator) {
    this.eTypes.forEach((eType, position) => {
      const disabled = this.isConditionDisabled(position, lastUiCompletePosition);
      eType.setDisabled(disabled || this.filterListOptions.length <= 1);
      if (position === 1) {
        setDisabled(this.eJoinOperatorPanels[0], disabled);
        this.eJoinOperatorsAnd[0].setDisabled(disabled);
        this.eJoinOperatorsOr[0].setDisabled(disabled);
      }
    });
    this.eConditionBodies.forEach((element, index) => {
      setDisplayed(element, this.isConditionBodyVisible(index));
    });
    const orChecked = (joinOperator !== null && joinOperator !== void 0 ? joinOperator : this.getJoinOperator()) === "OR";
    this.eJoinOperatorsAnd.forEach((eJoinOperatorAnd, index) => {
      eJoinOperatorAnd.setValue(!orChecked, true);
    });
    this.eJoinOperatorsOr.forEach((eJoinOperatorOr, index) => {
      eJoinOperatorOr.setValue(orChecked, true);
    });
    this.forEachInput((element, index, position, numberOfInputs) => {
      this.setElementDisplayed(element, index < numberOfInputs);
      this.setElementDisabled(element, this.isConditionDisabled(position, lastUiCompletePosition));
    });
    this.resetPlaceholder();
  }
  shouldAddNewConditionAtEnd(areAllConditionsUiComplete) {
    return areAllConditionsUiComplete && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
  }
  removeConditionsAndOperators(startPosition, deleteCount) {
    if (startPosition >= this.getNumConditions()) {
      return;
    }
    this.removeComponents(this.eTypes, startPosition, deleteCount);
    this.removeElements(this.eConditionBodies, startPosition, deleteCount);
    this.removeValueElements(startPosition, deleteCount);
    const joinOperatorIndex = Math.max(startPosition - 1, 0);
    this.removeElements(this.eJoinOperatorPanels, joinOperatorIndex, deleteCount);
    this.removeComponents(this.eJoinOperatorsAnd, joinOperatorIndex, deleteCount);
    this.removeComponents(this.eJoinOperatorsOr, joinOperatorIndex, deleteCount);
  }
  removeElements(elements, startPosition, deleteCount) {
    const removedElements = this.removeItems(elements, startPosition, deleteCount);
    removedElements.forEach((element) => removeFromParent(element));
  }
  removeComponents(components, startPosition, deleteCount) {
    const removedComponents = this.removeItems(components, startPosition, deleteCount);
    removedComponents.forEach((comp) => {
      removeFromParent(comp.getGui());
      this.destroyBean(comp);
    });
  }
  removeItems(items, startPosition, deleteCount) {
    return deleteCount == null ? items.splice(startPosition) : items.splice(startPosition, deleteCount);
  }
  afterGuiAttached(params) {
    super.afterGuiAttached(params);
    this.resetPlaceholder();
    if (!params || !params.suppressFocus && !this.isReadOnly()) {
      const firstInput = this.getInputs(0)[0];
      if (!firstInput) {
        return;
      }
      if (firstInput instanceof AgAbstractInputField) {
        firstInput.getInputElement().focus();
      }
    }
  }
  afterGuiDetached() {
    super.afterGuiDetached();
    const appliedModel = this.getModel();
    if (!this.areModelsEqual(appliedModel, this.getModelFromUi()) || this.hasInvalidInputs()) {
      this.resetUiToActiveModel(appliedModel);
    }
    let lastUiCompletePosition = -1;
    let updatedLastUiCompletePosition = -1;
    let conditionsRemoved = false;
    const joinOperator = this.getJoinOperator();
    for (let position = this.getNumConditions() - 1; position >= 0; position--) {
      if (this.isConditionUiComplete(position)) {
        if (lastUiCompletePosition === -1) {
          lastUiCompletePosition = position;
          updatedLastUiCompletePosition = position;
        }
      } else {
        const shouldRemovePositionAtEnd = position >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(position - 1);
        const positionBeforeLastUiCompletePosition = position < lastUiCompletePosition;
        if (shouldRemovePositionAtEnd || positionBeforeLastUiCompletePosition) {
          this.removeConditionsAndOperators(position, 1);
          conditionsRemoved = true;
          if (positionBeforeLastUiCompletePosition) {
            updatedLastUiCompletePosition--;
          }
        }
      }
    }
    let shouldUpdateConditionStatusesAndValues = false;
    if (this.getNumConditions() < this.numAlwaysVisibleConditions) {
      this.createMissingConditionsAndOperators();
      shouldUpdateConditionStatusesAndValues = true;
    }
    if (this.shouldAddNewConditionAtEnd(updatedLastUiCompletePosition === this.getNumConditions() - 1)) {
      this.createJoinOperatorPanel();
      this.createOption();
      shouldUpdateConditionStatusesAndValues = true;
    }
    if (shouldUpdateConditionStatusesAndValues) {
      this.updateConditionStatusesAndValues(updatedLastUiCompletePosition, joinOperator);
    }
    if (conditionsRemoved) {
      this.updateJoinOperatorsDisabled();
    }
    this.lastUiCompletePosition = updatedLastUiCompletePosition;
  }
  getPlaceholderText(defaultPlaceholder, position) {
    let placeholder = this.translate(defaultPlaceholder);
    if (isFunction(this.filterPlaceholder)) {
      const filterPlaceholderFn = this.filterPlaceholder;
      const filterOptionKey = this.eTypes[position].getValue();
      const filterOption = this.translate(filterOptionKey);
      placeholder = filterPlaceholderFn({
        filterOptionKey,
        filterOption,
        placeholder
      });
    } else if (typeof this.filterPlaceholder === "string") {
      placeholder = this.filterPlaceholder;
    }
    return placeholder;
  }
  resetPlaceholder() {
    const globalTranslate = this.localeService.getLocaleTextFunc();
    this.forEachInput((element, index, position, numberOfInputs) => {
      if (!(element instanceof AgAbstractInputField)) {
        return;
      }
      const placeholder = index === 0 && numberOfInputs > 1 ? "inRangeStart" : index === 0 ? "filterOoo" : "inRangeEnd";
      const ariaLabel = index === 0 && numberOfInputs > 1 ? globalTranslate("ariaFilterFromValue", "Filter from value") : index === 0 ? globalTranslate("ariaFilterValue", "Filter Value") : globalTranslate("ariaFilterToValue", "Filter to Value");
      element.setInputPlaceholder(this.getPlaceholderText(placeholder, position));
      element.setInputAriaLabel(ariaLabel);
    });
  }
  setElementValue(element, value) {
    if (element instanceof AgAbstractInputField) {
      element.setValue(value != null ? String(value) : null, true);
    }
  }
  setElementDisplayed(element, displayed) {
    if (element instanceof Component) {
      setDisplayed(element.getGui(), displayed);
    }
  }
  setElementDisabled(element, disabled) {
    if (element instanceof Component) {
      setDisabled(element.getGui(), disabled);
    }
  }
  attachElementOnChange(element, listener) {
    if (element instanceof AgAbstractInputField) {
      element.onValueChange(listener);
    }
  }
  forEachInput(cb) {
    this.getConditionTypes().forEach((type, position) => {
      this.forEachPositionTypeInput(position, type, cb);
    });
  }
  forEachPositionInput(position, cb) {
    const type = this.getConditionType(position);
    this.forEachPositionTypeInput(position, type, cb);
  }
  forEachPositionTypeInput(position, type, cb) {
    const numberOfInputs = this.getNumberOfInputs(type);
    const inputs = this.getInputs(position);
    for (let index = 0; index < inputs.length; index++) {
      const input = inputs[index];
      if (input != null) {
        cb(input, index, position, numberOfInputs);
      }
    }
  }
  isConditionDisabled(position, lastUiCompletePosition) {
    if (this.isReadOnly()) {
      return true;
    }
    if (position === 0) {
      return false;
    }
    return position > lastUiCompletePosition + 1;
  }
  isConditionBodyVisible(position) {
    const type = this.getConditionType(position);
    const numberOfInputs = this.getNumberOfInputs(type);
    return numberOfInputs > 0;
  }
  isConditionUiComplete(position) {
    if (position >= this.getNumConditions()) {
      return false;
    }
    const type = this.getConditionType(position);
    if (type === SimpleFilter.EMPTY) {
      return false;
    }
    if (this.getValues(position).some((v) => v == null)) {
      return false;
    }
    return true;
  }
  getNumConditions() {
    return this.eTypes.length;
  }
  getUiCompleteConditions() {
    const conditions = [];
    for (let position = 0; position < this.getNumConditions(); position++) {
      if (this.isConditionUiComplete(position)) {
        conditions.push(this.createCondition(position));
      }
    }
    return conditions;
  }
  createMissingConditionsAndOperators() {
    if (this.isReadOnly()) {
      return;
    }
    for (let i = this.getNumConditions(); i < this.numAlwaysVisibleConditions; i++) {
      this.createJoinOperatorPanel();
      this.createOption();
    }
  }
  resetUiToDefaults(silent) {
    this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions);
    this.eTypes.forEach((eType) => this.resetType(eType));
    this.eJoinOperatorsAnd.forEach((eJoinOperatorAnd, index) => this.resetJoinOperatorAnd(eJoinOperatorAnd, index, this.joinOperatorId + index));
    this.eJoinOperatorsOr.forEach((eJoinOperatorOr, index) => this.resetJoinOperatorOr(eJoinOperatorOr, index, this.joinOperatorId + index));
    this.joinOperatorId++;
    this.forEachInput((element) => this.resetInput(element));
    this.resetPlaceholder();
    this.createMissingConditionsAndOperators();
    this.lastUiCompletePosition = null;
    if (!silent) {
      this.onUiChanged();
    }
    return AgPromise.resolve();
  }
  resetType(eType) {
    const translate = this.localeService.getLocaleTextFunc();
    const filteringLabel = translate("ariaFilteringOperator", "Filtering operator");
    eType.setValue(this.optionsFactory.getDefaultOption(), true).setAriaLabel(filteringLabel).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
  }
  resetJoinOperatorAnd(eJoinOperatorAnd, index, uniqueGroupId) {
    this.resetJoinOperator(eJoinOperatorAnd, index, this.isDefaultOperator("AND"), this.translate("andCondition"), uniqueGroupId);
  }
  resetJoinOperatorOr(eJoinOperatorOr, index, uniqueGroupId) {
    this.resetJoinOperator(eJoinOperatorOr, index, this.isDefaultOperator("OR"), this.translate("orCondition"), uniqueGroupId);
  }
  resetJoinOperator(eJoinOperator, index, value, label, uniqueGroupId) {
    this.updateJoinOperatorDisabled(eJoinOperator.setValue(value, true).setName(`ag-simple-filter-and-or-${this.getCompId()}-${uniqueGroupId}`).setLabel(label), index);
  }
  updateJoinOperatorsDisabled() {
    this.eJoinOperatorsAnd.forEach((eJoinOperator, index) => this.updateJoinOperatorDisabled(eJoinOperator, index));
    this.eJoinOperatorsOr.forEach((eJoinOperator, index) => this.updateJoinOperatorDisabled(eJoinOperator, index));
  }
  updateJoinOperatorDisabled(eJoinOperator, index) {
    eJoinOperator.setDisabled(this.isReadOnly() || index > 0);
  }
  resetInput(element) {
    this.setElementValue(element, null);
    this.setElementDisabled(element, this.isReadOnly());
  }
  setConditionIntoUi(model, position) {
    const values2 = this.mapValuesFromModel(model);
    this.forEachInput((element, index, elPosition, _2) => {
      if (elPosition !== position) {
        return;
      }
      this.setElementValue(element, values2[index] != null ? values2[index] : null);
    });
  }
  setValueFromFloatingFilter(value) {
    this.forEachInput((element, index, position, _2) => {
      this.setElementValue(element, index === 0 && position === 0 ? value : null);
    });
  }
  isDefaultOperator(operator) {
    return operator === this.defaultJoinOperator;
  }
  addChangedListeners(eType, position) {
    if (this.isReadOnly()) {
      return;
    }
    eType.onValueChange(this.listener);
    this.forEachPositionInput(position, (element) => {
      this.attachElementOnChange(element, this.listener);
    });
  }
  individualConditionPasses(params, filterModel) {
    const cellValue = this.getCellValue(params.node);
    const values2 = this.mapValuesFromModel(filterModel);
    const customFilterOption = this.optionsFactory.getCustomOption(filterModel.type);
    const customFilterResult = this.evaluateCustomFilter(customFilterOption, values2, cellValue);
    if (customFilterResult != null) {
      return customFilterResult;
    }
    if (cellValue == null) {
      return this.evaluateNullValue(filterModel.type);
    }
    return this.evaluateNonNullValue(values2, cellValue, filterModel, params);
  }
  evaluateCustomFilter(customFilterOption, values2, cellValue) {
    if (customFilterOption == null) {
      return;
    }
    const { predicate } = customFilterOption;
    if (predicate != null && !values2.some((v) => v == null)) {
      return predicate(values2, cellValue);
    }
    return;
  }
  isBlank(cellValue) {
    return cellValue == null || typeof cellValue === "string" && cellValue.trim().length === 0;
  }
  hasInvalidInputs() {
    return false;
  }
};
SimpleFilter.EMPTY = "empty";
SimpleFilter.BLANK = "blank";
SimpleFilter.NOT_BLANK = "notBlank";
SimpleFilter.EQUALS = "equals";
SimpleFilter.NOT_EQUAL = "notEqual";
SimpleFilter.LESS_THAN = "lessThan";
SimpleFilter.LESS_THAN_OR_EQUAL = "lessThanOrEqual";
SimpleFilter.GREATER_THAN = "greaterThan";
SimpleFilter.GREATER_THAN_OR_EQUAL = "greaterThanOrEqual";
SimpleFilter.IN_RANGE = "inRange";
SimpleFilter.CONTAINS = "contains";
SimpleFilter.NOT_CONTAINS = "notContains";
SimpleFilter.STARTS_WITH = "startsWith";
SimpleFilter.ENDS_WITH = "endsWith";
var ScalarFilter = class extends SimpleFilter {
  setParams(params) {
    super.setParams(params);
    this.scalarFilterParams = params;
  }
  evaluateNullValue(filterType) {
    switch (filterType) {
      case ScalarFilter.EQUALS:
      case ScalarFilter.NOT_EQUAL:
        if (this.scalarFilterParams.includeBlanksInEquals) {
          return true;
        }
        break;
      case ScalarFilter.GREATER_THAN:
      case ScalarFilter.GREATER_THAN_OR_EQUAL:
        if (this.scalarFilterParams.includeBlanksInGreaterThan) {
          return true;
        }
        break;
      case ScalarFilter.LESS_THAN:
      case ScalarFilter.LESS_THAN_OR_EQUAL:
        if (this.scalarFilterParams.includeBlanksInLessThan) {
          return true;
        }
        break;
      case ScalarFilter.IN_RANGE:
        if (this.scalarFilterParams.includeBlanksInRange) {
          return true;
        }
        break;
      case ScalarFilter.BLANK:
        return true;
      case ScalarFilter.NOT_BLANK:
        return false;
    }
    return false;
  }
  evaluateNonNullValue(values2, cellValue, filterModel) {
    const comparator = this.comparator();
    const compareResult = values2[0] != null ? comparator(values2[0], cellValue) : 0;
    switch (filterModel.type) {
      case ScalarFilter.EQUALS:
        return compareResult === 0;
      case ScalarFilter.NOT_EQUAL:
        return compareResult !== 0;
      case ScalarFilter.GREATER_THAN:
        return compareResult > 0;
      case ScalarFilter.GREATER_THAN_OR_EQUAL:
        return compareResult >= 0;
      case ScalarFilter.LESS_THAN:
        return compareResult < 0;
      case ScalarFilter.LESS_THAN_OR_EQUAL:
        return compareResult <= 0;
      case ScalarFilter.IN_RANGE: {
        const compareToResult = comparator(values2[1], cellValue);
        return this.scalarFilterParams.inRangeInclusive ? compareResult >= 0 && compareToResult <= 0 : compareResult > 0 && compareToResult < 0;
      }
      case ScalarFilter.BLANK:
        return this.isBlank(cellValue);
      case ScalarFilter.NOT_BLANK:
        return !this.isBlank(cellValue);
      default:
        console.warn('AG Grid: Unexpected type of filter "' + filterModel.type + '", it looks like the filter was configured with incorrect Filter Options');
        return true;
    }
  }
};
var __decorate$2h = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DEFAULT_MIN_YEAR = 1e3;
var DEFAULT_MAX_YEAR = Infinity;
var DateFilterModelFormatter = class extends SimpleFilterModelFormatter {
  constructor(dateFilterParams, localeService, optionsFactory) {
    super(localeService, optionsFactory);
    this.dateFilterParams = dateFilterParams;
  }
  conditionToString(condition, options) {
    const { type } = condition;
    const { numberOfInputs } = options || {};
    const isRange = type == SimpleFilter.IN_RANGE || numberOfInputs === 2;
    const dateFrom = parseDateTimeFromString(condition.dateFrom);
    const dateTo = parseDateTimeFromString(condition.dateTo);
    const format = this.dateFilterParams.inRangeFloatingFilterDateFormat;
    if (isRange) {
      const formattedFrom = dateFrom !== null ? dateToFormattedString(dateFrom, format) : "null";
      const formattedTo = dateTo !== null ? dateToFormattedString(dateTo, format) : "null";
      return `${formattedFrom}-${formattedTo}`;
    }
    if (dateFrom != null) {
      return dateToFormattedString(dateFrom, format);
    }
    return `${type}`;
  }
};
var DateFilter = class extends ScalarFilter {
  constructor() {
    super("dateFilter");
    this.eConditionPanelsFrom = [];
    this.eConditionPanelsTo = [];
    this.dateConditionFromComps = [];
    this.dateConditionToComps = [];
    this.minValidYear = DEFAULT_MIN_YEAR;
    this.maxValidYear = DEFAULT_MAX_YEAR;
  }
  afterGuiAttached(params) {
    super.afterGuiAttached(params);
    this.dateConditionFromComps[0].afterGuiAttached(params);
  }
  mapValuesFromModel(filterModel) {
    const { dateFrom, dateTo, type } = filterModel || {};
    return [
      dateFrom && parseDateTimeFromString(dateFrom) || null,
      dateTo && parseDateTimeFromString(dateTo) || null
    ].slice(0, this.getNumberOfInputs(type));
  }
  comparator() {
    return this.dateFilterParams.comparator ? this.dateFilterParams.comparator : this.defaultComparator.bind(this);
  }
  defaultComparator(filterDate, cellValue) {
    const cellAsDate = cellValue;
    if (cellValue == null || cellAsDate < filterDate) {
      return -1;
    }
    if (cellAsDate > filterDate) {
      return 1;
    }
    return 0;
  }
  setParams(params) {
    this.dateFilterParams = params;
    super.setParams(params);
    const yearParser = (param, fallback) => {
      if (params[param] != null) {
        if (!isNaN(params[param])) {
          return params[param] == null ? fallback : Number(params[param]);
        } else {
          console.warn(`AG Grid: DateFilter ${param} is not a number`);
        }
      }
      return fallback;
    };
    this.minValidYear = yearParser("minValidYear", DEFAULT_MIN_YEAR);
    this.maxValidYear = yearParser("maxValidYear", DEFAULT_MAX_YEAR);
    if (this.minValidYear > this.maxValidYear) {
      console.warn(`AG Grid: DateFilter minValidYear should be <= maxValidYear`);
    }
    this.filterModelFormatter = new DateFilterModelFormatter(this.dateFilterParams, this.localeService, this.optionsFactory);
  }
  createDateCompWrapper(element) {
    const dateCompWrapper = new DateCompWrapper(this.getContext(), this.userComponentFactory, {
      onDateChanged: () => this.onUiChanged(),
      filterParams: this.dateFilterParams
    }, element);
    this.addDestroyFunc(() => dateCompWrapper.destroy());
    return dateCompWrapper;
  }
  setElementValue(element, value) {
    element.setDate(value);
  }
  setElementDisplayed(element, displayed) {
    element.setDisplayed(displayed);
  }
  setElementDisabled(element, disabled) {
    element.setDisabled(disabled);
  }
  getDefaultFilterOptions() {
    return DateFilter.DEFAULT_FILTER_OPTIONS;
  }
  createValueElement() {
    const eCondition = document.createElement("div");
    eCondition.classList.add("ag-filter-body");
    this.createFromToElement(eCondition, this.eConditionPanelsFrom, this.dateConditionFromComps, "from");
    this.createFromToElement(eCondition, this.eConditionPanelsTo, this.dateConditionToComps, "to");
    return eCondition;
  }
  createFromToElement(eCondition, eConditionPanels, dateConditionComps, fromTo) {
    const eConditionPanel = document.createElement("div");
    eConditionPanel.classList.add(`ag-filter-${fromTo}`);
    eConditionPanel.classList.add(`ag-filter-date-${fromTo}`);
    eConditionPanels.push(eConditionPanel);
    eCondition.appendChild(eConditionPanel);
    dateConditionComps.push(this.createDateCompWrapper(eConditionPanel));
  }
  removeValueElements(startPosition, deleteCount) {
    this.removeDateComps(this.dateConditionFromComps, startPosition, deleteCount);
    this.removeDateComps(this.dateConditionToComps, startPosition, deleteCount);
    this.removeItems(this.eConditionPanelsFrom, startPosition, deleteCount);
    this.removeItems(this.eConditionPanelsTo, startPosition, deleteCount);
  }
  removeDateComps(components, startPosition, deleteCount) {
    const removedComponents = this.removeItems(components, startPosition, deleteCount);
    removedComponents.forEach((comp) => comp.destroy());
  }
  isConditionUiComplete(position) {
    if (!super.isConditionUiComplete(position)) {
      return false;
    }
    const isValidDate = (value) => value != null && value.getUTCFullYear() >= this.minValidYear && value.getUTCFullYear() <= this.maxValidYear;
    let valid = true;
    this.forEachInput((element, index, elPosition, numberOfInputs) => {
      if (elPosition !== position || !valid || index >= numberOfInputs) {
        return;
      }
      valid = valid && isValidDate(element.getDate());
    });
    return valid;
  }
  areSimpleModelsEqual(aSimple, bSimple) {
    return aSimple.dateFrom === bSimple.dateFrom && aSimple.dateTo === bSimple.dateTo && aSimple.type === bSimple.type;
  }
  getFilterType() {
    return "date";
  }
  createCondition(position) {
    const type = this.getConditionType(position);
    const model = {};
    const values2 = this.getValues(position);
    if (values2.length > 0) {
      model.dateFrom = serialiseDate(values2[0]);
    }
    if (values2.length > 1) {
      model.dateTo = serialiseDate(values2[1]);
    }
    return Object.assign({ dateFrom: null, dateTo: null, filterType: this.getFilterType(), type }, model);
  }
  resetPlaceholder() {
    const globalTranslate = this.localeService.getLocaleTextFunc();
    const placeholder = this.translate("dateFormatOoo");
    const ariaLabel = globalTranslate("ariaFilterValue", "Filter Value");
    this.forEachInput((element) => {
      element.setInputPlaceholder(placeholder);
      element.setInputAriaLabel(ariaLabel);
    });
  }
  getInputs(position) {
    if (position >= this.dateConditionFromComps.length) {
      return [null, null];
    }
    return [this.dateConditionFromComps[position], this.dateConditionToComps[position]];
  }
  getValues(position) {
    const result = [];
    this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
      if (index < numberOfInputs) {
        result.push(element.getDate());
      }
    });
    return result;
  }
  getModelAsString(model) {
    var _a;
    return (_a = this.filterModelFormatter.getModelAsString(model)) !== null && _a !== void 0 ? _a : "";
  }
};
DateFilter.DEFAULT_FILTER_OPTIONS = [
  ScalarFilter.EQUALS,
  ScalarFilter.GREATER_THAN,
  ScalarFilter.LESS_THAN,
  ScalarFilter.NOT_EQUAL,
  ScalarFilter.IN_RANGE,
  ScalarFilter.BLANK,
  ScalarFilter.NOT_BLANK
];
__decorate$2h([
  Autowired("userComponentFactory")
], DateFilter.prototype, "userComponentFactory", void 0);
var SimpleFloatingFilter = class extends Component {
  getDefaultDebounceMs() {
    return 0;
  }
  destroy() {
    super.destroy();
  }
  isEventFromFloatingFilter(event) {
    return event && event.afterFloatingFilter;
  }
  isEventFromDataChange(event) {
    return event === null || event === void 0 ? void 0 : event.afterDataChange;
  }
  getLastType() {
    return this.lastType;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setLastTypeFromModel(model) {
    if (!model) {
      this.lastType = this.optionsFactory.getDefaultOption();
      return;
    }
    const isCombined = model.operator;
    let condition;
    if (isCombined) {
      const combinedModel = model;
      condition = combinedModel.conditions[0];
    } else {
      condition = model;
    }
    this.lastType = condition.type;
  }
  canWeEditAfterModelFromParentFilter(model) {
    if (!model) {
      return this.isTypeEditable(this.lastType);
    }
    const isCombined = model.operator;
    if (isCombined) {
      return false;
    }
    const simpleModel = model;
    return this.isTypeEditable(simpleModel.type);
  }
  init(params) {
    this.optionsFactory = new OptionsFactory();
    this.optionsFactory.init(params.filterParams, this.getDefaultFilterOptions());
    this.lastType = this.optionsFactory.getDefaultOption();
    this.readOnly = !!params.filterParams.readOnly;
    const editable = this.isTypeEditable(this.lastType);
    this.setEditable(editable);
  }
  doesFilterHaveSingleInput(filterType) {
    const customFilterOption = this.optionsFactory.getCustomOption(filterType);
    const { numberOfInputs } = customFilterOption || {};
    return numberOfInputs == null || numberOfInputs == 1;
  }
  isTypeEditable(type) {
    const uneditableTypes = [
      SimpleFilter.IN_RANGE,
      SimpleFilter.EMPTY,
      SimpleFilter.BLANK,
      SimpleFilter.NOT_BLANK
    ];
    return !!type && !this.isReadOnly() && this.doesFilterHaveSingleInput(type) && uneditableTypes.indexOf(type) < 0;
  }
};
var __decorate$2g = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DateFloatingFilter = class extends SimpleFloatingFilter {
  constructor() {
    super(`
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eReadOnlyText"></ag-input-text-field>
                <div ref="eDateWrapper" style="display: flex;"></div>
            </div>`);
  }
  getDefaultFilterOptions() {
    return DateFilter.DEFAULT_FILTER_OPTIONS;
  }
  init(params) {
    super.init(params);
    this.params = params;
    this.filterParams = params.filterParams;
    this.createDateComponent();
    const translate = this.localeService.getLocaleTextFunc();
    this.eReadOnlyText.setDisabled(true).setInputAriaLabel(translate("ariaDateFilterInput", "Date Filter Input"));
    this.filterModelFormatter = new DateFilterModelFormatter(this.filterParams, this.localeService, this.optionsFactory);
  }
  setEditable(editable) {
    setDisplayed(this.eDateWrapper, editable);
    setDisplayed(this.eReadOnlyText.getGui(), !editable);
  }
  onParentModelChanged(model, event) {
    if (this.isEventFromFloatingFilter(event) || this.isEventFromDataChange(event)) {
      return;
    }
    super.setLastTypeFromModel(model);
    const allowEditing = !this.isReadOnly() && this.canWeEditAfterModelFromParentFilter(model);
    this.setEditable(allowEditing);
    if (allowEditing) {
      if (model) {
        const dateModel = model;
        this.dateComp.setDate(parseDateTimeFromString(dateModel.dateFrom));
      } else {
        this.dateComp.setDate(null);
      }
      this.eReadOnlyText.setValue("");
    } else {
      this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(model));
      this.dateComp.setDate(null);
    }
  }
  onDateChanged() {
    const filterValueDate = this.dateComp.getDate();
    const filterValueText = serialiseDate(filterValueDate);
    this.params.parentFilterInstance((filterInstance) => {
      if (filterInstance) {
        const date = parseDateTimeFromString(filterValueText);
        filterInstance.onFloatingFilterChanged(this.getLastType() || null, date);
      }
    });
  }
  createDateComponent() {
    const debounceMs = ProvidedFilter.getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs());
    const dateComponentParams = {
      onDateChanged: debounce(this.onDateChanged.bind(this), debounceMs),
      filterParams: this.params.column.getColDef().filterParams
    };
    this.dateComp = new DateCompWrapper(this.getContext(), this.userComponentFactory, dateComponentParams, this.eDateWrapper);
    this.addDestroyFunc(() => this.dateComp.destroy());
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
};
__decorate$2g([
  Autowired("userComponentFactory")
], DateFloatingFilter.prototype, "userComponentFactory", void 0);
__decorate$2g([
  RefSelector("eReadOnlyText")
], DateFloatingFilter.prototype, "eReadOnlyText", void 0);
__decorate$2g([
  RefSelector("eDateWrapper")
], DateFloatingFilter.prototype, "eDateWrapper", void 0);
var __decorate$2f = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultDateComponent = class extends Component {
  constructor() {
    super(`
            <div class="ag-filter-filter">
                <ag-input-text-field class="ag-date-filter" ref="eDateInput"></ag-input-text-field>
            </div>`);
  }
  destroy() {
    super.destroy();
  }
  init(params) {
    const eDocument = this.gridOptionsService.getDocument();
    const inputElement = this.eDateInput.getInputElement();
    const shouldUseBrowserDatePicker = this.shouldUseBrowserDatePicker(params);
    if (shouldUseBrowserDatePicker) {
      inputElement.type = "date";
    }
    const usingSafariDatePicker = shouldUseBrowserDatePicker && isBrowserSafari();
    this.addManagedListener(inputElement, "mousedown", () => {
      if (this.eDateInput.isDisabled() || usingSafariDatePicker) {
        return;
      }
      inputElement.focus();
    });
    this.addManagedListener(inputElement, "input", (e) => {
      if (e.target !== eDocument.activeElement) {
        return;
      }
      if (this.eDateInput.isDisabled()) {
        return;
      }
      params.onDateChanged();
    });
    const { minValidYear, maxValidYear } = params.filterParams || {};
    if (minValidYear) {
      inputElement.min = `${minValidYear}-01-01`;
    }
    if (maxValidYear) {
      inputElement.max = `${maxValidYear}-12-31`;
    }
  }
  getDate() {
    return parseDateTimeFromString(this.eDateInput.getValue());
  }
  setDate(date) {
    this.eDateInput.setValue(serialiseDate(date, false));
  }
  setInputPlaceholder(placeholder) {
    this.eDateInput.setInputPlaceholder(placeholder);
  }
  setDisabled(disabled) {
    this.eDateInput.setDisabled(disabled);
  }
  afterGuiAttached(params) {
    if (!params || !params.suppressFocus) {
      this.eDateInput.getInputElement().focus();
    }
  }
  shouldUseBrowserDatePicker(params) {
    if (params.filterParams && params.filterParams.browserDatePicker != null) {
      return params.filterParams.browserDatePicker;
    }
    return isBrowserChrome() || isBrowserFirefox() || isBrowserSafari() && getSafariVersion() >= 14.1;
  }
};
__decorate$2f([
  RefSelector("eDateInput")
], DefaultDateComponent.prototype, "eDateInput", void 0);
var AgInputTextField = class extends AgAbstractInputField {
  constructor(config, className = "ag-text-field", inputType = "text") {
    super(config, className, inputType);
  }
  postConstruct() {
    super.postConstruct();
    if (this.config.allowedCharPattern) {
      this.preventDisallowedCharacters();
    }
  }
  setValue(value, silent) {
    const ret = super.setValue(value, silent);
    if (this.eInput.value !== value) {
      this.eInput.value = exists(value) ? value : "";
    }
    return ret;
  }
  setStartValue(value) {
    this.setValue(value, true);
  }
  preventDisallowedCharacters() {
    const pattern = new RegExp(`[${this.config.allowedCharPattern}]`);
    const preventCharacters = (event) => {
      if (!isEventFromPrintableCharacter(event)) {
        return;
      }
      if (event.key && !pattern.test(event.key)) {
        event.preventDefault();
      }
    };
    this.addManagedListener(this.eInput, "keydown", preventCharacters);
    this.addManagedListener(this.eInput, "paste", (e) => {
      var _a;
      const text = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text");
      if (text && text.split("").some((c) => !pattern.test(c))) {
        e.preventDefault();
      }
    });
  }
};
var AgInputNumberField = class extends AgInputTextField {
  constructor(config) {
    super(config, "ag-number-field", "number");
  }
  postConstruct() {
    super.postConstruct();
    this.addManagedListener(this.eInput, "blur", () => {
      const floatedValue = parseFloat(this.eInput.value);
      const value = isNaN(floatedValue) ? "" : this.normalizeValue(floatedValue.toString());
      if (this.value !== value) {
        this.setValue(value);
      }
    });
    this.addManagedListener(this.eInput, "wheel", this.onWheel.bind(this));
    this.eInput.step = "any";
  }
  onWheel(e) {
    if (document.activeElement === this.eInput) {
      e.preventDefault();
    }
  }
  normalizeValue(value) {
    if (value === "") {
      return "";
    }
    if (this.precision != null) {
      value = this.adjustPrecision(value);
    }
    const val = parseFloat(value);
    if (this.min != null && val < this.min) {
      value = this.min.toString();
    } else if (this.max != null && val > this.max) {
      value = this.max.toString();
    }
    return value;
  }
  adjustPrecision(value, isScientificNotation) {
    if (this.precision == null) {
      return value;
    }
    if (isScientificNotation) {
      const floatString = parseFloat(value).toFixed(this.precision);
      return parseFloat(floatString).toString();
    }
    const parts = String(value).split(".");
    if (parts.length > 1) {
      if (parts[1].length <= this.precision) {
        return value;
      } else if (this.precision > 0) {
        return `${parts[0]}.${parts[1].slice(0, this.precision)}`;
      }
    }
    return parts[0];
  }
  setMin(min) {
    if (this.min === min) {
      return this;
    }
    this.min = min;
    addOrRemoveAttribute(this.eInput, "min", min);
    return this;
  }
  setMax(max) {
    if (this.max === max) {
      return this;
    }
    this.max = max;
    addOrRemoveAttribute(this.eInput, "max", max);
    return this;
  }
  setPrecision(precision) {
    this.precision = precision;
    return this;
  }
  setStep(step) {
    if (this.step === step) {
      return this;
    }
    this.step = step;
    addOrRemoveAttribute(this.eInput, "step", step);
    return this;
  }
  setValue(value, silent) {
    return this.setValueOrInputValue((v) => super.setValue(v, silent), () => this, value);
  }
  setStartValue(value) {
    return this.setValueOrInputValue((v) => super.setValue(v, true), (v) => {
      this.eInput.value = v;
    }, value);
  }
  setValueOrInputValue(setValueFunc, setInputValueOnlyFunc, value) {
    if (exists(value)) {
      let setInputValueOnly = this.isScientificNotation(value);
      if (setInputValueOnly && this.eInput.validity.valid) {
        return setValueFunc(value);
      }
      if (!setInputValueOnly) {
        value = this.adjustPrecision(value);
        const normalizedValue = this.normalizeValue(value);
        setInputValueOnly = value != normalizedValue;
      }
      if (setInputValueOnly) {
        return setInputValueOnlyFunc(value);
      }
    }
    return setValueFunc(value);
  }
  getValue() {
    if (!this.eInput.validity.valid) {
      return void 0;
    }
    const inputValue = this.eInput.value;
    if (this.isScientificNotation(inputValue)) {
      return this.adjustPrecision(inputValue, true);
    }
    return super.getValue();
  }
  isScientificNotation(value) {
    return typeof value === "string" && value.includes("e");
  }
};
var NumberFilterModelFormatter = class extends SimpleFilterModelFormatter {
  conditionToString(condition, options) {
    const { numberOfInputs } = options || {};
    const isRange = condition.type == SimpleFilter.IN_RANGE || numberOfInputs === 2;
    if (isRange) {
      return `${condition.filter}-${condition.filterTo}`;
    }
    if (condition.filter != null) {
      return `${condition.filter}`;
    }
    return `${condition.type}`;
  }
};
function getAllowedCharPattern(filterParams) {
  const { allowedCharPattern } = filterParams !== null && filterParams !== void 0 ? filterParams : {};
  return allowedCharPattern !== null && allowedCharPattern !== void 0 ? allowedCharPattern : null;
}
var NumberFilter = class extends ScalarFilter {
  constructor() {
    super("numberFilter");
    this.eValuesFrom = [];
    this.eValuesTo = [];
  }
  mapValuesFromModel(filterModel) {
    const { filter, filterTo, type } = filterModel || {};
    return [
      this.processValue(filter),
      this.processValue(filterTo)
    ].slice(0, this.getNumberOfInputs(type));
  }
  getDefaultDebounceMs() {
    return 500;
  }
  comparator() {
    return (left, right) => {
      if (left === right) {
        return 0;
      }
      return left < right ? 1 : -1;
    };
  }
  setParams(params) {
    this.numberFilterParams = params;
    super.setParams(params);
    this.filterModelFormatter = new NumberFilterModelFormatter(this.localeService, this.optionsFactory);
  }
  getDefaultFilterOptions() {
    return NumberFilter.DEFAULT_FILTER_OPTIONS;
  }
  createValueElement() {
    const allowedCharPattern = getAllowedCharPattern(this.numberFilterParams);
    const eCondition = document.createElement("div");
    eCondition.classList.add("ag-filter-body");
    setAriaRole(eCondition, "presentation");
    this.createFromToElement(eCondition, this.eValuesFrom, "from", allowedCharPattern);
    this.createFromToElement(eCondition, this.eValuesTo, "to", allowedCharPattern);
    return eCondition;
  }
  createFromToElement(eCondition, eValues, fromTo, allowedCharPattern) {
    const eValue = this.createManagedBean(allowedCharPattern ? new AgInputTextField({ allowedCharPattern }) : new AgInputNumberField());
    eValue.addCssClass(`ag-filter-${fromTo}`);
    eValue.addCssClass("ag-filter-filter");
    eValues.push(eValue);
    eCondition.appendChild(eValue.getGui());
  }
  removeValueElements(startPosition, deleteCount) {
    this.removeComponents(this.eValuesFrom, startPosition, deleteCount);
    this.removeComponents(this.eValuesTo, startPosition, deleteCount);
  }
  getValues(position) {
    const result = [];
    this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
      if (index < numberOfInputs) {
        result.push(this.processValue(this.stringToFloat(element.getValue())));
      }
    });
    return result;
  }
  areSimpleModelsEqual(aSimple, bSimple) {
    return aSimple.filter === bSimple.filter && aSimple.filterTo === bSimple.filterTo && aSimple.type === bSimple.type;
  }
  getFilterType() {
    return "number";
  }
  processValue(value) {
    if (value == null) {
      return null;
    }
    return isNaN(value) ? null : value;
  }
  stringToFloat(value) {
    if (typeof value === "number") {
      return value;
    }
    let filterText = makeNull(value);
    if (filterText != null && filterText.trim() === "") {
      filterText = null;
    }
    if (this.numberFilterParams.numberParser) {
      return this.numberFilterParams.numberParser(filterText);
    }
    return filterText == null || filterText.trim() === "-" ? null : parseFloat(filterText);
  }
  createCondition(position) {
    const type = this.getConditionType(position);
    const model = {
      filterType: this.getFilterType(),
      type
    };
    const values2 = this.getValues(position);
    if (values2.length > 0) {
      model.filter = values2[0];
    }
    if (values2.length > 1) {
      model.filterTo = values2[1];
    }
    return model;
  }
  getInputs(position) {
    if (position >= this.eValuesFrom.length) {
      return [null, null];
    }
    return [this.eValuesFrom[position], this.eValuesTo[position]];
  }
  getModelAsString(model) {
    var _a;
    return (_a = this.filterModelFormatter.getModelAsString(model)) !== null && _a !== void 0 ? _a : "";
  }
  hasInvalidInputs() {
    let invalidInputs = false;
    this.forEachInput((element) => {
      if (!element.getInputElement().validity.valid) {
        invalidInputs = true;
        return;
      }
    });
    return invalidInputs;
  }
};
NumberFilter.DEFAULT_FILTER_OPTIONS = [
  ScalarFilter.EQUALS,
  ScalarFilter.NOT_EQUAL,
  ScalarFilter.LESS_THAN,
  ScalarFilter.LESS_THAN_OR_EQUAL,
  ScalarFilter.GREATER_THAN,
  ScalarFilter.GREATER_THAN_OR_EQUAL,
  ScalarFilter.IN_RANGE,
  ScalarFilter.BLANK,
  ScalarFilter.NOT_BLANK
];
var TextFilterModelFormatter = class extends SimpleFilterModelFormatter {
  conditionToString(condition, options) {
    const { numberOfInputs } = options || {};
    const isRange = condition.type == SimpleFilter.IN_RANGE || numberOfInputs === 2;
    if (isRange) {
      return `${condition.filter}-${condition.filterTo}`;
    }
    if (condition.filter != null) {
      return `${condition.filter}`;
    }
    return `${condition.type}`;
  }
};
var TextFilter = class extends SimpleFilter {
  constructor() {
    super("textFilter");
    this.eValuesFrom = [];
    this.eValuesTo = [];
  }
  static trimInput(value) {
    const trimmedInput = value && value.trim();
    return trimmedInput === "" ? value : trimmedInput;
  }
  getDefaultDebounceMs() {
    return 500;
  }
  setParams(params) {
    this.textFilterParams = params;
    super.setParams(params);
    this.matcher = this.getTextMatcher();
    this.formatter = this.textFilterParams.textFormatter || (this.textFilterParams.caseSensitive ? TextFilter.DEFAULT_FORMATTER : TextFilter.DEFAULT_LOWERCASE_FORMATTER);
    this.filterModelFormatter = new TextFilterModelFormatter(this.localeService, this.optionsFactory);
  }
  getTextMatcher() {
    const legacyComparator = this.textFilterParams.textCustomComparator;
    if (legacyComparator) {
      _.doOnce(() => console.warn("AG Grid - textCustomComparator is deprecated, use textMatcher instead."), "textCustomComparator.deprecated");
      return ({ filterOption, value, filterText }) => legacyComparator(filterOption, value, filterText);
    }
    return this.textFilterParams.textMatcher || TextFilter.DEFAULT_MATCHER;
  }
  createCondition(position) {
    const type = this.getConditionType(position);
    const model = {
      filterType: this.getFilterType(),
      type
    };
    const values2 = this.getValues(position);
    if (values2.length > 0) {
      model.filter = values2[0];
    }
    if (values2.length > 1) {
      model.filterTo = values2[1];
    }
    return model;
  }
  getFilterType() {
    return "text";
  }
  areSimpleModelsEqual(aSimple, bSimple) {
    return aSimple.filter === bSimple.filter && aSimple.filterTo === bSimple.filterTo && aSimple.type === bSimple.type;
  }
  getInputs(position) {
    if (position >= this.eValuesFrom.length) {
      return [null, null];
    }
    return [this.eValuesFrom[position], this.eValuesTo[position]];
  }
  getValues(position) {
    const result = [];
    this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
      if (index < numberOfInputs) {
        const value = makeNull(element.getValue());
        const cleanValue = (this.textFilterParams.trimInput ? TextFilter.trimInput(value) : value) || null;
        result.push(cleanValue);
        element.setValue(cleanValue, true);
      }
    });
    return result;
  }
  getDefaultFilterOptions() {
    return TextFilter.DEFAULT_FILTER_OPTIONS;
  }
  createValueElement() {
    const eCondition = document.createElement("div");
    eCondition.classList.add("ag-filter-body");
    setAriaRole(eCondition, "presentation");
    this.createFromToElement(eCondition, this.eValuesFrom, "from");
    this.createFromToElement(eCondition, this.eValuesTo, "to");
    return eCondition;
  }
  createFromToElement(eCondition, eValues, fromTo) {
    const eValue = this.createManagedBean(new AgInputTextField());
    eValue.addCssClass(`ag-filter-${fromTo}`);
    eValue.addCssClass("ag-filter-filter");
    eValues.push(eValue);
    eCondition.appendChild(eValue.getGui());
  }
  removeValueElements(startPosition, deleteCount) {
    this.removeComponents(this.eValuesFrom, startPosition, deleteCount);
    this.removeComponents(this.eValuesTo, startPosition, deleteCount);
  }
  mapValuesFromModel(filterModel) {
    const { filter, filterTo, type } = filterModel || {};
    return [
      filter || null,
      filterTo || null
    ].slice(0, this.getNumberOfInputs(type));
  }
  evaluateNullValue(filterType) {
    const filterTypesAllowNulls = [
      SimpleFilter.NOT_EQUAL,
      SimpleFilter.NOT_CONTAINS,
      SimpleFilter.BLANK
    ];
    return filterType ? filterTypesAllowNulls.indexOf(filterType) >= 0 : false;
  }
  evaluateNonNullValue(values2, cellValue, filterModel, params) {
    const formattedValues = values2.map((v) => this.formatter(v)) || [];
    const cellValueFormatted = this.formatter(cellValue);
    const { api, colDef, column, columnApi, context, textFormatter } = this.textFilterParams;
    if (filterModel.type === SimpleFilter.BLANK) {
      return this.isBlank(cellValue);
    } else if (filterModel.type === SimpleFilter.NOT_BLANK) {
      return !this.isBlank(cellValue);
    }
    const matcherParams = {
      api,
      colDef,
      column,
      columnApi,
      context,
      node: params.node,
      data: params.data,
      filterOption: filterModel.type,
      value: cellValueFormatted,
      textFormatter
    };
    return formattedValues.some((v) => this.matcher(Object.assign(Object.assign({}, matcherParams), { filterText: v })));
  }
  getModelAsString(model) {
    var _a;
    return (_a = this.filterModelFormatter.getModelAsString(model)) !== null && _a !== void 0 ? _a : "";
  }
};
TextFilter.DEFAULT_FILTER_OPTIONS = [
  SimpleFilter.CONTAINS,
  SimpleFilter.NOT_CONTAINS,
  SimpleFilter.EQUALS,
  SimpleFilter.NOT_EQUAL,
  SimpleFilter.STARTS_WITH,
  SimpleFilter.ENDS_WITH,
  SimpleFilter.BLANK,
  SimpleFilter.NOT_BLANK
];
TextFilter.DEFAULT_FORMATTER = (from) => from;
TextFilter.DEFAULT_LOWERCASE_FORMATTER = (from) => from == null ? null : from.toString().toLowerCase();
TextFilter.DEFAULT_MATCHER = ({ filterOption, value, filterText }) => {
  if (filterText == null) {
    return false;
  }
  switch (filterOption) {
    case TextFilter.CONTAINS:
      return value.indexOf(filterText) >= 0;
    case TextFilter.NOT_CONTAINS:
      return value.indexOf(filterText) < 0;
    case TextFilter.EQUALS:
      return value === filterText;
    case TextFilter.NOT_EQUAL:
      return value != filterText;
    case TextFilter.STARTS_WITH:
      return value.indexOf(filterText) === 0;
    case TextFilter.ENDS_WITH:
      const index = value.lastIndexOf(filterText);
      return index >= 0 && index === value.length - filterText.length;
    default:
      return false;
  }
};
var __decorate$2e = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FloatingFilterTextInputService = class extends BeanStub {
  constructor(params) {
    super();
    this.params = params;
  }
  setupGui(parentElement) {
    this.eFloatingFilterTextInput = this.createManagedBean(new AgInputTextField(this.params.config));
    this.eFloatingFilterTextInput.setInputAriaLabel(this.params.ariaLabel);
    parentElement.appendChild(this.eFloatingFilterTextInput.getGui());
  }
  setEditable(editable) {
    this.eFloatingFilterTextInput.setDisabled(!editable);
  }
  getValue() {
    return this.eFloatingFilterTextInput.getValue();
  }
  setValue(value, silent) {
    this.eFloatingFilterTextInput.setValue(value, silent);
  }
  addValueChangedListener(listener) {
    const inputGui = this.eFloatingFilterTextInput.getGui();
    this.addManagedListener(inputGui, "input", listener);
    this.addManagedListener(inputGui, "keydown", listener);
  }
};
var TextInputFloatingFilter = class extends SimpleFloatingFilter {
  postConstruct() {
    this.setTemplate(`
            <div class="ag-floating-filter-input" role="presentation" ref="eFloatingFilterInputContainer"></div>
        `);
  }
  getDefaultDebounceMs() {
    return 500;
  }
  onParentModelChanged(model, event) {
    if (this.isEventFromFloatingFilter(event) || this.isEventFromDataChange(event)) {
      return;
    }
    this.setLastTypeFromModel(model);
    this.setEditable(this.canWeEditAfterModelFromParentFilter(model));
    this.floatingFilterInputService.setValue(this.getFilterModelFormatter().getModelAsString(model));
  }
  init(params) {
    this.params = params;
    const displayName = this.columnModel.getDisplayNameForColumn(params.column, "header", true);
    const translate = this.localeService.getLocaleTextFunc();
    const ariaLabel = `${displayName} ${translate("ariaFilterInput", "Filter Input")}`;
    this.floatingFilterInputService = this.createFloatingFilterInputService(ariaLabel);
    this.floatingFilterInputService.setupGui(this.eFloatingFilterInputContainer);
    super.init(params);
    this.applyActive = ProvidedFilter.isUseApplyButton(this.params.filterParams);
    if (!this.isReadOnly()) {
      const debounceMs = ProvidedFilter.getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs());
      const toDebounce = debounce(this.syncUpWithParentFilter.bind(this), debounceMs);
      this.floatingFilterInputService.addValueChangedListener(toDebounce);
    }
  }
  syncUpWithParentFilter(e) {
    const isEnterKey = e.key === KeyCode.ENTER;
    if (this.applyActive && !isEnterKey) {
      return;
    }
    let value = this.floatingFilterInputService.getValue();
    if (this.params.filterParams.trimInput) {
      value = TextFilter.trimInput(value);
      this.floatingFilterInputService.setValue(value, true);
    }
    this.params.parentFilterInstance((filterInstance) => {
      if (filterInstance) {
        filterInstance.onFloatingFilterChanged(this.getLastType() || null, value || null);
      }
    });
  }
  setEditable(editable) {
    this.floatingFilterInputService.setEditable(editable);
  }
};
__decorate$2e([
  Autowired("columnModel")
], TextInputFloatingFilter.prototype, "columnModel", void 0);
__decorate$2e([
  RefSelector("eFloatingFilterInputContainer")
], TextInputFloatingFilter.prototype, "eFloatingFilterInputContainer", void 0);
__decorate$2e([
  PostConstruct
], TextInputFloatingFilter.prototype, "postConstruct", null);
var FloatingFilterNumberInputService = class extends BeanStub {
  constructor(params) {
    super();
    this.params = params;
    this.numberInputActive = true;
  }
  setupGui(parentElement) {
    this.eFloatingFilterNumberInput = this.createManagedBean(new AgInputNumberField());
    this.eFloatingFilterTextInput = this.createManagedBean(new AgInputTextField());
    this.eFloatingFilterTextInput.setDisabled(true);
    this.eFloatingFilterNumberInput.setInputAriaLabel(this.params.ariaLabel);
    this.eFloatingFilterTextInput.setInputAriaLabel(this.params.ariaLabel);
    parentElement.appendChild(this.eFloatingFilterNumberInput.getGui());
    parentElement.appendChild(this.eFloatingFilterTextInput.getGui());
  }
  setEditable(editable) {
    this.numberInputActive = editable;
    this.eFloatingFilterNumberInput.setDisplayed(this.numberInputActive);
    this.eFloatingFilterTextInput.setDisplayed(!this.numberInputActive);
  }
  getValue() {
    return this.getActiveInputElement().getValue();
  }
  setValue(value, silent) {
    this.getActiveInputElement().setValue(value, silent);
  }
  getActiveInputElement() {
    return this.numberInputActive ? this.eFloatingFilterNumberInput : this.eFloatingFilterTextInput;
  }
  addValueChangedListener(listener) {
    this.setupListeners(this.eFloatingFilterNumberInput.getGui(), listener);
    this.setupListeners(this.eFloatingFilterTextInput.getGui(), listener);
  }
  setupListeners(element, listener) {
    this.addManagedListener(element, "input", listener);
    this.addManagedListener(element, "keydown", listener);
  }
};
var NumberFloatingFilter = class extends TextInputFloatingFilter {
  init(params) {
    super.init(params);
    this.filterModelFormatter = new NumberFilterModelFormatter(this.localeService, this.optionsFactory);
  }
  getDefaultFilterOptions() {
    return NumberFilter.DEFAULT_FILTER_OPTIONS;
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
  createFloatingFilterInputService(ariaLabel) {
    const allowedCharPattern = getAllowedCharPattern(this.params.filterParams);
    if (allowedCharPattern) {
      return this.createManagedBean(new FloatingFilterTextInputService({
        config: { allowedCharPattern },
        ariaLabel
      }));
    }
    return this.createManagedBean(new FloatingFilterNumberInputService({ ariaLabel }));
  }
};
var TextFloatingFilter = class extends TextInputFloatingFilter {
  init(params) {
    super.init(params);
    this.filterModelFormatter = new TextFilterModelFormatter(this.localeService, this.optionsFactory);
  }
  getDefaultFilterOptions() {
    return TextFilter.DEFAULT_FILTER_OPTIONS;
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
  createFloatingFilterInputService(ariaLabel) {
    return this.createManagedBean(new FloatingFilterTextInputService({
      ariaLabel
    }));
  }
};
var TouchListener = class {
  constructor(eElement, preventMouseClick = false) {
    this.destroyFuncs = [];
    this.touching = false;
    this.eventService = new EventService();
    this.eElement = eElement;
    this.preventMouseClick = preventMouseClick;
    const startListener = this.onTouchStart.bind(this);
    const moveListener = this.onTouchMove.bind(this);
    const endListener = this.onTouchEnd.bind(this);
    this.eElement.addEventListener("touchstart", startListener, { passive: true });
    this.eElement.addEventListener("touchmove", moveListener, { passive: true });
    this.eElement.addEventListener("touchend", endListener, { passive: false });
    this.destroyFuncs.push(() => {
      this.eElement.removeEventListener("touchstart", startListener, { passive: true });
      this.eElement.removeEventListener("touchmove", moveListener, { passive: true });
      this.eElement.removeEventListener("touchend", endListener, { passive: false });
    });
  }
  getActiveTouch(touchList) {
    for (let i = 0; i < touchList.length; i++) {
      const matches = touchList[i].identifier === this.touchStart.identifier;
      if (matches) {
        return touchList[i];
      }
    }
    return null;
  }
  addEventListener(eventType, listener) {
    this.eventService.addEventListener(eventType, listener);
  }
  removeEventListener(eventType, listener) {
    this.eventService.removeEventListener(eventType, listener);
  }
  onTouchStart(touchEvent) {
    if (this.touching) {
      return;
    }
    this.touchStart = touchEvent.touches[0];
    this.touching = true;
    this.moved = false;
    const touchStartCopy = this.touchStart;
    window.setTimeout(() => {
      const touchesMatch = this.touchStart === touchStartCopy;
      if (this.touching && touchesMatch && !this.moved) {
        this.moved = true;
        const event = {
          type: TouchListener.EVENT_LONG_TAP,
          touchStart: this.touchStart,
          touchEvent
        };
        this.eventService.dispatchEvent(event);
      }
    }, 500);
  }
  onTouchMove(touchEvent) {
    if (!this.touching) {
      return;
    }
    const touch = this.getActiveTouch(touchEvent.touches);
    if (!touch) {
      return;
    }
    const eventIsFarAway = !areEventsNear(touch, this.touchStart, 4);
    if (eventIsFarAway) {
      this.moved = true;
    }
  }
  onTouchEnd(touchEvent) {
    if (!this.touching) {
      return;
    }
    if (!this.moved) {
      const event = {
        type: TouchListener.EVENT_TAP,
        touchStart: this.touchStart
      };
      this.eventService.dispatchEvent(event);
      this.checkForDoubleTap();
    }
    if (this.preventMouseClick && touchEvent.cancelable) {
      touchEvent.preventDefault();
    }
    this.touching = false;
  }
  checkForDoubleTap() {
    const now = new Date().getTime();
    if (this.lastTapTime && this.lastTapTime > 0) {
      const interval = now - this.lastTapTime;
      if (interval > TouchListener.DOUBLE_TAP_MILLIS) {
        const event = {
          type: TouchListener.EVENT_DOUBLE_TAP,
          touchStart: this.touchStart
        };
        this.eventService.dispatchEvent(event);
        this.lastTapTime = null;
      } else {
        this.lastTapTime = now;
      }
    } else {
      this.lastTapTime = now;
    }
  }
  destroy() {
    this.destroyFuncs.forEach((func) => func());
  }
};
TouchListener.EVENT_TAP = "tap";
TouchListener.EVENT_DOUBLE_TAP = "doubleTap";
TouchListener.EVENT_LONG_TAP = "longTap";
TouchListener.DOUBLE_TAP_MILLIS = 500;
var __decorate$2d = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SortIndicatorComp = class extends Component {
  constructor(skipTemplate) {
    super();
    if (!skipTemplate) {
      this.setTemplate(SortIndicatorComp.TEMPLATE);
    }
  }
  attachCustomElements(eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone) {
    this.eSortOrder = eSortOrder;
    this.eSortAsc = eSortAsc;
    this.eSortDesc = eSortDesc;
    this.eSortMixed = eSortMixed;
    this.eSortNone = eSortNone;
  }
  setupSort(column, suppressOrder = false) {
    this.column = column;
    this.suppressOrder = suppressOrder;
    this.setupMultiSortIndicator();
    const canSort = !!this.column.getColDef().sortable;
    if (!canSort) {
      return;
    }
    this.addInIcon("sortAscending", this.eSortAsc, column);
    this.addInIcon("sortDescending", this.eSortDesc, column);
    this.addInIcon("sortUnSort", this.eSortNone, column);
    this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, () => this.onSortChanged());
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onSortChanged());
    this.onSortChanged();
  }
  addInIcon(iconName, eParent, column) {
    if (eParent == null) {
      return;
    }
    const eIcon = createIconNoSpan(iconName, this.gridOptionsService, column);
    if (eIcon) {
      eParent.appendChild(eIcon);
    }
  }
  onSortChanged() {
    this.updateIcons();
    if (!this.suppressOrder) {
      this.updateSortOrder();
    }
  }
  updateIcons() {
    const sortDirection = this.sortController.getDisplaySortForColumn(this.column);
    if (this.eSortAsc) {
      const isAscending = sortDirection === "asc";
      setDisplayed(this.eSortAsc, isAscending, { skipAriaHidden: true });
    }
    if (this.eSortDesc) {
      const isDescending = sortDirection === "desc";
      setDisplayed(this.eSortDesc, isDescending, { skipAriaHidden: true });
    }
    if (this.eSortNone) {
      const alwaysHideNoSort = !this.column.getColDef().unSortIcon && !this.gridOptionsService.is("unSortIcon");
      const isNone = sortDirection === null || sortDirection === void 0;
      setDisplayed(this.eSortNone, !alwaysHideNoSort && isNone, { skipAriaHidden: true });
    }
  }
  setupMultiSortIndicator() {
    this.addInIcon("sortUnSort", this.eSortMixed, this.column);
    const isColumnShowingRowGroup = this.column.getColDef().showRowGroup;
    const areGroupsCoupled = this.gridOptionsService.isColumnsSortingCoupledToGroup();
    if (areGroupsCoupled && isColumnShowingRowGroup) {
      this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, () => this.updateMultiSortIndicator());
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.updateMultiSortIndicator());
      this.updateMultiSortIndicator();
    }
  }
  updateMultiSortIndicator() {
    if (this.eSortMixed) {
      const isMixedSort = this.sortController.getDisplaySortForColumn(this.column) === "mixed";
      setDisplayed(this.eSortMixed, isMixedSort, { skipAriaHidden: true });
    }
  }
  updateSortOrder() {
    var _a;
    if (!this.eSortOrder) {
      return;
    }
    const allColumnsWithSorting = this.sortController.getColumnsWithSortingOrdered();
    const indexThisCol = (_a = this.sortController.getDisplaySortIndexForColumn(this.column)) !== null && _a !== void 0 ? _a : -1;
    const moreThanOneColSorting = allColumnsWithSorting.some((col) => {
      var _a2;
      return (_a2 = this.sortController.getDisplaySortIndexForColumn(col)) !== null && _a2 !== void 0 ? _a2 : -1 >= 1;
    });
    const showIndex = indexThisCol >= 0 && moreThanOneColSorting;
    setDisplayed(this.eSortOrder, showIndex, { skipAriaHidden: true });
    if (indexThisCol >= 0) {
      this.eSortOrder.innerHTML = (indexThisCol + 1).toString();
    } else {
      clearElement(this.eSortOrder);
    }
  }
};
SortIndicatorComp.TEMPLATE = `<span class="ag-sort-indicator-container">
            <span ref="eSortOrder" class="ag-sort-indicator-icon ag-sort-order ag-hidden" aria-hidden="true"></span>
            <span ref="eSortAsc" class="ag-sort-indicator-icon ag-sort-ascending-icon ag-hidden" aria-hidden="true"></span>
            <span ref="eSortDesc" class="ag-sort-indicator-icon ag-sort-descending-icon ag-hidden" aria-hidden="true"></span>
            <span ref="eSortMixed" class="ag-sort-indicator-icon ag-sort-mixed-icon ag-hidden" aria-hidden="true"></span>
            <span ref="eSortNone" class="ag-sort-indicator-icon ag-sort-none-icon ag-hidden" aria-hidden="true"></span>
        </span>`;
__decorate$2d([
  RefSelector("eSortOrder")
], SortIndicatorComp.prototype, "eSortOrder", void 0);
__decorate$2d([
  RefSelector("eSortAsc")
], SortIndicatorComp.prototype, "eSortAsc", void 0);
__decorate$2d([
  RefSelector("eSortDesc")
], SortIndicatorComp.prototype, "eSortDesc", void 0);
__decorate$2d([
  RefSelector("eSortMixed")
], SortIndicatorComp.prototype, "eSortMixed", void 0);
__decorate$2d([
  RefSelector("eSortNone")
], SortIndicatorComp.prototype, "eSortNone", void 0);
__decorate$2d([
  Autowired("columnModel")
], SortIndicatorComp.prototype, "columnModel", void 0);
__decorate$2d([
  Autowired("sortController")
], SortIndicatorComp.prototype, "sortController", void 0);
var __decorate$2c = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HeaderComp = class extends Component {
  constructor() {
    super(...arguments);
    this.lastMovingChanged = 0;
  }
  destroy() {
    super.destroy();
  }
  refresh(params) {
    this.params = params;
    if (this.workOutTemplate() != this.currentTemplate) {
      return false;
    }
    if (this.workOutShowMenu() != this.currentShowMenu) {
      return false;
    }
    if (this.workOutSort() != this.currentSort) {
      return false;
    }
    this.setDisplayName(params);
    return true;
  }
  workOutTemplate() {
    let template = firstExistingValue(this.params.template, HeaderComp.TEMPLATE);
    template = template && template.trim ? template.trim() : template;
    return template;
  }
  init(params) {
    this.params = params;
    this.currentTemplate = this.workOutTemplate();
    this.setTemplate(this.currentTemplate);
    this.setupTap();
    this.setupIcons(params.column);
    this.setMenu();
    this.setupSort();
    this.setupFilterIcon();
    this.setDisplayName(params);
  }
  setDisplayName(params) {
    if (this.currentDisplayName != params.displayName) {
      this.currentDisplayName = params.displayName;
      const displayNameSanitised = escapeString(this.currentDisplayName);
      if (this.eText) {
        this.eText.innerHTML = displayNameSanitised;
      }
    }
  }
  setupIcons(column) {
    this.addInIcon("menu", this.eMenu, column);
    this.addInIcon("filter", this.eFilter, column);
  }
  addInIcon(iconName, eParent, column) {
    if (eParent == null) {
      return;
    }
    const eIcon = createIconNoSpan(iconName, this.gridOptionsService, column);
    if (eIcon) {
      eParent.appendChild(eIcon);
    }
  }
  setupTap() {
    const { gridOptionsService } = this;
    if (gridOptionsService.is("suppressTouch")) {
      return;
    }
    const touchListener = new TouchListener(this.getGui(), true);
    const suppressMenuHide = gridOptionsService.is("suppressMenuHide");
    const tapMenuButton = suppressMenuHide && exists(this.eMenu);
    const menuTouchListener = tapMenuButton ? new TouchListener(this.eMenu, true) : touchListener;
    if (this.params.enableMenu) {
      const eventType = tapMenuButton ? "EVENT_TAP" : "EVENT_LONG_TAP";
      const showMenuFn = (event) => {
        gridOptionsService.api.showColumnMenuAfterMouseClick(this.params.column, event.touchStart);
      };
      this.addManagedListener(menuTouchListener, TouchListener[eventType], showMenuFn);
    }
    if (this.params.enableSorting) {
      const tapListener = (event) => {
        const target = event.touchStart.target;
        if (suppressMenuHide && this.eMenu.contains(target)) {
          return;
        }
        this.sortController.progressSort(this.params.column, false, "uiColumnSorted");
      };
      this.addManagedListener(touchListener, TouchListener.EVENT_TAP, tapListener);
    }
    this.addDestroyFunc(() => touchListener.destroy());
    if (tapMenuButton) {
      this.addDestroyFunc(() => menuTouchListener.destroy());
    }
  }
  workOutShowMenu() {
    const menuHides = !this.gridOptionsService.is("suppressMenuHide");
    const onIpadAndMenuHides = isIOSUserAgent() && menuHides;
    const showMenu = this.params.enableMenu && !onIpadAndMenuHides;
    return showMenu;
  }
  setMenu() {
    if (!this.eMenu) {
      return;
    }
    this.currentShowMenu = this.workOutShowMenu();
    if (!this.currentShowMenu) {
      removeFromParent(this.eMenu);
      return;
    }
    const suppressMenuHide = this.gridOptionsService.is("suppressMenuHide");
    this.addManagedListener(this.eMenu, "click", () => this.showMenu(this.eMenu));
    this.eMenu.classList.toggle("ag-header-menu-always-show", suppressMenuHide);
  }
  showMenu(eventSource) {
    if (!eventSource) {
      eventSource = this.eMenu;
    }
    this.menuFactory.showMenuAfterButtonClick(this.params.column, eventSource, "columnMenu");
  }
  workOutSort() {
    return this.params.enableSorting;
  }
  setupSort() {
    this.currentSort = this.params.enableSorting;
    if (!this.eSortIndicator) {
      this.eSortIndicator = this.context.createBean(new SortIndicatorComp(true));
      this.eSortIndicator.attachCustomElements(this.eSortOrder, this.eSortAsc, this.eSortDesc, this.eSortMixed, this.eSortNone);
    }
    this.eSortIndicator.setupSort(this.params.column);
    if (!this.currentSort) {
      return;
    }
    const sortUsingCtrl = this.gridOptionsService.get("multiSortKey") === "ctrl";
    this.addManagedListener(this.params.column, Column.EVENT_MOVING_CHANGED, () => {
      this.lastMovingChanged = new Date().getTime();
    });
    if (this.eLabel) {
      this.addManagedListener(this.eLabel, "click", (event) => {
        const moving = this.params.column.isMoving();
        const nowTime = new Date().getTime();
        const movedRecently = nowTime - this.lastMovingChanged < 50;
        const columnMoving = moving || movedRecently;
        if (!columnMoving) {
          const multiSort = sortUsingCtrl ? event.ctrlKey || event.metaKey : event.shiftKey;
          this.params.progressSort(multiSort);
        }
      });
    }
    const onSortingChanged = () => {
      this.addOrRemoveCssClass("ag-header-cell-sorted-asc", this.params.column.isSortAscending());
      this.addOrRemoveCssClass("ag-header-cell-sorted-desc", this.params.column.isSortDescending());
      this.addOrRemoveCssClass("ag-header-cell-sorted-none", this.params.column.isSortNone());
      if (this.params.column.getColDef().showRowGroup) {
        const sourceColumns = this.columnModel.getSourceColumnsForGroupColumn(this.params.column);
        const sortDirectionsMatch = sourceColumns === null || sourceColumns === void 0 ? void 0 : sourceColumns.every((sourceCol) => this.params.column.getSort() == sourceCol.getSort());
        const isMultiSorting = !sortDirectionsMatch;
        this.addOrRemoveCssClass("ag-header-cell-sorted-mixed", isMultiSorting);
      }
    };
    this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, onSortingChanged);
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, onSortingChanged);
  }
  setupFilterIcon() {
    if (!this.eFilter) {
      return;
    }
    this.addManagedListener(this.params.column, Column.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));
    this.onFilterChanged();
  }
  onFilterChanged() {
    const filterPresent = this.params.column.isFilterActive();
    setDisplayed(this.eFilter, filterPresent, { skipAriaHidden: true });
  }
};
HeaderComp.TEMPLATE = `<div class="ag-cell-label-container" role="presentation">
            <span ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>
            <div ref="eLabel" class="ag-header-cell-label" role="presentation">
                <span ref="eText" class="ag-header-cell-text"></span>
                <span ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>
                <ag-sort-indicator ref="eSortIndicator"></ag-sort-indicator>
            </div>
        </div>`;
__decorate$2c([
  Autowired("sortController")
], HeaderComp.prototype, "sortController", void 0);
__decorate$2c([
  Autowired("menuFactory")
], HeaderComp.prototype, "menuFactory", void 0);
__decorate$2c([
  Autowired("columnModel")
], HeaderComp.prototype, "columnModel", void 0);
__decorate$2c([
  RefSelector("eFilter")
], HeaderComp.prototype, "eFilter", void 0);
__decorate$2c([
  RefSelector("eSortIndicator")
], HeaderComp.prototype, "eSortIndicator", void 0);
__decorate$2c([
  RefSelector("eMenu")
], HeaderComp.prototype, "eMenu", void 0);
__decorate$2c([
  RefSelector("eLabel")
], HeaderComp.prototype, "eLabel", void 0);
__decorate$2c([
  RefSelector("eText")
], HeaderComp.prototype, "eText", void 0);
__decorate$2c([
  RefSelector("eSortOrder")
], HeaderComp.prototype, "eSortOrder", void 0);
__decorate$2c([
  RefSelector("eSortAsc")
], HeaderComp.prototype, "eSortAsc", void 0);
__decorate$2c([
  RefSelector("eSortDesc")
], HeaderComp.prototype, "eSortDesc", void 0);
__decorate$2c([
  RefSelector("eSortMixed")
], HeaderComp.prototype, "eSortMixed", void 0);
__decorate$2c([
  RefSelector("eSortNone")
], HeaderComp.prototype, "eSortNone", void 0);
var __decorate$2b = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HeaderGroupComp = class extends Component {
  constructor() {
    super(HeaderGroupComp.TEMPLATE);
  }
  destroy() {
    super.destroy();
  }
  init(params) {
    this.params = params;
    this.checkWarnings();
    this.setupLabel();
    this.addGroupExpandIcon();
    this.setupExpandIcons();
  }
  checkWarnings() {
    const paramsAny = this.params;
    if (paramsAny.template) {
      const message = `AG Grid: A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)`;
      doOnce(() => console.warn(message), "HeaderGroupComp.templateNotSupported");
    }
  }
  setupExpandIcons() {
    this.addInIcon("columnGroupOpened", "agOpened");
    this.addInIcon("columnGroupClosed", "agClosed");
    const expandAction = (event) => {
      if (isStopPropagationForAgGrid(event)) {
        return;
      }
      const newExpandedValue = !this.params.columnGroup.isExpanded();
      this.columnModel.setColumnGroupOpened(this.params.columnGroup.getProvidedColumnGroup(), newExpandedValue, "uiColumnExpanded");
    };
    this.addTouchAndClickListeners(this.eCloseIcon, expandAction);
    this.addTouchAndClickListeners(this.eOpenIcon, expandAction);
    const stopPropagationAction = (event) => {
      stopPropagationForAgGrid(event);
    };
    this.addManagedListener(this.eCloseIcon, "dblclick", stopPropagationAction);
    this.addManagedListener(this.eOpenIcon, "dblclick", stopPropagationAction);
    this.addManagedListener(this.getGui(), "dblclick", expandAction);
    this.updateIconVisibility();
    const providedColumnGroup = this.params.columnGroup.getProvidedColumnGroup();
    this.addManagedListener(providedColumnGroup, ProvidedColumnGroup.EVENT_EXPANDED_CHANGED, this.updateIconVisibility.bind(this));
    this.addManagedListener(providedColumnGroup, ProvidedColumnGroup.EVENT_EXPANDABLE_CHANGED, this.updateIconVisibility.bind(this));
  }
  addTouchAndClickListeners(eElement, action) {
    const touchListener = new TouchListener(eElement, true);
    this.addManagedListener(touchListener, TouchListener.EVENT_TAP, action);
    this.addDestroyFunc(() => touchListener.destroy());
    this.addManagedListener(eElement, "click", action);
  }
  updateIconVisibility() {
    const columnGroup = this.params.columnGroup;
    if (columnGroup.isExpandable()) {
      const expanded = this.params.columnGroup.isExpanded();
      setDisplayed(this.eOpenIcon, expanded);
      setDisplayed(this.eCloseIcon, !expanded);
    } else {
      setDisplayed(this.eOpenIcon, false);
      setDisplayed(this.eCloseIcon, false);
    }
  }
  addInIcon(iconName, refName) {
    const eIcon = createIconNoSpan(iconName, this.gridOptionsService, null);
    if (eIcon) {
      this.getRefElement(refName).appendChild(eIcon);
    }
  }
  addGroupExpandIcon() {
    if (!this.params.columnGroup.isExpandable()) {
      setDisplayed(this.eOpenIcon, false);
      setDisplayed(this.eCloseIcon, false);
      return;
    }
  }
  setupLabel() {
    var _a;
    const { displayName, columnGroup } = this.params;
    if (exists(displayName)) {
      const displayNameSanitised = escapeString(displayName);
      this.getRefElement("agLabel").innerHTML = displayNameSanitised;
    }
    this.addOrRemoveCssClass("ag-sticky-label", !((_a = columnGroup.getColGroupDef()) === null || _a === void 0 ? void 0 : _a.suppressStickyLabel));
  }
};
HeaderGroupComp.TEMPLATE = `<div class="ag-header-group-cell-label" ref="agContainer" role="presentation">
            <span ref="agLabel" class="ag-header-group-text" role="presentation"></span>
            <span ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>
            <span ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>
        </div>`;
__decorate$2b([
  Autowired("columnModel")
], HeaderGroupComp.prototype, "columnModel", void 0);
__decorate$2b([
  RefSelector("agOpened")
], HeaderGroupComp.prototype, "eOpenIcon", void 0);
__decorate$2b([
  RefSelector("agClosed")
], HeaderGroupComp.prototype, "eCloseIcon", void 0);
var PopupComponent = class extends Component {
  isPopup() {
    return true;
  }
  setParentComponent(container) {
    container.addCssClass("ag-has-popup");
    super.setParentComponent(container);
  }
  destroy() {
    const parentComp = this.parentComponent;
    const hasParent = parentComp && parentComp.isAlive();
    if (hasParent) {
      parentComp.getGui().classList.remove("ag-has-popup");
    }
    super.destroy();
  }
};
var __decorate$2a = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LargeTextCellEditor = class extends PopupComponent {
  constructor() {
    super(LargeTextCellEditor.TEMPLATE);
  }
  init(params) {
    this.params = params;
    this.focusAfterAttached = params.cellStartedEdit;
    this.eTextArea.setMaxLength(params.maxLength || 200).setCols(params.cols || 60).setRows(params.rows || 10);
    if (exists(params.value, true)) {
      this.eTextArea.setValue(params.value.toString(), true);
    }
    this.addGuiEventListener("keydown", this.onKeyDown.bind(this));
  }
  onKeyDown(event) {
    const key = event.key;
    if (key === KeyCode.LEFT || key === KeyCode.UP || key === KeyCode.RIGHT || key === KeyCode.DOWN || event.shiftKey && key === KeyCode.ENTER) {
      event.stopPropagation();
    }
  }
  afterGuiAttached() {
    const translate = this.localeService.getLocaleTextFunc();
    this.eTextArea.setInputAriaLabel(translate("ariaInputEditor", "Input Editor"));
    if (this.focusAfterAttached) {
      this.eTextArea.getFocusableElement().focus();
    }
  }
  getValue() {
    const value = this.eTextArea.getValue();
    if (!exists(value) && !exists(this.params.value)) {
      return this.params.value;
    }
    return this.params.parseValue(value);
  }
};
LargeTextCellEditor.TEMPLATE = `<div class="ag-large-text" tabindex="0">
            <ag-input-text-area ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>
        </div>`;
__decorate$2a([
  RefSelector("eTextArea")
], LargeTextCellEditor.prototype, "eTextArea", void 0);
var __decorate$29 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SelectCellEditor = class extends PopupComponent {
  constructor() {
    super('<div class="ag-cell-edit-wrapper"><ag-select class="ag-cell-editor" ref="eSelect"></ag-select></div>');
    this.startedByEnter = false;
  }
  init(params) {
    this.focusAfterAttached = params.cellStartedEdit;
    if (missing(params.values)) {
      console.warn("AG Grid: no values found for select cellEditor");
      return;
    }
    this.startedByEnter = params.eventKey != null ? params.eventKey === KeyCode.ENTER : false;
    let hasValue = false;
    params.values.forEach((value) => {
      const option = { value };
      const valueFormatted = this.valueFormatterService.formatValue(params.column, null, value);
      const valueFormattedExits = valueFormatted !== null && valueFormatted !== void 0;
      option.text = valueFormattedExits ? valueFormatted : value;
      this.eSelect.addOption(option);
      hasValue = hasValue || params.value === value;
    });
    if (hasValue) {
      this.eSelect.setValue(params.value, true);
    } else if (params.values.length) {
      this.eSelect.setValue(params.values[0], true);
    }
    if (this.gridOptionsService.get("editType") !== "fullRow") {
      this.addManagedListener(this.eSelect, AgSelect.EVENT_ITEM_SELECTED, () => params.stopEditing());
    }
  }
  afterGuiAttached() {
    if (this.focusAfterAttached) {
      this.eSelect.getFocusableElement().focus();
    }
    if (this.startedByEnter) {
      this.eSelect.showPicker();
    }
  }
  focusIn() {
    this.eSelect.getFocusableElement().focus();
  }
  getValue() {
    return this.eSelect.getValue();
  }
  isPopup() {
    return false;
  }
};
__decorate$29([
  Autowired("valueFormatterService")
], SelectCellEditor.prototype, "valueFormatterService", void 0);
__decorate$29([
  RefSelector("eSelect")
], SelectCellEditor.prototype, "eSelect", void 0);
var __decorate$28 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SimpleCellEditor = class extends PopupComponent {
  constructor(cellEditorInput) {
    super(`
            <div class="ag-cell-edit-wrapper">
                ${cellEditorInput.getTemplate()}
            </div>`);
    this.cellEditorInput = cellEditorInput;
  }
  init(params) {
    this.params = params;
    const eInput = this.eInput;
    this.cellEditorInput.init(eInput, params);
    let startValue;
    if (params.cellStartedEdit) {
      this.focusAfterAttached = true;
      const eventKey = params.eventKey;
      if (eventKey === KeyCode.BACKSPACE || params.eventKey === KeyCode.DELETE) {
        startValue = "";
      } else if (eventKey && eventKey.length === 1) {
        startValue = eventKey;
      } else {
        startValue = this.cellEditorInput.getStartValue();
        if (eventKey !== KeyCode.F2) {
          this.highlightAllOnFocus = true;
        }
      }
    } else {
      this.focusAfterAttached = false;
      startValue = this.cellEditorInput.getStartValue();
    }
    if (startValue != null) {
      eInput.setStartValue(startValue);
    }
    this.addManagedListener(eInput.getGui(), "keydown", (event) => {
      const { key } = event;
      if (key === KeyCode.PAGE_UP || key === KeyCode.PAGE_DOWN) {
        event.preventDefault();
      }
    });
  }
  afterGuiAttached() {
    var _a, _b;
    const translate = this.localeService.getLocaleTextFunc();
    const eInput = this.eInput;
    eInput.setInputAriaLabel(translate("ariaInputEditor", "Input Editor"));
    if (!this.focusAfterAttached) {
      return;
    }
    if (!isBrowserSafari()) {
      eInput.getFocusableElement().focus();
    }
    const inputEl = eInput.getInputElement();
    if (this.highlightAllOnFocus) {
      inputEl.select();
    } else {
      (_b = (_a = this.cellEditorInput).setCaret) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
  }
  focusIn() {
    const eInput = this.eInput;
    const focusEl = eInput.getFocusableElement();
    const inputEl = eInput.getInputElement();
    focusEl.focus();
    inputEl.select();
  }
  getValue() {
    return this.cellEditorInput.getValue();
  }
  isPopup() {
    return false;
  }
};
__decorate$28([
  RefSelector("eInput")
], SimpleCellEditor.prototype, "eInput", void 0);
var TextCellEditorInput = class {
  getTemplate() {
    return `<ag-input-text-field class="ag-cell-editor" ref="eInput"></ag-input-text-field>`;
  }
  init(eInput, params) {
    this.eInput = eInput;
    this.params = params;
    if (params.maxLength != null) {
      eInput.setMaxLength(params.maxLength);
    }
  }
  getValue() {
    const value = this.eInput.getValue();
    if (!exists(value) && !exists(this.params.value)) {
      return this.params.value;
    }
    return this.params.parseValue(value);
  }
  getStartValue() {
    const formatValue = this.params.useFormatter || this.params.column.getColDef().refData;
    return formatValue ? this.params.formatValue(this.params.value) : this.params.value;
  }
  setCaret() {
    const value = this.eInput.getValue();
    const len = exists(value) && value.length || 0;
    if (len) {
      this.eInput.getInputElement().setSelectionRange(len, len);
    }
  }
};
var TextCellEditor = class extends SimpleCellEditor {
  constructor() {
    super(new TextCellEditorInput());
  }
};
var __decorate$27 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ARROW_UP = "\u2191";
var ARROW_DOWN = "\u2193";
var AnimateShowChangeCellRenderer = class extends Component {
  constructor() {
    super(AnimateShowChangeCellRenderer.TEMPLATE);
    this.refreshCount = 0;
  }
  init(params) {
    this.eValue = this.queryForHtmlElement(".ag-value-change-value");
    this.eDelta = this.queryForHtmlElement(".ag-value-change-delta");
    this.refresh(params);
  }
  showDelta(params, delta) {
    const absDelta = Math.abs(delta);
    const valueFormatted = params.formatValue(absDelta);
    const valueToUse = exists(valueFormatted) ? valueFormatted : absDelta;
    const deltaUp = delta >= 0;
    if (deltaUp) {
      this.eDelta.innerHTML = ARROW_UP + valueToUse;
    } else {
      this.eDelta.innerHTML = ARROW_DOWN + valueToUse;
    }
    this.eDelta.classList.toggle("ag-value-change-delta-up", deltaUp);
    this.eDelta.classList.toggle("ag-value-change-delta-down", !deltaUp);
  }
  setTimerToRemoveDelta() {
    this.refreshCount++;
    const refreshCountCopy = this.refreshCount;
    window.setTimeout(() => {
      if (refreshCountCopy === this.refreshCount) {
        this.hideDeltaValue();
      }
    }, 2e3);
  }
  hideDeltaValue() {
    this.eValue.classList.remove("ag-value-change-value-highlight");
    clearElement(this.eDelta);
  }
  refresh(params) {
    const value = params.value;
    if (value === this.lastValue) {
      return false;
    }
    if (exists(params.valueFormatted)) {
      this.eValue.innerHTML = params.valueFormatted;
    } else if (exists(params.value)) {
      this.eValue.innerHTML = value;
    } else {
      clearElement(this.eValue);
    }
    if (this.filterManager.isSuppressFlashingCellsBecauseFiltering()) {
      return false;
    }
    if (typeof value === "number" && typeof this.lastValue === "number") {
      const delta = value - this.lastValue;
      this.showDelta(params, delta);
    }
    if (this.lastValue) {
      this.eValue.classList.add("ag-value-change-value-highlight");
    }
    this.setTimerToRemoveDelta();
    this.lastValue = value;
    return true;
  }
};
AnimateShowChangeCellRenderer.TEMPLATE = '<span><span class="ag-value-change-delta"></span><span class="ag-value-change-value"></span></span>';
__decorate$27([
  Autowired("filterManager")
], AnimateShowChangeCellRenderer.prototype, "filterManager", void 0);
var __decorate$26 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AnimateSlideCellRenderer = class extends Component {
  constructor() {
    super(AnimateSlideCellRenderer.TEMPLATE);
    this.refreshCount = 0;
    this.eCurrent = this.queryForHtmlElement(".ag-value-slide-current");
  }
  init(params) {
    this.refresh(params);
  }
  addSlideAnimation() {
    this.refreshCount++;
    const refreshCountCopy = this.refreshCount;
    if (this.ePrevious) {
      this.getGui().removeChild(this.ePrevious);
    }
    this.ePrevious = loadTemplate('<span class="ag-value-slide-previous ag-value-slide-out"></span>');
    this.ePrevious.innerHTML = this.eCurrent.innerHTML;
    this.getGui().insertBefore(this.ePrevious, this.eCurrent);
    window.setTimeout(() => {
      if (refreshCountCopy !== this.refreshCount) {
        return;
      }
      this.ePrevious.classList.add("ag-value-slide-out-end");
    }, 50);
    window.setTimeout(() => {
      if (refreshCountCopy !== this.refreshCount) {
        return;
      }
      this.getGui().removeChild(this.ePrevious);
      this.ePrevious = null;
    }, 3e3);
  }
  refresh(params) {
    let value = params.value;
    if (missing(value)) {
      value = "";
    }
    if (value === this.lastValue) {
      return false;
    }
    if (this.filterManager.isSuppressFlashingCellsBecauseFiltering()) {
      return false;
    }
    this.addSlideAnimation();
    this.lastValue = value;
    if (exists(params.valueFormatted)) {
      this.eCurrent.innerHTML = params.valueFormatted;
    } else if (exists(params.value)) {
      this.eCurrent.innerHTML = value;
    } else {
      clearElement(this.eCurrent);
    }
    return true;
  }
};
AnimateSlideCellRenderer.TEMPLATE = `<span>
            <span class="ag-value-slide-current"></span>
        </span>`;
__decorate$26([
  Autowired("filterManager")
], AnimateSlideCellRenderer.prototype, "filterManager", void 0);
var RowNode = class {
  constructor(beans) {
    this.rowIndex = null;
    this.key = null;
    this.childrenMapped = {};
    this.displayed = false;
    this.rowTop = null;
    this.oldRowTop = null;
    this.selectable = true;
    this.__objectId = RowNode.OBJECT_ID_SEQUENCE++;
    this.__autoHeights = {};
    this.alreadyRendered = false;
    this.highlighted = null;
    this.hovered = false;
    this.selected = false;
    this.beans = beans;
  }
  setData(data) {
    this.setDataCommon(data, false);
  }
  updateData(data) {
    this.setDataCommon(data, true);
  }
  setDataCommon(data, update) {
    const oldData = this.data;
    this.data = data;
    this.beans.valueCache.onDataChanged();
    this.updateDataOnDetailNode();
    this.checkRowSelectable();
    this.resetQuickFilterAggregateText();
    const event = this.createDataChangedEvent(data, oldData, update);
    this.dispatchLocalEvent(event);
  }
  updateDataOnDetailNode() {
    if (this.detailNode) {
      this.detailNode.data = this.data;
    }
  }
  createDataChangedEvent(newData, oldData, update) {
    return {
      type: RowNode.EVENT_DATA_CHANGED,
      node: this,
      oldData,
      newData,
      update
    };
  }
  createLocalRowEvent(type) {
    return {
      type,
      node: this
    };
  }
  getRowIndexString() {
    if (this.rowPinned === "top") {
      return "t-" + this.rowIndex;
    }
    if (this.rowPinned === "bottom") {
      return "b-" + this.rowIndex;
    }
    return this.rowIndex.toString();
  }
  createDaemonNode() {
    const oldNode = new RowNode(this.beans);
    oldNode.id = this.id;
    oldNode.data = this.data;
    oldNode.__daemon = true;
    oldNode.selected = this.selected;
    oldNode.level = this.level;
    return oldNode;
  }
  setDataAndId(data, id) {
    const oldNode = exists(this.id) ? this.createDaemonNode() : null;
    const oldData = this.data;
    this.data = data;
    this.updateDataOnDetailNode();
    this.setId(id);
    this.beans.selectionService.syncInRowNode(this, oldNode);
    this.checkRowSelectable();
    const event = this.createDataChangedEvent(data, oldData, false);
    this.dispatchLocalEvent(event);
  }
  checkRowSelectable() {
    const isRowSelectableFunc = this.beans.gridOptionsService.get("isRowSelectable");
    this.setRowSelectable(isRowSelectableFunc ? isRowSelectableFunc(this) : true);
  }
  setRowSelectable(newVal) {
    if (this.selectable !== newVal) {
      this.selectable = newVal;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_SELECTABLE_CHANGED));
      }
      const isGroupSelectsChildren = this.beans.gridOptionsService.is("groupSelectsChildren");
      if (isGroupSelectsChildren) {
        const selected = this.calculateSelectedFromChildren();
        this.setSelectedParams({
          newValue: selected !== null && selected !== void 0 ? selected : false,
          source: "selectableChanged"
        });
      }
    }
  }
  setId(id) {
    const getRowIdFunc = this.beans.gridOptionsService.getCallback("getRowId");
    if (getRowIdFunc) {
      if (this.data) {
        const parentKeys = this.getGroupKeys(true);
        this.id = getRowIdFunc({
          data: this.data,
          parentKeys: parentKeys.length > 0 ? parentKeys : void 0,
          level: this.level
        });
        if (this.id !== null && typeof this.id === "string" && this.id.startsWith(RowNode.ID_PREFIX_ROW_GROUP)) {
          console.error(`AG Grid: Row IDs cannot start with ${RowNode.ID_PREFIX_ROW_GROUP}, this is a reserved prefix for AG Grid's row grouping feature.`);
        }
        if (this.id !== null && typeof this.id !== "string") {
          this.id = "" + this.id;
        }
      } else {
        this.id = void 0;
      }
    } else {
      this.id = id;
    }
  }
  getGroupKeys(excludeSelf = false) {
    const keys2 = [];
    let pointer = this;
    if (excludeSelf) {
      pointer = pointer.parent;
    }
    while (pointer && pointer.level >= 0) {
      keys2.push(pointer.key);
      pointer = pointer.parent;
    }
    keys2.reverse();
    return keys2;
  }
  isPixelInRange(pixel) {
    if (!exists(this.rowTop) || !exists(this.rowHeight)) {
      return false;
    }
    return pixel >= this.rowTop && pixel < this.rowTop + this.rowHeight;
  }
  setFirstChild(firstChild) {
    if (this.firstChild === firstChild) {
      return;
    }
    this.firstChild = firstChild;
    if (this.eventService) {
      this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_FIRST_CHILD_CHANGED));
    }
  }
  setLastChild(lastChild) {
    if (this.lastChild === lastChild) {
      return;
    }
    this.lastChild = lastChild;
    if (this.eventService) {
      this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_LAST_CHILD_CHANGED));
    }
  }
  setChildIndex(childIndex) {
    if (this.childIndex === childIndex) {
      return;
    }
    this.childIndex = childIndex;
    if (this.eventService) {
      this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_CHILD_INDEX_CHANGED));
    }
  }
  setRowTop(rowTop) {
    this.oldRowTop = this.rowTop;
    if (this.rowTop === rowTop) {
      return;
    }
    this.rowTop = rowTop;
    if (this.eventService) {
      this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_TOP_CHANGED));
    }
    this.setDisplayed(rowTop !== null);
  }
  clearRowTopAndRowIndex() {
    this.oldRowTop = null;
    this.setRowTop(null);
    this.setRowIndex(null);
  }
  setDisplayed(displayed) {
    if (this.displayed === displayed) {
      return;
    }
    this.displayed = displayed;
    if (this.eventService) {
      this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_DISPLAYED_CHANGED));
    }
  }
  setDragging(dragging) {
    if (this.dragging === dragging) {
      return;
    }
    this.dragging = dragging;
    if (this.eventService) {
      this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_DRAGGING_CHANGED));
    }
  }
  setHighlighted(highlighted) {
    if (highlighted === this.highlighted) {
      return;
    }
    this.highlighted = highlighted;
    if (this.eventService) {
      this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_HIGHLIGHT_CHANGED));
    }
  }
  setHovered(hovered) {
    if (this.hovered === hovered) {
      return;
    }
    this.hovered = hovered;
  }
  isHovered() {
    return this.hovered;
  }
  setAllChildrenCount(allChildrenCount) {
    if (this.allChildrenCount === allChildrenCount) {
      return;
    }
    this.allChildrenCount = allChildrenCount;
    if (this.eventService) {
      this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_ALL_CHILDREN_COUNT_CHANGED));
    }
  }
  setMaster(master) {
    if (this.master === master) {
      return;
    }
    if (this.master && !master) {
      this.expanded = false;
    }
    this.master = master;
    if (this.eventService) {
      this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_MASTER_CHANGED));
    }
  }
  setGroup(group) {
    if (this.group === group) {
      return;
    }
    if (this.group && !group) {
      this.expanded = false;
    }
    this.group = group;
    this.updateHasChildren();
    if (this.eventService) {
      this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_GROUP_CHANGED));
    }
  }
  setRowHeight(rowHeight, estimated = false) {
    this.rowHeight = rowHeight;
    this.rowHeightEstimated = estimated;
    if (this.eventService) {
      this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_HEIGHT_CHANGED));
    }
  }
  setRowAutoHeight(cellHeight, column) {
    if (!this.__autoHeights) {
      this.__autoHeights = {};
    }
    this.__autoHeights[column.getId()] = cellHeight;
    if (cellHeight != null) {
      if (this.checkAutoHeightsDebounced == null) {
        this.checkAutoHeightsDebounced = debounce(this.checkAutoHeights.bind(this), 1);
      }
      this.checkAutoHeightsDebounced();
    }
  }
  checkAutoHeights() {
    let notAllPresent = false;
    let nonePresent = true;
    let newRowHeight = 0;
    const autoHeights = this.__autoHeights;
    if (autoHeights == null) {
      return;
    }
    const displayedAutoHeightCols = this.beans.columnModel.getAllDisplayedAutoHeightCols();
    displayedAutoHeightCols.forEach((col) => {
      let cellHeight = autoHeights[col.getId()];
      if (cellHeight == null) {
        if (this.beans.columnModel.isColSpanActive()) {
          let activeColsForRow = [];
          switch (col.getPinned()) {
            case "left":
              activeColsForRow = this.beans.columnModel.getDisplayedLeftColumnsForRow(this);
              break;
            case "right":
              activeColsForRow = this.beans.columnModel.getDisplayedRightColumnsForRow(this);
              break;
            case null:
              activeColsForRow = this.beans.columnModel.getViewportCenterColumnsForRow(this);
              break;
          }
          if (activeColsForRow.includes(col)) {
            notAllPresent = true;
            return;
          }
          cellHeight = -1;
        } else {
          notAllPresent = true;
          return;
        }
      } else {
        nonePresent = false;
      }
      if (cellHeight > newRowHeight) {
        newRowHeight = cellHeight;
      }
    });
    if (notAllPresent) {
      return;
    }
    if (nonePresent || newRowHeight < 10) {
      newRowHeight = this.beans.gridOptionsService.getRowHeightForNode(this).height;
    }
    if (newRowHeight == this.rowHeight) {
      return;
    }
    this.setRowHeight(newRowHeight);
    const rowModel = this.beans.rowModel;
    if (rowModel.onRowHeightChangedDebounced) {
      rowModel.onRowHeightChangedDebounced();
    }
  }
  setRowIndex(rowIndex) {
    if (this.rowIndex === rowIndex) {
      return;
    }
    this.rowIndex = rowIndex;
    if (this.eventService) {
      this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_ROW_INDEX_CHANGED));
    }
  }
  setUiLevel(uiLevel) {
    if (this.uiLevel === uiLevel) {
      return;
    }
    this.uiLevel = uiLevel;
    if (this.eventService) {
      this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_UI_LEVEL_CHANGED));
    }
  }
  setExpanded(expanded, e) {
    if (this.expanded === expanded) {
      return;
    }
    this.expanded = expanded;
    if (this.eventService) {
      this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_EXPANDED_CHANGED));
    }
    const event = Object.assign({}, this.createGlobalRowEvent(Events.EVENT_ROW_GROUP_OPENED), {
      expanded,
      event: e || null
    });
    this.beans.rowNodeEventThrottle.dispatchExpanded(event);
    if (this.beans.gridOptionsService.is("groupIncludeFooter")) {
      this.beans.rowRenderer.refreshCells({ rowNodes: [this] });
    }
  }
  createGlobalRowEvent(type) {
    return {
      type,
      node: this,
      data: this.data,
      rowIndex: this.rowIndex,
      rowPinned: this.rowPinned,
      context: this.beans.gridOptionsService.context,
      api: this.beans.gridOptionsService.api,
      columnApi: this.beans.gridOptionsService.columnApi
    };
  }
  dispatchLocalEvent(event) {
    if (this.eventService) {
      this.eventService.dispatchEvent(event);
    }
  }
  setDataValue(colKey, newValue, eventSource) {
    const getColumnFromKey = () => {
      var _a;
      if (typeof colKey !== "string") {
        return colKey;
      }
      return (_a = this.beans.columnModel.getGridColumn(colKey)) !== null && _a !== void 0 ? _a : this.beans.columnModel.getPrimaryColumn(colKey);
    };
    const column = getColumnFromKey();
    const oldValue = this.getValueFromValueService(column);
    if (this.beans.gridOptionsService.is("readOnlyEdit")) {
      this.dispatchEventForSaveValueReadOnly(column, oldValue, newValue, eventSource);
      return false;
    }
    const valueChanged = this.beans.valueService.setValue(this, column, newValue, eventSource);
    this.dispatchCellChangedEvent(column, newValue, oldValue);
    this.checkRowSelectable();
    return valueChanged;
  }
  getValueFromValueService(column) {
    const lockedClosedGroup = this.leafGroup && this.beans.columnModel.isPivotMode();
    const isOpenGroup = this.group && this.expanded && !this.footer && !lockedClosedGroup;
    const groupFootersEnabled = this.beans.gridOptionsService.is("groupIncludeFooter");
    const groupAlwaysShowAggData = this.beans.gridOptionsService.is("groupSuppressBlankHeader");
    const ignoreAggData = isOpenGroup && groupFootersEnabled && !groupAlwaysShowAggData;
    const value = this.beans.valueService.getValue(column, this, false, ignoreAggData);
    return value;
  }
  dispatchEventForSaveValueReadOnly(column, oldValue, newValue, eventSource) {
    const event = {
      type: Events.EVENT_CELL_EDIT_REQUEST,
      event: null,
      rowIndex: this.rowIndex,
      rowPinned: this.rowPinned,
      column,
      colDef: column.getColDef(),
      context: this.beans.gridOptionsService.context,
      api: this.beans.gridOptionsService.api,
      columnApi: this.beans.gridOptionsService.columnApi,
      data: this.data,
      node: this,
      oldValue,
      newValue,
      value: newValue,
      source: eventSource
    };
    this.beans.eventService.dispatchEvent(event);
  }
  setGroupValue(colKey, newValue) {
    const column = this.beans.columnModel.getGridColumn(colKey);
    if (missing(this.groupData)) {
      this.groupData = {};
    }
    const columnId = column.getColId();
    const oldValue = this.groupData[columnId];
    if (oldValue === newValue) {
      return;
    }
    this.groupData[columnId] = newValue;
    this.dispatchCellChangedEvent(column, newValue, oldValue);
  }
  setAggData(newAggData) {
    const colIds = getAllKeysInObjects([this.aggData, newAggData]);
    const oldAggData = this.aggData;
    this.aggData = newAggData;
    if (this.eventService) {
      colIds.forEach((colId) => {
        const column = this.beans.columnModel.getGridColumn(colId);
        const value = this.aggData ? this.aggData[colId] : void 0;
        const oldValue = oldAggData ? oldAggData[colId] : void 0;
        this.dispatchCellChangedEvent(column, value, oldValue);
      });
    }
  }
  updateHasChildren() {
    let newValue = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
    const isSsrm = this.beans.gridOptionsService.isRowModelType("serverSide");
    if (isSsrm) {
      const isTreeData = this.beans.gridOptionsService.isTreeData();
      const isGroupFunc = this.beans.gridOptionsService.get("isServerSideGroup");
      newValue = !this.stub && !this.footer && (isTreeData ? !!isGroupFunc && isGroupFunc(this.data) : !!this.group);
    }
    if (newValue !== this.__hasChildren) {
      this.__hasChildren = !!newValue;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_HAS_CHILDREN_CHANGED));
      }
    }
  }
  hasChildren() {
    if (this.__hasChildren == null) {
      this.updateHasChildren();
    }
    return this.__hasChildren;
  }
  isEmptyRowGroupNode() {
    return this.group && missingOrEmpty(this.childrenAfterGroup);
  }
  dispatchCellChangedEvent(column, newValue, oldValue) {
    const cellChangedEvent = {
      type: RowNode.EVENT_CELL_CHANGED,
      node: this,
      column,
      newValue,
      oldValue
    };
    this.dispatchLocalEvent(cellChangedEvent);
  }
  resetQuickFilterAggregateText() {
    this.quickFilterAggregateText = null;
  }
  isExpandable() {
    return this.hasChildren() && !this.footer || this.master ? true : false;
  }
  isSelected() {
    if (this.footer) {
      return this.sibling.isSelected();
    }
    return this.selected;
  }
  depthFirstSearch(callback) {
    if (this.childrenAfterGroup) {
      this.childrenAfterGroup.forEach((child) => child.depthFirstSearch(callback));
    }
    callback(this);
  }
  calculateSelectedFromChildren() {
    var _a;
    let atLeastOneSelected = false;
    let atLeastOneDeSelected = false;
    let atLeastOneMixed = false;
    if (!((_a = this.childrenAfterGroup) === null || _a === void 0 ? void 0 : _a.length)) {
      return this.selectable ? this.selected : null;
    }
    for (let i = 0; i < this.childrenAfterGroup.length; i++) {
      const child = this.childrenAfterGroup[i];
      let childState = child.isSelected();
      if (!child.selectable) {
        const selectable = child.calculateSelectedFromChildren();
        if (selectable === null) {
          continue;
        }
        childState = selectable;
      }
      switch (childState) {
        case true:
          atLeastOneSelected = true;
          break;
        case false:
          atLeastOneDeSelected = true;
          break;
        default:
          atLeastOneMixed = true;
          break;
      }
    }
    if (atLeastOneMixed || atLeastOneSelected && atLeastOneDeSelected) {
      return void 0;
    }
    if (atLeastOneSelected) {
      return true;
    }
    if (atLeastOneDeSelected) {
      return false;
    }
    if (!this.selectable) {
      return null;
    }
    return this.selected;
  }
  setSelectedInitialValue(selected) {
    this.selected = selected;
  }
  selectThisNode(newValue, e, source = "api") {
    const selectionNotAllowed = !this.selectable && newValue;
    const selectionNotChanged = this.selected === newValue;
    if (selectionNotAllowed || selectionNotChanged) {
      return false;
    }
    this.selected = newValue;
    if (this.eventService) {
      this.dispatchLocalEvent(this.createLocalRowEvent(RowNode.EVENT_ROW_SELECTED));
    }
    const event = Object.assign(Object.assign({}, this.createGlobalRowEvent(Events.EVENT_ROW_SELECTED)), { event: e || null, source });
    this.beans.eventService.dispatchEvent(event);
    return true;
  }
  setSelected(newValue, clearSelection = false, source = "api") {
    if (typeof source === "boolean") {
      console.warn("AG Grid: since version v30, rowNode.setSelected() property `suppressFinishActions` has been removed, please use `gridApi.setNodesSelected()` for bulk actions, and the event `source` property for ignoring events instead.");
      return;
    }
    this.setSelectedParams({
      newValue,
      clearSelection,
      rangeSelect: false,
      source
    });
  }
  setSelectedParams(params) {
    if (this.rowPinned) {
      console.warn("AG Grid: cannot select pinned rows");
      return 0;
    }
    if (this.id === void 0) {
      console.warn("AG Grid: cannot select node until id for node is known");
      return 0;
    }
    return this.beans.selectionService.setNodesSelected(Object.assign(Object.assign({}, params), { nodes: [this.footer ? this.sibling : this] }));
  }
  isRowPinned() {
    return this.rowPinned === "top" || this.rowPinned === "bottom";
  }
  isParentOfNode(potentialParent) {
    let parentNode = this.parent;
    while (parentNode) {
      if (parentNode === potentialParent) {
        return true;
      }
      parentNode = parentNode.parent;
    }
    return false;
  }
  addEventListener(eventType, listener) {
    if (!this.eventService) {
      this.eventService = new EventService();
    }
    this.eventService.addEventListener(eventType, listener);
  }
  removeEventListener(eventType, listener) {
    if (!this.eventService) {
      return;
    }
    this.eventService.removeEventListener(eventType, listener);
    if (this.eventService.noRegisteredListenersExist()) {
      this.eventService = null;
    }
  }
  onMouseEnter() {
    this.dispatchLocalEvent(this.createLocalRowEvent(RowNode.EVENT_MOUSE_ENTER));
  }
  onMouseLeave() {
    this.dispatchLocalEvent(this.createLocalRowEvent(RowNode.EVENT_MOUSE_LEAVE));
  }
  getFirstChildOfFirstChild(rowGroupColumn) {
    let currentRowNode = this;
    let isCandidate = true;
    let foundFirstChildPath = false;
    let nodeToSwapIn = null;
    while (isCandidate && !foundFirstChildPath) {
      const parentRowNode = currentRowNode.parent;
      const firstChild = exists(parentRowNode) && currentRowNode.firstChild;
      if (firstChild) {
        if (parentRowNode.rowGroupColumn === rowGroupColumn) {
          foundFirstChildPath = true;
          nodeToSwapIn = parentRowNode;
        }
      } else {
        isCandidate = false;
      }
      currentRowNode = parentRowNode;
    }
    return foundFirstChildPath ? nodeToSwapIn : null;
  }
  isFullWidthCell() {
    const isFullWidthCellFunc = this.beans.gridOptionsService.getCallback("isFullWidthRow");
    return isFullWidthCellFunc ? isFullWidthCellFunc({ rowNode: this }) : false;
  }
  getRoute() {
    if (this.key == null) {
      return;
    }
    const res = [];
    let pointer = this;
    while (pointer.key != null) {
      res.push(pointer.key);
      pointer = pointer.parent;
    }
    return res.reverse();
  }
  createFooter() {
    if (this.sibling) {
      return;
    }
    const footerNode = new RowNode(this.beans);
    Object.keys(this).forEach((key) => {
      footerNode[key] = this[key];
    });
    footerNode.footer = true;
    footerNode.setRowTop(null);
    footerNode.setRowIndex(null);
    footerNode.oldRowTop = null;
    footerNode.id = "rowGroupFooter_" + this.id;
    footerNode.sibling = this;
    this.sibling = footerNode;
  }
};
RowNode.ID_PREFIX_ROW_GROUP = "row-group-";
RowNode.ID_PREFIX_TOP_PINNED = "t-";
RowNode.ID_PREFIX_BOTTOM_PINNED = "b-";
RowNode.OBJECT_ID_SEQUENCE = 0;
RowNode.EVENT_ROW_SELECTED = "rowSelected";
RowNode.EVENT_DATA_CHANGED = "dataChanged";
RowNode.EVENT_CELL_CHANGED = "cellChanged";
RowNode.EVENT_ALL_CHILDREN_COUNT_CHANGED = "allChildrenCountChanged";
RowNode.EVENT_MASTER_CHANGED = "masterChanged";
RowNode.EVENT_GROUP_CHANGED = "groupChanged";
RowNode.EVENT_MOUSE_ENTER = "mouseEnter";
RowNode.EVENT_MOUSE_LEAVE = "mouseLeave";
RowNode.EVENT_HEIGHT_CHANGED = "heightChanged";
RowNode.EVENT_TOP_CHANGED = "topChanged";
RowNode.EVENT_DISPLAYED_CHANGED = "displayedChanged";
RowNode.EVENT_FIRST_CHILD_CHANGED = "firstChildChanged";
RowNode.EVENT_LAST_CHILD_CHANGED = "lastChildChanged";
RowNode.EVENT_CHILD_INDEX_CHANGED = "childIndexChanged";
RowNode.EVENT_ROW_INDEX_CHANGED = "rowIndexChanged";
RowNode.EVENT_EXPANDED_CHANGED = "expandedChanged";
RowNode.EVENT_HAS_CHILDREN_CHANGED = "hasChildrenChanged";
RowNode.EVENT_SELECTABLE_CHANGED = "selectableChanged";
RowNode.EVENT_UI_LEVEL_CHANGED = "uiLevelChanged";
RowNode.EVENT_HIGHLIGHT_CHANGED = "rowHighlightChanged";
RowNode.EVENT_DRAGGING_CHANGED = "draggingChanged";
var __decorate$25 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CheckboxSelectionComponent = class extends Component {
  constructor() {
    super(`
            <div class="ag-selection-checkbox" role="presentation">
                <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>
            </div>`);
  }
  postConstruct() {
    this.eCheckbox.setPassive(true);
    setAriaLive(this.eCheckbox.getInputElement(), "polite");
  }
  getCheckboxId() {
    return this.eCheckbox.getInputElement().id;
  }
  onDataChanged() {
    this.onSelectionChanged();
  }
  onSelectableChanged() {
    this.showOrHideSelect();
  }
  onSelectionChanged() {
    const translate = this.localeService.getLocaleTextFunc();
    const state = this.rowNode.isSelected();
    const stateName = getAriaCheckboxStateName(translate, state);
    const ariaLabel = translate("ariaRowToggleSelection", "Press Space to toggle row selection");
    this.eCheckbox.setValue(state, true);
    this.eCheckbox.setInputAriaLabel(`${ariaLabel} (${stateName})`);
  }
  onCheckedClicked(event) {
    const groupSelectsFiltered = this.gridOptionsService.is("groupSelectsFiltered");
    return this.rowNode.setSelectedParams({ newValue: false, rangeSelect: event.shiftKey, groupSelectsFiltered, event, source: "checkboxSelected" });
  }
  onUncheckedClicked(event) {
    const groupSelectsFiltered = this.gridOptionsService.is("groupSelectsFiltered");
    return this.rowNode.setSelectedParams({ newValue: true, rangeSelect: event.shiftKey, groupSelectsFiltered, event, source: "checkboxSelected" });
  }
  init(params) {
    this.rowNode = params.rowNode;
    this.column = params.column;
    this.overrides = params.overrides;
    this.onSelectionChanged();
    this.addManagedListener(this.eCheckbox.getInputElement(), "dblclick", (event) => {
      stopPropagationForAgGrid(event);
    });
    this.addManagedListener(this.eCheckbox.getInputElement(), "click", (event) => {
      stopPropagationForAgGrid(event);
      const isSelected = this.eCheckbox.getValue();
      if (isSelected) {
        this.onCheckedClicked(event);
      } else {
        this.onUncheckedClicked(event || {});
      }
    });
    this.addManagedListener(this.rowNode, RowNode.EVENT_ROW_SELECTED, this.onSelectionChanged.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_DATA_CHANGED, this.onDataChanged.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_SELECTABLE_CHANGED, this.onSelectableChanged.bind(this));
    const isRowSelectableFunc = this.gridOptionsService.get("isRowSelectable");
    const checkboxVisibleIsDynamic = isRowSelectableFunc || typeof this.getIsVisible() === "function";
    if (checkboxVisibleIsDynamic) {
      const showOrHideSelectListener = this.showOrHideSelect.bind(this);
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, showOrHideSelectListener);
      this.addManagedListener(this.rowNode, RowNode.EVENT_DATA_CHANGED, showOrHideSelectListener);
      this.addManagedListener(this.rowNode, RowNode.EVENT_CELL_CHANGED, showOrHideSelectListener);
      this.showOrHideSelect();
    }
    this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
  }
  showOrHideSelect() {
    var _a, _b, _c, _d;
    let selectable = this.rowNode.selectable;
    const isVisible2 = this.getIsVisible();
    if (selectable) {
      if (typeof isVisible2 === "function") {
        const extraParams = (_a = this.overrides) === null || _a === void 0 ? void 0 : _a.callbackParams;
        const params = (_b = this.column) === null || _b === void 0 ? void 0 : _b.createColumnFunctionCallbackParams(this.rowNode);
        selectable = params ? isVisible2(Object.assign(Object.assign({}, extraParams), params)) : false;
      } else {
        selectable = isVisible2 !== null && isVisible2 !== void 0 ? isVisible2 : false;
      }
    }
    const disableInsteadOfHide = (_c = this.column) === null || _c === void 0 ? void 0 : _c.getColDef().showDisabledCheckboxes;
    if (disableInsteadOfHide) {
      this.eCheckbox.setDisabled(!selectable);
      this.setVisible(true);
      this.setDisplayed(true);
      return;
    }
    if ((_d = this.overrides) === null || _d === void 0 ? void 0 : _d.removeHidden) {
      this.setDisplayed(selectable);
      return;
    }
    this.setVisible(selectable);
  }
  getIsVisible() {
    var _a, _b;
    if (this.overrides) {
      return this.overrides.isVisible;
    }
    return (_b = (_a = this.column) === null || _a === void 0 ? void 0 : _a.getColDef()) === null || _b === void 0 ? void 0 : _b.checkboxSelection;
  }
};
__decorate$25([
  RefSelector("eCheckbox")
], CheckboxSelectionComponent.prototype, "eCheckbox", void 0);
__decorate$25([
  PostConstruct
], CheckboxSelectionComponent.prototype, "postConstruct", null);
var __decorate$24 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DragAndDropService_1;
var DragSourceType;
(function(DragSourceType2) {
  DragSourceType2[DragSourceType2["ToolPanel"] = 0] = "ToolPanel";
  DragSourceType2[DragSourceType2["HeaderCell"] = 1] = "HeaderCell";
  DragSourceType2[DragSourceType2["RowDrag"] = 2] = "RowDrag";
  DragSourceType2[DragSourceType2["ChartPanel"] = 3] = "ChartPanel";
})(DragSourceType || (DragSourceType = {}));
var VerticalDirection;
(function(VerticalDirection2) {
  VerticalDirection2[VerticalDirection2["Up"] = 0] = "Up";
  VerticalDirection2[VerticalDirection2["Down"] = 1] = "Down";
})(VerticalDirection || (VerticalDirection = {}));
var HorizontalDirection;
(function(HorizontalDirection2) {
  HorizontalDirection2[HorizontalDirection2["Left"] = 0] = "Left";
  HorizontalDirection2[HorizontalDirection2["Right"] = 1] = "Right";
})(HorizontalDirection || (HorizontalDirection = {}));
var DragAndDropService = DragAndDropService_1 = class DragAndDropService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.dragSourceAndParamsList = [];
    this.dropTargets = [];
  }
  init() {
    this.ePinnedIcon = createIcon("columnMovePin", this.gridOptionsService, null);
    this.eHideIcon = createIcon("columnMoveHide", this.gridOptionsService, null);
    this.eMoveIcon = createIcon("columnMoveMove", this.gridOptionsService, null);
    this.eLeftIcon = createIcon("columnMoveLeft", this.gridOptionsService, null);
    this.eRightIcon = createIcon("columnMoveRight", this.gridOptionsService, null);
    this.eGroupIcon = createIcon("columnMoveGroup", this.gridOptionsService, null);
    this.eAggregateIcon = createIcon("columnMoveValue", this.gridOptionsService, null);
    this.ePivotIcon = createIcon("columnMovePivot", this.gridOptionsService, null);
    this.eDropNotAllowedIcon = createIcon("dropNotAllowed", this.gridOptionsService, null);
  }
  addDragSource(dragSource, allowTouch = false) {
    const params = {
      eElement: dragSource.eElement,
      dragStartPixels: dragSource.dragStartPixels,
      onDragStart: this.onDragStart.bind(this, dragSource),
      onDragStop: this.onDragStop.bind(this),
      onDragging: this.onDragging.bind(this)
    };
    this.dragSourceAndParamsList.push({ params, dragSource });
    this.dragService.addDragSource(params, allowTouch);
  }
  removeDragSource(dragSource) {
    const sourceAndParams = this.dragSourceAndParamsList.find((item) => item.dragSource === dragSource);
    if (sourceAndParams) {
      this.dragService.removeDragSource(sourceAndParams.params);
      removeFromArray(this.dragSourceAndParamsList, sourceAndParams);
    }
  }
  clearDragSourceParamsList() {
    this.dragSourceAndParamsList.forEach((sourceAndParams) => this.dragService.removeDragSource(sourceAndParams.params));
    this.dragSourceAndParamsList.length = 0;
    this.dropTargets.length = 0;
  }
  nudge() {
    if (this.dragging) {
      this.onDragging(this.eventLastTime, true);
    }
  }
  onDragStart(dragSource, mouseEvent) {
    this.dragging = true;
    this.dragSource = dragSource;
    this.eventLastTime = mouseEvent;
    this.dragItem = this.dragSource.getDragItem();
    this.lastDropTarget = this.dragSource.dragSourceDropTarget;
    if (this.dragSource.onDragStarted) {
      this.dragSource.onDragStarted();
    }
    this.createGhost();
  }
  onDragStop(mouseEvent) {
    this.eventLastTime = null;
    this.dragging = false;
    if (this.dragSource.onDragStopped) {
      this.dragSource.onDragStopped();
    }
    if (this.lastDropTarget && this.lastDropTarget.onDragStop) {
      const draggingEvent = this.createDropTargetEvent(this.lastDropTarget, mouseEvent, null, null, false);
      this.lastDropTarget.onDragStop(draggingEvent);
    }
    this.lastDropTarget = null;
    this.dragItem = null;
    this.removeGhost();
  }
  onDragging(mouseEvent, fromNudge) {
    var _a, _b, _c, _d;
    const hDirection = this.getHorizontalDirection(mouseEvent);
    const vDirection = this.getVerticalDirection(mouseEvent);
    this.eventLastTime = mouseEvent;
    this.positionGhost(mouseEvent);
    const validDropTargets = this.dropTargets.filter((target) => this.isMouseOnDropTarget(mouseEvent, target));
    const dropTarget = this.findCurrentDropTarget(mouseEvent, validDropTargets);
    if (dropTarget !== this.lastDropTarget) {
      this.leaveLastTargetIfExists(mouseEvent, hDirection, vDirection, fromNudge);
      if (this.lastDropTarget !== null && dropTarget === null) {
        (_b = (_a = this.dragSource).onGridExit) === null || _b === void 0 ? void 0 : _b.call(_a, this.dragItem);
      }
      if (this.lastDropTarget === null && dropTarget !== null) {
        (_d = (_c = this.dragSource).onGridEnter) === null || _d === void 0 ? void 0 : _d.call(_c, this.dragItem);
      }
      this.enterDragTargetIfExists(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
      this.lastDropTarget = dropTarget;
    } else if (dropTarget && dropTarget.onDragging) {
      const draggingEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
      dropTarget.onDragging(draggingEvent);
    }
  }
  getAllContainersFromDropTarget(dropTarget) {
    const secondaryContainers = dropTarget.getSecondaryContainers ? dropTarget.getSecondaryContainers() : null;
    const containers = [[dropTarget.getContainer()]];
    return secondaryContainers ? containers.concat(secondaryContainers) : containers;
  }
  allContainersIntersect(mouseEvent, containers) {
    for (const container of containers) {
      const rect = container.getBoundingClientRect();
      if (rect.width === 0 || rect.height === 0) {
        return false;
      }
      const horizontalFit = mouseEvent.clientX >= rect.left && mouseEvent.clientX < rect.right;
      const verticalFit = mouseEvent.clientY >= rect.top && mouseEvent.clientY < rect.bottom;
      if (!horizontalFit || !verticalFit) {
        return false;
      }
    }
    return true;
  }
  isMouseOnDropTarget(mouseEvent, dropTarget) {
    const allContainersFromDropTarget = this.getAllContainersFromDropTarget(dropTarget);
    let mouseOverTarget = false;
    for (const currentContainers of allContainersFromDropTarget) {
      if (this.allContainersIntersect(mouseEvent, currentContainers)) {
        mouseOverTarget = true;
        break;
      }
    }
    if (dropTarget.targetContainsSource && !dropTarget.getContainer().contains(this.dragSource.eElement)) {
      return false;
    }
    return mouseOverTarget && dropTarget.isInterestedIn(this.dragSource.type, this.dragSource.eElement);
  }
  findCurrentDropTarget(mouseEvent, validDropTargets) {
    const len = validDropTargets.length;
    if (len === 0) {
      return null;
    }
    if (len === 1) {
      return validDropTargets[0];
    }
    const rootNode = this.gridOptionsService.getRootNode();
    const elementStack = rootNode.elementsFromPoint(mouseEvent.clientX, mouseEvent.clientY);
    for (const el of elementStack) {
      for (const dropTarget of validDropTargets) {
        const containers = flatten(this.getAllContainersFromDropTarget(dropTarget));
        if (containers.indexOf(el) !== -1) {
          return dropTarget;
        }
      }
    }
    return null;
  }
  enterDragTargetIfExists(dropTarget, mouseEvent, hDirection, vDirection, fromNudge) {
    if (!dropTarget) {
      return;
    }
    if (dropTarget.onDragEnter) {
      const dragEnterEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
      dropTarget.onDragEnter(dragEnterEvent);
    }
    this.setGhostIcon(dropTarget.getIconName ? dropTarget.getIconName() : null);
  }
  leaveLastTargetIfExists(mouseEvent, hDirection, vDirection, fromNudge) {
    if (!this.lastDropTarget) {
      return;
    }
    if (this.lastDropTarget.onDragLeave) {
      const dragLeaveEvent = this.createDropTargetEvent(this.lastDropTarget, mouseEvent, hDirection, vDirection, fromNudge);
      this.lastDropTarget.onDragLeave(dragLeaveEvent);
    }
    this.setGhostIcon(null);
  }
  addDropTarget(dropTarget) {
    this.dropTargets.push(dropTarget);
  }
  removeDropTarget(dropTarget) {
    this.dropTargets = this.dropTargets.filter((target) => target.getContainer() !== dropTarget.getContainer());
  }
  hasExternalDropZones() {
    return this.dropTargets.some((zones) => zones.external);
  }
  findExternalZone(params) {
    const externalTargets = this.dropTargets.filter((target) => target.external);
    return externalTargets.find((zone) => zone.getContainer() === params.getContainer()) || null;
  }
  getHorizontalDirection(event) {
    const clientX = this.eventLastTime && this.eventLastTime.clientX;
    const eClientX = event.clientX;
    if (clientX === eClientX) {
      return null;
    }
    return clientX > eClientX ? HorizontalDirection.Left : HorizontalDirection.Right;
  }
  getVerticalDirection(event) {
    const clientY = this.eventLastTime && this.eventLastTime.clientY;
    const eClientY = event.clientY;
    if (clientY === eClientY) {
      return null;
    }
    return clientY > eClientY ? VerticalDirection.Up : VerticalDirection.Down;
  }
  createDropTargetEvent(dropTarget, event, hDirection, vDirection, fromNudge) {
    const dropZoneTarget = dropTarget.getContainer();
    const rect = dropZoneTarget.getBoundingClientRect();
    const { gridApi: api, columnApi, dragItem, dragSource } = this;
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    return { event, x, y, vDirection, hDirection, dragSource, fromNudge, dragItem, api, columnApi, dropZoneTarget };
  }
  positionGhost(event) {
    const ghost = this.eGhost;
    if (!ghost) {
      return;
    }
    const ghostRect = ghost.getBoundingClientRect();
    const ghostHeight = ghostRect.height;
    const browserWidth = getBodyWidth() - 2;
    const browserHeight = getBodyHeight() - 2;
    let top = event.pageY - ghostHeight / 2;
    let left = event.pageX - 10;
    const eDocument = this.gridOptionsService.getDocument();
    const win = eDocument.defaultView || window;
    const windowScrollY = win.pageYOffset || eDocument.documentElement.scrollTop;
    const windowScrollX = win.pageXOffset || eDocument.documentElement.scrollLeft;
    if (browserWidth > 0 && left + ghost.clientWidth > browserWidth + windowScrollX) {
      left = browserWidth + windowScrollX - ghost.clientWidth;
    }
    if (left < 0) {
      left = 0;
    }
    if (browserHeight > 0 && top + ghost.clientHeight > browserHeight + windowScrollY) {
      top = browserHeight + windowScrollY - ghost.clientHeight;
    }
    if (top < 0) {
      top = 0;
    }
    ghost.style.left = `${left}px`;
    ghost.style.top = `${top}px`;
  }
  removeGhost() {
    if (this.eGhost && this.eGhostParent) {
      this.eGhostParent.removeChild(this.eGhost);
    }
    this.eGhost = null;
  }
  createGhost() {
    this.eGhost = loadTemplate(DragAndDropService_1.GHOST_TEMPLATE);
    this.mouseEventService.stampTopLevelGridCompWithGridInstance(this.eGhost);
    const { theme } = this.environment.getTheme();
    if (theme) {
      this.eGhost.classList.add(theme);
    }
    this.eGhostIcon = this.eGhost.querySelector(".ag-dnd-ghost-icon");
    this.setGhostIcon(null);
    const eText = this.eGhost.querySelector(".ag-dnd-ghost-label");
    let dragItemName = this.dragSource.dragItemName;
    if (isFunction(dragItemName)) {
      dragItemName = dragItemName();
    }
    eText.innerHTML = escapeString(dragItemName) || "";
    this.eGhost.style.height = "25px";
    this.eGhost.style.top = "20px";
    this.eGhost.style.left = "20px";
    const eDocument = this.gridOptionsService.getDocument();
    let targetEl = null;
    try {
      targetEl = eDocument.fullscreenElement;
    } catch (e) {
    } finally {
      if (!targetEl) {
        const rootNode = this.gridOptionsService.getRootNode();
        const body = rootNode.querySelector("body");
        if (body) {
          targetEl = body;
        } else if (rootNode instanceof ShadowRoot) {
          targetEl = rootNode;
        } else {
          targetEl = rootNode === null || rootNode === void 0 ? void 0 : rootNode.documentElement;
        }
      }
    }
    this.eGhostParent = targetEl;
    if (!this.eGhostParent) {
      console.warn("AG Grid: could not find document body, it is needed for dragging columns");
    } else {
      this.eGhostParent.appendChild(this.eGhost);
    }
  }
  setGhostIcon(iconName, shake = false) {
    clearElement(this.eGhostIcon);
    let eIcon = null;
    if (!iconName) {
      iconName = this.dragSource.defaultIconName || DragAndDropService_1.ICON_NOT_ALLOWED;
    }
    switch (iconName) {
      case DragAndDropService_1.ICON_PINNED:
        eIcon = this.ePinnedIcon;
        break;
      case DragAndDropService_1.ICON_MOVE:
        eIcon = this.eMoveIcon;
        break;
      case DragAndDropService_1.ICON_LEFT:
        eIcon = this.eLeftIcon;
        break;
      case DragAndDropService_1.ICON_RIGHT:
        eIcon = this.eRightIcon;
        break;
      case DragAndDropService_1.ICON_GROUP:
        eIcon = this.eGroupIcon;
        break;
      case DragAndDropService_1.ICON_AGGREGATE:
        eIcon = this.eAggregateIcon;
        break;
      case DragAndDropService_1.ICON_PIVOT:
        eIcon = this.ePivotIcon;
        break;
      case DragAndDropService_1.ICON_NOT_ALLOWED:
        eIcon = this.eDropNotAllowedIcon;
        break;
      case DragAndDropService_1.ICON_HIDE:
        eIcon = this.eHideIcon;
        break;
    }
    this.eGhostIcon.classList.toggle("ag-shake-left-to-right", shake);
    if (eIcon === this.eHideIcon && this.gridOptionsService.is("suppressDragLeaveHidesColumns")) {
      return;
    }
    if (eIcon) {
      this.eGhostIcon.appendChild(eIcon);
    }
  }
};
DragAndDropService.ICON_PINNED = "pinned";
DragAndDropService.ICON_MOVE = "move";
DragAndDropService.ICON_LEFT = "left";
DragAndDropService.ICON_RIGHT = "right";
DragAndDropService.ICON_GROUP = "group";
DragAndDropService.ICON_AGGREGATE = "aggregate";
DragAndDropService.ICON_PIVOT = "pivot";
DragAndDropService.ICON_NOT_ALLOWED = "notAllowed";
DragAndDropService.ICON_HIDE = "hide";
DragAndDropService.GHOST_TEMPLATE = `<div class="ag-dnd-ghost ag-unselectable">
            <span class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>
            <div class="ag-dnd-ghost-label"></div>
        </div>`;
__decorate$24([
  Autowired("dragService")
], DragAndDropService.prototype, "dragService", void 0);
__decorate$24([
  Autowired("mouseEventService")
], DragAndDropService.prototype, "mouseEventService", void 0);
__decorate$24([
  Autowired("columnApi")
], DragAndDropService.prototype, "columnApi", void 0);
__decorate$24([
  Autowired("gridApi")
], DragAndDropService.prototype, "gridApi", void 0);
__decorate$24([
  PostConstruct
], DragAndDropService.prototype, "init", null);
__decorate$24([
  PreDestroy
], DragAndDropService.prototype, "clearDragSourceParamsList", null);
DragAndDropService = DragAndDropService_1 = __decorate$24([
  Bean("dragAndDropService")
], DragAndDropService);
var __decorate$23 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RowDragComp = class extends Component {
  constructor(cellValueFn, rowNode, column, customGui, dragStartPixels, suppressVisibilityChange) {
    super();
    this.cellValueFn = cellValueFn;
    this.rowNode = rowNode;
    this.column = column;
    this.customGui = customGui;
    this.dragStartPixels = dragStartPixels;
    this.suppressVisibilityChange = suppressVisibilityChange;
    this.dragSource = null;
  }
  isCustomGui() {
    return this.customGui != null;
  }
  postConstruct() {
    if (!this.customGui) {
      this.setTemplate(`<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>`);
      this.getGui().appendChild(createIconNoSpan("rowDrag", this.gridOptionsService, null));
      this.addDragSource();
    } else {
      this.setDragElement(this.customGui, this.dragStartPixels);
    }
    this.checkCompatibility();
    if (!this.suppressVisibilityChange) {
      const strategy = this.gridOptionsService.is("rowDragManaged") ? new ManagedVisibilityStrategy(this, this.beans, this.rowNode, this.column) : new NonManagedVisibilityStrategy(this, this.beans, this.rowNode, this.column);
      this.createManagedBean(strategy, this.beans.context);
    }
  }
  setDragElement(dragElement, dragStartPixels) {
    this.setTemplateFromElement(dragElement);
    this.addDragSource(dragStartPixels);
  }
  getSelectedNodes() {
    const isRowDragMultiRow = this.gridOptionsService.is("rowDragMultiRow");
    if (!isRowDragMultiRow) {
      return [this.rowNode];
    }
    const selection = this.beans.selectionService.getSelectedNodes();
    return selection.indexOf(this.rowNode) !== -1 ? selection : [this.rowNode];
  }
  checkCompatibility() {
    const managed = this.gridOptionsService.is("rowDragManaged");
    const treeData = this.gridOptionsService.isTreeData();
    if (treeData && managed) {
      doOnce(() => console.warn("AG Grid: If using row drag with tree data, you cannot have rowDragManaged=true"), "RowDragComp.managedAndTreeData");
    }
  }
  getDragItem() {
    return {
      rowNode: this.rowNode,
      rowNodes: this.getSelectedNodes(),
      columns: this.column ? [this.column] : void 0,
      defaultTextValue: this.cellValueFn()
    };
  }
  getRowDragText(column) {
    if (column) {
      const colDef = column.getColDef();
      if (colDef.rowDragText) {
        return colDef.rowDragText;
      }
    }
    return this.gridOptionsService.get("rowDragText");
  }
  addDragSource(dragStartPixels = 4) {
    if (this.dragSource) {
      this.removeDragSource();
    }
    const rowDragText = this.getRowDragText(this.column);
    const translate = this.localeService.getLocaleTextFunc();
    this.dragSource = {
      type: DragSourceType.RowDrag,
      eElement: this.getGui(),
      dragItemName: () => {
        var _a;
        const dragItem = this.getDragItem();
        const dragItemCount = ((_a = dragItem.rowNodes) === null || _a === void 0 ? void 0 : _a.length) || 1;
        if (rowDragText) {
          return rowDragText(dragItem, dragItemCount);
        }
        return dragItemCount === 1 ? this.cellValueFn() : `${dragItemCount} ${translate("rowDragRows", "rows")}`;
      },
      getDragItem: () => this.getDragItem(),
      dragStartPixels,
      dragSourceDomDataKey: this.gridOptionsService.getDomDataKey()
    };
    this.beans.dragAndDropService.addDragSource(this.dragSource, true);
  }
  removeDragSource() {
    if (this.dragSource) {
      this.beans.dragAndDropService.removeDragSource(this.dragSource);
    }
    this.dragSource = null;
  }
};
__decorate$23([
  Autowired("beans")
], RowDragComp.prototype, "beans", void 0);
__decorate$23([
  PostConstruct
], RowDragComp.prototype, "postConstruct", null);
__decorate$23([
  PreDestroy
], RowDragComp.prototype, "removeDragSource", null);
var VisibilityStrategy = class extends BeanStub {
  constructor(parent, rowNode, column) {
    super();
    this.parent = parent;
    this.rowNode = rowNode;
    this.column = column;
  }
  setDisplayedOrVisible(neverDisplayed) {
    const displayedOptions = { skipAriaHidden: true };
    if (neverDisplayed) {
      this.parent.setDisplayed(false, displayedOptions);
    } else {
      let shown = true;
      let isShownSometimes = false;
      if (this.column) {
        shown = this.column.isRowDrag(this.rowNode) || this.parent.isCustomGui();
        isShownSometimes = isFunction(this.column.getColDef().rowDrag);
      }
      if (isShownSometimes) {
        this.parent.setDisplayed(true, displayedOptions);
        this.parent.setVisible(shown, displayedOptions);
      } else {
        this.parent.setDisplayed(shown, displayedOptions);
        this.parent.setVisible(true, displayedOptions);
      }
    }
  }
};
var NonManagedVisibilityStrategy = class extends VisibilityStrategy {
  constructor(parent, beans, rowNode, column) {
    super(parent, rowNode, column);
    this.beans = beans;
  }
  postConstruct() {
    this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this));
    this.addManagedListener(this.beans.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.workOutVisibility.bind(this));
    this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const neverDisplayed = this.gridOptionsService.is("suppressRowDrag");
    this.setDisplayedOrVisible(neverDisplayed);
  }
};
__decorate$23([
  PostConstruct
], NonManagedVisibilityStrategy.prototype, "postConstruct", null);
var ManagedVisibilityStrategy = class extends VisibilityStrategy {
  constructor(parent, beans, rowNode, column) {
    super(parent, rowNode, column);
    this.beans = beans;
  }
  postConstruct() {
    this.addManagedListener(this.beans.eventService, Events.EVENT_SORT_CHANGED, this.workOutVisibility.bind(this));
    this.addManagedListener(this.beans.eventService, Events.EVENT_FILTER_CHANGED, this.workOutVisibility.bind(this));
    this.addManagedListener(this.beans.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.workOutVisibility.bind(this));
    this.addManagedListener(this.beans.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.workOutVisibility.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this));
    this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this));
    this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const gridBodyCon = this.beans.ctrlsService.getGridBodyCtrl();
    const rowDragFeature = gridBodyCon.getRowDragFeature();
    const shouldPreventRowMove = rowDragFeature && rowDragFeature.shouldPreventRowMove();
    const suppressRowDrag = this.gridOptionsService.is("suppressRowDrag");
    const hasExternalDropZones = this.beans.dragAndDropService.hasExternalDropZones();
    const neverDisplayed = shouldPreventRowMove && !hasExternalDropZones || suppressRowDrag;
    this.setDisplayedOrVisible(neverDisplayed);
  }
};
__decorate$23([
  PostConstruct
], ManagedVisibilityStrategy.prototype, "postConstruct", null);
var __decorate$22 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GroupCellRendererCtrl = class extends BeanStub {
  init(comp, eGui, eCheckbox, eExpanded, eContracted, compClass, params) {
    this.params = params;
    this.eGui = eGui;
    this.eCheckbox = eCheckbox;
    this.eExpanded = eExpanded;
    this.eContracted = eContracted;
    this.comp = comp;
    this.compClass = compClass;
    const topLevelFooter = this.isTopLevelFooter();
    const embeddedRowMismatch = this.isEmbeddedRowMismatch();
    const isNullValueAndNotMaster = params.value == null && !params.node.master;
    let skipCell = false;
    if (this.gridOptionsService.is("groupIncludeFooter") && this.gridOptionsService.is("groupHideOpenParents")) {
      const node = params.node;
      if (node.footer) {
        const showRowGroup = params.colDef && params.colDef.showRowGroup;
        const rowGroupColumnId = node.rowGroupColumn && node.rowGroupColumn.getColId();
        skipCell = showRowGroup !== rowGroupColumnId;
      }
    }
    this.cellIsBlank = topLevelFooter ? false : embeddedRowMismatch || isNullValueAndNotMaster && !params.node.master || skipCell;
    if (this.cellIsBlank) {
      return;
    }
    this.setupShowingValueForOpenedParent();
    this.findDisplayedGroupNode();
    this.addFullWidthRowDraggerIfNeeded();
    this.addExpandAndContract();
    this.addCheckboxIfNeeded();
    this.addValueElement();
    this.setupIndent();
    this.refreshAriaExpanded();
  }
  destroy() {
    super.destroy();
    this.expandListener = null;
  }
  refreshAriaExpanded() {
    const { node, eParentOfValue } = this.params;
    if (this.expandListener) {
      this.expandListener = this.expandListener();
    }
    if (!this.isExpandable()) {
      removeAriaExpanded(eParentOfValue);
      return;
    }
    const listener = () => {
      setAriaExpanded(eParentOfValue, !!node.expanded);
    };
    this.expandListener = this.addManagedListener(node, RowNode.EVENT_EXPANDED_CHANGED, listener) || null;
    listener();
  }
  isTopLevelFooter() {
    if (!this.gridOptionsService.is("groupIncludeTotalFooter")) {
      return false;
    }
    if (this.params.value != null || this.params.node.level != -1) {
      return false;
    }
    const colDef = this.params.colDef;
    const doingFullWidth = colDef == null;
    if (doingFullWidth) {
      return true;
    }
    if (colDef.showRowGroup === true) {
      return true;
    }
    const rowGroupCols = this.columnModel.getRowGroupColumns();
    if (!rowGroupCols || rowGroupCols.length === 0) {
      return true;
    }
    const firstRowGroupCol = rowGroupCols[0];
    return firstRowGroupCol.getId() === colDef.showRowGroup;
  }
  isEmbeddedRowMismatch() {
    if (!this.params.fullWidth || !this.gridOptionsService.is("embedFullWidthRows")) {
      return false;
    }
    const pinnedLeftCell = this.params.pinned === "left";
    const pinnedRightCell = this.params.pinned === "right";
    const bodyCell = !pinnedLeftCell && !pinnedRightCell;
    if (this.gridOptionsService.is("enableRtl")) {
      if (this.columnModel.isPinningLeft()) {
        return !pinnedRightCell;
      }
      return !bodyCell;
    }
    if (this.columnModel.isPinningLeft()) {
      return !pinnedLeftCell;
    }
    return !bodyCell;
  }
  findDisplayedGroupNode() {
    const column = this.params.column;
    const rowNode = this.params.node;
    if (this.showingValueForOpenedParent) {
      let pointer = rowNode.parent;
      while (pointer != null) {
        if (pointer.rowGroupColumn && column.isRowGroupDisplayed(pointer.rowGroupColumn.getId())) {
          this.displayedGroupNode = pointer;
          break;
        }
        pointer = pointer.parent;
      }
    }
    if (missing(this.displayedGroupNode)) {
      this.displayedGroupNode = rowNode;
    }
  }
  setupShowingValueForOpenedParent() {
    const rowNode = this.params.node;
    const column = this.params.column;
    if (!this.gridOptionsService.is("groupHideOpenParents")) {
      this.showingValueForOpenedParent = false;
      return;
    }
    if (!rowNode.groupData) {
      this.showingValueForOpenedParent = false;
      return;
    }
    const showingGroupNode = rowNode.rowGroupColumn != null;
    if (showingGroupNode) {
      const keyOfGroupingColumn = rowNode.rowGroupColumn.getId();
      const configuredToShowThisGroupLevel = column.isRowGroupDisplayed(keyOfGroupingColumn);
      if (configuredToShowThisGroupLevel) {
        this.showingValueForOpenedParent = false;
        return;
      }
    }
    const valPresent = rowNode.groupData[column.getId()] != null;
    this.showingValueForOpenedParent = valPresent;
  }
  addValueElement() {
    if (this.displayedGroupNode.footer) {
      this.addFooterValue();
    } else {
      this.addGroupValue();
      this.addChildCount();
    }
  }
  addGroupValue() {
    const paramsAdjusted = this.adjustParamsWithDetailsFromRelatedColumn();
    const innerCompDetails = this.getInnerCompDetails(paramsAdjusted);
    const { valueFormatted, value } = paramsAdjusted;
    let valueWhenNoRenderer = valueFormatted;
    if (valueWhenNoRenderer == null) {
      if (value === "" && this.params.node.group) {
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        valueWhenNoRenderer = localeTextFunc("blanks", "(Blanks)");
      } else {
        valueWhenNoRenderer = value !== null && value !== void 0 ? value : null;
      }
    }
    this.comp.setInnerRenderer(innerCompDetails, valueWhenNoRenderer);
  }
  adjustParamsWithDetailsFromRelatedColumn() {
    const relatedColumn = this.displayedGroupNode.rowGroupColumn;
    const column = this.params.column;
    if (!relatedColumn) {
      return this.params;
    }
    const notFullWidth = column != null;
    if (notFullWidth) {
      const showingThisRowGroup = column.isRowGroupDisplayed(relatedColumn.getId());
      if (!showingThisRowGroup) {
        return this.params;
      }
    }
    const params = this.params;
    const { value, node } = this.params;
    const valueFormatted = this.valueFormatterService.formatValue(relatedColumn, node, value);
    const paramsAdjusted = Object.assign(Object.assign({}, params), { valueFormatted });
    return paramsAdjusted;
  }
  addFooterValue() {
    const footerValueGetter = this.params.footerValueGetter;
    let footerValue = "";
    if (footerValueGetter) {
      const paramsClone = cloneObject(this.params);
      paramsClone.value = this.params.value;
      if (typeof footerValueGetter === "function") {
        footerValue = footerValueGetter(paramsClone);
      } else if (typeof footerValueGetter === "string") {
        footerValue = this.expressionService.evaluate(footerValueGetter, paramsClone);
      } else {
        console.warn("AG Grid: footerValueGetter should be either a function or a string (expression)");
      }
    } else {
      footerValue = "Total " + (this.params.value != null ? this.params.value : "");
    }
    const innerCompDetails = this.getInnerCompDetails(this.params);
    this.comp.setInnerRenderer(innerCompDetails, footerValue);
  }
  getInnerCompDetails(params) {
    if (params.fullWidth) {
      return this.userComponentFactory.getFullWidthGroupRowInnerCellRenderer(this.gridOptionsService.get("groupRowRendererParams"), params);
    }
    const innerCompDetails = this.userComponentFactory.getInnerRendererDetails(params, params);
    const isGroupRowRenderer = (details) => details && details.componentClass == this.compClass;
    if (innerCompDetails && !isGroupRowRenderer(innerCompDetails)) {
      return innerCompDetails;
    }
    const relatedColumn = this.displayedGroupNode.rowGroupColumn;
    const relatedColDef = relatedColumn ? relatedColumn.getColDef() : void 0;
    if (!relatedColDef) {
      return;
    }
    const relatedCompDetails = this.userComponentFactory.getCellRendererDetails(relatedColDef, params);
    if (relatedCompDetails && !isGroupRowRenderer(relatedCompDetails)) {
      return relatedCompDetails;
    }
    if (isGroupRowRenderer(relatedCompDetails) && relatedColDef.cellRendererParams && relatedColDef.cellRendererParams.innerRenderer) {
      const res = this.userComponentFactory.getInnerRendererDetails(relatedColDef.cellRendererParams, params);
      return res;
    }
  }
  addChildCount() {
    if (this.params.suppressCount) {
      return;
    }
    this.addManagedListener(this.displayedGroupNode, RowNode.EVENT_ALL_CHILDREN_COUNT_CHANGED, this.updateChildCount.bind(this));
    this.updateChildCount();
  }
  updateChildCount() {
    const allChildrenCount = this.displayedGroupNode.allChildrenCount;
    const showingGroupForThisNode = this.isShowRowGroupForThisRow();
    const showCount = showingGroupForThisNode && allChildrenCount != null && allChildrenCount >= 0;
    const countString = showCount ? `(${allChildrenCount})` : ``;
    this.comp.setChildCount(countString);
  }
  isShowRowGroupForThisRow() {
    if (this.gridOptionsService.isTreeData()) {
      return true;
    }
    const rowGroupColumn = this.displayedGroupNode.rowGroupColumn;
    if (!rowGroupColumn) {
      return false;
    }
    const column = this.params.column;
    const thisColumnIsInterested = column == null || column.isRowGroupDisplayed(rowGroupColumn.getId());
    return thisColumnIsInterested;
  }
  addExpandAndContract() {
    var _a;
    const params = this.params;
    const eExpandedIcon = createIconNoSpan("groupExpanded", this.gridOptionsService, null);
    const eContractedIcon = createIconNoSpan("groupContracted", this.gridOptionsService, null);
    if (eExpandedIcon) {
      this.eExpanded.appendChild(eExpandedIcon);
    }
    if (eContractedIcon) {
      this.eContracted.appendChild(eContractedIcon);
    }
    const eGroupCell = params.eGridCell;
    const isDoubleClickEdit = ((_a = this.params.column) === null || _a === void 0 ? void 0 : _a.isCellEditable(params.node)) && this.gridOptionsService.is("enableGroupEdit");
    if (!isDoubleClickEdit && this.isExpandable() && !params.suppressDoubleClickExpand) {
      this.addManagedListener(eGroupCell, "dblclick", this.onCellDblClicked.bind(this));
    }
    this.addManagedListener(this.eExpanded, "click", this.onExpandClicked.bind(this));
    this.addManagedListener(this.eContracted, "click", this.onExpandClicked.bind(this));
    this.addManagedListener(eGroupCell, "keydown", this.onKeyDown.bind(this));
    this.addManagedListener(params.node, RowNode.EVENT_EXPANDED_CHANGED, this.showExpandAndContractIcons.bind(this));
    this.showExpandAndContractIcons();
    const expandableChangedListener = this.onRowNodeIsExpandableChanged.bind(this);
    this.addManagedListener(this.displayedGroupNode, RowNode.EVENT_ALL_CHILDREN_COUNT_CHANGED, expandableChangedListener);
    this.addManagedListener(this.displayedGroupNode, RowNode.EVENT_MASTER_CHANGED, expandableChangedListener);
    this.addManagedListener(this.displayedGroupNode, RowNode.EVENT_GROUP_CHANGED, expandableChangedListener);
    this.addManagedListener(this.displayedGroupNode, RowNode.EVENT_HAS_CHILDREN_CHANGED, expandableChangedListener);
  }
  onExpandClicked(mouseEvent) {
    if (isStopPropagationForAgGrid(mouseEvent)) {
      return;
    }
    stopPropagationForAgGrid(mouseEvent);
    this.onExpandOrContract(mouseEvent);
  }
  onExpandOrContract(e) {
    const rowNode = this.displayedGroupNode;
    const nextExpandState = !rowNode.expanded;
    if (!nextExpandState && rowNode.sticky) {
      this.scrollToStickyNode(rowNode);
    }
    rowNode.setExpanded(nextExpandState, e);
  }
  scrollToStickyNode(rowNode) {
    const gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
    const scrollFeature = gridBodyCtrl.getScrollFeature();
    scrollFeature.setVerticalScrollPosition(rowNode.rowTop - rowNode.stickyRowTop);
  }
  isExpandable() {
    if (this.showingValueForOpenedParent) {
      return true;
    }
    const rowNode = this.displayedGroupNode;
    const reducedLeafNode = this.columnModel.isPivotMode() && rowNode.leafGroup;
    const expandableGroup = rowNode.isExpandable() && !rowNode.footer && !reducedLeafNode;
    if (!expandableGroup) {
      return false;
    }
    const column = this.params.column;
    const displayingForOneColumnOnly = column != null && typeof column.getColDef().showRowGroup === "string";
    if (displayingForOneColumnOnly) {
      const showing = this.isShowRowGroupForThisRow();
      return showing;
    }
    return true;
  }
  showExpandAndContractIcons() {
    const { params, displayedGroupNode: displayedGroup, columnModel } = this;
    const { node } = params;
    const isExpandable = this.isExpandable();
    if (isExpandable) {
      const expanded = this.showingValueForOpenedParent ? true : node.expanded;
      this.comp.setExpandedDisplayed(expanded);
      this.comp.setContractedDisplayed(!expanded);
    } else {
      this.comp.setExpandedDisplayed(false);
      this.comp.setContractedDisplayed(false);
    }
    const pivotMode = columnModel.isPivotMode();
    const pivotModeAndLeafGroup = pivotMode && displayedGroup.leafGroup;
    const addExpandableCss = isExpandable && !pivotModeAndLeafGroup;
    const isTotalFooterNode = node.footer && node.level === -1;
    this.comp.addOrRemoveCssClass("ag-cell-expandable", addExpandableCss);
    this.comp.addOrRemoveCssClass("ag-row-group", addExpandableCss);
    if (pivotMode) {
      this.comp.addOrRemoveCssClass("ag-pivot-leaf-group", pivotModeAndLeafGroup);
    } else if (!isTotalFooterNode) {
      this.comp.addOrRemoveCssClass("ag-row-group-leaf-indent", !addExpandableCss);
    }
  }
  onRowNodeIsExpandableChanged() {
    this.showExpandAndContractIcons();
    this.setIndent();
    this.refreshAriaExpanded();
  }
  setupIndent() {
    const node = this.params.node;
    const suppressPadding = this.params.suppressPadding;
    if (!suppressPadding) {
      this.addManagedListener(node, RowNode.EVENT_UI_LEVEL_CHANGED, this.setIndent.bind(this));
      this.setIndent();
    }
  }
  setIndent() {
    if (this.gridOptionsService.is("groupHideOpenParents")) {
      return;
    }
    const params = this.params;
    const rowNode = params.node;
    const fullWithRow = !!params.colDef;
    const treeData = this.gridOptionsService.isTreeData();
    const manyDimensionThisColumn = !fullWithRow || treeData || params.colDef.showRowGroup === true;
    const paddingCount = manyDimensionThisColumn ? rowNode.uiLevel : 0;
    if (this.indentClass) {
      this.comp.addOrRemoveCssClass(this.indentClass, false);
    }
    this.indentClass = "ag-row-group-indent-" + paddingCount;
    this.comp.addOrRemoveCssClass(this.indentClass, true);
  }
  addFullWidthRowDraggerIfNeeded() {
    if (!this.params.fullWidth || !this.params.rowDrag) {
      return;
    }
    const rowDragComp = new RowDragComp(() => this.params.value, this.params.node);
    this.createManagedBean(rowDragComp, this.context);
    this.eGui.insertAdjacentElement("afterbegin", rowDragComp.getGui());
  }
  isUserWantsSelected() {
    const paramsCheckbox = this.params.checkbox;
    return typeof paramsCheckbox === "function" || paramsCheckbox === true;
  }
  addCheckboxIfNeeded() {
    const rowNode = this.displayedGroupNode;
    const checkboxNeeded = this.isUserWantsSelected() && !rowNode.footer && !rowNode.rowPinned && !rowNode.detail;
    if (checkboxNeeded) {
      const cbSelectionComponent = new CheckboxSelectionComponent();
      this.getContext().createBean(cbSelectionComponent);
      cbSelectionComponent.init({
        rowNode,
        column: this.params.column,
        overrides: {
          isVisible: this.params.checkbox,
          callbackParams: this.params,
          removeHidden: true
        }
      });
      this.eCheckbox.appendChild(cbSelectionComponent.getGui());
      this.addDestroyFunc(() => this.getContext().destroyBean(cbSelectionComponent));
    }
    this.comp.setCheckboxVisible(checkboxNeeded);
  }
  onKeyDown(event) {
    const isEnterKey = event.key === KeyCode.ENTER;
    if (!isEnterKey || this.params.suppressEnterExpand) {
      return;
    }
    const cellEditable = this.params.column && this.params.column.isCellEditable(this.params.node);
    if (cellEditable) {
      return;
    }
    this.onExpandOrContract(event);
  }
  onCellDblClicked(mouseEvent) {
    if (isStopPropagationForAgGrid(mouseEvent)) {
      return;
    }
    const targetIsExpandIcon = isElementInEventPath(this.eExpanded, mouseEvent) || isElementInEventPath(this.eContracted, mouseEvent);
    if (!targetIsExpandIcon) {
      this.onExpandOrContract(mouseEvent);
    }
  }
};
__decorate$22([
  Autowired("expressionService")
], GroupCellRendererCtrl.prototype, "expressionService", void 0);
__decorate$22([
  Autowired("valueFormatterService")
], GroupCellRendererCtrl.prototype, "valueFormatterService", void 0);
__decorate$22([
  Autowired("columnModel")
], GroupCellRendererCtrl.prototype, "columnModel", void 0);
__decorate$22([
  Autowired("userComponentFactory")
], GroupCellRendererCtrl.prototype, "userComponentFactory", void 0);
__decorate$22([
  Autowired("ctrlsService")
], GroupCellRendererCtrl.prototype, "ctrlsService", void 0);
var __decorate$21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GroupCellRenderer = class extends Component {
  constructor() {
    super(GroupCellRenderer.TEMPLATE);
  }
  init(params) {
    const compProxy = {
      setInnerRenderer: (compDetails, valueToDisplay) => this.setRenderDetails(compDetails, valueToDisplay),
      setChildCount: (count) => this.eChildCount.innerHTML = count,
      addOrRemoveCssClass: (cssClass, value) => this.addOrRemoveCssClass(cssClass, value),
      setContractedDisplayed: (expanded) => setDisplayed(this.eContracted, expanded),
      setExpandedDisplayed: (expanded) => setDisplayed(this.eExpanded, expanded),
      setCheckboxVisible: (visible) => this.eCheckbox.classList.toggle("ag-invisible", !visible)
    };
    const ctrl = this.createManagedBean(new GroupCellRendererCtrl());
    const fullWidth = !params.colDef;
    const eGui = this.getGui();
    ctrl.init(compProxy, eGui, this.eCheckbox, this.eExpanded, this.eContracted, this.constructor, params);
    if (fullWidth) {
      setAriaRole(eGui, "gridcell");
    }
  }
  setRenderDetails(compDetails, valueToDisplay) {
    if (compDetails) {
      const componentPromise = compDetails.newAgStackInstance();
      if (!componentPromise) {
        return;
      }
      componentPromise.then((comp) => {
        if (!comp) {
          return;
        }
        const destroyComp = () => this.context.destroyBean(comp);
        if (this.isAlive()) {
          this.eValue.appendChild(comp.getGui());
          this.addDestroyFunc(destroyComp);
        } else {
          destroyComp();
        }
      });
    } else {
      this.eValue.innerText = valueToDisplay;
    }
  }
  destroy() {
    this.getContext().destroyBean(this.innerCellRenderer);
    super.destroy();
  }
  refresh() {
    return false;
  }
};
GroupCellRenderer.TEMPLATE = `<span class="ag-cell-wrapper">
            <span class="ag-group-expanded" ref="eExpanded"></span>
            <span class="ag-group-contracted" ref="eContracted"></span>
            <span class="ag-group-checkbox ag-invisible" ref="eCheckbox"></span>
            <span class="ag-group-value" ref="eValue"></span>
            <span class="ag-group-child-count" ref="eChildCount"></span>
        </span>`;
__decorate$21([
  RefSelector("eExpanded")
], GroupCellRenderer.prototype, "eExpanded", void 0);
__decorate$21([
  RefSelector("eContracted")
], GroupCellRenderer.prototype, "eContracted", void 0);
__decorate$21([
  RefSelector("eCheckbox")
], GroupCellRenderer.prototype, "eCheckbox", void 0);
__decorate$21([
  RefSelector("eValue")
], GroupCellRenderer.prototype, "eValue", void 0);
__decorate$21([
  RefSelector("eChildCount")
], GroupCellRenderer.prototype, "eChildCount", void 0);
var __decorate$20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LoadingCellRenderer = class extends Component {
  constructor() {
    super(LoadingCellRenderer.TEMPLATE);
  }
  init(params) {
    params.node.failedLoad ? this.setupFailed() : this.setupLoading();
  }
  setupFailed() {
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    this.eLoadingText.innerText = localeTextFunc("loadingError", "ERR");
  }
  setupLoading() {
    const eLoadingIcon = createIconNoSpan("groupLoading", this.gridOptionsService, null);
    if (eLoadingIcon) {
      this.eLoadingIcon.appendChild(eLoadingIcon);
    }
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    this.eLoadingText.innerText = localeTextFunc("loadingOoo", "Loading");
  }
  refresh(params) {
    return false;
  }
  destroy() {
    super.destroy();
  }
};
LoadingCellRenderer.TEMPLATE = `<div class="ag-loading">
            <span class="ag-loading-icon" ref="eLoadingIcon"></span>
            <span class="ag-loading-text" ref="eLoadingText"></span>
        </div>`;
__decorate$20([
  RefSelector("eLoadingIcon")
], LoadingCellRenderer.prototype, "eLoadingIcon", void 0);
__decorate$20([
  RefSelector("eLoadingText")
], LoadingCellRenderer.prototype, "eLoadingText", void 0);
var LoadingOverlayComponent$1 = class extends Component {
  constructor() {
    super();
  }
  destroy() {
    super.destroy();
  }
  init(params) {
    var _a;
    const template = (_a = this.gridOptionsService.get("overlayLoadingTemplate")) !== null && _a !== void 0 ? _a : LoadingOverlayComponent$1.DEFAULT_LOADING_OVERLAY_TEMPLATE;
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    const localisedTemplate = template.replace("[LOADING...]", localeTextFunc("loadingOoo", "Loading..."));
    this.setTemplate(localisedTemplate);
  }
};
LoadingOverlayComponent$1.DEFAULT_LOADING_OVERLAY_TEMPLATE = '<span class="ag-overlay-loading-center">[LOADING...]</span>';
var NoRowsOverlayComponent$1 = class extends Component {
  constructor() {
    super();
  }
  destroy() {
    super.destroy();
  }
  init(params) {
    var _a;
    const template = (_a = this.gridOptionsService.get("overlayNoRowsTemplate")) !== null && _a !== void 0 ? _a : NoRowsOverlayComponent$1.DEFAULT_NO_ROWS_TEMPLATE;
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    const localisedTemplate = template.replace("[NO_ROWS_TO_SHOW]", localeTextFunc("noRowsToShow", "No Rows To Show"));
    this.setTemplate(localisedTemplate);
  }
};
NoRowsOverlayComponent$1.DEFAULT_NO_ROWS_TEMPLATE = '<span class="ag-overlay-no-rows-center">[NO_ROWS_TO_SHOW]</span>';
var TooltipComponent$1 = class extends PopupComponent {
  constructor() {
    super(`<div class="ag-tooltip"></div>`);
  }
  init(params) {
    const { value } = params;
    this.getGui().innerHTML = escapeString(value);
  }
};
var NumberCellEditorInput = class {
  getTemplate() {
    return `<ag-input-number-field class="ag-cell-editor" ref="eInput"></ag-input-number-field>`;
  }
  init(eInput, params) {
    this.eInput = eInput;
    this.params = params;
    if (params.max != null) {
      eInput.setMax(params.max);
    }
    if (params.min != null) {
      eInput.setMin(params.min);
    }
    if (params.precision != null) {
      eInput.setPrecision(params.precision);
    }
    if (params.step != null) {
      eInput.setStep(params.step);
    }
    if (params.showStepperButtons) {
      eInput.getInputElement().classList.add("ag-number-field-input-stepper");
    }
  }
  getValue() {
    const value = this.eInput.getValue();
    if (!exists(value) && !exists(this.params.value)) {
      return this.params.value;
    }
    let parsedValue = this.params.parseValue(value);
    if (parsedValue == null) {
      return parsedValue;
    }
    if (typeof parsedValue === "string") {
      if (parsedValue === "") {
        return null;
      }
      parsedValue = Number(parsedValue);
    }
    return isNaN(parsedValue) ? null : parsedValue;
  }
  getStartValue() {
    return this.params.value;
  }
};
var NumberCellEditor = class extends SimpleCellEditor {
  constructor() {
    super(new NumberCellEditorInput());
  }
};
var DateCellEditorInput = class {
  getTemplate() {
    return `<ag-input-date-field class="ag-cell-editor" ref="eInput"></ag-input-date-field>`;
  }
  init(eInput, params) {
    this.eInput = eInput;
    this.params = params;
    if (params.min != null) {
      eInput.setMin(params.min);
    }
    if (params.max != null) {
      eInput.setMax(params.max);
    }
    if (params.step != null) {
      eInput.setStep(params.step);
    }
  }
  getValue() {
    const value = this.eInput.getDate();
    if (!exists(value) && !exists(this.params.value)) {
      return this.params.value;
    }
    return value !== null && value !== void 0 ? value : null;
  }
  getStartValue() {
    const { value } = this.params;
    if (!(value instanceof Date)) {
      return void 0;
    }
    return serialiseDate(value, false);
  }
};
var DateCellEditor = class extends SimpleCellEditor {
  constructor() {
    super(new DateCellEditorInput());
  }
};
var __decorate$1$ = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DateStringCellEditorInput = class {
  constructor(getDataTypeService) {
    this.getDataTypeService = getDataTypeService;
  }
  getTemplate() {
    return `<ag-input-date-field class="ag-cell-editor" ref="eInput"></ag-input-date-field>`;
  }
  init(eInput, params) {
    this.eInput = eInput;
    this.params = params;
    if (params.min != null) {
      eInput.setMin(params.min);
    }
    if (params.max != null) {
      eInput.setMax(params.max);
    }
    if (params.step != null) {
      eInput.setStep(params.step);
    }
  }
  getValue() {
    const value = this.formatDate(this.eInput.getDate());
    if (!exists(value) && !exists(this.params.value)) {
      return this.params.value;
    }
    return this.params.parseValue(value !== null && value !== void 0 ? value : "");
  }
  getStartValue() {
    var _a, _b;
    return serialiseDate((_b = this.parseDate((_a = this.params.value) !== null && _a !== void 0 ? _a : void 0)) !== null && _b !== void 0 ? _b : null, false);
  }
  parseDate(value) {
    return this.getDataTypeService().getDateParserFunction()(value);
  }
  formatDate(value) {
    return this.getDataTypeService().getDateFormatterFunction()(value);
  }
};
var DateStringCellEditor = class extends SimpleCellEditor {
  constructor() {
    super(new DateStringCellEditorInput(() => this.dataTypeService));
  }
};
__decorate$1$([
  Autowired("dataTypeService")
], DateStringCellEditor.prototype, "dataTypeService", void 0);
var __decorate$1_ = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CheckboxCellRenderer = class extends Component {
  constructor() {
    super(CheckboxCellRenderer.TEMPLATE);
  }
  init(params) {
    this.params = params;
    this.updateCheckbox(params);
    this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
    this.addManagedListener(this.eCheckbox.getInputElement(), "click", (event) => {
      stopPropagationForAgGrid(event);
      if (this.eCheckbox.isDisabled()) {
        return;
      }
      const isSelected = this.eCheckbox.getValue();
      this.onCheckboxChanged(isSelected);
    });
    this.addManagedListener(this.eCheckbox.getInputElement(), "dblclick", (event) => {
      stopPropagationForAgGrid(event);
    });
    const eDocument = this.gridOptionsService.getDocument();
    this.addManagedListener(this.params.eGridCell, "keydown", (event) => {
      if (event.key === KeyCode.SPACE && !this.eCheckbox.isDisabled()) {
        if (this.params.eGridCell === eDocument.activeElement) {
          this.eCheckbox.toggle();
        }
        const isSelected = this.eCheckbox.getValue();
        this.onCheckboxChanged(isSelected);
        event.preventDefault();
      }
    });
  }
  refresh(params) {
    this.params = params;
    this.updateCheckbox(params);
    return true;
  }
  updateCheckbox(params) {
    var _a, _b, _c;
    let isSelected;
    let displayed = true;
    if (params.node.group && params.column) {
      const colId = params.column.getColId();
      if (colId.startsWith(GROUP_AUTO_COLUMN_ID)) {
        isSelected = params.value == null || params.value === "" ? void 0 : params.value === "true";
      } else if (params.node.aggData && params.node.aggData[colId] !== void 0) {
        isSelected = (_a = params.value) !== null && _a !== void 0 ? _a : void 0;
      } else {
        displayed = false;
      }
    } else {
      isSelected = (_b = params.value) !== null && _b !== void 0 ? _b : void 0;
    }
    if (!displayed) {
      this.eCheckbox.setDisplayed(false);
      return;
    }
    this.eCheckbox.setValue(isSelected);
    const disabled = params.disabled != null ? params.disabled : !((_c = params.column) === null || _c === void 0 ? void 0 : _c.isCellEditable(params.node));
    this.eCheckbox.setDisabled(disabled);
    const translate = this.localeService.getLocaleTextFunc();
    const stateName = getAriaCheckboxStateName(translate, isSelected);
    const ariaLabel = disabled ? stateName : `${translate("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${stateName})`;
    this.eCheckbox.setInputAriaLabel(ariaLabel);
  }
  onCheckboxChanged(isSelected) {
    const { column, node, rowIndex, value } = this.params;
    const eventStarted = {
      type: Events.EVENT_CELL_EDITING_STARTED,
      column,
      colDef: column === null || column === void 0 ? void 0 : column.getColDef(),
      data: node.data,
      node,
      rowIndex,
      rowPinned: node.rowPinned,
      value
    };
    this.eventService.dispatchEvent(eventStarted);
    const valueChanged = this.params.node.setDataValue(this.params.column, isSelected, "edit");
    const eventStopped = {
      type: Events.EVENT_CELL_EDITING_STOPPED,
      column,
      colDef: column === null || column === void 0 ? void 0 : column.getColDef(),
      data: node.data,
      node,
      rowIndex,
      rowPinned: node.rowPinned,
      value,
      oldValue: value,
      newValue: isSelected,
      valueChanged
    };
    this.eventService.dispatchEvent(eventStopped);
  }
};
CheckboxCellRenderer.TEMPLATE = `
        <div class="ag-cell-wrapper ag-checkbox-cell" role="presentation">
            <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>
        </div>`;
__decorate$1_([
  RefSelector("eCheckbox")
], CheckboxCellRenderer.prototype, "eCheckbox", void 0);
var __decorate$1Z = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CheckboxCellEditor = class extends PopupComponent {
  constructor() {
    super(`
            <div class="ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit">
                <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>
            </div>`);
  }
  init(params) {
    var _a;
    this.params = params;
    const isSelected = (_a = params.value) !== null && _a !== void 0 ? _a : void 0;
    this.eCheckbox.setValue(isSelected);
    this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
    this.setAriaLabel(isSelected);
    this.addManagedListener(this.eCheckbox, AgCheckbox.EVENT_CHANGED, (event) => this.setAriaLabel(event.selected));
  }
  getValue() {
    return this.eCheckbox.getValue();
  }
  focusIn() {
    this.eCheckbox.getFocusableElement().focus();
  }
  afterGuiAttached() {
    if (this.params.cellStartedEdit) {
      this.focusIn();
    }
  }
  isPopup() {
    return false;
  }
  setAriaLabel(isSelected) {
    const translate = this.localeService.getLocaleTextFunc();
    const stateName = getAriaCheckboxStateName(translate, isSelected);
    const ariaLabel = translate("ariaToggleCellValue", "Press SPACE to toggle cell value");
    this.eCheckbox.setInputAriaLabel(`${ariaLabel} (${stateName})`);
  }
};
__decorate$1Z([
  RefSelector("eCheckbox")
], CheckboxCellEditor.prototype, "eCheckbox", void 0);
var __decorate$1Y = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var UserComponentRegistry = class UserComponentRegistry2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.agGridDefaults = {
      agDateInput: DefaultDateComponent,
      agColumnHeader: HeaderComp,
      agColumnGroupHeader: HeaderGroupComp,
      agSortIndicator: SortIndicatorComp,
      agTextColumnFloatingFilter: TextFloatingFilter,
      agNumberColumnFloatingFilter: NumberFloatingFilter,
      agDateColumnFloatingFilter: DateFloatingFilter,
      agReadOnlyFloatingFilter: ReadOnlyFloatingFilter,
      agAnimateShowChangeCellRenderer: AnimateShowChangeCellRenderer,
      agAnimateSlideCellRenderer: AnimateSlideCellRenderer,
      agGroupCellRenderer: GroupCellRenderer,
      agGroupRowRenderer: GroupCellRenderer,
      agLoadingCellRenderer: LoadingCellRenderer,
      agCheckboxCellRenderer: CheckboxCellRenderer,
      agCellEditor: TextCellEditor,
      agTextCellEditor: TextCellEditor,
      agNumberCellEditor: NumberCellEditor,
      agDateCellEditor: DateCellEditor,
      agDateStringCellEditor: DateStringCellEditor,
      agSelectCellEditor: SelectCellEditor,
      agLargeTextCellEditor: LargeTextCellEditor,
      agCheckboxCellEditor: CheckboxCellEditor,
      agTextColumnFilter: TextFilter,
      agNumberColumnFilter: NumberFilter,
      agDateColumnFilter: DateFilter,
      agLoadingOverlay: LoadingOverlayComponent$1,
      agNoRowsOverlay: NoRowsOverlayComponent$1,
      agTooltipComponent: TooltipComponent$1
    };
    this.enterpriseAgDefaultCompsModule = {
      agSetColumnFilter: ModuleNames.SetFilterModule,
      agSetColumnFloatingFilter: ModuleNames.SetFilterModule,
      agMultiColumnFilter: ModuleNames.MultiFilterModule,
      agMultiColumnFloatingFilter: ModuleNames.MultiFilterModule,
      agGroupColumnFilter: ModuleNames.RowGroupingModule,
      agGroupColumnFloatingFilter: ModuleNames.RowGroupingModule,
      agRichSelect: ModuleNames.RichSelectModule,
      agRichSelectCellEditor: ModuleNames.RichSelectModule,
      agDetailCellRenderer: ModuleNames.MasterDetailModule,
      agSparklineCellRenderer: ModuleNames.SparklinesModule
    };
    this.jsComps = {};
  }
  init() {
    if (this.gridOptions.components != null) {
      iterateObject(this.gridOptions.components, (key, component) => this.registerJsComponent(key, component));
    }
  }
  registerDefaultComponent(name, component) {
    if (this.agGridDefaults[name]) {
      console.error(`Trying to overwrite a default component. You should call registerComponent`);
      return;
    }
    this.agGridDefaults[name] = component;
  }
  registerJsComponent(name, component) {
    this.jsComps[name] = component;
  }
  retrieve(propertyName, name) {
    const createResult = (component, componentFromFramework) => ({ componentFromFramework, component });
    const registeredViaFrameworkComp = this.getFrameworkOverrides().frameworkComponent(name, this.gridOptions.components);
    if (registeredViaFrameworkComp != null) {
      return createResult(registeredViaFrameworkComp, true);
    }
    const jsComponent = this.jsComps[name];
    if (jsComponent) {
      const isFwkComp = this.getFrameworkOverrides().isFrameworkComponent(jsComponent);
      return createResult(jsComponent, isFwkComp);
    }
    const defaultComponent = this.agGridDefaults[name];
    if (defaultComponent) {
      return createResult(defaultComponent, false);
    }
    const moduleForComponent = this.enterpriseAgDefaultCompsModule[name];
    if (moduleForComponent) {
      ModuleRegistry.assertRegistered(moduleForComponent, `AG Grid '${propertyName}' component: ${name}`, this.context.getGridId());
    } else {
      doOnce(() => {
        this.warnAboutMissingComponent(propertyName, name);
      }, "MissingComp" + name);
    }
    return null;
  }
  warnAboutMissingComponent(propertyName, componentName) {
    const validComponents = [
      ...Object.keys(this.agGridDefaults).filter((k) => !["agCellEditor", "agGroupRowRenderer", "agSortIndicator"].includes(k)),
      ...Object.keys(this.jsComps)
    ];
    const suggestions = fuzzySuggestions(componentName, validComponents, true, 0.8);
    console.warn(`AG Grid: Could not find '${componentName}' component. It was configured as "${propertyName}: '${componentName}'" but it wasn't found in the list of registered components.`);
    if (suggestions.length > 0) {
      console.warn(`         Did you mean: [${suggestions.slice(0, 3)}]?`);
    }
    console.warn(`If using a custom component check it has been registered as described in: https://ag-grid.com/javascript-data-grid/components/`);
  }
};
__decorate$1Y([
  Autowired("gridOptions")
], UserComponentRegistry.prototype, "gridOptions", void 0);
__decorate$1Y([
  PostConstruct
], UserComponentRegistry.prototype, "init", null);
UserComponentRegistry = __decorate$1Y([
  Bean("userComponentRegistry")
], UserComponentRegistry);
var DateComponent = {
  propertyName: "dateComponent",
  cellRenderer: false
};
var HeaderComponent = {
  propertyName: "headerComponent",
  cellRenderer: false
};
var HeaderGroupComponent = {
  propertyName: "headerGroupComponent",
  cellRenderer: false
};
var CellRendererComponent = {
  propertyName: "cellRenderer",
  cellRenderer: true
};
var CellEditorComponent = {
  propertyName: "cellEditor",
  cellRenderer: false
};
var InnerRendererComponent = {
  propertyName: "innerRenderer",
  cellRenderer: true
};
var LoadingOverlayComponent = {
  propertyName: "loadingOverlayComponent",
  cellRenderer: false
};
var NoRowsOverlayComponent = {
  propertyName: "noRowsOverlayComponent",
  cellRenderer: false
};
var TooltipComponent = {
  propertyName: "tooltipComponent",
  cellRenderer: false
};
var FilterComponent = {
  propertyName: "filter",
  cellRenderer: false
};
var FloatingFilterComponent = {
  propertyName: "floatingFilterComponent",
  cellRenderer: false
};
var ToolPanelComponent = {
  propertyName: "toolPanel",
  cellRenderer: false
};
var StatusPanelComponent = {
  propertyName: "statusPanel",
  cellRenderer: false
};
var FullWidth = {
  propertyName: "fullWidthCellRenderer",
  cellRenderer: true
};
var FullWidthLoading = {
  propertyName: "loadingCellRenderer",
  cellRenderer: true
};
var FullWidthGroup = {
  propertyName: "groupRowRenderer",
  cellRenderer: true
};
var FullWidthDetail = {
  propertyName: "detailCellRenderer",
  cellRenderer: true
};
var FloatingFilterMapper = class {
  static getFloatingFilterType(filterType) {
    return this.filterToFloatingFilterMapping[filterType];
  }
};
FloatingFilterMapper.filterToFloatingFilterMapping = {
  set: "agSetColumnFloatingFilter",
  agSetColumnFilter: "agSetColumnFloatingFilter",
  multi: "agMultiColumnFloatingFilter",
  agMultiColumnFilter: "agMultiColumnFloatingFilter",
  group: "agGroupColumnFloatingFilter",
  agGroupColumnFilter: "agGroupColumnFloatingFilter",
  number: "agNumberColumnFloatingFilter",
  agNumberColumnFilter: "agNumberColumnFloatingFilter",
  date: "agDateColumnFloatingFilter",
  agDateColumnFilter: "agDateColumnFloatingFilter",
  text: "agTextColumnFloatingFilter",
  agTextColumnFilter: "agTextColumnFloatingFilter"
};
var __decorate$1X = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var UserComponentFactory = class UserComponentFactory2 extends BeanStub {
  getHeaderCompDetails(colDef, params) {
    return this.getCompDetails(colDef, HeaderComponent, "agColumnHeader", params);
  }
  getHeaderGroupCompDetails(params) {
    const colGroupDef = params.columnGroup.getColGroupDef();
    return this.getCompDetails(colGroupDef, HeaderGroupComponent, "agColumnGroupHeader", params);
  }
  getFullWidthCellRendererDetails(params) {
    return this.getCompDetails(this.gridOptions, FullWidth, null, params, true);
  }
  getFullWidthLoadingCellRendererDetails(params) {
    return this.getCompDetails(this.gridOptions, FullWidthLoading, "agLoadingCellRenderer", params, true);
  }
  getFullWidthGroupCellRendererDetails(params) {
    return this.getCompDetails(this.gridOptions, FullWidthGroup, "agGroupRowRenderer", params, true);
  }
  getFullWidthDetailCellRendererDetails(params) {
    return this.getCompDetails(this.gridOptions, FullWidthDetail, "agDetailCellRenderer", params, true);
  }
  getInnerRendererDetails(def, params) {
    return this.getCompDetails(def, InnerRendererComponent, null, params);
  }
  getFullWidthGroupRowInnerCellRenderer(def, params) {
    return this.getCompDetails(def, InnerRendererComponent, null, params);
  }
  getCellRendererDetails(def, params) {
    return this.getCompDetails(def, CellRendererComponent, null, params);
  }
  getCellEditorDetails(def, params) {
    return this.getCompDetails(def, CellEditorComponent, "agCellEditor", params, true);
  }
  getFilterDetails(def, params, defaultFilter) {
    return this.getCompDetails(def, FilterComponent, defaultFilter, params, true);
  }
  getDateCompDetails(params) {
    return this.getCompDetails(this.gridOptions, DateComponent, "agDateInput", params, true);
  }
  getLoadingOverlayCompDetails(params) {
    return this.getCompDetails(this.gridOptions, LoadingOverlayComponent, "agLoadingOverlay", params, true);
  }
  getNoRowsOverlayCompDetails(params) {
    return this.getCompDetails(this.gridOptions, NoRowsOverlayComponent, "agNoRowsOverlay", params, true);
  }
  getTooltipCompDetails(params) {
    return this.getCompDetails(params.colDef, TooltipComponent, "agTooltipComponent", params, true);
  }
  getSetFilterCellRendererDetails(def, params) {
    return this.getCompDetails(def, CellRendererComponent, null, params);
  }
  getFloatingFilterCompDetails(def, params, defaultFloatingFilter) {
    return this.getCompDetails(def, FloatingFilterComponent, defaultFloatingFilter, params);
  }
  getToolPanelCompDetails(toolPanelDef, params) {
    return this.getCompDetails(toolPanelDef, ToolPanelComponent, null, params, true);
  }
  getStatusPanelCompDetails(def, params) {
    return this.getCompDetails(def, StatusPanelComponent, null, params, true);
  }
  getCompDetails(defObject, type, defaultName, params, mandatory = false) {
    const { propertyName, cellRenderer } = type;
    let { compName, jsComp, fwComp, paramsFromSelector, popupFromSelector, popupPositionFromSelector } = this.getCompKeys(defObject, type, params);
    const lookupFromRegistry = (key) => {
      const item = this.userComponentRegistry.retrieve(propertyName, key);
      if (item) {
        jsComp = !item.componentFromFramework ? item.component : void 0;
        fwComp = item.componentFromFramework ? item.component : void 0;
      }
    };
    if (compName != null) {
      lookupFromRegistry(compName);
    }
    if (jsComp == null && fwComp == null && defaultName != null) {
      lookupFromRegistry(defaultName);
    }
    if (jsComp && cellRenderer && !this.agComponentUtils.doesImplementIComponent(jsComp)) {
      jsComp = this.agComponentUtils.adaptFunction(propertyName, jsComp);
    }
    if (!jsComp && !fwComp) {
      if (mandatory) {
        console.error(`AG Grid: Could not find component ${compName}, did you forget to configure this component?`);
      }
      return;
    }
    const paramsMerged = this.mergeParamsWithApplicationProvidedParams(defObject, type, params, paramsFromSelector);
    const componentFromFramework = jsComp == null;
    const componentClass = jsComp ? jsComp : fwComp;
    return {
      componentFromFramework,
      componentClass,
      params: paramsMerged,
      type,
      popupFromSelector,
      popupPositionFromSelector,
      newAgStackInstance: () => this.newAgStackInstance(componentClass, componentFromFramework, paramsMerged, type)
    };
  }
  getCompKeys(defObject, type, params) {
    const { propertyName } = type;
    let compName;
    let jsComp;
    let fwComp;
    let paramsFromSelector;
    let popupFromSelector;
    let popupPositionFromSelector;
    if (defObject) {
      const defObjectAny = defObject;
      const selectorFunc = defObjectAny[propertyName + "Selector"];
      const selectorRes = selectorFunc ? selectorFunc(params) : null;
      const assignComp = (providedJsComp) => {
        if (typeof providedJsComp === "string") {
          compName = providedJsComp;
        } else if (providedJsComp != null && providedJsComp !== true) {
          const isFwkComp = this.getFrameworkOverrides().isFrameworkComponent(providedJsComp);
          if (isFwkComp) {
            fwComp = providedJsComp;
          } else {
            jsComp = providedJsComp;
          }
        }
      };
      if (selectorRes) {
        assignComp(selectorRes.component);
        paramsFromSelector = selectorRes.params;
        popupFromSelector = selectorRes.popup;
        popupPositionFromSelector = selectorRes.popupPosition;
      } else {
        assignComp(defObjectAny[propertyName]);
      }
    }
    return { compName, jsComp, fwComp, paramsFromSelector, popupFromSelector, popupPositionFromSelector };
  }
  newAgStackInstance(ComponentClass, componentFromFramework, params, type) {
    const propertyName = type.propertyName;
    const jsComponent = !componentFromFramework;
    let instance;
    if (jsComponent) {
      instance = new ComponentClass();
    } else {
      const thisComponentConfig = this.componentMetadataProvider.retrieve(propertyName);
      instance = this.frameworkComponentWrapper.wrap(ComponentClass, thisComponentConfig.mandatoryMethodList, thisComponentConfig.optionalMethodList, type);
    }
    const deferredInit = this.initComponent(instance, params);
    if (deferredInit == null) {
      return AgPromise.resolve(instance);
    }
    return deferredInit.then(() => instance);
  }
  mergeParamsWithApplicationProvidedParams(defObject, type, paramsFromGrid, paramsFromSelector = null) {
    const params = {
      context: this.gridOptionsService.context,
      columnApi: this.gridOptionsService.columnApi,
      api: this.gridOptionsService.api
    };
    mergeDeep(params, paramsFromGrid);
    const defObjectAny = defObject;
    const userParams = defObjectAny && defObjectAny[type.propertyName + "Params"];
    if (typeof userParams === "function") {
      const userParamsFromFunc = userParams(paramsFromGrid);
      mergeDeep(params, userParamsFromFunc);
    } else if (typeof userParams === "object") {
      mergeDeep(params, userParams);
    }
    mergeDeep(params, paramsFromSelector);
    return params;
  }
  initComponent(component, params) {
    this.context.createBean(component);
    if (component.init == null) {
      return;
    }
    return component.init(params);
  }
  getDefaultFloatingFilterType(def, getFromDefault) {
    if (def == null) {
      return null;
    }
    let defaultFloatingFilterType = null;
    let { compName, jsComp, fwComp } = this.getCompKeys(def, FilterComponent);
    if (compName) {
      defaultFloatingFilterType = FloatingFilterMapper.getFloatingFilterType(compName);
    } else {
      const usingDefaultFilter = jsComp == null && fwComp == null && def.filter === true;
      if (usingDefaultFilter) {
        defaultFloatingFilterType = getFromDefault();
      }
    }
    return defaultFloatingFilterType;
  }
};
__decorate$1X([
  Autowired("gridOptions")
], UserComponentFactory.prototype, "gridOptions", void 0);
__decorate$1X([
  Autowired("agComponentUtils")
], UserComponentFactory.prototype, "agComponentUtils", void 0);
__decorate$1X([
  Autowired("componentMetadataProvider")
], UserComponentFactory.prototype, "componentMetadataProvider", void 0);
__decorate$1X([
  Autowired("userComponentRegistry")
], UserComponentFactory.prototype, "userComponentRegistry", void 0);
__decorate$1X([
  Optional("frameworkComponentWrapper")
], UserComponentFactory.prototype, "frameworkComponentWrapper", void 0);
UserComponentFactory = __decorate$1X([
  Bean("userComponentFactory")
], UserComponentFactory);
var ExcelFactoryMode;
(function(ExcelFactoryMode2) {
  ExcelFactoryMode2[ExcelFactoryMode2["SINGLE_SHEET"] = 0] = "SINGLE_SHEET";
  ExcelFactoryMode2[ExcelFactoryMode2["MULTI_SHEET"] = 1] = "MULTI_SHEET";
})(ExcelFactoryMode || (ExcelFactoryMode = {}));
var __decorate$1W = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DragService = class DragService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.dragEndFunctions = [];
    this.dragSources = [];
  }
  removeAllListeners() {
    this.dragSources.forEach(this.removeListener.bind(this));
    this.dragSources.length = 0;
  }
  removeListener(dragSourceAndListener) {
    const element = dragSourceAndListener.dragSource.eElement;
    const mouseDownListener = dragSourceAndListener.mouseDownListener;
    element.removeEventListener("mousedown", mouseDownListener);
    if (dragSourceAndListener.touchEnabled) {
      const touchStartListener = dragSourceAndListener.touchStartListener;
      element.removeEventListener("touchstart", touchStartListener, { passive: true });
    }
  }
  removeDragSource(params) {
    const dragSourceAndListener = this.dragSources.find((item) => item.dragSource === params);
    if (!dragSourceAndListener) {
      return;
    }
    this.removeListener(dragSourceAndListener);
    removeFromArray(this.dragSources, dragSourceAndListener);
  }
  isDragging() {
    return this.dragging;
  }
  addDragSource(params, includeTouch = false) {
    const mouseListener = this.onMouseDown.bind(this, params);
    params.eElement.addEventListener("mousedown", mouseListener);
    let touchListener = null;
    const suppressTouch = this.gridOptionsService.is("suppressTouch");
    if (includeTouch && !suppressTouch) {
      touchListener = (touchEvent) => {
        if (isFocusableFormField(touchEvent.target)) {
          return;
        }
        if (touchEvent.cancelable) {
          touchEvent.preventDefault();
          touchEvent.stopPropagation();
        }
        this.onTouchStart(params, touchEvent);
      };
      params.eElement.addEventListener("touchstart", touchListener, { passive: false });
    }
    this.dragSources.push({
      dragSource: params,
      mouseDownListener: mouseListener,
      touchStartListener: touchListener,
      touchEnabled: includeTouch
    });
  }
  getStartTarget() {
    return this.startTarget;
  }
  onTouchStart(params, touchEvent) {
    this.currentDragParams = params;
    this.dragging = false;
    const touch = touchEvent.touches[0];
    this.touchLastTime = touch;
    this.touchStart = touch;
    const touchMoveEvent = (e) => this.onTouchMove(e, params.eElement);
    const touchEndEvent = (e) => this.onTouchUp(e, params.eElement);
    const documentTouchMove = (e) => {
      if (e.cancelable) {
        e.preventDefault();
      }
    };
    const target = touchEvent.target;
    const events = [
      { target: this.gridOptionsService.getRootNode(), type: "touchmove", listener: documentTouchMove, options: { passive: false } },
      { target, type: "touchmove", listener: touchMoveEvent, options: { passive: true } },
      { target, type: "touchend", listener: touchEndEvent, options: { passive: true } },
      { target, type: "touchcancel", listener: touchEndEvent, options: { passive: true } }
    ];
    this.addTemporaryEvents(events);
    if (params.dragStartPixels === 0) {
      this.onCommonMove(touch, this.touchStart, params.eElement);
    }
  }
  onMouseDown(params, mouseEvent) {
    const e = mouseEvent;
    if (params.skipMouseEvent && params.skipMouseEvent(mouseEvent)) {
      return;
    }
    if (e._alreadyProcessedByDragService) {
      return;
    }
    e._alreadyProcessedByDragService = true;
    if (mouseEvent.button !== 0) {
      return;
    }
    this.currentDragParams = params;
    this.dragging = false;
    this.mouseStartEvent = mouseEvent;
    this.startTarget = mouseEvent.target;
    const mouseMoveEvent = (event) => this.onMouseMove(event, params.eElement);
    const mouseUpEvent = (event) => this.onMouseUp(event, params.eElement);
    const contextEvent = (event) => event.preventDefault();
    const target = this.gridOptionsService.getRootNode();
    const events = [
      { target, type: "mousemove", listener: mouseMoveEvent },
      { target, type: "mouseup", listener: mouseUpEvent },
      { target, type: "contextmenu", listener: contextEvent }
    ];
    this.addTemporaryEvents(events);
    if (params.dragStartPixels === 0) {
      this.onMouseMove(mouseEvent, params.eElement);
    }
  }
  addTemporaryEvents(events) {
    events.forEach((currentEvent) => {
      const { target, type, listener, options } = currentEvent;
      target.addEventListener(type, listener, options);
    });
    this.dragEndFunctions.push(() => {
      events.forEach((currentEvent) => {
        const { target, type, listener, options } = currentEvent;
        target.removeEventListener(type, listener, options);
      });
    });
  }
  isEventNearStartEvent(currentEvent, startEvent) {
    const { dragStartPixels } = this.currentDragParams;
    const requiredPixelDiff = exists(dragStartPixels) ? dragStartPixels : 4;
    return areEventsNear(currentEvent, startEvent, requiredPixelDiff);
  }
  getFirstActiveTouch(touchList) {
    for (let i = 0; i < touchList.length; i++) {
      if (touchList[i].identifier === this.touchStart.identifier) {
        return touchList[i];
      }
    }
    return null;
  }
  onCommonMove(currentEvent, startEvent, el) {
    if (!this.dragging) {
      if (!this.dragging && this.isEventNearStartEvent(currentEvent, startEvent)) {
        return;
      }
      this.dragging = true;
      const event = {
        type: Events.EVENT_DRAG_STARTED,
        target: el
      };
      this.eventService.dispatchEvent(event);
      this.currentDragParams.onDragStart(startEvent);
      this.currentDragParams.onDragging(startEvent);
    }
    this.currentDragParams.onDragging(currentEvent);
  }
  onTouchMove(touchEvent, el) {
    const touch = this.getFirstActiveTouch(touchEvent.touches);
    if (!touch) {
      return;
    }
    this.onCommonMove(touch, this.touchStart, el);
  }
  onMouseMove(mouseEvent, el) {
    if ((this.gridOptionsService.is("enableCellTextSelection") || isBrowserSafari()) && mouseEvent.type === "mousemove" && mouseEvent.cancelable && this.mouseEventService.isEventFromThisGrid(mouseEvent) && !this.isOverFormFieldElement(mouseEvent)) {
      mouseEvent.preventDefault();
    }
    this.onCommonMove(mouseEvent, this.mouseStartEvent, el);
  }
  isOverFormFieldElement(mouseEvent) {
    const el = mouseEvent.target;
    const tagName = el === null || el === void 0 ? void 0 : el.tagName.toLocaleLowerCase();
    return !!(tagName === null || tagName === void 0 ? void 0 : tagName.match("^a$|textarea|input|select|button"));
  }
  onTouchUp(touchEvent, el) {
    let touch = this.getFirstActiveTouch(touchEvent.changedTouches);
    if (!touch) {
      touch = this.touchLastTime;
    }
    this.onUpCommon(touch, el);
  }
  onMouseUp(mouseEvent, el) {
    this.onUpCommon(mouseEvent, el);
  }
  onUpCommon(eventOrTouch, el) {
    if (this.dragging) {
      this.dragging = false;
      this.currentDragParams.onDragStop(eventOrTouch);
      const event = {
        type: Events.EVENT_DRAG_STOPPED,
        target: el
      };
      this.eventService.dispatchEvent(event);
    }
    this.mouseStartEvent = null;
    this.startTarget = null;
    this.touchStart = null;
    this.touchLastTime = null;
    this.currentDragParams = null;
    this.dragEndFunctions.forEach((func) => func());
    this.dragEndFunctions.length = 0;
  }
};
__decorate$1W([
  Autowired("mouseEventService")
], DragService.prototype, "mouseEventService", void 0);
__decorate$1W([
  PreDestroy
], DragService.prototype, "removeAllListeners", null);
DragService = __decorate$1W([
  Bean("dragService")
], DragService);
var RowHighlightPosition;
(function(RowHighlightPosition2) {
  RowHighlightPosition2[RowHighlightPosition2["Above"] = 0] = "Above";
  RowHighlightPosition2[RowHighlightPosition2["Below"] = 1] = "Below";
})(RowHighlightPosition || (RowHighlightPosition = {}));
var ClientSideRowModelSteps;
(function(ClientSideRowModelSteps2) {
  ClientSideRowModelSteps2["EVERYTHING"] = "group";
  ClientSideRowModelSteps2["FILTER"] = "filter";
  ClientSideRowModelSteps2["SORT"] = "sort";
  ClientSideRowModelSteps2["MAP"] = "map";
  ClientSideRowModelSteps2["AGGREGATE"] = "aggregate";
  ClientSideRowModelSteps2["FILTER_AGGREGATES"] = "filter_aggregates";
  ClientSideRowModelSteps2["PIVOT"] = "pivot";
  ClientSideRowModelSteps2["NOTHING"] = "nothing";
})(ClientSideRowModelSteps || (ClientSideRowModelSteps = {}));
var __decorate$1V = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function unwrapUserComp(comp) {
  const compAsAny = comp;
  const isProxy = compAsAny != null && compAsAny.getFrameworkComponentInstance != null;
  return isProxy ? compAsAny.getFrameworkComponentInstance() : comp;
}
var GridApi = class GridApi2 {
  constructor() {
    this.detailGridInfoMap = {};
    this.destroyCalled = false;
  }
  registerOverlayWrapperComp(overlayWrapperComp) {
    this.overlayWrapperComp = overlayWrapperComp;
  }
  registerSideBarComp(sideBarComp) {
    this.sideBarComp = sideBarComp;
  }
  init() {
    switch (this.rowModel.getType()) {
      case "clientSide":
        this.clientSideRowModel = this.rowModel;
        break;
      case "infinite":
        this.infiniteRowModel = this.rowModel;
        break;
      case "serverSide":
        this.serverSideRowModel = this.rowModel;
        break;
    }
    this.ctrlsService.whenReady(() => {
      this.gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
    });
  }
  __getAlignedGridService() {
    return this.alignedGridsService;
  }
  __getContext() {
    return this.context;
  }
  getSetterMethod(key) {
    return `set${key.charAt(0).toUpperCase()}${key.substring(1)}`;
  }
  __setProperty(propertyName, value) {
    this.gridOptionsService.set(propertyName, value);
    const setterName = this.getSetterMethod(propertyName);
    const dynamicApi = this;
    if (dynamicApi[setterName]) {
      dynamicApi[setterName](value);
    }
  }
  getGridId() {
    return this.context.getGridId();
  }
  addDetailGridInfo(id, gridInfo) {
    this.detailGridInfoMap[id] = gridInfo;
  }
  removeDetailGridInfo(id) {
    this.detailGridInfoMap[id] = void 0;
  }
  getDetailGridInfo(id) {
    return this.detailGridInfoMap[id];
  }
  forEachDetailGridInfo(callback) {
    let index = 0;
    iterateObject(this.detailGridInfoMap, (id, gridInfo) => {
      if (exists(gridInfo)) {
        callback(gridInfo, index);
        index++;
      }
    });
  }
  getDataAsCsv(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.CsvExportModule, "api.getDataAsCsv", this.context.getGridId())) {
      return this.csvCreator.getDataAsCsv(params);
    }
  }
  exportDataAsCsv(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.CsvExportModule, "api.exportDataAsCSv", this.context.getGridId())) {
      this.csvCreator.exportDataAsCsv(params);
    }
  }
  getExcelExportMode(params) {
    const baseParams = this.gridOptionsService.get("defaultExcelExportParams");
    const mergedParams = Object.assign({ exportMode: "xlsx" }, baseParams, params);
    return mergedParams.exportMode;
  }
  assertNotExcelMultiSheet(method, params) {
    if (!ModuleRegistry.assertRegistered(ModuleNames.ExcelExportModule, "api." + method, this.context.getGridId())) {
      return false;
    }
    const exportMode = this.getExcelExportMode(params);
    if (this.excelCreator.getFactoryMode(exportMode) === ExcelFactoryMode.MULTI_SHEET) {
      console.warn("AG Grid: The Excel Exporter is currently on Multi Sheet mode. End that operation by calling 'api.getMultipleSheetAsExcel()' or 'api.exportMultipleSheetsAsExcel()'");
      return false;
    }
    return true;
  }
  getDataAsExcel(params) {
    if (this.assertNotExcelMultiSheet("getDataAsExcel", params)) {
      return this.excelCreator.getDataAsExcel(params);
    }
  }
  exportDataAsExcel(params) {
    if (this.assertNotExcelMultiSheet("exportDataAsExcel", params)) {
      this.excelCreator.exportDataAsExcel(params);
    }
  }
  getSheetDataForExcel(params) {
    if (!ModuleRegistry.assertRegistered(ModuleNames.ExcelExportModule, "api.getSheetDataForExcel", this.context.getGridId())) {
      return;
    }
    const exportMode = this.getExcelExportMode(params);
    this.excelCreator.setFactoryMode(ExcelFactoryMode.MULTI_SHEET, exportMode);
    return this.excelCreator.getSheetDataForExcel(params);
  }
  getMultipleSheetsAsExcel(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.ExcelExportModule, "api.getMultipleSheetsAsExcel", this.context.getGridId())) {
      return this.excelCreator.getMultipleSheetsAsExcel(params);
    }
  }
  exportMultipleSheetsAsExcel(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.ExcelExportModule, "api.exportMultipleSheetsAsExcel", this.context.getGridId())) {
      return this.excelCreator.exportMultipleSheetsAsExcel(params);
    }
  }
  setGridAriaProperty(property, value) {
    if (!property) {
      return;
    }
    const eGrid = this.ctrlsService.getGridBodyCtrl().getGui();
    const ariaProperty = `aria-${property}`;
    if (value === null) {
      eGrid.removeAttribute(ariaProperty);
    } else {
      eGrid.setAttribute(ariaProperty, value);
    }
  }
  logMissingRowModel(apiMethod, ...requiredRowModels) {
    console.error(`AG Grid: api.${apiMethod} can only be called when gridOptions.rowModelType is ${requiredRowModels.join(" or ")}`);
  }
  setServerSideDatasource(datasource) {
    if (this.serverSideRowModel) {
      this.serverSideRowModel.setDatasource(datasource);
    } else {
      this.logMissingRowModel("setServerSideDatasource", "serverSide");
    }
  }
  setCacheBlockSize(blockSize) {
    if (this.serverSideRowModel) {
      this.gridOptionsService.set("cacheBlockSize", blockSize);
      this.serverSideRowModel.resetRootStore();
    } else {
      this.logMissingRowModel("setCacheBlockSize", "serverSide");
    }
  }
  setDatasource(datasource) {
    if (this.gridOptionsService.isRowModelType("infinite")) {
      this.rowModel.setDatasource(datasource);
    } else {
      this.logMissingRowModel("setDatasource", "infinite");
    }
  }
  setViewportDatasource(viewportDatasource) {
    if (this.gridOptionsService.isRowModelType("viewport")) {
      this.rowModel.setViewportDatasource(viewportDatasource);
    } else {
      this.logMissingRowModel("setViewportDatasource", "viewport");
    }
  }
  setRowData(rowData) {
    const missingImmutableService = this.immutableService == null;
    if (missingImmutableService) {
      this.logMissingRowModel("setRowData", "clientSide");
      return;
    }
    if (this.immutableService.isActive()) {
      this.immutableService.setRowData(rowData);
    } else {
      this.selectionService.reset();
      this.clientSideRowModel.setRowData(rowData);
    }
  }
  setPinnedTopRowData(rows) {
    this.pinnedRowModel.setPinnedTopRowData(rows);
  }
  setPinnedBottomRowData(rows) {
    this.pinnedRowModel.setPinnedBottomRowData(rows);
  }
  getPinnedTopRowCount() {
    return this.pinnedRowModel.getPinnedTopRowCount();
  }
  getPinnedBottomRowCount() {
    return this.pinnedRowModel.getPinnedBottomRowCount();
  }
  getPinnedTopRow(index) {
    return this.pinnedRowModel.getPinnedTopRow(index);
  }
  getPinnedBottomRow(index) {
    return this.pinnedRowModel.getPinnedBottomRow(index);
  }
  setColumnDefs(colDefs, source = "api") {
    this.columnModel.setColumnDefs(colDefs, source);
    this.gridOptionsService.set("columnDefs", colDefs, true, { source });
  }
  setAutoGroupColumnDef(colDef, source = "api") {
    this.gridOptionsService.set("autoGroupColumnDef", colDef, true, { source });
  }
  setDefaultColDef(colDef, source = "api") {
    this.gridOptionsService.set("defaultColDef", colDef, true, { source });
  }
  setColumnTypes(columnTypes, source = "api") {
    this.gridOptionsService.set("columnTypes", columnTypes, true, { source });
  }
  expireValueCache() {
    this.valueCache.expire();
  }
  getVerticalPixelRange() {
    return this.gridBodyCtrl.getScrollFeature().getVScrollPosition();
  }
  getHorizontalPixelRange() {
    return this.gridBodyCtrl.getScrollFeature().getHScrollPosition();
  }
  setAlwaysShowHorizontalScroll(show) {
    this.gridOptionsService.set("alwaysShowHorizontalScroll", show);
  }
  setAlwaysShowVerticalScroll(show) {
    this.gridOptionsService.set("alwaysShowVerticalScroll", show);
  }
  refreshCells(params = {}) {
    this.rowRenderer.refreshCells(params);
  }
  flashCells(params = {}) {
    this.rowRenderer.flashCells(params);
  }
  redrawRows(params = {}) {
    const rowNodes = params ? params.rowNodes : void 0;
    this.rowRenderer.redrawRows(rowNodes);
  }
  setFunctionsReadOnly(readOnly) {
    this.gridOptionsService.set("functionsReadOnly", readOnly);
  }
  refreshHeader() {
    this.ctrlsService.getHeaderRowContainerCtrls().forEach((c) => c.refresh());
  }
  isAnyFilterPresent() {
    return this.filterManager.isAnyFilterPresent();
  }
  isColumnFilterPresent() {
    return this.filterManager.isColumnFilterPresent() || this.filterManager.isAggregateFilterPresent();
  }
  isQuickFilterPresent() {
    return this.filterManager.isQuickFilterPresent();
  }
  getModel() {
    return this.rowModel;
  }
  setRowNodeExpanded(rowNode, expanded, expandParents) {
    if (rowNode) {
      if (expandParents && rowNode.parent && rowNode.parent.level !== -1) {
        this.setRowNodeExpanded(rowNode.parent, expanded, expandParents);
      }
      rowNode.setExpanded(expanded);
    }
  }
  onGroupExpandedOrCollapsed() {
    if (missing(this.clientSideRowModel)) {
      this.logMissingRowModel("onGroupExpandedOrCollapsed", "clientSide");
      return;
    }
    this.clientSideRowModel.refreshModel({ step: ClientSideRowModelSteps.MAP });
  }
  refreshClientSideRowModel(step) {
    if (missing(this.clientSideRowModel)) {
      this.logMissingRowModel("refreshClientSideRowModel", "clientSide");
      return;
    }
    this.clientSideRowModel.refreshModel(step);
  }
  isAnimationFrameQueueEmpty() {
    return this.animationFrameService.isQueueEmpty();
  }
  flushAllAnimationFrames() {
    this.animationFrameService.flushAllFrames();
  }
  getRowNode(id) {
    return this.rowModel.getRowNode(id);
  }
  getSizesForCurrentTheme() {
    return {
      rowHeight: this.gridOptionsService.getRowHeightAsNumber(),
      headerHeight: this.columnModel.getHeaderHeight()
    };
  }
  expandAll() {
    if (this.clientSideRowModel) {
      this.clientSideRowModel.expandOrCollapseAll(true);
    } else if (this.serverSideRowModel) {
      this.serverSideRowModel.expandAll(true);
    } else {
      this.logMissingRowModel("expandAll", "clientSide", "serverSide");
    }
  }
  collapseAll() {
    if (this.clientSideRowModel) {
      this.clientSideRowModel.expandOrCollapseAll(false);
    } else if (this.serverSideRowModel) {
      this.serverSideRowModel.expandAll(false);
    } else {
      this.logMissingRowModel("expandAll", "clientSide", "serverSide");
    }
  }
  addRenderedRowListener(eventName, rowIndex, callback) {
    this.rowRenderer.addRenderedRowListener(eventName, rowIndex, callback);
  }
  getQuickFilter() {
    return this.gridOptionsService.get("quickFilterText");
  }
  setQuickFilter(newFilter) {
    this.gridOptionsService.set("quickFilterText", newFilter);
  }
  setExcludeHiddenColumnsFromQuickFilter(value) {
    logDeprecation("30", "setExcludeHiddenColumnsFromQuickFilter", void 0, "Hidden columns are now excluded from the Quick Filter by default. This can be toggled using `setIncludeHiddenColumnsInQuickFilter`");
    this.setIncludeHiddenColumnsInQuickFilter(!value);
  }
  setIncludeHiddenColumnsInQuickFilter(value) {
    this.gridOptionsService.set("includeHiddenColumnsInQuickFilter", value);
  }
  setNodesSelected(params) {
    const allNodesValid = params.nodes.every((node) => {
      if (node.rowPinned) {
        console.warn("AG Grid: cannot select pinned rows");
        return false;
      }
      if (node.id === void 0) {
        console.warn("AG Grid: cannot select node until id for node is known");
        return false;
      }
      return true;
    });
    if (!allNodesValid) {
      return;
    }
    const { nodes, source, newValue } = params;
    const nodesAsRowNode = nodes;
    this.selectionService.setNodesSelected({ nodes: nodesAsRowNode, source: source !== null && source !== void 0 ? source : "api", newValue });
  }
  selectAll(source = "apiSelectAll") {
    this.selectionService.selectAllRowNodes({ source });
  }
  deselectAll(source = "apiSelectAll") {
    this.selectionService.deselectAllRowNodes({ source });
  }
  selectAllFiltered(source = "apiSelectAllFiltered") {
    this.selectionService.selectAllRowNodes({ source, justFiltered: true });
  }
  deselectAllFiltered(source = "apiSelectAllFiltered") {
    this.selectionService.deselectAllRowNodes({ source, justFiltered: true });
  }
  getServerSideSelectionState() {
    if (missing(this.serverSideRowModel)) {
      this.logMissingRowModel("getServerSideSelectionState", "serverSide");
      return null;
    }
    return this.selectionService.getServerSideSelectionState();
  }
  setServerSideSelectionState(state) {
    if (missing(this.serverSideRowModel)) {
      this.logMissingRowModel("setServerSideSelectionState", "serverSide");
      return;
    }
    this.selectionService.setServerSideSelectionState(state);
  }
  selectAllOnCurrentPage(source = "apiSelectAllCurrentPage") {
    this.selectionService.selectAllRowNodes({ source, justCurrentPage: true });
  }
  deselectAllOnCurrentPage(source = "apiSelectAllCurrentPage") {
    this.selectionService.deselectAllRowNodes({ source, justCurrentPage: true });
  }
  sizeColumnsToFit(params) {
    this.gridBodyCtrl.sizeColumnsToFit(params);
  }
  showLoadingOverlay() {
    this.overlayWrapperComp.showLoadingOverlay();
  }
  showNoRowsOverlay() {
    this.overlayWrapperComp.showNoRowsOverlay();
  }
  hideOverlay() {
    this.overlayWrapperComp.hideOverlay();
  }
  getSelectedNodes() {
    return this.selectionService.getSelectedNodes();
  }
  getSelectedRows() {
    return this.selectionService.getSelectedRows();
  }
  getBestCostNodeSelection() {
    if (missing(this.clientSideRowModel)) {
      this.logMissingRowModel("getBestCostNodeSelection", "clientSide");
      return;
    }
    return this.selectionService.getBestCostNodeSelection();
  }
  getRenderedNodes() {
    return this.rowRenderer.getRenderedNodes();
  }
  ensureColumnVisible(key, position = "auto") {
    this.gridBodyCtrl.getScrollFeature().ensureColumnVisible(key, position);
  }
  ensureIndexVisible(index, position) {
    this.gridBodyCtrl.getScrollFeature().ensureIndexVisible(index, position);
  }
  ensureNodeVisible(nodeSelector, position = null) {
    this.gridBodyCtrl.getScrollFeature().ensureNodeVisible(nodeSelector, position);
  }
  forEachLeafNode(callback) {
    if (missing(this.clientSideRowModel)) {
      this.logMissingRowModel("forEachLeafNode", "clientSide");
      return;
    }
    this.clientSideRowModel.forEachLeafNode(callback);
  }
  forEachNode(callback, includeFooterNodes) {
    this.rowModel.forEachNode(callback, includeFooterNodes);
  }
  forEachNodeAfterFilter(callback) {
    if (missing(this.clientSideRowModel)) {
      this.logMissingRowModel("forEachNodeAfterFilter", "clientSide");
      return;
    }
    this.clientSideRowModel.forEachNodeAfterFilter(callback);
  }
  forEachNodeAfterFilterAndSort(callback) {
    if (missing(this.clientSideRowModel)) {
      this.logMissingRowModel("forEachNodeAfterFilterAndSort", "clientSide");
      return;
    }
    this.clientSideRowModel.forEachNodeAfterFilterAndSort(callback);
  }
  getFilterInstance(key, callback) {
    const res = this.getFilterInstanceImpl(key, (instance) => {
      if (!callback) {
        return;
      }
      const unwrapped2 = unwrapUserComp(instance);
      callback(unwrapped2);
    });
    const unwrapped = unwrapUserComp(res);
    return unwrapped;
  }
  getFilterInstanceImpl(key, callback) {
    const column = this.columnModel.getPrimaryColumn(key);
    if (!column) {
      return void 0;
    }
    const filterPromise = this.filterManager.getFilterComponent(column, "NO_UI");
    const currentValue = filterPromise && filterPromise.resolveNow(null, (filterComp) => filterComp);
    if (currentValue) {
      setTimeout(callback, 0, currentValue);
    } else if (filterPromise) {
      filterPromise.then((comp) => {
        callback(comp);
      });
    }
    return currentValue;
  }
  destroyFilter(key) {
    const column = this.columnModel.getPrimaryColumn(key);
    if (column) {
      return this.filterManager.destroyFilter(column, "api");
    }
  }
  getStatusPanel(key) {
    if (!ModuleRegistry.assertRegistered(ModuleNames.StatusBarModule, "api.getStatusPanel", this.context.getGridId())) {
      return;
    }
    const comp = this.statusBarService.getStatusPanel(key);
    return unwrapUserComp(comp);
  }
  getColumnDef(key) {
    const column = this.columnModel.getPrimaryColumn(key);
    if (column) {
      return column.getColDef();
    }
    return null;
  }
  getColumnDefs() {
    return this.columnModel.getColumnDefs();
  }
  onFilterChanged() {
    this.filterManager.onFilterChanged();
  }
  onSortChanged() {
    this.sortController.onSortChanged("api");
  }
  setFilterModel(model) {
    this.filterManager.setFilterModel(model);
  }
  getFilterModel() {
    return this.filterManager.getFilterModel();
  }
  getFocusedCell() {
    return this.focusService.getFocusedCell();
  }
  clearFocusedCell() {
    return this.focusService.clearFocusedCell();
  }
  setFocusedCell(rowIndex, colKey, rowPinned) {
    this.focusService.setFocusedCell({ rowIndex, column: colKey, rowPinned, forceBrowserFocus: true });
  }
  setSuppressRowDrag(value) {
    this.gridOptionsService.set("suppressRowDrag", value);
  }
  setSuppressMoveWhenRowDragging(value) {
    this.gridOptionsService.set("suppressMoveWhenRowDragging", value);
  }
  setSuppressRowClickSelection(value) {
    this.gridOptionsService.set("suppressRowClickSelection", value);
  }
  addRowDropZone(params) {
    this.gridBodyCtrl.getRowDragFeature().addRowDropZone(params);
  }
  removeRowDropZone(params) {
    const activeDropTarget = this.dragAndDropService.findExternalZone(params);
    if (activeDropTarget) {
      this.dragAndDropService.removeDropTarget(activeDropTarget);
    }
  }
  getRowDropZoneParams(events) {
    return this.gridBodyCtrl.getRowDragFeature().getRowDropZone(events);
  }
  setHeaderHeight(headerHeight) {
    this.gridOptionsService.set("headerHeight", headerHeight);
  }
  setDomLayout(domLayout) {
    if (!this.clientSideRowModel && domLayout === "autoHeight" && !this.gridOptionsService.is("pagination")) {
      console.error(`AG Grid: domLayout can only be set to 'autoHeight' when using the client side row model or when using pagination.`);
      return;
    }
    this.gridOptionsService.set("domLayout", domLayout);
  }
  setEnableCellTextSelection(selectable) {
    this.gridBodyCtrl.setCellTextSelection(selectable);
  }
  setFillHandleDirection(direction) {
    this.gridOptionsService.set("fillHandleDirection", direction);
  }
  setGroupHeaderHeight(headerHeight) {
    this.gridOptionsService.set("groupHeaderHeight", headerHeight);
  }
  setFloatingFiltersHeight(headerHeight) {
    this.gridOptionsService.set("floatingFiltersHeight", headerHeight);
  }
  setPivotHeaderHeight(headerHeight) {
    this.gridOptionsService.set("pivotHeaderHeight", headerHeight);
  }
  setPivotGroupHeaderHeight(headerHeight) {
    this.gridOptionsService.set("pivotGroupHeaderHeight", headerHeight);
  }
  setPivotMode(pivotMode) {
    this.columnModel.setPivotMode(pivotMode);
  }
  setAnimateRows(animateRows) {
    this.gridOptionsService.set("animateRows", animateRows);
  }
  setIsExternalFilterPresent(isExternalFilterPresentFunc) {
    this.gridOptionsService.set("isExternalFilterPresent", isExternalFilterPresentFunc);
  }
  setDoesExternalFilterPass(doesExternalFilterPassFunc) {
    this.gridOptionsService.set("doesExternalFilterPass", doesExternalFilterPassFunc);
  }
  setNavigateToNextCell(navigateToNextCellFunc) {
    this.gridOptionsService.set("navigateToNextCell", navigateToNextCellFunc);
  }
  setTabToNextCell(tabToNextCellFunc) {
    this.gridOptionsService.set("tabToNextCell", tabToNextCellFunc);
  }
  setTabToNextHeader(tabToNextHeaderFunc) {
    this.gridOptionsService.set("tabToNextHeader", tabToNextHeaderFunc);
  }
  setNavigateToNextHeader(navigateToNextHeaderFunc) {
    this.gridOptionsService.set("navigateToNextHeader", navigateToNextHeaderFunc);
  }
  setRowGroupPanelShow(rowGroupPanelShow) {
    this.gridOptionsService.set("rowGroupPanelShow", rowGroupPanelShow);
  }
  setGetGroupRowAgg(getGroupRowAggFunc) {
    this.gridOptionsService.set("getGroupRowAgg", getGroupRowAggFunc);
  }
  setGetBusinessKeyForNode(getBusinessKeyForNodeFunc) {
    this.gridOptionsService.set("getBusinessKeyForNode", getBusinessKeyForNodeFunc);
  }
  setGetChildCount(getChildCountFunc) {
    this.gridOptionsService.set("getChildCount", getChildCountFunc);
  }
  setProcessRowPostCreate(processRowPostCreateFunc) {
    this.gridOptionsService.set("processRowPostCreate", processRowPostCreateFunc);
  }
  setGetRowId(getRowIdFunc) {
    this.gridOptionsService.set("getRowId", getRowIdFunc);
  }
  setGetRowClass(rowClassFunc) {
    this.gridOptionsService.set("getRowClass", rowClassFunc);
  }
  setIsFullWidthRow(isFullWidthRowFunc) {
    this.gridOptionsService.set("isFullWidthRow", isFullWidthRowFunc);
  }
  setIsRowSelectable(isRowSelectableFunc) {
    this.gridOptionsService.set("isRowSelectable", isRowSelectableFunc);
  }
  setIsRowMaster(isRowMasterFunc) {
    this.gridOptionsService.set("isRowMaster", isRowMasterFunc);
  }
  setPostSortRows(postSortRowsFunc) {
    this.gridOptionsService.set("postSortRows", postSortRowsFunc);
  }
  setGetDocument(getDocumentFunc) {
    this.gridOptionsService.set("getDocument", getDocumentFunc);
  }
  setGetContextMenuItems(getContextMenuItemsFunc) {
    this.gridOptionsService.set("getContextMenuItems", getContextMenuItemsFunc);
  }
  setGetMainMenuItems(getMainMenuItemsFunc) {
    this.gridOptionsService.set("getMainMenuItems", getMainMenuItemsFunc);
  }
  setProcessCellForClipboard(processCellForClipboardFunc) {
    this.gridOptionsService.set("processCellForClipboard", processCellForClipboardFunc);
  }
  setSendToClipboard(sendToClipboardFunc) {
    this.gridOptionsService.set("sendToClipboard", sendToClipboardFunc);
  }
  setProcessCellFromClipboard(processCellFromClipboardFunc) {
    this.gridOptionsService.set("processCellFromClipboard", processCellFromClipboardFunc);
  }
  setProcessSecondaryColDef(processSecondaryColDefFunc) {
    logDeprecation("28.0", "setProcessSecondaryColDef", "setProcessPivotResultColDef");
    this.setProcessPivotResultColDef(processSecondaryColDefFunc);
  }
  setProcessSecondaryColGroupDef(processSecondaryColGroupDefFunc) {
    logDeprecation("28.0", "setProcessSecondaryColGroupDef", "setProcessPivotResultColGroupDef");
    this.setProcessPivotResultColGroupDef(processSecondaryColGroupDefFunc);
  }
  setProcessPivotResultColDef(processPivotResultColDefFunc) {
    this.gridOptionsService.set("processPivotResultColDef", processPivotResultColDefFunc);
  }
  setProcessPivotResultColGroupDef(processPivotResultColGroupDefFunc) {
    this.gridOptionsService.set("processPivotResultColGroupDef", processPivotResultColGroupDefFunc);
  }
  setPostProcessPopup(postProcessPopupFunc) {
    this.gridOptionsService.set("postProcessPopup", postProcessPopupFunc);
  }
  setInitialGroupOrderComparator(initialGroupOrderComparatorFunc) {
    this.gridOptionsService.set("initialGroupOrderComparator", initialGroupOrderComparatorFunc);
  }
  setGetChartToolbarItems(getChartToolbarItemsFunc) {
    this.gridOptionsService.set("getChartToolbarItems", getChartToolbarItemsFunc);
  }
  setPaginationNumberFormatter(paginationNumberFormatterFunc) {
    this.gridOptionsService.set("paginationNumberFormatter", paginationNumberFormatterFunc);
  }
  setGetServerSideStoreParams(getServerSideStoreParamsFunc) {
    logDeprecation("28.0", "setGetServerSideStoreParams", "setGetServerSideGroupLevelParams");
    this.setGetServerSideGroupLevelParams(getServerSideStoreParamsFunc);
  }
  setGetServerSideGroupLevelParams(getServerSideGroupLevelParamsFunc) {
    this.gridOptionsService.set("getServerSideGroupLevelParams", getServerSideGroupLevelParamsFunc);
  }
  setIsServerSideGroupOpenByDefault(isServerSideGroupOpenByDefaultFunc) {
    this.gridOptionsService.set("isServerSideGroupOpenByDefault", isServerSideGroupOpenByDefaultFunc);
  }
  setIsApplyServerSideTransaction(isApplyServerSideTransactionFunc) {
    this.gridOptionsService.set("isApplyServerSideTransaction", isApplyServerSideTransactionFunc);
  }
  setIsServerSideGroup(isServerSideGroupFunc) {
    this.gridOptionsService.set("isServerSideGroup", isServerSideGroupFunc);
  }
  setGetServerSideGroupKey(getServerSideGroupKeyFunc) {
    this.gridOptionsService.set("getServerSideGroupKey", getServerSideGroupKeyFunc);
  }
  setGetRowStyle(rowStyleFunc) {
    this.gridOptionsService.set("getRowStyle", rowStyleFunc);
  }
  setGetRowHeight(rowHeightFunc) {
    this.gridOptionsService.set("getRowHeight", rowHeightFunc);
  }
  assertSideBarLoaded(apiMethod) {
    return ModuleRegistry.assertRegistered(ModuleNames.SideBarModule, "api." + apiMethod, this.context.getGridId());
  }
  isSideBarVisible() {
    return this.assertSideBarLoaded("isSideBarVisible") && this.sideBarComp.isDisplayed();
  }
  setSideBarVisible(show) {
    if (this.assertSideBarLoaded("setSideBarVisible")) {
      this.sideBarComp.setDisplayed(show);
    }
  }
  setSideBarPosition(position) {
    if (this.assertSideBarLoaded("setSideBarPosition")) {
      this.sideBarComp.setSideBarPosition(position);
    }
  }
  openToolPanel(key) {
    if (this.assertSideBarLoaded("openToolPanel")) {
      this.sideBarComp.openToolPanel(key, "api");
    }
  }
  closeToolPanel() {
    if (this.assertSideBarLoaded("closeToolPanel")) {
      this.sideBarComp.close("api");
    }
  }
  getOpenedToolPanel() {
    if (this.assertSideBarLoaded("getOpenedToolPanel")) {
      return this.sideBarComp.openedItem();
    }
    return null;
  }
  refreshToolPanel() {
    if (this.assertSideBarLoaded("refreshToolPanel")) {
      this.sideBarComp.refresh();
    }
  }
  isToolPanelShowing() {
    return this.assertSideBarLoaded("isToolPanelShowing") && this.sideBarComp.isToolPanelShowing();
  }
  getToolPanelInstance(id) {
    if (this.assertSideBarLoaded("getToolPanelInstance")) {
      const comp = this.sideBarComp.getToolPanelInstance(id);
      return unwrapUserComp(comp);
    }
  }
  getSideBar() {
    if (this.assertSideBarLoaded("getSideBar")) {
      return this.sideBarComp.getDef();
    }
    return void 0;
  }
  setSideBar(def) {
    this.gridOptionsService.set("sideBar", def);
  }
  setSuppressClipboardPaste(value) {
    this.gridOptionsService.set("suppressClipboardPaste", value);
  }
  resetRowHeights() {
    if (exists(this.clientSideRowModel)) {
      if (this.columnModel.isAutoRowHeightActive()) {
        console.warn("AG Grid: calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.");
        return;
      }
      this.clientSideRowModel.resetRowHeights();
    }
  }
  setGroupRemoveSingleChildren(value) {
    this.gridOptionsService.set("groupRemoveSingleChildren", value);
  }
  setGroupRemoveLowestSingleChildren(value) {
    this.gridOptionsService.set("groupRemoveLowestSingleChildren", value);
  }
  setGroupDisplayType(value) {
    this.gridOptionsService.set("groupDisplayType", value);
  }
  setRowClass(className) {
    this.gridOptionsService.set("rowClass", className);
  }
  setDeltaSort(enable) {
    this.gridOptionsService.set("deltaSort", enable);
  }
  setRowCount(rowCount, maxRowFound) {
    if (this.serverSideRowModel) {
      if (this.columnModel.isRowGroupEmpty()) {
        this.serverSideRowModel.setRowCount(rowCount, maxRowFound);
        return;
      }
      console.error("AG Grid: setRowCount cannot be used while using row grouping.");
      return;
    }
    if (this.infiniteRowModel) {
      this.infiniteRowModel.setRowCount(rowCount, maxRowFound);
      return;
    }
    this.logMissingRowModel("setRowCount", "infinite", "serverSide");
  }
  onRowHeightChanged() {
    if (this.clientSideRowModel) {
      this.clientSideRowModel.onRowHeightChanged();
    } else if (this.serverSideRowModel) {
      this.serverSideRowModel.onRowHeightChanged();
    }
  }
  getValue(colKey, rowNode) {
    let column = this.columnModel.getPrimaryColumn(colKey);
    if (missing(column)) {
      column = this.columnModel.getGridColumn(colKey);
    }
    if (missing(column)) {
      return null;
    }
    return this.valueService.getValue(column, rowNode);
  }
  addEventListener(eventType, listener) {
    const async = this.gridOptionsService.useAsyncEvents();
    this.eventService.addEventListener(eventType, listener, async);
  }
  addGlobalListener(listener) {
    const async = this.gridOptionsService.useAsyncEvents();
    this.eventService.addGlobalListener(listener, async);
  }
  removeEventListener(eventType, listener) {
    const async = this.gridOptionsService.useAsyncEvents();
    this.eventService.removeEventListener(eventType, listener, async);
  }
  removeGlobalListener(listener) {
    const async = this.gridOptionsService.useAsyncEvents();
    this.eventService.removeGlobalListener(listener, async);
  }
  dispatchEvent(event) {
    this.eventService.dispatchEvent(event);
  }
  destroy() {
    if (this.destroyCalled) {
      return;
    }
    this.destroyCalled = true;
    const gridCtrl = this.ctrlsService.getGridCtrl();
    if (gridCtrl) {
      gridCtrl.destroyGridUi();
    }
    this.context.destroy();
  }
  cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid() {
    setTimeout(removeAllReferences.bind(window, this, "Grid API"), 100);
  }
  warnIfDestroyed(methodName) {
    if (this.destroyCalled) {
      console.warn(`AG Grid: Grid API method ${methodName} was called on a grid that was destroyed.`);
    }
    return this.destroyCalled;
  }
  resetQuickFilter() {
    if (this.warnIfDestroyed("resetQuickFilter")) {
      return;
    }
    this.filterManager.resetQuickFilterCache();
  }
  getCellRanges() {
    if (this.rangeService) {
      return this.rangeService.getCellRanges();
    }
    ModuleRegistry.assertRegistered(ModuleNames.RangeSelectionModule, "api.getCellRanges", this.context.getGridId());
    return null;
  }
  addCellRange(params) {
    if (this.rangeService) {
      this.rangeService.addCellRange(params);
      return;
    }
    ModuleRegistry.assertRegistered(ModuleNames.RangeSelectionModule, "api.addCellRange", this.context.getGridId());
  }
  clearRangeSelection() {
    if (this.rangeService) {
      this.rangeService.removeAllCellRanges();
    }
    ModuleRegistry.assertRegistered(ModuleNames.RangeSelectionModule, "gridApi.clearRangeSelection", this.context.getGridId());
  }
  undoCellEditing() {
    this.undoRedoService.undo("api");
  }
  redoCellEditing() {
    this.undoRedoService.redo("api");
  }
  getCurrentUndoSize() {
    return this.undoRedoService.getCurrentUndoStackSize();
  }
  getCurrentRedoSize() {
    return this.undoRedoService.getCurrentRedoStackSize();
  }
  getChartModels() {
    if (ModuleRegistry.assertRegistered(ModuleNames.GridChartsModule, "api.getChartModels", this.context.getGridId())) {
      return this.chartService.getChartModels();
    }
  }
  getChartRef(chartId) {
    if (ModuleRegistry.assertRegistered(ModuleNames.GridChartsModule, "api.getChartRef", this.context.getGridId())) {
      return this.chartService.getChartRef(chartId);
    }
  }
  getChartImageDataURL(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.GridChartsModule, "api.getChartImageDataURL", this.context.getGridId())) {
      return this.chartService.getChartImageDataURL(params);
    }
  }
  downloadChart(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.GridChartsModule, "api.downloadChart", this.context.getGridId())) {
      return this.chartService.downloadChart(params);
    }
  }
  openChartToolPanel(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.GridChartsModule, "api.openChartToolPanel", this.context.getGridId())) {
      return this.chartService.openChartToolPanel(params);
    }
  }
  closeChartToolPanel(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.GridChartsModule, "api.closeChartToolPanel", this.context.getGridId())) {
      return this.chartService.closeChartToolPanel(params.chartId);
    }
  }
  createRangeChart(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.GridChartsModule, "api.createRangeChart", this.context.getGridId())) {
      return this.chartService.createRangeChart(params);
    }
  }
  createPivotChart(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.GridChartsModule, "api.createPivotChart", this.context.getGridId())) {
      return this.chartService.createPivotChart(params);
    }
  }
  createCrossFilterChart(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.GridChartsModule, "api.createCrossFilterChart", this.context.getGridId())) {
      return this.chartService.createCrossFilterChart(params);
    }
  }
  updateChart(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.GridChartsModule, "api.updateChart", this.context.getGridId())) {
      this.chartService.updateChart(params);
    }
  }
  restoreChart(chartModel, chartContainer) {
    if (ModuleRegistry.assertRegistered(ModuleNames.GridChartsModule, "api.restoreChart", this.context.getGridId())) {
      return this.chartService.restoreChart(chartModel, chartContainer);
    }
  }
  copyToClipboard(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.ClipboardModule, "api.copyToClipboard", this.context.getGridId())) {
      this.clipboardService.copyToClipboard(params);
    }
  }
  cutToClipboard(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.ClipboardModule, "api.cutToClipboard", this.context.getGridId())) {
      this.clipboardService.cutToClipboard(params, "api");
    }
  }
  copySelectedRowsToClipboard(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.ClipboardModule, "api.copySelectedRowsToClipboard", this.context.getGridId())) {
      this.clipboardService.copySelectedRowsToClipboard(params);
    }
  }
  copySelectedRangeToClipboard(params) {
    if (ModuleRegistry.assertRegistered(ModuleNames.ClipboardModule, "api.copySelectedRangeToClipboard", this.context.getGridId())) {
      this.clipboardService.copySelectedRangeToClipboard(params);
    }
  }
  copySelectedRangeDown() {
    if (ModuleRegistry.assertRegistered(ModuleNames.ClipboardModule, "api.copySelectedRangeDown", this.context.getGridId())) {
      this.clipboardService.copyRangeDown();
    }
  }
  pasteFromClipboard() {
    if (ModuleRegistry.assertRegistered(ModuleNames.ClipboardModule, "api.pasteFromClipboard", this.context.getGridId())) {
      this.clipboardService.pasteFromClipboard();
    }
  }
  showColumnMenuAfterButtonClick(colKey, buttonElement) {
    const column = this.columnModel.getGridColumn(colKey);
    this.menuFactory.showMenuAfterButtonClick(column, buttonElement, "columnMenu");
  }
  showColumnMenuAfterMouseClick(colKey, mouseEvent) {
    let column = this.columnModel.getGridColumn(colKey);
    if (!column) {
      column = this.columnModel.getPrimaryColumn(colKey);
    }
    if (!column) {
      console.error(`AG Grid: column '${colKey}' not found`);
      return;
    }
    this.menuFactory.showMenuAfterMouseEvent(column, mouseEvent);
  }
  hidePopupMenu() {
    if (this.contextMenuFactory) {
      this.contextMenuFactory.hideActiveMenu();
    }
    this.menuFactory.hideActiveMenu();
  }
  setPopupParent(ePopupParent) {
    this.gridOptionsService.set("popupParent", ePopupParent);
  }
  tabToNextCell(event) {
    return this.navigationService.tabToNextCell(false, event);
  }
  tabToPreviousCell(event) {
    return this.navigationService.tabToNextCell(true, event);
  }
  getCellRendererInstances(params = {}) {
    const res = this.rowRenderer.getCellRendererInstances(params);
    const unwrapped = res.map(unwrapUserComp);
    return unwrapped;
  }
  getCellEditorInstances(params = {}) {
    const res = this.rowRenderer.getCellEditorInstances(params);
    const unwrapped = res.map(unwrapUserComp);
    return unwrapped;
  }
  getEditingCells() {
    return this.rowRenderer.getEditingCells();
  }
  stopEditing(cancel = false) {
    this.rowRenderer.stopEditing(cancel);
  }
  startEditingCell(params) {
    const column = this.columnModel.getGridColumn(params.colKey);
    if (!column) {
      console.warn(`AG Grid: no column found for ${params.colKey}`);
      return;
    }
    const cellPosition = {
      rowIndex: params.rowIndex,
      rowPinned: params.rowPinned || null,
      column
    };
    const notPinned = params.rowPinned == null;
    if (notPinned) {
      this.gridBodyCtrl.getScrollFeature().ensureIndexVisible(params.rowIndex);
    }
    const cell = this.navigationService.getCellByPosition(cellPosition);
    if (!cell) {
      return;
    }
    cell.startRowOrCellEdit(params.key);
  }
  addAggFunc(key, aggFunc) {
    if (this.aggFuncService) {
      this.aggFuncService.addAggFunc(key, aggFunc);
    }
  }
  addAggFuncs(aggFuncs) {
    if (this.aggFuncService) {
      this.aggFuncService.addAggFuncs(aggFuncs);
    }
  }
  clearAggFuncs() {
    if (this.aggFuncService) {
      this.aggFuncService.clear();
    }
  }
  applyServerSideTransaction(transaction) {
    if (!this.serverSideTransactionManager) {
      this.logMissingRowModel("applyServerSideTransaction", "serverSide");
      return;
    }
    return this.serverSideTransactionManager.applyTransaction(transaction);
  }
  applyServerSideTransactionAsync(transaction, callback) {
    if (!this.serverSideTransactionManager) {
      this.logMissingRowModel("applyServerSideTransactionAsync", "serverSide");
      return;
    }
    return this.serverSideTransactionManager.applyTransactionAsync(transaction, callback);
  }
  retryServerSideLoads() {
    if (!this.serverSideRowModel) {
      this.logMissingRowModel("retryServerSideLoads", "serverSide");
      return;
    }
    this.serverSideRowModel.retryLoads();
  }
  flushServerSideAsyncTransactions() {
    if (!this.serverSideTransactionManager) {
      this.logMissingRowModel("flushServerSideAsyncTransactions", "serverSide");
      return;
    }
    return this.serverSideTransactionManager.flushAsyncTransactions();
  }
  applyTransaction(rowDataTransaction) {
    if (!this.clientSideRowModel) {
      this.logMissingRowModel("applyTransaction", "clientSide");
      return;
    }
    const res = this.clientSideRowModel.updateRowData(rowDataTransaction);
    if (!this.gridOptionsService.is("suppressChangeDetection")) {
      this.rowRenderer.refreshCells();
    }
    return res;
  }
  applyTransactionAsync(rowDataTransaction, callback) {
    if (!this.clientSideRowModel) {
      this.logMissingRowModel("applyTransactionAsync", "clientSide");
      return;
    }
    this.clientSideRowModel.batchUpdateRowData(rowDataTransaction, callback);
  }
  flushAsyncTransactions() {
    if (!this.clientSideRowModel) {
      this.logMissingRowModel("flushAsyncTransactions", "clientSide");
      return;
    }
    this.clientSideRowModel.flushAsyncTransactions();
  }
  setSuppressModelUpdateAfterUpdateTransaction(value) {
    this.gridOptionsService.set("suppressModelUpdateAfterUpdateTransaction", value);
  }
  refreshInfiniteCache() {
    if (this.infiniteRowModel) {
      this.infiniteRowModel.refreshCache();
    } else {
      this.logMissingRowModel("refreshInfiniteCache", "infinite");
    }
  }
  purgeInfiniteCache() {
    if (this.infiniteRowModel) {
      this.infiniteRowModel.purgeCache();
    } else {
      this.logMissingRowModel("purgeInfiniteCache", "infinite");
    }
  }
  refreshServerSide(params) {
    if (!this.serverSideRowModel) {
      this.logMissingRowModel("refreshServerSide", "serverSide");
      return;
    }
    this.serverSideRowModel.refreshStore(params);
  }
  refreshServerSideStore(params) {
    logDeprecation("28.0", "refreshServerSideStore", "refreshServerSide");
    return this.refreshServerSide(params);
  }
  getServerSideStoreState() {
    logDeprecation("28.0", "getServerSideStoreState", "getServerSideGroupLevelState");
    return this.getServerSideGroupLevelState();
  }
  getServerSideGroupLevelState() {
    if (!this.serverSideRowModel) {
      this.logMissingRowModel("getServerSideGroupLevelState", "serverSide");
      return [];
    }
    return this.serverSideRowModel.getStoreState();
  }
  getInfiniteRowCount() {
    if (this.infiniteRowModel) {
      return this.infiniteRowModel.getRowCount();
    } else {
      this.logMissingRowModel("getInfiniteRowCount", "infinite");
    }
  }
  isLastRowIndexKnown() {
    if (this.infiniteRowModel) {
      return this.infiniteRowModel.isLastRowIndexKnown();
    } else {
      this.logMissingRowModel("isLastRowIndexKnown", "infinite");
    }
  }
  getCacheBlockState() {
    return this.rowNodeBlockLoader.getBlockState();
  }
  getFirstDisplayedRow() {
    return this.rowRenderer.getFirstVirtualRenderedRow();
  }
  getLastDisplayedRow() {
    return this.rowRenderer.getLastVirtualRenderedRow();
  }
  getDisplayedRowAtIndex(index) {
    return this.rowModel.getRow(index);
  }
  getDisplayedRowCount() {
    return this.rowModel.getRowCount();
  }
  setDataTypeDefinitions(dataTypeDefinitions) {
    this.gridOptionsService.set("dataTypeDefinitions", dataTypeDefinitions);
  }
  setPagination(value) {
    if (!this.clientSideRowModel && this.gridOptionsService.get("domLayout") === "autoHeight" && !value) {
      console.error(`AG Grid: Pagination cannot be disabled when using domLayout set to 'autoHeight' unless using the client-side row model.`);
      return;
    }
    this.gridOptionsService.set("pagination", value);
  }
  paginationIsLastPageFound() {
    return this.paginationProxy.isLastPageFound();
  }
  paginationGetPageSize() {
    return this.paginationProxy.getPageSize();
  }
  paginationSetPageSize(size) {
    this.gridOptionsService.set("paginationPageSize", size);
  }
  paginationGetCurrentPage() {
    return this.paginationProxy.getCurrentPage();
  }
  paginationGetTotalPages() {
    return this.paginationProxy.getTotalPages();
  }
  paginationGetRowCount() {
    return this.paginationProxy.getMasterRowCount();
  }
  paginationGoToNextPage() {
    this.paginationProxy.goToNextPage();
  }
  paginationGoToPreviousPage() {
    this.paginationProxy.goToPreviousPage();
  }
  paginationGoToFirstPage() {
    this.paginationProxy.goToFirstPage();
  }
  paginationGoToLastPage() {
    this.paginationProxy.goToLastPage();
  }
  paginationGoToPage(page) {
    this.paginationProxy.goToPage(page);
  }
};
__decorate$1V([
  Optional("immutableService")
], GridApi.prototype, "immutableService", void 0);
__decorate$1V([
  Optional("csvCreator")
], GridApi.prototype, "csvCreator", void 0);
__decorate$1V([
  Optional("excelCreator")
], GridApi.prototype, "excelCreator", void 0);
__decorate$1V([
  Autowired("rowRenderer")
], GridApi.prototype, "rowRenderer", void 0);
__decorate$1V([
  Autowired("navigationService")
], GridApi.prototype, "navigationService", void 0);
__decorate$1V([
  Autowired("filterManager")
], GridApi.prototype, "filterManager", void 0);
__decorate$1V([
  Autowired("columnModel")
], GridApi.prototype, "columnModel", void 0);
__decorate$1V([
  Autowired("selectionService")
], GridApi.prototype, "selectionService", void 0);
__decorate$1V([
  Autowired("gridOptionsService")
], GridApi.prototype, "gridOptionsService", void 0);
__decorate$1V([
  Autowired("valueService")
], GridApi.prototype, "valueService", void 0);
__decorate$1V([
  Autowired("alignedGridsService")
], GridApi.prototype, "alignedGridsService", void 0);
__decorate$1V([
  Autowired("eventService")
], GridApi.prototype, "eventService", void 0);
__decorate$1V([
  Autowired("pinnedRowModel")
], GridApi.prototype, "pinnedRowModel", void 0);
__decorate$1V([
  Autowired("context")
], GridApi.prototype, "context", void 0);
__decorate$1V([
  Autowired("rowModel")
], GridApi.prototype, "rowModel", void 0);
__decorate$1V([
  Autowired("sortController")
], GridApi.prototype, "sortController", void 0);
__decorate$1V([
  Autowired("paginationProxy")
], GridApi.prototype, "paginationProxy", void 0);
__decorate$1V([
  Autowired("focusService")
], GridApi.prototype, "focusService", void 0);
__decorate$1V([
  Autowired("dragAndDropService")
], GridApi.prototype, "dragAndDropService", void 0);
__decorate$1V([
  Optional("rangeService")
], GridApi.prototype, "rangeService", void 0);
__decorate$1V([
  Optional("clipboardService")
], GridApi.prototype, "clipboardService", void 0);
__decorate$1V([
  Optional("aggFuncService")
], GridApi.prototype, "aggFuncService", void 0);
__decorate$1V([
  Autowired("menuFactory")
], GridApi.prototype, "menuFactory", void 0);
__decorate$1V([
  Optional("contextMenuFactory")
], GridApi.prototype, "contextMenuFactory", void 0);
__decorate$1V([
  Autowired("valueCache")
], GridApi.prototype, "valueCache", void 0);
__decorate$1V([
  Autowired("animationFrameService")
], GridApi.prototype, "animationFrameService", void 0);
__decorate$1V([
  Optional("statusBarService")
], GridApi.prototype, "statusBarService", void 0);
__decorate$1V([
  Optional("chartService")
], GridApi.prototype, "chartService", void 0);
__decorate$1V([
  Optional("undoRedoService")
], GridApi.prototype, "undoRedoService", void 0);
__decorate$1V([
  Optional("rowNodeBlockLoader")
], GridApi.prototype, "rowNodeBlockLoader", void 0);
__decorate$1V([
  Optional("ssrmTransactionManager")
], GridApi.prototype, "serverSideTransactionManager", void 0);
__decorate$1V([
  Autowired("ctrlsService")
], GridApi.prototype, "ctrlsService", void 0);
__decorate$1V([
  PostConstruct
], GridApi.prototype, "init", null);
__decorate$1V([
  PreDestroy
], GridApi.prototype, "cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid", null);
GridApi = __decorate$1V([
  Bean("gridApi")
], GridApi);
var __decorate$1U = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FilterManager_1;
var FilterManager = FilterManager_1 = class FilterManager2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.allColumnFilters = /* @__PURE__ */ new Map();
    this.allColumnListeners = /* @__PURE__ */ new Map();
    this.activeAggregateFilters = [];
    this.activeColumnFilters = [];
    this.quickFilter = null;
    this.quickFilterParts = null;
    this.processingFilterChange = false;
  }
  init() {
    this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, () => this.onColumnsChanged());
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, () => this.refreshFiltersForAggregations());
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, () => this.refreshFiltersForAggregations());
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => {
      this.refreshFiltersForAggregations();
      this.resetQuickFilterCache();
    });
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, () => this.resetQuickFilterCache());
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.resetQuickFilterCache());
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, () => {
      if (!this.gridOptionsService.is("includeHiddenColumnsInQuickFilter")) {
        this.resetQuickFilterCache();
      }
    });
    this.addManagedPropertyListener("quickFilterText", (e) => this.setQuickFilter(e.currentValue));
    this.addManagedPropertyListener("includeHiddenColumnsInQuickFilter", () => this.onIncludeHiddenColumnsInQuickFilterChanged());
    this.quickFilter = this.parseQuickFilter(this.gridOptionsService.get("quickFilterText"));
    this.setQuickFilterParts();
    this.allowShowChangeAfterFilter = this.gridOptionsService.is("allowShowChangeAfterFilter");
    this.externalFilterPresent = this.isExternalFilterPresentCallback();
    this.updateAggFiltering();
    this.addManagedPropertyListener("groupAggFiltering", () => this.updateAggFiltering());
  }
  isExternalFilterPresentCallback() {
    const isFilterPresent = this.gridOptionsService.getCallback("isExternalFilterPresent");
    if (typeof isFilterPresent === "function") {
      return isFilterPresent({});
    }
    return false;
  }
  doesExternalFilterPass(node) {
    const doesFilterPass = this.gridOptionsService.get("doesExternalFilterPass");
    if (typeof doesFilterPass === "function") {
      return doesFilterPass(node);
    }
    return false;
  }
  setQuickFilterParts() {
    this.quickFilterParts = this.quickFilter ? this.quickFilter.split(" ") : null;
  }
  setFilterModel(model) {
    const allPromises = [];
    const previousModel = this.getFilterModel();
    if (model) {
      const modelKeys = convertToSet(Object.keys(model));
      this.allColumnFilters.forEach((filterWrapper, colId) => {
        const newModel = model[colId];
        allPromises.push(this.setModelOnFilterWrapper(filterWrapper.filterPromise, newModel));
        modelKeys.delete(colId);
      });
      modelKeys.forEach((colId) => {
        const column = this.columnModel.getPrimaryColumn(colId) || this.columnModel.getGridColumn(colId);
        if (!column) {
          console.warn("AG Grid: setFilterModel() - no column found for colId: " + colId);
          return;
        }
        if (!column.isFilterAllowed()) {
          console.warn("AG Grid: setFilterModel() - unable to fully apply model, filtering disabled for colId: " + colId);
          return;
        }
        const filterWrapper = this.getOrCreateFilterWrapper(column, "NO_UI");
        if (!filterWrapper) {
          console.warn("AG-Grid: setFilterModel() - unable to fully apply model, unable to create filter for colId: " + colId);
          return;
        }
        allPromises.push(this.setModelOnFilterWrapper(filterWrapper.filterPromise, model[colId]));
      });
    } else {
      this.allColumnFilters.forEach((filterWrapper) => {
        allPromises.push(this.setModelOnFilterWrapper(filterWrapper.filterPromise, null));
      });
    }
    AgPromise.all(allPromises).then(() => {
      const currentModel = this.getFilterModel();
      const columns = [];
      this.allColumnFilters.forEach((filterWrapper, colId) => {
        const before = previousModel ? previousModel[colId] : null;
        const after = currentModel ? currentModel[colId] : null;
        if (!_.jsonEquals(before, after)) {
          columns.push(filterWrapper.column);
        }
      });
      if (columns.length > 0) {
        this.onFilterChanged({ columns });
      }
    });
  }
  setModelOnFilterWrapper(filterPromise, newModel) {
    return new AgPromise((resolve) => {
      filterPromise.then((filter) => {
        if (typeof filter.setModel !== "function") {
          console.warn("AG Grid: filter missing setModel method, which is needed for setFilterModel");
          resolve();
        }
        (filter.setModel(newModel) || AgPromise.resolve()).then(() => resolve());
      });
    });
  }
  getFilterModel() {
    const result = {};
    this.allColumnFilters.forEach((filterWrapper, key) => {
      const filterPromise = filterWrapper.filterPromise;
      const filter = filterPromise.resolveNow(null, (promiseFilter) => promiseFilter);
      if (filter == null) {
        return null;
      }
      if (typeof filter.getModel !== "function") {
        console.warn("AG Grid: filter API missing getModel method, which is needed for getFilterModel");
        return;
      }
      const model = filter.getModel();
      if (exists(model)) {
        result[key] = model;
      }
    });
    return result;
  }
  isColumnFilterPresent() {
    return this.activeColumnFilters.length > 0;
  }
  isAggregateFilterPresent() {
    return !!this.activeAggregateFilters.length;
  }
  isExternalFilterPresent() {
    return this.externalFilterPresent;
  }
  doAggregateFiltersPass(node, filterToSkip) {
    return this.doColumnFiltersPass(node, filterToSkip, true);
  }
  updateActiveFilters() {
    this.activeColumnFilters.length = 0;
    this.activeAggregateFilters.length = 0;
    const isFilterActive = (filter) => {
      if (!filter) {
        return false;
      }
      if (!filter.isFilterActive) {
        console.warn("AG Grid: Filter is missing isFilterActive() method");
        return false;
      }
      return filter.isFilterActive();
    };
    const groupFilterEnabled = !!this.gridOptionsService.getGroupAggFiltering();
    const isAggFilter = (column) => {
      const isSecondary = !column.isPrimary();
      if (isSecondary) {
        return true;
      }
      const isShowingPrimaryColumns = !this.columnModel.isPivotActive();
      const isValueActive = column.isValueActive();
      if (!isValueActive || !isShowingPrimaryColumns) {
        return false;
      }
      if (this.columnModel.isPivotMode()) {
        return true;
      }
      return groupFilterEnabled;
    };
    this.allColumnFilters.forEach((filterWrapper) => {
      if (filterWrapper.filterPromise.resolveNow(false, isFilterActive)) {
        const filterComp = filterWrapper.filterPromise.resolveNow(null, (filter) => filter);
        if (isAggFilter(filterWrapper.column)) {
          this.activeAggregateFilters.push(filterComp);
        } else {
          this.activeColumnFilters.push(filterComp);
        }
      }
    });
  }
  updateFilterFlagInColumns(source, additionalEventAttributes) {
    this.allColumnFilters.forEach((filterWrapper) => {
      const isFilterActive = filterWrapper.filterPromise.resolveNow(false, (filter) => filter.isFilterActive());
      filterWrapper.column.setFilterActive(isFilterActive, source, additionalEventAttributes);
    });
  }
  isAnyFilterPresent() {
    return this.isQuickFilterPresent() || this.isColumnFilterPresent() || this.isAggregateFilterPresent() || this.isExternalFilterPresent();
  }
  doColumnFiltersPass(node, filterToSkip, targetAggregates) {
    const { data, aggData } = node;
    const targetedFilters = targetAggregates ? this.activeAggregateFilters : this.activeColumnFilters;
    const targetedData = targetAggregates ? aggData : data;
    for (let i = 0; i < targetedFilters.length; i++) {
      const filter = targetedFilters[i];
      if (filter == null || filter === filterToSkip) {
        continue;
      }
      if (typeof filter.doesFilterPass !== "function") {
        throw new Error("Filter is missing method doesFilterPass");
      }
      if (!filter.doesFilterPass({ node, data: targetedData })) {
        return false;
      }
    }
    return true;
  }
  parseQuickFilter(newFilter) {
    if (!exists(newFilter)) {
      return null;
    }
    if (!this.gridOptionsService.isRowModelType("clientSide")) {
      console.warn("AG Grid - Quick filtering only works with the Client-Side Row Model");
      return null;
    }
    return newFilter.toUpperCase();
  }
  setQuickFilter(newFilter) {
    if (newFilter != null && typeof newFilter !== "string") {
      console.warn(`AG Grid - setQuickFilter() only supports string inputs, received: ${typeof newFilter}`);
      return;
    }
    const parsedFilter = this.parseQuickFilter(newFilter);
    if (this.quickFilter !== parsedFilter) {
      this.quickFilter = parsedFilter;
      this.setQuickFilterParts();
      this.onFilterChanged();
    }
  }
  resetQuickFilterCache() {
    this.rowModel.forEachNode((node) => node.quickFilterAggregateText = null);
  }
  onIncludeHiddenColumnsInQuickFilterChanged() {
    this.columnModel.refreshQuickFilterColumns();
    this.resetQuickFilterCache();
    if (this.isQuickFilterPresent()) {
      this.onFilterChanged();
    }
  }
  refreshFiltersForAggregations() {
    const isAggFiltering = this.gridOptionsService.getGroupAggFiltering();
    if (isAggFiltering) {
      this.onFilterChanged();
    }
  }
  callOnFilterChangedOutsideRenderCycle(params = {}) {
    const action = () => this.onFilterChanged(params);
    if (this.rowRenderer.isRefreshInProgress()) {
      setTimeout(action, 0);
    } else {
      action();
    }
  }
  onFilterChanged(params = {}) {
    const { filterInstance, additionalEventAttributes, columns } = params;
    this.updateDependantFilters();
    this.updateActiveFilters();
    this.updateFilterFlagInColumns("filterChanged", additionalEventAttributes);
    this.externalFilterPresent = this.isExternalFilterPresentCallback();
    this.allColumnFilters.forEach((filterWrapper) => {
      if (!filterWrapper.filterPromise) {
        return;
      }
      filterWrapper.filterPromise.then((filter) => {
        if (filter && filter !== filterInstance && filter.onAnyFilterChanged) {
          filter.onAnyFilterChanged();
        }
      });
    });
    const filterChangedEvent = {
      type: Events.EVENT_FILTER_CHANGED,
      columns: columns || []
    };
    if (additionalEventAttributes) {
      mergeDeep(filterChangedEvent, additionalEventAttributes);
    }
    this.processingFilterChange = true;
    this.eventService.dispatchEvent(filterChangedEvent);
    this.processingFilterChange = false;
  }
  isSuppressFlashingCellsBecauseFiltering() {
    return !this.allowShowChangeAfterFilter && this.processingFilterChange;
  }
  isQuickFilterPresent() {
    return this.quickFilter !== null;
  }
  updateAggFiltering() {
    this.aggFiltering = !!this.gridOptionsService.getGroupAggFiltering();
  }
  isAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && (this.aggFiltering || this.columnModel.isPivotMode());
  }
  isNonAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && !(this.aggFiltering || this.columnModel.isPivotMode());
  }
  doesRowPassOtherFilters(filterToSkip, node) {
    return this.doesRowPassFilter({ rowNode: node, filterInstanceToSkip: filterToSkip });
  }
  doesRowPassQuickFilterNoCache(node, filterPart) {
    const columns = this.columnModel.getAllColumnsForQuickFilter();
    return columns.some((column) => {
      const part = this.getQuickFilterTextForColumn(column, node);
      return exists(part) && part.indexOf(filterPart) >= 0;
    });
  }
  doesRowPassQuickFilterCache(node, filterPart) {
    if (!node.quickFilterAggregateText) {
      this.aggregateRowForQuickFilter(node);
    }
    return node.quickFilterAggregateText.indexOf(filterPart) >= 0;
  }
  doesRowPassQuickFilter(node) {
    const usingCache = this.gridOptionsService.is("cacheQuickFilter");
    return this.quickFilterParts.every((part) => usingCache ? this.doesRowPassQuickFilterCache(node, part) : this.doesRowPassQuickFilterNoCache(node, part));
  }
  doesRowPassAggregateFilters(params) {
    if (this.isAggregateQuickFilterPresent() && !this.doesRowPassQuickFilter(params.rowNode)) {
      return false;
    }
    if (this.isAggregateFilterPresent() && !this.doAggregateFiltersPass(params.rowNode, params.filterInstanceToSkip)) {
      return false;
    }
    return true;
  }
  doesRowPassFilter(params) {
    if (this.isNonAggregateQuickFilterPresent() && !this.doesRowPassQuickFilter(params.rowNode)) {
      return false;
    }
    if (this.isExternalFilterPresent() && !this.doesExternalFilterPass(params.rowNode)) {
      return false;
    }
    if (this.isColumnFilterPresent() && !this.doColumnFiltersPass(params.rowNode, params.filterInstanceToSkip)) {
      return false;
    }
    return true;
  }
  getQuickFilterTextForColumn(column, node) {
    let value = this.valueService.getValue(column, node, true);
    const colDef = column.getColDef();
    if (colDef.getQuickFilterText) {
      const params = {
        value,
        node,
        data: node.data,
        column,
        colDef,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      };
      value = colDef.getQuickFilterText(params);
    }
    return exists(value) ? value.toString().toUpperCase() : null;
  }
  aggregateRowForQuickFilter(node) {
    const stringParts = [];
    const columns = this.columnModel.getAllColumnsForQuickFilter();
    columns.forEach((column) => {
      const part = this.getQuickFilterTextForColumn(column, node);
      if (exists(part)) {
        stringParts.push(part);
      }
    });
    node.quickFilterAggregateText = stringParts.join(FilterManager_1.QUICK_FILTER_SEPARATOR);
  }
  onNewRowsLoaded(source) {
    this.allColumnFilters.forEach((filterWrapper) => {
      filterWrapper.filterPromise.then((filter) => {
        if (filter.onNewRowsLoaded) {
          filter.onNewRowsLoaded();
        }
      });
    });
    this.updateFilterFlagInColumns(source, { afterDataChange: true });
    this.updateActiveFilters();
  }
  createValueGetter(column) {
    return ({ node }) => this.valueService.getValue(column, node, true);
  }
  getFilterComponent(column, source, createIfDoesNotExist = true) {
    var _a;
    if (createIfDoesNotExist) {
      return ((_a = this.getOrCreateFilterWrapper(column, source)) === null || _a === void 0 ? void 0 : _a.filterPromise) || null;
    }
    const filterWrapper = this.cachedFilter(column);
    return filterWrapper ? filterWrapper.filterPromise : null;
  }
  isFilterActive(column) {
    const filterWrapper = this.cachedFilter(column);
    return !!filterWrapper && filterWrapper.filterPromise.resolveNow(false, (filter) => filter.isFilterActive());
  }
  getOrCreateFilterWrapper(column, source) {
    if (!column.isFilterAllowed()) {
      return null;
    }
    let filterWrapper = this.cachedFilter(column);
    if (!filterWrapper) {
      filterWrapper = this.createFilterWrapper(column, source);
      const colId = column.getColId();
      this.allColumnFilters.set(colId, filterWrapper);
      this.allColumnListeners.set(colId, this.addManagedListener(column, Column.EVENT_COL_DEF_CHANGED, () => this.checkDestroyFilter(colId)));
    } else if (source !== "NO_UI") {
      this.putIntoGui(filterWrapper, source);
    }
    return filterWrapper;
  }
  cachedFilter(column) {
    return this.allColumnFilters.get(column.getColId());
  }
  getDefaultFilter(column) {
    let defaultFilter;
    if (ModuleRegistry.isRegistered(ModuleNames.SetFilterModule, this.context.getGridId())) {
      defaultFilter = "agSetColumnFilter";
    } else {
      const cellDataType = column.getColDef().cellDataType;
      if (cellDataType === "number") {
        defaultFilter = "agNumberColumnFilter";
      } else if (cellDataType === "date" || cellDataType === "dateString") {
        defaultFilter = "agDateColumnFilter";
      } else {
        defaultFilter = "agTextColumnFilter";
      }
    }
    return defaultFilter;
  }
  getDefaultFloatingFilter(column) {
    let defaultFloatingFilterType;
    if (ModuleRegistry.isRegistered(ModuleNames.SetFilterModule, this.context.getGridId())) {
      defaultFloatingFilterType = "agSetColumnFloatingFilter";
    } else {
      const cellDataType = column.getColDef().cellDataType;
      if (cellDataType === "number") {
        defaultFloatingFilterType = "agNumberColumnFloatingFilter";
      } else if (cellDataType === "date" || cellDataType === "dateString") {
        defaultFloatingFilterType = "agDateColumnFloatingFilter";
      } else {
        defaultFloatingFilterType = "agTextColumnFloatingFilter";
      }
    }
    return defaultFloatingFilterType;
  }
  createFilterInstance(column) {
    const defaultFilter = this.getDefaultFilter(column);
    const colDef = column.getColDef();
    let filterInstance;
    const params = Object.assign(Object.assign({}, this.createFilterParams(column, colDef)), { filterModifiedCallback: () => {
      const event = {
        type: Events.EVENT_FILTER_MODIFIED,
        column,
        filterInstance
      };
      this.eventService.dispatchEvent(event);
    }, filterChangedCallback: (additionalEventAttributes) => {
      const params2 = { filterInstance, additionalEventAttributes, columns: [column] };
      this.callOnFilterChangedOutsideRenderCycle(params2);
    }, doesRowPassOtherFilter: (node) => this.doesRowPassOtherFilters(filterInstance, node) });
    const compDetails = this.userComponentFactory.getFilterDetails(colDef, params, defaultFilter);
    if (!compDetails) {
      return { filterPromise: null, compDetails: null };
    }
    return {
      filterPromise: () => {
        const filterPromise = compDetails.newAgStackInstance();
        if (filterPromise) {
          filterPromise.then((r) => filterInstance = r);
        }
        return filterPromise;
      },
      compDetails
    };
  }
  createFilterParams(column, colDef) {
    const params = {
      column,
      colDef: cloneObject(colDef),
      rowModel: this.rowModel,
      filterChangedCallback: () => {
      },
      filterModifiedCallback: () => {
      },
      valueGetter: this.createValueGetter(column),
      doesRowPassOtherFilter: () => true,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    };
    return params;
  }
  createFilterWrapper(column, source) {
    var _a;
    const filterWrapper = {
      column,
      filterPromise: null,
      compiledElement: null,
      guiPromise: AgPromise.resolve(null),
      compDetails: null
    };
    const { filterPromise, compDetails } = this.createFilterInstance(column);
    filterWrapper.filterPromise = (_a = filterPromise === null || filterPromise === void 0 ? void 0 : filterPromise()) !== null && _a !== void 0 ? _a : null;
    filterWrapper.compDetails = compDetails;
    if (filterPromise) {
      this.putIntoGui(filterWrapper, source);
    }
    return filterWrapper;
  }
  putIntoGui(filterWrapper, source) {
    const eFilterGui = document.createElement("div");
    eFilterGui.className = "ag-filter";
    filterWrapper.guiPromise = new AgPromise((resolve) => {
      filterWrapper.filterPromise.then((filter) => {
        let guiFromFilter = filter.getGui();
        if (!exists(guiFromFilter)) {
          console.warn(`AG Grid: getGui method from filter returned ${guiFromFilter}, it should be a DOM element or an HTML template string.`);
        }
        if (typeof guiFromFilter === "string") {
          guiFromFilter = loadTemplate(guiFromFilter);
        }
        eFilterGui.appendChild(guiFromFilter);
        resolve(eFilterGui);
        const event = {
          type: Events.EVENT_FILTER_OPENED,
          column: filterWrapper.column,
          source,
          eGui: eFilterGui
        };
        this.eventService.dispatchEvent(event);
      });
    });
  }
  onColumnsChanged() {
    const columns = [];
    this.allColumnFilters.forEach((wrapper, colId) => {
      let currentColumn;
      if (wrapper.column.isPrimary()) {
        currentColumn = this.columnModel.getPrimaryColumn(colId);
      } else {
        currentColumn = this.columnModel.getGridColumn(colId);
      }
      if (currentColumn) {
        return;
      }
      columns.push(wrapper.column);
      this.disposeFilterWrapper(wrapper, "columnChanged");
      this.disposeColumnListener(colId);
    });
    if (columns.length > 0) {
      this.onFilterChanged({ columns });
    } else {
      this.updateDependantFilters();
    }
  }
  updateDependantFilters() {
    const groupColumns = this.columnModel.getGroupAutoColumns();
    groupColumns === null || groupColumns === void 0 ? void 0 : groupColumns.forEach((groupColumn) => {
      if (groupColumn.getColDef().filter === "agGroupColumnFilter") {
        this.getOrCreateFilterWrapper(groupColumn, "NO_UI");
      }
    });
  }
  isFilterAllowed(column) {
    var _a, _b;
    const isFilterAllowed = column.isFilterAllowed();
    if (!isFilterAllowed) {
      return false;
    }
    const filterWrapper = this.allColumnFilters.get(column.getColId());
    return (_b = (_a = filterWrapper === null || filterWrapper === void 0 ? void 0 : filterWrapper.filterPromise) === null || _a === void 0 ? void 0 : _a.resolveNow(
      true,
      (filter) => {
        var _a2, _b2;
        return typeof ((_a2 = filter) === null || _a2 === void 0 ? void 0 : _a2.isFilterAllowed) === "function" ? (_b2 = filter) === null || _b2 === void 0 ? void 0 : _b2.isFilterAllowed() : true;
      }
    )) !== null && _b !== void 0 ? _b : true;
  }
  getFloatingFilterCompDetails(column, showParentFilter) {
    const colDef = column.getColDef();
    const filterParams = this.createFilterParams(column, colDef);
    const finalFilterParams = this.userComponentFactory.mergeParamsWithApplicationProvidedParams(colDef, FilterComponent, filterParams);
    let defaultFloatingFilterType = this.userComponentFactory.getDefaultFloatingFilterType(colDef, () => this.getDefaultFloatingFilter(column));
    if (defaultFloatingFilterType == null) {
      defaultFloatingFilterType = "agReadOnlyFloatingFilter";
    }
    const parentFilterInstance = (callback) => {
      const filterComponent = this.getFilterComponent(column, "NO_UI");
      if (filterComponent == null) {
        return;
      }
      filterComponent.then((instance) => {
        callback(unwrapUserComp(instance));
      });
    };
    const params = {
      column,
      filterParams: finalFilterParams,
      currentParentModel: () => this.getCurrentFloatingFilterParentModel(column),
      parentFilterInstance,
      showParentFilter,
      suppressFilterButton: false
    };
    return this.userComponentFactory.getFloatingFilterCompDetails(colDef, params, defaultFloatingFilterType);
  }
  getCurrentFloatingFilterParentModel(column) {
    const filterComponent = this.getFilterComponent(column, "NO_UI", false);
    return filterComponent ? filterComponent.resolveNow(null, (filter) => filter && filter.getModel()) : null;
  }
  destroyFilter(column, source = "api") {
    const colId = column.getColId();
    const filterWrapper = this.allColumnFilters.get(colId);
    this.disposeColumnListener(colId);
    if (filterWrapper) {
      this.disposeFilterWrapper(filterWrapper, source);
      this.onFilterChanged({ columns: [column] });
    }
  }
  disposeColumnListener(colId) {
    const columnListener = this.allColumnListeners.get(colId);
    if (columnListener) {
      this.allColumnListeners.delete(colId);
      columnListener();
    }
  }
  disposeFilterWrapper(filterWrapper, source) {
    filterWrapper.filterPromise.then((filter) => {
      (filter.setModel(null) || AgPromise.resolve()).then(() => {
        this.getContext().destroyBean(filter);
        filterWrapper.column.setFilterActive(false, "filterDestroyed");
        this.allColumnFilters.delete(filterWrapper.column.getColId());
        const event = {
          type: Events.EVENT_FILTER_DESTROYED,
          source,
          column: filterWrapper.column
        };
        this.eventService.dispatchEvent(event);
      });
    });
  }
  checkDestroyFilter(colId) {
    var _a;
    const filterWrapper = this.allColumnFilters.get(colId);
    if (!filterWrapper) {
      return;
    }
    const column = filterWrapper.column;
    const { compDetails } = column.isFilterAllowed() ? this.createFilterInstance(column) : { compDetails: null };
    if (!compDetails || ((_a = filterWrapper.compDetails) === null || _a === void 0 ? void 0 : _a.componentClass) !== compDetails.componentClass) {
      this.destroyFilter(column, "columnChanged");
    }
  }
  destroy() {
    super.destroy();
    this.allColumnFilters.forEach((filterWrapper) => this.disposeFilterWrapper(filterWrapper, "gridDestroyed"));
    this.allColumnListeners.clear();
  }
};
FilterManager.QUICK_FILTER_SEPARATOR = "\n";
__decorate$1U([
  Autowired("valueService")
], FilterManager.prototype, "valueService", void 0);
__decorate$1U([
  Autowired("columnModel")
], FilterManager.prototype, "columnModel", void 0);
__decorate$1U([
  Autowired("rowModel")
], FilterManager.prototype, "rowModel", void 0);
__decorate$1U([
  Autowired("userComponentFactory")
], FilterManager.prototype, "userComponentFactory", void 0);
__decorate$1U([
  Autowired("rowRenderer")
], FilterManager.prototype, "rowRenderer", void 0);
__decorate$1U([
  PostConstruct
], FilterManager.prototype, "init", null);
FilterManager = FilterManager_1 = __decorate$1U([
  Bean("filterManager")
], FilterManager);
var AbstractHeaderCellComp = class extends Component {
  constructor(template, ctrl) {
    super(template);
    this.ctrl = ctrl;
  }
  getCtrl() {
    return this.ctrl;
  }
};
var __decorate$1T = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HeaderFilterCellComp = class extends AbstractHeaderCellComp {
  constructor(ctrl) {
    super(HeaderFilterCellComp.TEMPLATE, ctrl);
  }
  postConstruct() {
    const eGui = this.getGui();
    const compProxy = {
      addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
      addOrRemoveBodyCssClass: (cssClassName, on) => this.eFloatingFilterBody.classList.toggle(cssClassName, on),
      setButtonWrapperDisplayed: (displayed) => setDisplayed(this.eButtonWrapper, displayed),
      setCompDetails: (compDetails) => this.setCompDetails(compDetails),
      getFloatingFilterComp: () => this.compPromise,
      setWidth: (width) => eGui.style.width = width,
      setMenuIcon: (eIcon) => this.eButtonShowMainFilter.appendChild(eIcon)
    };
    this.ctrl.setComp(compProxy, eGui, this.eButtonShowMainFilter, this.eFloatingFilterBody);
  }
  setCompDetails(compDetails) {
    if (!compDetails) {
      this.destroyFloatingFilterComp();
      this.compPromise = null;
      return;
    }
    this.compPromise = compDetails.newAgStackInstance();
    this.compPromise.then((comp) => this.afterCompCreated(comp));
  }
  destroyFloatingFilterComp() {
    if (this.floatingFilterComp) {
      this.eFloatingFilterBody.removeChild(this.floatingFilterComp.getGui());
      this.floatingFilterComp = this.destroyBean(this.floatingFilterComp);
    }
  }
  afterCompCreated(comp) {
    if (!comp) {
      return;
    }
    if (!this.isAlive()) {
      this.destroyBean(comp);
      return;
    }
    this.destroyFloatingFilterComp();
    this.floatingFilterComp = comp;
    this.eFloatingFilterBody.appendChild(comp.getGui());
    if (comp.afterGuiAttached) {
      comp.afterGuiAttached();
    }
  }
};
HeaderFilterCellComp.TEMPLATE = `<div class="ag-header-cell ag-floating-filter" role="gridcell" tabindex="-1">
            <div ref="eFloatingFilterBody" role="presentation"></div>
            <div class="ag-floating-filter-button ag-hidden" ref="eButtonWrapper" role="presentation">
                <button type="button" class="ag-button ag-floating-filter-button-button" ref="eButtonShowMainFilter" tabindex="-1"></button>
            </div>
        </div>`;
__decorate$1T([
  RefSelector("eFloatingFilterBody")
], HeaderFilterCellComp.prototype, "eFloatingFilterBody", void 0);
__decorate$1T([
  RefSelector("eButtonWrapper")
], HeaderFilterCellComp.prototype, "eButtonWrapper", void 0);
__decorate$1T([
  RefSelector("eButtonShowMainFilter")
], HeaderFilterCellComp.prototype, "eButtonShowMainFilter", void 0);
__decorate$1T([
  PostConstruct
], HeaderFilterCellComp.prototype, "postConstruct", null);
__decorate$1T([
  PreDestroy
], HeaderFilterCellComp.prototype, "destroyFloatingFilterComp", null);
var __decorate$1S = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LayoutCssClasses;
(function(LayoutCssClasses2) {
  LayoutCssClasses2["AUTO_HEIGHT"] = "ag-layout-auto-height";
  LayoutCssClasses2["NORMAL"] = "ag-layout-normal";
  LayoutCssClasses2["PRINT"] = "ag-layout-print";
})(LayoutCssClasses || (LayoutCssClasses = {}));
var LayoutFeature = class extends BeanStub {
  constructor(view) {
    super();
    this.view = view;
  }
  postConstruct() {
    this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this));
    this.updateLayoutClasses();
  }
  updateLayoutClasses() {
    const domLayout = this.getDomLayout();
    const params = {
      autoHeight: domLayout === "autoHeight",
      normal: domLayout === "normal",
      print: domLayout === "print"
    };
    const cssClass = params.autoHeight ? LayoutCssClasses.AUTO_HEIGHT : params.print ? LayoutCssClasses.PRINT : LayoutCssClasses.NORMAL;
    this.view.updateLayoutClasses(cssClass, params);
  }
  getDomLayout() {
    var _a;
    const domLayout = (_a = this.gridOptionsService.get("domLayout")) !== null && _a !== void 0 ? _a : "normal";
    const validLayouts = ["normal", "print", "autoHeight"];
    if (validLayouts.indexOf(domLayout) === -1) {
      doOnce(() => console.warn(`AG Grid: ${domLayout} is not valid for DOM Layout, valid values are 'normal', 'autoHeight', 'print'.`), "warn about dom layout values");
      return "normal";
    }
    return domLayout;
  }
};
__decorate$1S([
  PostConstruct
], LayoutFeature.prototype, "postConstruct", null);
var __decorate$1R = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GridBodyScrollFeature = class extends BeanStub {
  constructor(eBodyViewport) {
    super();
    this.scrollLeft = -1;
    this.nextScrollTop = -1;
    this.scrollTop = -1;
    this.eBodyViewport = eBodyViewport;
    this.resetLastHScrollDebounced = debounce(() => this.eLastHScroll = null, 500);
    this.resetLastVScrollDebounced = debounce(() => this.eLastVScroll = null, 500);
  }
  postConstruct() {
    this.enableRtl = this.gridOptionsService.is("enableRtl");
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));
    this.ctrlsService.whenReady((p) => {
      this.centerRowContainerCtrl = p.centerRowContainerCtrl;
      this.onDisplayedColumnsWidthChanged();
      this.addScrollListener();
    });
  }
  addScrollListener() {
    const fakeHScroll = this.ctrlsService.getFakeHScrollComp();
    const fakeVScroll = this.ctrlsService.getFakeVScrollComp();
    this.addManagedListener(this.centerRowContainerCtrl.getViewportElement(), "scroll", this.onHScroll.bind(this));
    this.addManagedListener(fakeHScroll.getViewport(), "scroll", this.onFakeHScroll.bind(this));
    const isDebounce = this.gridOptionsService.is("debounceVerticalScrollbar");
    const onVScroll = isDebounce ? debounce(this.onVScroll.bind(this), 100) : this.onVScroll.bind(this);
    const onFakeVScroll = isDebounce ? debounce(this.onFakeVScroll.bind(this), 100) : this.onFakeVScroll.bind(this);
    this.addManagedListener(this.eBodyViewport, "scroll", onVScroll);
    this.addManagedListener(fakeVScroll.getViewport(), "scroll", onFakeVScroll);
  }
  onDisplayedColumnsWidthChanged() {
    if (this.enableRtl) {
      this.horizontallyScrollHeaderCenterAndFloatingCenter();
    }
  }
  horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft) {
    const notYetInitialised = this.centerRowContainerCtrl == null;
    if (notYetInitialised) {
      return;
    }
    if (scrollLeft === void 0) {
      scrollLeft = this.centerRowContainerCtrl.getCenterViewportScrollLeft();
    }
    const offset = this.enableRtl ? scrollLeft : -scrollLeft;
    const topCenterContainer = this.ctrlsService.getTopCenterRowContainerCtrl();
    const stickyTopCenterContainer = this.ctrlsService.getStickyTopCenterRowContainerCtrl();
    const bottomCenterContainer = this.ctrlsService.getBottomCenterRowContainerCtrl();
    const fakeHScroll = this.ctrlsService.getFakeHScrollComp();
    const centerHeaderContainer = this.ctrlsService.getHeaderRowContainerCtrl();
    centerHeaderContainer.setHorizontalScroll(-offset);
    bottomCenterContainer.setContainerTranslateX(offset);
    topCenterContainer.setContainerTranslateX(offset);
    stickyTopCenterContainer.setContainerTranslateX(offset);
    const centerViewport = this.centerRowContainerCtrl.getViewportElement();
    const isCenterViewportLastHorizontal = this.eLastHScroll === centerViewport;
    const partner = isCenterViewportLastHorizontal ? fakeHScroll.getViewport() : this.centerRowContainerCtrl.getViewportElement();
    setScrollLeft(partner, Math.abs(scrollLeft), this.enableRtl);
  }
  isControllingHScroll(eDiv) {
    if (!this.eLastHScroll) {
      this.eLastHScroll = eDiv;
      return true;
    }
    return eDiv === this.eLastHScroll;
  }
  isControllingVScroll(eDiv) {
    if (!this.eLastVScroll) {
      this.eLastVScroll = eDiv;
      return true;
    }
    return eDiv === this.eLastVScroll;
  }
  onFakeHScroll() {
    const fakeHScrollViewport = this.ctrlsService.getFakeHScrollComp().getViewport();
    if (!this.isControllingHScroll(fakeHScrollViewport)) {
      return;
    }
    this.onHScrollCommon(fakeHScrollViewport);
  }
  onHScroll() {
    const centerContainerViewport = this.centerRowContainerCtrl.getViewportElement();
    if (!this.isControllingHScroll(centerContainerViewport)) {
      return;
    }
    this.onHScrollCommon(centerContainerViewport);
  }
  onHScrollCommon(eSource) {
    const centerContainerViewport = this.centerRowContainerCtrl.getViewportElement();
    const { scrollLeft } = centerContainerViewport;
    if (this.shouldBlockScrollUpdate("horizontal", scrollLeft, true)) {
      return;
    }
    this.doHorizontalScroll(Math.round(getScrollLeft(eSource, this.enableRtl)));
    this.resetLastHScrollDebounced();
  }
  onFakeVScroll() {
    const fakeVScrollViewport = this.ctrlsService.getFakeVScrollComp().getViewport();
    if (!this.isControllingVScroll(fakeVScrollViewport)) {
      return;
    }
    this.onVScrollCommon(fakeVScrollViewport);
  }
  onVScroll() {
    if (!this.isControllingVScroll(this.eBodyViewport)) {
      return;
    }
    this.onVScrollCommon(this.eBodyViewport);
  }
  onVScrollCommon(eSource) {
    const scrollTop = eSource.scrollTop;
    if (this.shouldBlockScrollUpdate("vertical", scrollTop, true)) {
      return;
    }
    this.animationFrameService.setScrollTop(scrollTop);
    this.nextScrollTop = scrollTop;
    if (eSource === this.eBodyViewport) {
      const fakeVScrollViewport = this.ctrlsService.getFakeVScrollComp().getViewport();
      fakeVScrollViewport.scrollTop = scrollTop;
    } else {
      this.eBodyViewport.scrollTop = scrollTop;
    }
    if (this.gridOptionsService.is("suppressAnimationFrame")) {
      this.scrollGridIfNeeded();
    } else {
      this.animationFrameService.schedule();
    }
    this.resetLastVScrollDebounced();
  }
  doHorizontalScroll(scrollLeft) {
    const fakeHScrollViewport = this.ctrlsService.getFakeHScrollComp().getViewport();
    const fakeScrollLeft = getScrollLeft(fakeHScrollViewport, this.enableRtl);
    if (this.scrollLeft === scrollLeft && scrollLeft === fakeScrollLeft) {
      return;
    }
    this.scrollLeft = scrollLeft;
    this.fireScrollEvent("horizontal");
    this.horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft);
    this.onHorizontalViewportChanged();
  }
  fireScrollEvent(direction) {
    const bodyScrollEvent = {
      type: Events.EVENT_BODY_SCROLL,
      direction,
      left: this.scrollLeft,
      top: this.scrollTop
    };
    this.eventService.dispatchEvent(bodyScrollEvent);
    window.clearTimeout(this.scrollTimer);
    this.scrollTimer = void 0;
    this.scrollTimer = window.setTimeout(() => {
      const bodyScrollEndEvent = Object.assign(Object.assign({}, bodyScrollEvent), { type: Events.EVENT_BODY_SCROLL_END });
      this.eventService.dispatchEvent(bodyScrollEndEvent);
    }, 100);
  }
  shouldBlockScrollUpdate(direction, scrollTo, touchOnly = false) {
    if (touchOnly && !isIOSUserAgent()) {
      return false;
    }
    if (direction === "vertical") {
      return this.shouldBlockVerticalScroll(scrollTo);
    }
    return this.shouldBlockHorizontalScroll(scrollTo);
  }
  shouldBlockVerticalScroll(scrollTo) {
    const clientHeight = getInnerHeight(this.eBodyViewport);
    const { scrollHeight } = this.eBodyViewport;
    if (scrollTo < 0 || scrollTo + clientHeight > scrollHeight) {
      return true;
    }
    return false;
  }
  shouldBlockHorizontalScroll(scrollTo) {
    const clientWidth = this.centerRowContainerCtrl.getCenterWidth();
    const { scrollWidth } = this.centerRowContainerCtrl.getViewportElement();
    if (this.enableRtl && isRtlNegativeScroll()) {
      if (scrollTo > 0) {
        return true;
      }
    } else if (scrollTo < 0) {
      return true;
    }
    if (Math.abs(scrollTo) + clientWidth > scrollWidth) {
      return true;
    }
    return false;
  }
  redrawRowsAfterScroll() {
    this.fireScrollEvent("vertical");
  }
  onHorizontalViewportChanged() {
    this.centerRowContainerCtrl.onHorizontalViewportChanged();
  }
  checkScrollLeft() {
    if (this.scrollLeft !== this.centerRowContainerCtrl.getCenterViewportScrollLeft()) {
      this.onHScrollCommon(this.centerRowContainerCtrl.getViewportElement());
    }
  }
  scrollGridIfNeeded() {
    const frameNeeded = this.scrollTop != this.nextScrollTop;
    if (frameNeeded) {
      this.scrollTop = this.nextScrollTop;
      this.redrawRowsAfterScroll();
    }
    return frameNeeded;
  }
  setHorizontalScrollPosition(hScrollPosition) {
    this.ctrlsService.getFakeHScrollComp().getGui();
    const minScrollLeft = 0;
    const maxScrollLeft = this.centerRowContainerCtrl.getViewportElement().scrollWidth - this.centerRowContainerCtrl.getCenterWidth();
    if (this.shouldBlockScrollUpdate("horizontal", hScrollPosition)) {
      if (this.enableRtl && isRtlNegativeScroll()) {
        hScrollPosition = hScrollPosition > 0 ? 0 : maxScrollLeft;
      } else {
        hScrollPosition = Math.min(Math.max(hScrollPosition, minScrollLeft), maxScrollLeft);
      }
    }
    setScrollLeft(this.centerRowContainerCtrl.getViewportElement(), Math.abs(hScrollPosition), this.enableRtl);
    this.doHorizontalScroll(hScrollPosition);
  }
  setVerticalScrollPosition(vScrollPosition) {
    this.eBodyViewport.scrollTop = vScrollPosition;
  }
  getVScrollPosition() {
    const result = {
      top: this.eBodyViewport.scrollTop,
      bottom: this.eBodyViewport.scrollTop + this.eBodyViewport.offsetHeight
    };
    return result;
  }
  getHScrollPosition() {
    return this.centerRowContainerCtrl.getHScrollPosition();
  }
  isHorizontalScrollShowing() {
    return this.centerRowContainerCtrl.isHorizontalScrollShowing();
  }
  scrollHorizontally(pixels) {
    const oldScrollPosition = this.centerRowContainerCtrl.getViewportElement().scrollLeft;
    this.setHorizontalScrollPosition(oldScrollPosition + pixels);
    return this.centerRowContainerCtrl.getViewportElement().scrollLeft - oldScrollPosition;
  }
  scrollToTop() {
    this.eBodyViewport.scrollTop = 0;
  }
  ensureNodeVisible(comparator, position = null) {
    const rowCount = this.rowModel.getRowCount();
    let indexToSelect = -1;
    for (let i = 0; i < rowCount; i++) {
      const node = this.rowModel.getRow(i);
      if (typeof comparator === "function") {
        const predicate = comparator;
        if (node && predicate(node)) {
          indexToSelect = i;
          break;
        }
      } else {
        if (comparator === node || comparator === node.data) {
          indexToSelect = i;
          break;
        }
      }
    }
    if (indexToSelect >= 0) {
      this.ensureIndexVisible(indexToSelect, position);
    }
  }
  ensureIndexVisible(index, position) {
    if (this.gridOptionsService.isDomLayout("print")) {
      return;
    }
    const rowCount = this.paginationProxy.getRowCount();
    if (typeof index !== "number" || index < 0 || index >= rowCount) {
      console.warn("AG Grid: Invalid row index for ensureIndexVisible: " + index);
      return;
    }
    const isPaging = this.gridOptionsService.is("pagination");
    const paginationPanelEnabled = isPaging && !this.gridOptionsService.is("suppressPaginationPanel");
    if (!paginationPanelEnabled) {
      this.paginationProxy.goToPageWithIndex(index);
    }
    const gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
    const stickyTopHeight = gridBodyCtrl.getStickyTopHeight();
    const rowNode = this.paginationProxy.getRow(index);
    let rowGotShiftedDuringOperation;
    do {
      const startingRowTop = rowNode.rowTop;
      const startingRowHeight = rowNode.rowHeight;
      const paginationOffset = this.paginationProxy.getPixelOffset();
      const rowTopPixel = rowNode.rowTop - paginationOffset;
      const rowBottomPixel = rowTopPixel + rowNode.rowHeight;
      const scrollPosition = this.getVScrollPosition();
      const heightOffset = this.heightScaler.getDivStretchOffset();
      const vScrollTop = scrollPosition.top + heightOffset;
      const vScrollBottom = scrollPosition.bottom + heightOffset;
      const viewportHeight = vScrollBottom - vScrollTop;
      const pxTop = this.heightScaler.getScrollPositionForPixel(rowTopPixel);
      const pxBottom = this.heightScaler.getScrollPositionForPixel(rowBottomPixel - viewportHeight);
      const pxMiddle = Math.min((pxTop + pxBottom) / 2, rowTopPixel);
      const rowAboveViewport = vScrollTop + stickyTopHeight > rowTopPixel;
      const rowBelowViewport = vScrollBottom < rowBottomPixel;
      let newScrollPosition = null;
      if (position === "top") {
        newScrollPosition = pxTop;
      } else if (position === "bottom") {
        newScrollPosition = pxBottom;
      } else if (position === "middle") {
        newScrollPosition = pxMiddle;
      } else if (rowAboveViewport) {
        newScrollPosition = pxTop - stickyTopHeight;
      } else if (rowBelowViewport) {
        newScrollPosition = pxBottom;
      }
      if (newScrollPosition !== null) {
        this.setVerticalScrollPosition(newScrollPosition);
        this.rowRenderer.redrawAfterScroll();
      }
      rowGotShiftedDuringOperation = startingRowTop !== rowNode.rowTop || startingRowHeight !== rowNode.rowHeight;
    } while (rowGotShiftedDuringOperation);
    this.animationFrameService.flushAllFrames();
  }
  ensureColumnVisible(key, position = "auto") {
    const column = this.columnModel.getGridColumn(key);
    if (!column) {
      return;
    }
    if (column.isPinned()) {
      return;
    }
    if (!this.columnModel.isColumnDisplayed(column)) {
      return;
    }
    const newHorizontalScroll = this.getPositionedHorizontalScroll(column, position);
    if (newHorizontalScroll !== null) {
      this.centerRowContainerCtrl.setCenterViewportScrollLeft(newHorizontalScroll);
    }
    this.centerRowContainerCtrl.onHorizontalViewportChanged();
    this.animationFrameService.flushAllFrames();
  }
  getPositionedHorizontalScroll(column, position) {
    const { columnBeforeStart, columnAfterEnd } = this.isColumnOutsideViewport(column);
    const viewportTooSmallForColumn = this.centerRowContainerCtrl.getCenterWidth() < column.getActualWidth();
    const viewportWidth = this.centerRowContainerCtrl.getCenterWidth();
    const isRtl = this.enableRtl;
    let alignColToStart = (isRtl ? columnBeforeStart : columnAfterEnd) || viewportTooSmallForColumn;
    let alignColToEnd = isRtl ? columnAfterEnd : columnBeforeStart;
    if (position !== "auto") {
      alignColToStart = position === "start";
      alignColToEnd = position === "end";
    }
    const isMiddle = position === "middle";
    if (alignColToStart || alignColToEnd || isMiddle) {
      const { colLeft, colMiddle, colRight } = this.getColumnBounds(column);
      if (isMiddle) {
        return colMiddle - viewportWidth / 2;
      }
      if (alignColToStart) {
        return isRtl ? colRight : colLeft;
      }
      return isRtl ? colLeft - viewportWidth : colRight - viewportWidth;
    }
    return null;
  }
  isColumnOutsideViewport(column) {
    const { start: viewportStart, end: viewportEnd } = this.getViewportBounds();
    const { colLeft, colRight } = this.getColumnBounds(column);
    const isRtl = this.enableRtl;
    const columnBeforeStart = isRtl ? viewportStart > colRight : viewportEnd < colRight;
    const columnAfterEnd = isRtl ? viewportEnd < colLeft : viewportStart > colLeft;
    return { columnBeforeStart, columnAfterEnd };
  }
  getColumnBounds(column) {
    const isRtl = this.enableRtl;
    const bodyWidth = this.columnModel.getBodyContainerWidth();
    const colWidth = column.getActualWidth();
    const colLeft = column.getLeft();
    const multiplier = isRtl ? -1 : 1;
    const colLeftPixel = isRtl ? bodyWidth - colLeft : colLeft;
    const colRightPixel = colLeftPixel + colWidth * multiplier;
    const colMidPixel = colLeftPixel + colWidth / 2 * multiplier;
    return { colLeft: colLeftPixel, colMiddle: colMidPixel, colRight: colRightPixel };
  }
  getViewportBounds() {
    const viewportWidth = this.centerRowContainerCtrl.getCenterWidth();
    const scrollPosition = this.centerRowContainerCtrl.getCenterViewportScrollLeft();
    const viewportStartPixel = scrollPosition;
    const viewportEndPixel = viewportWidth + scrollPosition;
    return { start: viewportStartPixel, end: viewportEndPixel, width: viewportWidth };
  }
};
__decorate$1R([
  Autowired("ctrlsService")
], GridBodyScrollFeature.prototype, "ctrlsService", void 0);
__decorate$1R([
  Autowired("animationFrameService")
], GridBodyScrollFeature.prototype, "animationFrameService", void 0);
__decorate$1R([
  Autowired("paginationProxy")
], GridBodyScrollFeature.prototype, "paginationProxy", void 0);
__decorate$1R([
  Autowired("rowModel")
], GridBodyScrollFeature.prototype, "rowModel", void 0);
__decorate$1R([
  Autowired("rowContainerHeightService")
], GridBodyScrollFeature.prototype, "heightScaler", void 0);
__decorate$1R([
  Autowired("rowRenderer")
], GridBodyScrollFeature.prototype, "rowRenderer", void 0);
__decorate$1R([
  Autowired("columnModel")
], GridBodyScrollFeature.prototype, "columnModel", void 0);
__decorate$1R([
  PostConstruct
], GridBodyScrollFeature.prototype, "postConstruct", null);
var AutoScrollService = class {
  constructor(params) {
    this.tickingInterval = null;
    this.onScrollCallback = null;
    this.scrollContainer = params.scrollContainer;
    this.scrollHorizontally = params.scrollAxis.indexOf("x") !== -1;
    this.scrollVertically = params.scrollAxis.indexOf("y") !== -1;
    this.scrollByTick = params.scrollByTick != null ? params.scrollByTick : 20;
    if (params.onScrollCallback) {
      this.onScrollCallback = params.onScrollCallback;
    }
    if (this.scrollVertically) {
      this.getVerticalPosition = params.getVerticalPosition;
      this.setVerticalPosition = params.setVerticalPosition;
    }
    if (this.scrollHorizontally) {
      this.getHorizontalPosition = params.getHorizontalPosition;
      this.setHorizontalPosition = params.setHorizontalPosition;
    }
    this.shouldSkipVerticalScroll = params.shouldSkipVerticalScroll || (() => false);
    this.shouldSkipHorizontalScroll = params.shouldSkipHorizontalScroll || (() => false);
  }
  check(mouseEvent, forceSkipVerticalScroll = false) {
    const skipVerticalScroll = forceSkipVerticalScroll || this.shouldSkipVerticalScroll();
    if (skipVerticalScroll && this.shouldSkipHorizontalScroll()) {
      return;
    }
    const rect = this.scrollContainer.getBoundingClientRect();
    const scrollTick = this.scrollByTick;
    this.tickLeft = mouseEvent.clientX < rect.left + scrollTick;
    this.tickRight = mouseEvent.clientX > rect.right - scrollTick;
    this.tickUp = mouseEvent.clientY < rect.top + scrollTick && !skipVerticalScroll;
    this.tickDown = mouseEvent.clientY > rect.bottom - scrollTick && !skipVerticalScroll;
    if (this.tickLeft || this.tickRight || this.tickUp || this.tickDown) {
      this.ensureTickingStarted();
    } else {
      this.ensureCleared();
    }
  }
  ensureTickingStarted() {
    if (this.tickingInterval === null) {
      this.tickingInterval = window.setInterval(this.doTick.bind(this), 100);
      this.tickCount = 0;
    }
  }
  doTick() {
    this.tickCount++;
    let tickAmount;
    tickAmount = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40;
    if (this.scrollVertically) {
      const vScrollPosition = this.getVerticalPosition();
      if (this.tickUp) {
        this.setVerticalPosition(vScrollPosition - tickAmount);
      }
      if (this.tickDown) {
        this.setVerticalPosition(vScrollPosition + tickAmount);
      }
    }
    if (this.scrollHorizontally) {
      const hScrollPosition = this.getHorizontalPosition();
      if (this.tickLeft) {
        this.setHorizontalPosition(hScrollPosition - tickAmount);
      }
      if (this.tickRight) {
        this.setHorizontalPosition(hScrollPosition + tickAmount);
      }
    }
    if (this.onScrollCallback) {
      this.onScrollCallback();
    }
  }
  ensureCleared() {
    if (this.tickingInterval) {
      window.clearInterval(this.tickingInterval);
      this.tickingInterval = null;
    }
  }
};
var __decorate$1Q = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RowDragFeature = class extends BeanStub {
  constructor(eContainer) {
    super();
    this.isMultiRowDrag = false;
    this.isGridSorted = false;
    this.isGridFiltered = false;
    this.isRowGroupActive = false;
    this.eContainer = eContainer;
  }
  postConstruct() {
    if (this.gridOptionsService.isRowModelType("clientSide")) {
      this.clientSideRowModel = this.rowModel;
    }
    const refreshStatus = () => {
      this.onSortChanged();
      this.onFilterChanged();
      this.onRowGroupChanged();
    };
    this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onRowGroupChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, () => {
      refreshStatus();
    });
    refreshStatus();
    this.ctrlsService.whenReady(() => {
      const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
      this.autoScrollService = new AutoScrollService({
        scrollContainer: gridBodyCon.getBodyViewportElement(),
        scrollAxis: "y",
        getVerticalPosition: () => gridBodyCon.getScrollFeature().getVScrollPosition().top,
        setVerticalPosition: (position) => gridBodyCon.getScrollFeature().setVerticalScrollPosition(position),
        onScrollCallback: () => {
          this.onDragging(this.lastDraggingEvent);
        }
      });
    });
  }
  onSortChanged() {
    this.isGridSorted = this.sortController.isSortActive();
  }
  onFilterChanged() {
    this.isGridFiltered = this.filterManager.isAnyFilterPresent();
  }
  onRowGroupChanged() {
    const rowGroups = this.columnModel.getRowGroupColumns();
    this.isRowGroupActive = !missingOrEmpty(rowGroups);
  }
  getContainer() {
    return this.eContainer;
  }
  isInterestedIn(type) {
    return type === DragSourceType.RowDrag;
  }
  getIconName() {
    const managedDrag = this.gridOptionsService.is("rowDragManaged");
    if (managedDrag && this.shouldPreventRowMove()) {
      return DragAndDropService.ICON_NOT_ALLOWED;
    }
    return DragAndDropService.ICON_MOVE;
  }
  shouldPreventRowMove() {
    return this.isGridSorted || this.isGridFiltered || this.isRowGroupActive;
  }
  getRowNodes(draggingEvent) {
    if (!this.isFromThisGrid(draggingEvent)) {
      return draggingEvent.dragItem.rowNodes || [];
    }
    const isRowDragMultiRow = this.gridOptionsService.is("rowDragMultiRow");
    const selectedNodes = [...this.selectionService.getSelectedNodes()].sort((a, b) => {
      if (a.rowIndex == null || b.rowIndex == null) {
        return 0;
      }
      return this.getRowIndexNumber(a) - this.getRowIndexNumber(b);
    });
    const currentNode = draggingEvent.dragItem.rowNode;
    if (isRowDragMultiRow && selectedNodes.indexOf(currentNode) !== -1) {
      this.isMultiRowDrag = true;
      return selectedNodes;
    }
    this.isMultiRowDrag = false;
    return [currentNode];
  }
  onDragEnter(draggingEvent) {
    draggingEvent.dragItem.rowNodes = this.getRowNodes(draggingEvent);
    this.dispatchGridEvent(Events.EVENT_ROW_DRAG_ENTER, draggingEvent);
    this.getRowNodes(draggingEvent).forEach((rowNode) => {
      rowNode.setDragging(true);
    });
    this.onEnterOrDragging(draggingEvent);
  }
  onDragging(draggingEvent) {
    this.onEnterOrDragging(draggingEvent);
  }
  isFromThisGrid(draggingEvent) {
    const { dragSourceDomDataKey } = draggingEvent.dragSource;
    return dragSourceDomDataKey === this.gridOptionsService.getDomDataKey();
  }
  isDropZoneWithinThisGrid(draggingEvent) {
    const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
    const gridGui = gridBodyCon.getGui();
    const { dropZoneTarget } = draggingEvent;
    return !gridGui.contains(dropZoneTarget);
  }
  onEnterOrDragging(draggingEvent) {
    this.dispatchGridEvent(Events.EVENT_ROW_DRAG_MOVE, draggingEvent);
    this.lastDraggingEvent = draggingEvent;
    const pixel = this.mouseEventService.getNormalisedPosition(draggingEvent).y;
    const managedDrag = this.gridOptionsService.is("rowDragManaged");
    if (managedDrag) {
      this.doManagedDrag(draggingEvent, pixel);
    }
    this.autoScrollService.check(draggingEvent.event);
  }
  doManagedDrag(draggingEvent, pixel) {
    const isFromThisGrid = this.isFromThisGrid(draggingEvent);
    const managedDrag = this.gridOptionsService.is("rowDragManaged");
    const rowNodes = draggingEvent.dragItem.rowNodes;
    if (managedDrag && this.shouldPreventRowMove()) {
      return;
    }
    if (this.gridOptionsService.is("suppressMoveWhenRowDragging") || !isFromThisGrid) {
      if (!this.isDropZoneWithinThisGrid(draggingEvent)) {
        this.clientSideRowModel.highlightRowAtPixel(rowNodes[0], pixel);
      }
    } else {
      this.moveRows(rowNodes, pixel);
    }
  }
  getRowIndexNumber(rowNode) {
    return parseInt(last(rowNode.getRowIndexString().split("-")), 10);
  }
  moveRowAndClearHighlight(draggingEvent) {
    const lastHighlightedRowNode = this.clientSideRowModel.getLastHighlightedRowNode();
    const isBelow = lastHighlightedRowNode && lastHighlightedRowNode.highlighted === RowHighlightPosition.Below;
    const pixel = this.mouseEventService.getNormalisedPosition(draggingEvent).y;
    const rowNodes = draggingEvent.dragItem.rowNodes;
    let increment = isBelow ? 1 : 0;
    if (this.isFromThisGrid(draggingEvent)) {
      rowNodes.forEach((rowNode) => {
        if (rowNode.rowTop < pixel) {
          increment -= 1;
        }
      });
      this.moveRows(rowNodes, pixel, increment);
    } else {
      const getRowIdFunc = this.gridOptionsService.getCallback("getRowId");
      let addIndex = this.clientSideRowModel.getRowIndexAtPixel(pixel) + 1;
      if (this.clientSideRowModel.getHighlightPosition(pixel) === RowHighlightPosition.Above) {
        addIndex--;
      }
      this.clientSideRowModel.updateRowData({
        add: rowNodes.map((node) => node.data).filter((data) => !this.clientSideRowModel.getRowNode(getRowIdFunc ? getRowIdFunc({ data, level: 0 }) : data.id)),
        addIndex
      });
    }
    this.clearRowHighlight();
  }
  clearRowHighlight() {
    this.clientSideRowModel.highlightRowAtPixel(null);
  }
  moveRows(rowNodes, pixel, increment = 0) {
    const rowWasMoved = this.clientSideRowModel.ensureRowsAtPixel(rowNodes, pixel, increment);
    if (rowWasMoved) {
      this.focusService.clearFocusedCell();
      if (this.rangeService) {
        this.rangeService.removeAllCellRanges();
      }
    }
  }
  addRowDropZone(params) {
    if (!params.getContainer()) {
      doOnce(() => console.warn("AG Grid: addRowDropZone - A container target needs to be provided"), "add-drop-zone-empty-target");
      return;
    }
    if (this.dragAndDropService.findExternalZone(params)) {
      console.warn("AG Grid: addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.");
      return;
    }
    let processedParams = {
      getContainer: params.getContainer
    };
    if (params.fromGrid) {
      params.fromGrid = void 0;
      processedParams = params;
    } else {
      if (params.onDragEnter) {
        processedParams.onDragEnter = (e) => {
          params.onDragEnter(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_ENTER, e));
        };
      }
      if (params.onDragLeave) {
        processedParams.onDragLeave = (e) => {
          params.onDragLeave(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_LEAVE, e));
        };
      }
      if (params.onDragging) {
        processedParams.onDragging = (e) => {
          params.onDragging(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_MOVE, e));
        };
      }
      if (params.onDragStop) {
        processedParams.onDragStop = (e) => {
          params.onDragStop(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_END, e));
        };
      }
    }
    this.dragAndDropService.addDropTarget(Object.assign({ isInterestedIn: (type) => type === DragSourceType.RowDrag, getIconName: () => DragAndDropService.ICON_MOVE, external: true }, processedParams));
  }
  getRowDropZone(events) {
    const getContainer = this.getContainer.bind(this);
    const onDragEnter = this.onDragEnter.bind(this);
    const onDragLeave = this.onDragLeave.bind(this);
    const onDragging = this.onDragging.bind(this);
    const onDragStop = this.onDragStop.bind(this);
    if (!events) {
      return { getContainer, onDragEnter, onDragLeave, onDragging, onDragStop, fromGrid: true };
    }
    return {
      getContainer,
      onDragEnter: events.onDragEnter ? (e) => {
        onDragEnter(e);
        events.onDragEnter(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_ENTER, e));
      } : onDragEnter,
      onDragLeave: events.onDragLeave ? (e) => {
        onDragLeave(e);
        events.onDragLeave(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_LEAVE, e));
      } : onDragLeave,
      onDragging: events.onDragging ? (e) => {
        onDragging(e);
        events.onDragging(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_MOVE, e));
      } : onDragging,
      onDragStop: events.onDragStop ? (e) => {
        onDragStop(e);
        events.onDragStop(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_END, e));
      } : onDragStop,
      fromGrid: true
    };
  }
  draggingToRowDragEvent(type, draggingEvent) {
    const yNormalised = this.mouseEventService.getNormalisedPosition(draggingEvent).y;
    const mouseIsPastLastRow = yNormalised > this.paginationProxy.getCurrentPageHeight();
    let overIndex = -1;
    let overNode;
    if (!mouseIsPastLastRow) {
      overIndex = this.rowModel.getRowIndexAtPixel(yNormalised);
      overNode = this.rowModel.getRow(overIndex);
    }
    let vDirectionString;
    switch (draggingEvent.vDirection) {
      case VerticalDirection.Down:
        vDirectionString = "down";
        break;
      case VerticalDirection.Up:
        vDirectionString = "up";
        break;
      default:
        vDirectionString = null;
        break;
    }
    const event = {
      type,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context,
      event: draggingEvent.event,
      node: draggingEvent.dragItem.rowNode,
      nodes: draggingEvent.dragItem.rowNodes,
      overIndex,
      overNode,
      y: yNormalised,
      vDirection: vDirectionString
    };
    return event;
  }
  dispatchGridEvent(type, draggingEvent) {
    const event = this.draggingToRowDragEvent(type, draggingEvent);
    this.eventService.dispatchEvent(event);
  }
  onDragLeave(draggingEvent) {
    this.dispatchGridEvent(Events.EVENT_ROW_DRAG_LEAVE, draggingEvent);
    this.stopDragging(draggingEvent);
    if (this.gridOptionsService.is("rowDragManaged")) {
      this.clearRowHighlight();
    }
    if (this.isFromThisGrid(draggingEvent)) {
      this.isMultiRowDrag = false;
    }
  }
  onDragStop(draggingEvent) {
    this.dispatchGridEvent(Events.EVENT_ROW_DRAG_END, draggingEvent);
    this.stopDragging(draggingEvent);
    if (this.gridOptionsService.is("rowDragManaged") && (this.gridOptionsService.is("suppressMoveWhenRowDragging") || !this.isFromThisGrid(draggingEvent)) && !this.isDropZoneWithinThisGrid(draggingEvent)) {
      this.moveRowAndClearHighlight(draggingEvent);
    }
  }
  stopDragging(draggingEvent) {
    this.autoScrollService.ensureCleared();
    this.getRowNodes(draggingEvent).forEach((rowNode) => {
      rowNode.setDragging(false);
    });
  }
};
__decorate$1Q([
  Autowired("dragAndDropService")
], RowDragFeature.prototype, "dragAndDropService", void 0);
__decorate$1Q([
  Autowired("rowModel")
], RowDragFeature.prototype, "rowModel", void 0);
__decorate$1Q([
  Autowired("paginationProxy")
], RowDragFeature.prototype, "paginationProxy", void 0);
__decorate$1Q([
  Autowired("columnModel")
], RowDragFeature.prototype, "columnModel", void 0);
__decorate$1Q([
  Autowired("focusService")
], RowDragFeature.prototype, "focusService", void 0);
__decorate$1Q([
  Autowired("sortController")
], RowDragFeature.prototype, "sortController", void 0);
__decorate$1Q([
  Autowired("filterManager")
], RowDragFeature.prototype, "filterManager", void 0);
__decorate$1Q([
  Autowired("selectionService")
], RowDragFeature.prototype, "selectionService", void 0);
__decorate$1Q([
  Autowired("mouseEventService")
], RowDragFeature.prototype, "mouseEventService", void 0);
__decorate$1Q([
  Autowired("ctrlsService")
], RowDragFeature.prototype, "ctrlsService", void 0);
__decorate$1Q([
  Optional("rangeService")
], RowDragFeature.prototype, "rangeService", void 0);
__decorate$1Q([
  PostConstruct
], RowDragFeature.prototype, "postConstruct", null);
var __decorate$1P = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RowAnimationCssClasses;
(function(RowAnimationCssClasses2) {
  RowAnimationCssClasses2["ANIMATION_ON"] = "ag-row-animation";
  RowAnimationCssClasses2["ANIMATION_OFF"] = "ag-row-no-animation";
})(RowAnimationCssClasses || (RowAnimationCssClasses = {}));
var CSS_CLASS_FORCE_VERTICAL_SCROLL = "ag-force-vertical-scroll";
var CSS_CLASS_CELL_SELECTABLE = "ag-selectable";
var CSS_CLASS_COLUMN_MOVING = "ag-column-moving";
var GridBodyCtrl = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.stickyTopHeight = 0;
  }
  getScrollFeature() {
    return this.bodyScrollFeature;
  }
  getBodyViewportElement() {
    return this.eBodyViewport;
  }
  setComp(comp, eGridBody, eBodyViewport, eTop, eBottom, eStickyTop) {
    this.comp = comp;
    this.eGridBody = eGridBody;
    this.eBodyViewport = eBodyViewport;
    this.eTop = eTop;
    this.eBottom = eBottom;
    this.eStickyTop = eStickyTop;
    this.setCellTextSelection(this.gridOptionsService.is("enableCellTextSelection"));
    this.createManagedBean(new LayoutFeature(this.comp));
    this.bodyScrollFeature = this.createManagedBean(new GridBodyScrollFeature(this.eBodyViewport));
    this.addRowDragListener();
    this.setupRowAnimationCssClass();
    this.addEventListeners();
    this.addFocusListeners([eTop, eBodyViewport, eBottom, eStickyTop]);
    this.onGridColumnsChanged();
    this.addBodyViewportListener();
    this.setFloatingHeights();
    this.disableBrowserDragging();
    this.addStopEditingWhenGridLosesFocus();
    this.ctrlsService.registerGridBodyCtrl(this);
  }
  getComp() {
    return this.comp;
  }
  addEventListeners() {
    this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_HEADER_HEIGHT_CHANGED, this.onHeaderHeightChanged.bind(this));
  }
  addFocusListeners(elements) {
    elements.forEach((element) => {
      this.addManagedListener(element, "focusin", (e) => {
        const { target } = e;
        const isFocusedElementNested = isElementChildOfClass(target, "ag-root", element);
        element.classList.toggle("ag-has-focus", !isFocusedElementNested);
      });
      this.addManagedListener(element, "focusout", (e) => {
        const { target, relatedTarget } = e;
        const gridContainRelatedTarget = element.contains(relatedTarget);
        const isNestedRelatedTarget = isElementChildOfClass(relatedTarget, "ag-root", element);
        const isNestedTarget = isElementChildOfClass(target, "ag-root", element);
        if (isNestedTarget) {
          return;
        }
        if (!gridContainRelatedTarget || isNestedRelatedTarget) {
          element.classList.remove("ag-has-focus");
        }
      });
    });
  }
  setColumnMovingCss(moving) {
    this.comp.setColumnMovingCss(CSS_CLASS_COLUMN_MOVING, moving);
  }
  setCellTextSelection(selectable = false) {
    this.comp.setCellSelectableCss(CSS_CLASS_CELL_SELECTABLE, selectable);
  }
  onScrollVisibilityChanged() {
    const visible = this.scrollVisibleService.isVerticalScrollShowing();
    this.setVerticalScrollPaddingVisible(visible);
    this.setStickyTopWidth(visible);
    const scrollbarWidth = visible ? this.gridOptionsService.getScrollbarWidth() || 0 : 0;
    const pad = isInvisibleScrollbar() ? 16 : 0;
    const width = `calc(100% + ${scrollbarWidth + pad}px)`;
    this.animationFrameService.requestAnimationFrame(() => this.comp.setBodyViewportWidth(width));
  }
  onGridColumnsChanged() {
    const columns = this.columnModel.getAllGridColumns();
    this.comp.setColumnCount(columns ? columns.length : 0);
  }
  disableBrowserDragging() {
    this.addManagedListener(this.eGridBody, "dragstart", (event) => {
      if (event.target instanceof HTMLImageElement) {
        event.preventDefault();
        return false;
      }
    });
  }
  addStopEditingWhenGridLosesFocus() {
    if (!this.gridOptionsService.is("stopEditingWhenCellsLoseFocus")) {
      return;
    }
    const focusOutListener = (event) => {
      const elementWithFocus = event.relatedTarget;
      if (getTabIndex(elementWithFocus) === null) {
        this.rowRenderer.stopEditing();
        return;
      }
      let clickInsideGrid = viewports.some((viewport) => viewport.contains(elementWithFocus)) && this.mouseEventService.isElementInThisGrid(elementWithFocus);
      if (!clickInsideGrid) {
        const popupService = this.popupService;
        clickInsideGrid = popupService.getActivePopups().some((popup) => popup.contains(elementWithFocus)) || popupService.isElementWithinCustomPopup(elementWithFocus);
      }
      if (!clickInsideGrid) {
        this.rowRenderer.stopEditing();
      }
    };
    const viewports = [this.eBodyViewport, this.eBottom, this.eTop, this.eStickyTop];
    viewports.forEach((viewport) => this.addManagedListener(viewport, "focusout", focusOutListener));
  }
  updateRowCount() {
    const headerCount = this.headerNavigationService.getHeaderRowCount();
    const rowCount = this.rowModel.isLastRowIndexKnown() ? this.rowModel.getRowCount() : -1;
    const total = rowCount === -1 ? -1 : headerCount + rowCount;
    this.comp.setRowCount(total);
  }
  registerBodyViewportResizeListener(listener) {
    this.comp.registerBodyViewportResizeListener(listener);
  }
  setVerticalScrollPaddingVisible(visible) {
    const overflowY = visible ? "scroll" : "hidden";
    this.comp.setPinnedTopBottomOverflowY(overflowY);
  }
  isVerticalScrollShowing() {
    const show = this.gridOptionsService.is("alwaysShowVerticalScroll");
    const cssClass = show ? CSS_CLASS_FORCE_VERTICAL_SCROLL : null;
    const allowVerticalScroll = this.gridOptionsService.isDomLayout("normal");
    this.comp.setAlwaysVerticalScrollClass(cssClass, show);
    return show || allowVerticalScroll && isVerticalScrollShowing(this.eBodyViewport);
  }
  setupRowAnimationCssClass() {
    const listener = () => {
      const animateRows = this.gridOptionsService.isAnimateRows() && !this.rowContainerHeightService.isStretching();
      const animateRowsCssClass = animateRows ? RowAnimationCssClasses.ANIMATION_ON : RowAnimationCssClasses.ANIMATION_OFF;
      this.comp.setRowAnimationCssOnBodyViewport(animateRowsCssClass, animateRows);
    };
    listener();
    this.addManagedListener(this.eventService, Events.EVENT_HEIGHT_SCALE_CHANGED, listener);
    this.addManagedPropertyListener("animateRows", listener);
  }
  getGridBodyElement() {
    return this.eGridBody;
  }
  addBodyViewportListener() {
    const listener = this.onBodyViewportContextMenu.bind(this);
    this.addManagedListener(this.eBodyViewport, "contextmenu", listener);
    this.mockContextMenuForIPad(listener);
    this.addManagedListener(this.eBodyViewport, "wheel", this.onBodyViewportWheel.bind(this));
    this.addManagedListener(this.eStickyTop, "wheel", this.onStickyTopWheel.bind(this));
    this.addFullWidthContainerWheelListener();
  }
  addFullWidthContainerWheelListener() {
    const fullWidthContainer = this.eBodyViewport.querySelector(".ag-full-width-container");
    const eCenterColsViewport = this.eBodyViewport.querySelector(".ag-center-cols-viewport");
    if (fullWidthContainer && eCenterColsViewport) {
      this.addManagedListener(fullWidthContainer, "wheel", (e) => this.onFullWidthContainerWheel(e, eCenterColsViewport));
    }
  }
  onFullWidthContainerWheel(e, eCenterColsViewport) {
    if (!e.deltaX || Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
      return;
    }
    e.preventDefault();
    eCenterColsViewport.scrollBy({ left: e.deltaX });
  }
  onBodyViewportContextMenu(mouseEvent, touch, touchEvent) {
    if (!mouseEvent && !touchEvent) {
      return;
    }
    if (this.gridOptionsService.is("preventDefaultOnContextMenu")) {
      const event = mouseEvent || touchEvent;
      event.preventDefault();
    }
    const { target } = mouseEvent || touch;
    if (target === this.eBodyViewport || target === this.ctrlsService.getCenterRowContainerCtrl().getViewportElement()) {
      if (!this.contextMenuFactory) {
        return;
      }
      if (mouseEvent) {
        this.contextMenuFactory.onContextMenu(mouseEvent, null, null, null, null, this.eGridBody);
      } else if (touchEvent) {
        this.contextMenuFactory.onContextMenu(null, touchEvent, null, null, null, this.eGridBody);
      }
    }
  }
  mockContextMenuForIPad(listener) {
    if (!isIOSUserAgent()) {
      return;
    }
    const touchListener = new TouchListener(this.eBodyViewport);
    const longTapListener = (event) => {
      listener(void 0, event.touchStart, event.touchEvent);
    };
    this.addManagedListener(touchListener, TouchListener.EVENT_LONG_TAP, longTapListener);
    this.addDestroyFunc(() => touchListener.destroy());
  }
  onBodyViewportWheel(e) {
    if (!this.gridOptionsService.is("suppressScrollWhenPopupsAreOpen")) {
      return;
    }
    if (this.popupService.hasAnchoredPopup()) {
      e.preventDefault();
    }
  }
  onStickyTopWheel(e) {
    e.preventDefault();
    if (e.offsetY) {
      this.scrollVertically(e.deltaY);
    }
  }
  getGui() {
    return this.eGridBody;
  }
  scrollVertically(pixels) {
    const oldScrollPosition = this.eBodyViewport.scrollTop;
    this.bodyScrollFeature.setVerticalScrollPosition(oldScrollPosition + pixels);
    return this.eBodyViewport.scrollTop - oldScrollPosition;
  }
  addRowDragListener() {
    this.rowDragFeature = this.createManagedBean(new RowDragFeature(this.eBodyViewport));
    this.dragAndDropService.addDropTarget(this.rowDragFeature);
  }
  getRowDragFeature() {
    return this.rowDragFeature;
  }
  onPinnedRowDataChanged() {
    this.setFloatingHeights();
  }
  setFloatingHeights() {
    const { pinnedRowModel } = this;
    let floatingTopHeight = pinnedRowModel.getPinnedTopTotalHeight();
    if (floatingTopHeight) {
      floatingTopHeight += 1;
    }
    let floatingBottomHeight = pinnedRowModel.getPinnedBottomTotalHeight();
    if (floatingBottomHeight) {
      floatingBottomHeight += 1;
    }
    this.comp.setTopHeight(floatingTopHeight);
    this.comp.setBottomHeight(floatingBottomHeight);
    this.comp.setTopDisplay(floatingTopHeight ? "inherit" : "none");
    this.comp.setBottomDisplay(floatingBottomHeight ? "inherit" : "none");
    this.setStickyTopOffsetTop();
  }
  setStickyTopHeight(height = 0) {
    this.comp.setStickyTopHeight(`${height}px`);
    this.stickyTopHeight = height;
  }
  getStickyTopHeight() {
    return this.stickyTopHeight;
  }
  setStickyTopWidth(vScrollVisible) {
    if (!vScrollVisible) {
      this.comp.setStickyTopWidth("100%");
    } else {
      const scrollbarWidth = this.gridOptionsService.getScrollbarWidth();
      this.comp.setStickyTopWidth(`calc(100% - ${scrollbarWidth}px)`);
    }
  }
  onHeaderHeightChanged() {
    this.setStickyTopOffsetTop();
  }
  setStickyTopOffsetTop() {
    const headerCtrl = this.ctrlsService.getGridHeaderCtrl();
    const headerHeight = headerCtrl.getHeaderHeight();
    const pinnedTopHeight = this.pinnedRowModel.getPinnedTopTotalHeight();
    let height = 0;
    if (headerHeight > 0) {
      height += headerHeight + 1;
    }
    if (pinnedTopHeight > 0) {
      height += pinnedTopHeight + 1;
    }
    this.comp.setStickyTopTop(`${height}px`);
  }
  sizeColumnsToFit(params, nextTimeout) {
    const removeScrollWidth = this.isVerticalScrollShowing();
    const scrollWidthToRemove = removeScrollWidth ? this.gridOptionsService.getScrollbarWidth() : 0;
    const bodyViewportWidth = getInnerWidth(this.eGridBody);
    const availableWidth = bodyViewportWidth - scrollWidthToRemove;
    if (availableWidth > 0) {
      this.columnModel.sizeColumnsToFit(availableWidth, "sizeColumnsToFit", false, params);
      return;
    }
    if (nextTimeout === void 0) {
      window.setTimeout(() => {
        this.sizeColumnsToFit(params, 100);
      }, 0);
    } else if (nextTimeout === 100) {
      window.setTimeout(() => {
        this.sizeColumnsToFit(params, 500);
      }, 100);
    } else if (nextTimeout === 500) {
      window.setTimeout(() => {
        this.sizeColumnsToFit(params, -1);
      }, 500);
    } else {
      console.warn("AG Grid: tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?");
    }
  }
  addScrollEventListener(listener) {
    this.eBodyViewport.addEventListener("scroll", listener, { passive: true });
  }
  removeScrollEventListener(listener) {
    this.eBodyViewport.removeEventListener("scroll", listener);
  }
};
__decorate$1P([
  Autowired("animationFrameService")
], GridBodyCtrl.prototype, "animationFrameService", void 0);
__decorate$1P([
  Autowired("rowContainerHeightService")
], GridBodyCtrl.prototype, "rowContainerHeightService", void 0);
__decorate$1P([
  Autowired("ctrlsService")
], GridBodyCtrl.prototype, "ctrlsService", void 0);
__decorate$1P([
  Autowired("columnModel")
], GridBodyCtrl.prototype, "columnModel", void 0);
__decorate$1P([
  Autowired("scrollVisibleService")
], GridBodyCtrl.prototype, "scrollVisibleService", void 0);
__decorate$1P([
  Optional("contextMenuFactory")
], GridBodyCtrl.prototype, "contextMenuFactory", void 0);
__decorate$1P([
  Autowired("headerNavigationService")
], GridBodyCtrl.prototype, "headerNavigationService", void 0);
__decorate$1P([
  Autowired("dragAndDropService")
], GridBodyCtrl.prototype, "dragAndDropService", void 0);
__decorate$1P([
  Autowired("pinnedRowModel")
], GridBodyCtrl.prototype, "pinnedRowModel", void 0);
__decorate$1P([
  Autowired("rowRenderer")
], GridBodyCtrl.prototype, "rowRenderer", void 0);
__decorate$1P([
  Autowired("popupService")
], GridBodyCtrl.prototype, "popupService", void 0);
__decorate$1P([
  Autowired("mouseEventService")
], GridBodyCtrl.prototype, "mouseEventService", void 0);
__decorate$1P([
  Autowired("rowModel")
], GridBodyCtrl.prototype, "rowModel", void 0);
var SelectionHandleType;
(function(SelectionHandleType2) {
  SelectionHandleType2[SelectionHandleType2["FILL"] = 0] = "FILL";
  SelectionHandleType2[SelectionHandleType2["RANGE"] = 1] = "RANGE";
})(SelectionHandleType || (SelectionHandleType = {}));
var CellRangeType;
(function(CellRangeType2) {
  CellRangeType2[CellRangeType2["VALUE"] = 0] = "VALUE";
  CellRangeType2[CellRangeType2["DIMENSION"] = 1] = "DIMENSION";
})(CellRangeType || (CellRangeType = {}));
var CSS_CELL_RANGE_SELECTED = "ag-cell-range-selected";
var CSS_CELL_RANGE_CHART = "ag-cell-range-chart";
var CSS_CELL_RANGE_SINGLE_CELL = "ag-cell-range-single-cell";
var CSS_CELL_RANGE_CHART_CATEGORY = "ag-cell-range-chart-category";
var CSS_CELL_RANGE_HANDLE = "ag-cell-range-handle";
var CSS_CELL_RANGE_TOP = "ag-cell-range-top";
var CSS_CELL_RANGE_RIGHT = "ag-cell-range-right";
var CSS_CELL_RANGE_BOTTOM = "ag-cell-range-bottom";
var CSS_CELL_RANGE_LEFT = "ag-cell-range-left";
var CellRangeFeature = class {
  constructor(beans, ctrl) {
    this.beans = beans;
    this.cellCtrl = ctrl;
  }
  setComp(cellComp, eGui) {
    this.cellComp = cellComp;
    this.eGui = eGui;
    this.onRangeSelectionChanged();
  }
  onRangeSelectionChanged() {
    if (!this.cellComp) {
      return;
    }
    this.rangeCount = this.beans.rangeService.getCellRangeCount(this.cellCtrl.getCellPosition());
    this.hasChartRange = this.getHasChartRange();
    this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_SELECTED, this.rangeCount !== 0);
    this.cellComp.addOrRemoveCssClass(`${CSS_CELL_RANGE_SELECTED}-1`, this.rangeCount === 1);
    this.cellComp.addOrRemoveCssClass(`${CSS_CELL_RANGE_SELECTED}-2`, this.rangeCount === 2);
    this.cellComp.addOrRemoveCssClass(`${CSS_CELL_RANGE_SELECTED}-3`, this.rangeCount === 3);
    this.cellComp.addOrRemoveCssClass(`${CSS_CELL_RANGE_SELECTED}-4`, this.rangeCount >= 4);
    this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_CHART, this.hasChartRange);
    setAriaSelected(this.eGui, this.rangeCount > 0 ? true : void 0);
    this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_SINGLE_CELL, this.isSingleCell());
    this.updateRangeBorders();
    this.refreshHandle();
  }
  updateRangeBorders() {
    const rangeBorders = this.getRangeBorders();
    const isSingleCell = this.isSingleCell();
    const isTop = !isSingleCell && rangeBorders.top;
    const isRight = !isSingleCell && rangeBorders.right;
    const isBottom = !isSingleCell && rangeBorders.bottom;
    const isLeft = !isSingleCell && rangeBorders.left;
    this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_TOP, isTop);
    this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_RIGHT, isRight);
    this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_BOTTOM, isBottom);
    this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_LEFT, isLeft);
  }
  isSingleCell() {
    const { rangeService } = this.beans;
    return this.rangeCount === 1 && rangeService && !rangeService.isMoreThanOneCell();
  }
  getHasChartRange() {
    const { rangeService } = this.beans;
    if (!this.rangeCount || !rangeService) {
      return false;
    }
    const cellRanges = rangeService.getCellRanges();
    return cellRanges.length > 0 && cellRanges.every((range) => includes([CellRangeType.DIMENSION, CellRangeType.VALUE], range.type));
  }
  updateRangeBordersIfRangeCount() {
    if (this.rangeCount > 0) {
      this.updateRangeBorders();
      this.refreshHandle();
    }
  }
  getRangeBorders() {
    const isRtl = this.beans.gridOptionsService.is("enableRtl");
    let top = false;
    let right = false;
    let bottom = false;
    let left = false;
    const thisCol = this.cellCtrl.getCellPosition().column;
    const { rangeService, columnModel } = this.beans;
    let leftCol;
    let rightCol;
    if (isRtl) {
      leftCol = columnModel.getDisplayedColAfter(thisCol);
      rightCol = columnModel.getDisplayedColBefore(thisCol);
    } else {
      leftCol = columnModel.getDisplayedColBefore(thisCol);
      rightCol = columnModel.getDisplayedColAfter(thisCol);
    }
    const ranges = rangeService.getCellRanges().filter((range) => rangeService.isCellInSpecificRange(this.cellCtrl.getCellPosition(), range));
    if (!leftCol) {
      left = true;
    }
    if (!rightCol) {
      right = true;
    }
    for (let i = 0; i < ranges.length; i++) {
      if (top && right && bottom && left) {
        break;
      }
      const range = ranges[i];
      const startRow = rangeService.getRangeStartRow(range);
      const endRow = rangeService.getRangeEndRow(range);
      if (!top && this.beans.rowPositionUtils.sameRow(startRow, this.cellCtrl.getCellPosition())) {
        top = true;
      }
      if (!bottom && this.beans.rowPositionUtils.sameRow(endRow, this.cellCtrl.getCellPosition())) {
        bottom = true;
      }
      if (!left && leftCol && range.columns.indexOf(leftCol) < 0) {
        left = true;
      }
      if (!right && rightCol && range.columns.indexOf(rightCol) < 0) {
        right = true;
      }
    }
    return { top, right, bottom, left };
  }
  refreshHandle() {
    if (!this.beans.rangeService) {
      return;
    }
    const shouldHaveSelectionHandle = this.shouldHaveSelectionHandle();
    if (this.selectionHandle && !shouldHaveSelectionHandle) {
      this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle);
    }
    if (shouldHaveSelectionHandle) {
      this.addSelectionHandle();
    }
    this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_HANDLE, !!this.selectionHandle);
  }
  shouldHaveSelectionHandle() {
    const { gridOptionsService, rangeService } = this.beans;
    const cellRanges = rangeService.getCellRanges();
    const rangesLen = cellRanges.length;
    if (this.rangeCount < 1 || rangesLen < 1) {
      return false;
    }
    const cellRange = last(cellRanges);
    const cellPosition = this.cellCtrl.getCellPosition();
    const isFillHandleAvailable = gridOptionsService.is("enableFillHandle") && !this.cellCtrl.isSuppressFillHandle();
    const isRangeHandleAvailable = gridOptionsService.is("enableRangeHandle");
    let handleIsAvailable = rangesLen === 1 && !this.cellCtrl.isEditing() && (isFillHandleAvailable || isRangeHandleAvailable);
    if (this.hasChartRange) {
      const hasCategoryRange = cellRanges[0].type === CellRangeType.DIMENSION;
      const isCategoryCell = hasCategoryRange && rangeService.isCellInSpecificRange(cellPosition, cellRanges[0]);
      this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_CHART_CATEGORY, isCategoryCell);
      handleIsAvailable = cellRange.type === CellRangeType.VALUE;
    }
    return handleIsAvailable && cellRange.endRow != null && rangeService.isContiguousRange(cellRange) && rangeService.isBottomRightCell(cellRange, cellPosition);
  }
  addSelectionHandle() {
    const { gridOptionsService, rangeService } = this.beans;
    const cellRangeType = last(rangeService.getCellRanges()).type;
    const selectionHandleFill = gridOptionsService.is("enableFillHandle") && missing(cellRangeType);
    const type = selectionHandleFill ? SelectionHandleType.FILL : SelectionHandleType.RANGE;
    if (this.selectionHandle && this.selectionHandle.getType() !== type) {
      this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle);
    }
    if (!this.selectionHandle) {
      this.selectionHandle = this.beans.selectionHandleFactory.createSelectionHandle(type);
    }
    this.selectionHandle.refresh(this.cellCtrl);
  }
  destroy() {
    this.beans.context.destroyBean(this.selectionHandle);
  }
};
var CellPositionFeature = class extends BeanStub {
  constructor(ctrl, beans) {
    super();
    this.cellCtrl = ctrl;
    this.beans = beans;
    this.column = ctrl.getColumn();
    this.rowNode = ctrl.getRowNode();
    this.setupColSpan();
    this.setupRowSpan();
  }
  setupRowSpan() {
    this.rowSpan = this.column.getRowSpan(this.rowNode);
  }
  setComp(eGui) {
    this.eGui = eGui;
    this.onLeftChanged();
    this.onWidthChanged();
    this.applyRowSpan();
  }
  onDisplayColumnsChanged() {
    const colsSpanning = this.getColSpanningList();
    if (!areEqual(this.colsSpanning, colsSpanning)) {
      this.colsSpanning = colsSpanning;
      this.onWidthChanged();
      this.onLeftChanged();
    }
  }
  setupColSpan() {
    if (this.column.getColDef().colSpan == null) {
      return;
    }
    this.colsSpanning = this.getColSpanningList();
    this.addManagedListener(this.beans.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayColumnsChanged.bind(this));
    this.addManagedListener(this.beans.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onWidthChanged.bind(this));
  }
  onWidthChanged() {
    if (!this.eGui) {
      return;
    }
    const width = this.getCellWidth();
    this.eGui.style.width = `${width}px`;
  }
  getCellWidth() {
    if (!this.colsSpanning) {
      return this.column.getActualWidth();
    }
    return this.colsSpanning.reduce((width, col) => width + col.getActualWidth(), 0);
  }
  getColSpanningList() {
    const colSpan = this.column.getColSpan(this.rowNode);
    const colsSpanning = [];
    if (colSpan === 1) {
      colsSpanning.push(this.column);
    } else {
      let pointer = this.column;
      const pinned = this.column.getPinned();
      for (let i = 0; pointer && i < colSpan; i++) {
        colsSpanning.push(pointer);
        pointer = this.beans.columnModel.getDisplayedColAfter(pointer);
        if (!pointer || missing(pointer)) {
          break;
        }
        if (pinned !== pointer.getPinned()) {
          break;
        }
      }
    }
    return colsSpanning;
  }
  onLeftChanged() {
    if (!this.eGui) {
      return;
    }
    const left = this.modifyLeftForPrintLayout(this.getCellLeft());
    this.eGui.style.left = left + "px";
  }
  getCellLeft() {
    let mostLeftCol;
    if (this.beans.gridOptionsService.is("enableRtl") && this.colsSpanning) {
      mostLeftCol = last(this.colsSpanning);
    } else {
      mostLeftCol = this.column;
    }
    return mostLeftCol.getLeft();
  }
  modifyLeftForPrintLayout(leftPosition) {
    if (!this.cellCtrl.isPrintLayout() || this.column.getPinned() === "left") {
      return leftPosition;
    }
    const leftWidth = this.beans.columnModel.getDisplayedColumnsLeftWidth();
    if (this.column.getPinned() === "right") {
      const bodyWidth = this.beans.columnModel.getBodyContainerWidth();
      return leftWidth + bodyWidth + (leftPosition || 0);
    }
    return leftWidth + (leftPosition || 0);
  }
  applyRowSpan() {
    if (this.rowSpan === 1) {
      return;
    }
    const singleRowHeight = this.beans.gridOptionsService.getRowHeightAsNumber();
    const totalRowHeight = singleRowHeight * this.rowSpan;
    this.eGui.style.height = `${totalRowHeight}px`;
    this.eGui.style.zIndex = "1";
  }
  destroy() {
    super.destroy();
  }
};
var CellCustomStyleFeature = class extends BeanStub {
  constructor(ctrl, beans) {
    super();
    this.staticClasses = [];
    this.cellCtrl = ctrl;
    this.beans = beans;
    this.column = ctrl.getColumn();
    this.rowNode = ctrl.getRowNode();
  }
  setComp(comp) {
    this.cellComp = comp;
    this.applyUserStyles();
    this.applyCellClassRules();
    this.applyClassesFromColDef();
  }
  applyCellClassRules() {
    const colDef = this.column.getColDef();
    const cellClassParams = {
      value: this.cellCtrl.getValue(),
      data: this.rowNode.data,
      node: this.rowNode,
      colDef,
      column: this.column,
      rowIndex: this.rowNode.rowIndex,
      api: this.beans.gridOptionsService.api,
      columnApi: this.beans.gridOptionsService.columnApi,
      context: this.beans.gridOptionsService.context
    };
    this.beans.stylingService.processClassRules(colDef.cellClassRules, cellClassParams, (className) => this.cellComp.addOrRemoveCssClass(className, true), (className) => this.cellComp.addOrRemoveCssClass(className, false));
  }
  applyUserStyles() {
    const colDef = this.column.getColDef();
    if (!colDef.cellStyle) {
      return;
    }
    let styles;
    if (typeof colDef.cellStyle === "function") {
      const cellStyleParams = {
        column: this.column,
        value: this.cellCtrl.getValue(),
        colDef,
        data: this.rowNode.data,
        node: this.rowNode,
        rowIndex: this.rowNode.rowIndex,
        api: this.beans.gridOptionsService.api,
        columnApi: this.beans.gridOptionsService.columnApi,
        context: this.beans.gridOptionsService.context
      };
      const cellStyleFunc = colDef.cellStyle;
      styles = cellStyleFunc(cellStyleParams);
    } else {
      styles = colDef.cellStyle;
    }
    if (styles) {
      this.cellComp.setUserStyles(styles);
    }
  }
  applyClassesFromColDef() {
    const colDef = this.column.getColDef();
    const cellClassParams = {
      value: this.cellCtrl.getValue(),
      data: this.rowNode.data,
      node: this.rowNode,
      column: this.column,
      colDef,
      rowIndex: this.rowNode.rowIndex,
      api: this.beans.gridOptionsService.api,
      columnApi: this.beans.gridOptionsService.columnApi,
      context: this.beans.gridOptionsService.context
    };
    if (this.staticClasses.length) {
      this.staticClasses.forEach((className) => this.cellComp.addOrRemoveCssClass(className, false));
    }
    this.staticClasses = this.beans.stylingService.getStaticCellClasses(colDef, cellClassParams);
    if (this.staticClasses.length) {
      this.staticClasses.forEach((className) => this.cellComp.addOrRemoveCssClass(className, true));
    }
  }
  destroy() {
    super.destroy();
  }
};
var TooltipFeature = class extends BeanStub {
  constructor(ctrl, beans) {
    super();
    this.ctrl = ctrl;
    this.beans = beans;
  }
  setComp(comp) {
    this.comp = comp;
    this.setupTooltip();
  }
  setupTooltip() {
    this.browserTooltips = this.beans.gridOptionsService.is("enableBrowserTooltips");
    this.updateTooltipText();
    if (this.browserTooltips) {
      this.comp.setTitle(this.tooltip != null ? this.tooltip : void 0);
    } else {
      this.createTooltipFeatureIfNeeded();
    }
  }
  updateTooltipText() {
    this.tooltip = this.ctrl.getTooltipValue();
  }
  createTooltipFeatureIfNeeded() {
    if (this.genericTooltipFeature != null) {
      return;
    }
    const parent = {
      getTooltipParams: () => this.getTooltipParams(),
      getGui: () => this.ctrl.getGui()
    };
    this.genericTooltipFeature = this.createManagedBean(new CustomTooltipFeature(parent), this.beans.context);
  }
  refreshToolTip() {
    this.updateTooltipText();
    if (this.browserTooltips) {
      this.comp.setTitle(this.tooltip != null ? this.tooltip : void 0);
    }
  }
  getTooltipParams() {
    const ctrl = this.ctrl;
    const column = ctrl.getColumn ? ctrl.getColumn() : void 0;
    const colDef = ctrl.getColDef ? ctrl.getColDef() : void 0;
    const rowNode = ctrl.getRowNode ? ctrl.getRowNode() : void 0;
    return {
      location: ctrl.getLocation(),
      colDef,
      column,
      rowIndex: ctrl.getRowIndex ? ctrl.getRowIndex() : void 0,
      node: rowNode,
      data: rowNode ? rowNode.data : void 0,
      value: this.getTooltipText(),
      valueFormatted: ctrl.getValueFormatted ? ctrl.getValueFormatted() : void 0
    };
  }
  getTooltipText() {
    return this.tooltip;
  }
  destroy() {
    super.destroy();
  }
};
var __decorate$1O = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Beans = class Beans2 {
  postConstruct() {
    this.doingMasterDetail = this.gridOptionsService.isMasterDetail();
    if (this.gridOptionsService.isRowModelType("clientSide")) {
      this.clientSideRowModel = this.rowModel;
    }
    if (this.gridOptionsService.isRowModelType("serverSide")) {
      this.serverSideRowModel = this.rowModel;
    }
  }
};
__decorate$1O([
  Autowired("resizeObserverService")
], Beans.prototype, "resizeObserverService", void 0);
__decorate$1O([
  Autowired("paginationProxy")
], Beans.prototype, "paginationProxy", void 0);
__decorate$1O([
  Autowired("context")
], Beans.prototype, "context", void 0);
__decorate$1O([
  Autowired("columnApi")
], Beans.prototype, "columnApi", void 0);
__decorate$1O([
  Autowired("gridApi")
], Beans.prototype, "gridApi", void 0);
__decorate$1O([
  Autowired("gridOptionsService")
], Beans.prototype, "gridOptionsService", void 0);
__decorate$1O([
  Autowired("expressionService")
], Beans.prototype, "expressionService", void 0);
__decorate$1O([
  Autowired("environment")
], Beans.prototype, "environment", void 0);
__decorate$1O([
  Autowired("rowRenderer")
], Beans.prototype, "rowRenderer", void 0);
__decorate$1O([
  Autowired("templateService")
], Beans.prototype, "templateService", void 0);
__decorate$1O([
  Autowired("valueService")
], Beans.prototype, "valueService", void 0);
__decorate$1O([
  Autowired("eventService")
], Beans.prototype, "eventService", void 0);
__decorate$1O([
  Autowired("columnModel")
], Beans.prototype, "columnModel", void 0);
__decorate$1O([
  Autowired("headerNavigationService")
], Beans.prototype, "headerNavigationService", void 0);
__decorate$1O([
  Autowired("navigationService")
], Beans.prototype, "navigationService", void 0);
__decorate$1O([
  Autowired("columnAnimationService")
], Beans.prototype, "columnAnimationService", void 0);
__decorate$1O([
  Optional("rangeService")
], Beans.prototype, "rangeService", void 0);
__decorate$1O([
  Autowired("focusService")
], Beans.prototype, "focusService", void 0);
__decorate$1O([
  Optional("contextMenuFactory")
], Beans.prototype, "contextMenuFactory", void 0);
__decorate$1O([
  Autowired("popupService")
], Beans.prototype, "popupService", void 0);
__decorate$1O([
  Autowired("valueFormatterService")
], Beans.prototype, "valueFormatterService", void 0);
__decorate$1O([
  Autowired("stylingService")
], Beans.prototype, "stylingService", void 0);
__decorate$1O([
  Autowired("columnHoverService")
], Beans.prototype, "columnHoverService", void 0);
__decorate$1O([
  Autowired("userComponentFactory")
], Beans.prototype, "userComponentFactory", void 0);
__decorate$1O([
  Autowired("userComponentRegistry")
], Beans.prototype, "userComponentRegistry", void 0);
__decorate$1O([
  Autowired("animationFrameService")
], Beans.prototype, "animationFrameService", void 0);
__decorate$1O([
  Autowired("dragService")
], Beans.prototype, "dragService", void 0);
__decorate$1O([
  Autowired("dragAndDropService")
], Beans.prototype, "dragAndDropService", void 0);
__decorate$1O([
  Autowired("sortController")
], Beans.prototype, "sortController", void 0);
__decorate$1O([
  Autowired("filterManager")
], Beans.prototype, "filterManager", void 0);
__decorate$1O([
  Autowired("rowContainerHeightService")
], Beans.prototype, "rowContainerHeightService", void 0);
__decorate$1O([
  Autowired("frameworkOverrides")
], Beans.prototype, "frameworkOverrides", void 0);
__decorate$1O([
  Autowired("cellPositionUtils")
], Beans.prototype, "cellPositionUtils", void 0);
__decorate$1O([
  Autowired("rowPositionUtils")
], Beans.prototype, "rowPositionUtils", void 0);
__decorate$1O([
  Autowired("selectionService")
], Beans.prototype, "selectionService", void 0);
__decorate$1O([
  Optional("selectionHandleFactory")
], Beans.prototype, "selectionHandleFactory", void 0);
__decorate$1O([
  Autowired("rowCssClassCalculator")
], Beans.prototype, "rowCssClassCalculator", void 0);
__decorate$1O([
  Autowired("rowModel")
], Beans.prototype, "rowModel", void 0);
__decorate$1O([
  Autowired("ctrlsService")
], Beans.prototype, "ctrlsService", void 0);
__decorate$1O([
  Autowired("ctrlsFactory")
], Beans.prototype, "ctrlsFactory", void 0);
__decorate$1O([
  Autowired("agStackComponentsRegistry")
], Beans.prototype, "agStackComponentsRegistry", void 0);
__decorate$1O([
  Autowired("valueCache")
], Beans.prototype, "valueCache", void 0);
__decorate$1O([
  Autowired("rowNodeEventThrottle")
], Beans.prototype, "rowNodeEventThrottle", void 0);
__decorate$1O([
  Autowired("localeService")
], Beans.prototype, "localeService", void 0);
__decorate$1O([
  Autowired("valueParserService")
], Beans.prototype, "valueParserService", void 0);
__decorate$1O([
  PostConstruct
], Beans.prototype, "postConstruct", null);
Beans = __decorate$1O([
  Bean("beans")
], Beans);
var CellMouseListenerFeature = class extends Beans {
  constructor(ctrl, beans, column) {
    super();
    this.cellCtrl = ctrl;
    this.beans = beans;
    this.column = column;
  }
  onMouseEvent(eventName, mouseEvent) {
    if (isStopPropagationForAgGrid(mouseEvent)) {
      return;
    }
    switch (eventName) {
      case "click":
        this.onCellClicked(mouseEvent);
        break;
      case "mousedown":
      case "touchstart":
        this.onMouseDown(mouseEvent);
        break;
      case "dblclick":
        this.onCellDoubleClicked(mouseEvent);
        break;
      case "mouseout":
        this.onMouseOut(mouseEvent);
        break;
      case "mouseover":
        this.onMouseOver(mouseEvent);
        break;
    }
  }
  onCellClicked(mouseEvent) {
    if (this.isDoubleClickOnIPad()) {
      this.onCellDoubleClicked(mouseEvent);
      mouseEvent.preventDefault();
      return;
    }
    const { eventService, rangeService, gridOptionsService } = this.beans;
    const isMultiKey = mouseEvent.ctrlKey || mouseEvent.metaKey;
    if (rangeService && isMultiKey) {
      if (rangeService.getCellRangeCount(this.cellCtrl.getCellPosition()) > 1) {
        rangeService.intersectLastRange(true);
      }
    }
    const cellClickedEvent = this.cellCtrl.createEvent(mouseEvent, Events.EVENT_CELL_CLICKED);
    eventService.dispatchEvent(cellClickedEvent);
    const colDef = this.column.getColDef();
    if (colDef.onCellClicked) {
      window.setTimeout(() => colDef.onCellClicked(cellClickedEvent), 0);
    }
    const editOnSingleClick = (gridOptionsService.is("singleClickEdit") || colDef.singleClickEdit) && !gridOptionsService.is("suppressClickEdit");
    if (editOnSingleClick) {
      this.cellCtrl.startRowOrCellEdit();
    }
  }
  isDoubleClickOnIPad() {
    if (!isIOSUserAgent() || isEventSupported("dblclick")) {
      return false;
    }
    const nowMillis = new Date().getTime();
    const res = nowMillis - this.lastIPadMouseClickEvent < 200;
    this.lastIPadMouseClickEvent = nowMillis;
    return res;
  }
  onCellDoubleClicked(mouseEvent) {
    const colDef = this.column.getColDef();
    const cellDoubleClickedEvent = this.cellCtrl.createEvent(mouseEvent, Events.EVENT_CELL_DOUBLE_CLICKED);
    this.beans.eventService.dispatchEvent(cellDoubleClickedEvent);
    if (typeof colDef.onCellDoubleClicked === "function") {
      window.setTimeout(() => colDef.onCellDoubleClicked(cellDoubleClickedEvent), 0);
    }
    const editOnDoubleClick = !this.beans.gridOptionsService.is("singleClickEdit") && !this.beans.gridOptionsService.is("suppressClickEdit");
    if (editOnDoubleClick) {
      this.cellCtrl.startRowOrCellEdit(null, mouseEvent);
    }
  }
  onMouseDown(mouseEvent) {
    const { ctrlKey, metaKey, shiftKey } = mouseEvent;
    const target = mouseEvent.target;
    const { eventService, rangeService } = this.beans;
    if (this.isRightClickInExistingRange(mouseEvent)) {
      return;
    }
    const ranges = rangeService && rangeService.getCellRanges().length != 0;
    if (!shiftKey || !ranges) {
      const forceBrowserFocus = isBrowserSafari() && !this.cellCtrl.isEditing() && !isFocusableFormField(target);
      this.cellCtrl.focusCell(forceBrowserFocus);
    }
    if (shiftKey && ranges) {
      mouseEvent.preventDefault();
    }
    if (this.containsWidget(target)) {
      return;
    }
    if (rangeService) {
      const thisCell = this.cellCtrl.getCellPosition();
      if (shiftKey) {
        rangeService.extendLatestRangeToCell(thisCell);
      } else {
        const isMultiKey = ctrlKey || metaKey;
        rangeService.setRangeToCell(thisCell, isMultiKey);
      }
    }
    eventService.dispatchEvent(this.cellCtrl.createEvent(mouseEvent, Events.EVENT_CELL_MOUSE_DOWN));
  }
  isRightClickInExistingRange(mouseEvent) {
    const { rangeService } = this.beans;
    if (rangeService) {
      const cellInRange = rangeService.isCellInAnyRange(this.cellCtrl.getCellPosition());
      if (cellInRange && mouseEvent.button === 2) {
        return true;
      }
    }
    return false;
  }
  containsWidget(target) {
    return isElementChildOfClass(target, "ag-selection-checkbox", 3);
  }
  onMouseOut(mouseEvent) {
    if (this.mouseStayingInsideCell(mouseEvent)) {
      return;
    }
    const cellMouseOutEvent = this.cellCtrl.createEvent(mouseEvent, Events.EVENT_CELL_MOUSE_OUT);
    this.beans.eventService.dispatchEvent(cellMouseOutEvent);
    this.beans.columnHoverService.clearMouseOver();
  }
  onMouseOver(mouseEvent) {
    if (this.mouseStayingInsideCell(mouseEvent)) {
      return;
    }
    const cellMouseOverEvent = this.cellCtrl.createEvent(mouseEvent, Events.EVENT_CELL_MOUSE_OVER);
    this.beans.eventService.dispatchEvent(cellMouseOverEvent);
    this.beans.columnHoverService.setMouseOver([this.column]);
  }
  mouseStayingInsideCell(e) {
    if (!e.target || !e.relatedTarget) {
      return false;
    }
    const eGui = this.cellCtrl.getGui();
    const cellContainsTarget = eGui.contains(e.target);
    const cellContainsRelatedTarget = eGui.contains(e.relatedTarget);
    return cellContainsTarget && cellContainsRelatedTarget;
  }
  destroy() {
  }
};
var CellKeyboardListenerFeature = class extends BeanStub {
  constructor(ctrl, beans, column, rowNode, rowCtrl) {
    super();
    this.cellCtrl = ctrl;
    this.beans = beans;
    this.rowNode = rowNode;
    this.rowCtrl = rowCtrl;
  }
  setComp(eGui) {
    this.eGui = eGui;
  }
  onKeyDown(event) {
    const key = event.key;
    switch (key) {
      case KeyCode.ENTER:
        this.onEnterKeyDown(event);
        break;
      case KeyCode.F2:
        this.onF2KeyDown(event);
        break;
      case KeyCode.ESCAPE:
        this.onEscapeKeyDown(event);
        break;
      case KeyCode.TAB:
        this.onTabKeyDown(event);
        break;
      case KeyCode.BACKSPACE:
      case KeyCode.DELETE:
        this.onBackspaceOrDeleteKeyDown(key, event);
        break;
      case KeyCode.DOWN:
      case KeyCode.UP:
      case KeyCode.RIGHT:
      case KeyCode.LEFT:
        this.onNavigationKeyDown(event, key);
        break;
    }
  }
  onNavigationKeyDown(event, key) {
    if (this.cellCtrl.isEditing()) {
      return;
    }
    if (event.shiftKey && this.cellCtrl.isRangeSelectionEnabled()) {
      this.onShiftRangeSelect(event);
    } else {
      this.beans.navigationService.navigateToNextCell(event, key, this.cellCtrl.getCellPosition(), true);
    }
    event.preventDefault();
  }
  onShiftRangeSelect(event) {
    if (!this.beans.rangeService) {
      return;
    }
    const endCell = this.beans.rangeService.extendLatestRangeInDirection(event);
    if (endCell) {
      this.beans.navigationService.ensureCellVisible(endCell);
    }
  }
  onTabKeyDown(event) {
    this.beans.navigationService.onTabKeyDown(this.cellCtrl, event);
  }
  onBackspaceOrDeleteKeyDown(key, event) {
    const { cellCtrl, beans, rowNode } = this;
    const { gridOptionsService, rangeService, eventService } = beans;
    if (cellCtrl.isEditing()) {
      return;
    }
    eventService.dispatchEvent({ type: Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_START });
    if (isDeleteKey(key, gridOptionsService.is("enableCellEditingOnBackspace"))) {
      if (rangeService && gridOptionsService.isEnableRangeSelection()) {
        rangeService.clearCellRangeCellValues({ dispatchWrapperEvents: true, wrapperEventSource: "deleteKey" });
      } else if (cellCtrl.isCellEditable()) {
        rowNode.setDataValue(cellCtrl.getColumn(), null, "cellClear");
      }
    } else {
      cellCtrl.startRowOrCellEdit(key, event);
    }
    eventService.dispatchEvent({ type: Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_END });
  }
  onEnterKeyDown(e) {
    if (this.cellCtrl.isEditing() || this.rowCtrl.isEditing()) {
      this.cellCtrl.stopEditingAndFocus(false, e.shiftKey);
    } else {
      if (this.beans.gridOptionsService.is("enterNavigatesVertically")) {
        const key = e.shiftKey ? KeyCode.UP : KeyCode.DOWN;
        this.beans.navigationService.navigateToNextCell(null, key, this.cellCtrl.getCellPosition(), false);
      } else {
        this.cellCtrl.startRowOrCellEdit(KeyCode.ENTER, e);
        if (this.cellCtrl.isEditing()) {
          e.preventDefault();
        }
      }
    }
  }
  onF2KeyDown(event) {
    if (!this.cellCtrl.isEditing()) {
      this.cellCtrl.startRowOrCellEdit(KeyCode.F2, event);
    }
  }
  onEscapeKeyDown(event) {
    if (this.cellCtrl.isEditing()) {
      this.cellCtrl.stopRowOrCellEdit(true);
      this.cellCtrl.focusCell(true);
    }
  }
  processCharacter(event) {
    const eventTarget = event.target;
    const eventOnChildComponent = eventTarget !== this.eGui;
    if (eventOnChildComponent || this.cellCtrl.isEditing()) {
      return;
    }
    const key = event.key;
    if (key === " ") {
      this.onSpaceKeyDown(event);
    } else {
      this.cellCtrl.startRowOrCellEdit(key, event);
      event.preventDefault();
    }
  }
  onSpaceKeyDown(event) {
    const { gridOptionsService } = this.beans;
    if (!this.cellCtrl.isEditing() && gridOptionsService.isRowSelection()) {
      const currentSelection = this.rowNode.isSelected();
      const newSelection = !currentSelection;
      if (newSelection || !gridOptionsService.is("suppressRowDeselection")) {
        const groupSelectsFiltered = this.beans.gridOptionsService.is("groupSelectsFiltered");
        const updatedCount = this.rowNode.setSelectedParams({
          newValue: newSelection,
          rangeSelect: event.shiftKey,
          groupSelectsFiltered,
          event,
          source: "spaceKey"
        });
        if (currentSelection === void 0 && updatedCount === 0) {
          this.rowNode.setSelectedParams({
            newValue: false,
            rangeSelect: event.shiftKey,
            groupSelectsFiltered,
            event,
            source: "spaceKey"
          });
        }
      }
    }
    event.preventDefault();
  }
  destroy() {
    super.destroy();
  }
};
var __decorate$1N = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DndSourceComp = class extends Component {
  constructor(rowNode, column, eCell) {
    super(`<div class="ag-drag-handle ag-row-drag" draggable="true"></div>`);
    this.rowNode = rowNode;
    this.column = column;
    this.eCell = eCell;
  }
  postConstruct() {
    const eGui = this.getGui();
    eGui.appendChild(createIconNoSpan("rowDrag", this.gridOptionsService, null));
    this.addGuiEventListener("mousedown", (e) => {
      e.stopPropagation();
    });
    this.addDragSource();
    this.checkVisibility();
  }
  addDragSource() {
    this.addGuiEventListener("dragstart", this.onDragStart.bind(this));
  }
  onDragStart(dragEvent) {
    const providedOnRowDrag = this.column.getColDef().dndSourceOnRowDrag;
    dragEvent.dataTransfer.setDragImage(this.eCell, 0, 0);
    const defaultOnRowDrag = () => {
      try {
        const jsonData = JSON.stringify(this.rowNode.data);
        dragEvent.dataTransfer.setData("application/json", jsonData);
        dragEvent.dataTransfer.setData("text/plain", jsonData);
      } catch (e) {
      }
    };
    if (providedOnRowDrag) {
      const params = {
        rowNode: this.rowNode,
        dragEvent,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      };
      providedOnRowDrag(params);
    } else {
      defaultOnRowDrag();
    }
  }
  checkVisibility() {
    const visible = this.column.isDndSource(this.rowNode);
    this.setDisplayed(visible);
  }
};
__decorate$1N([
  PostConstruct
], DndSourceComp.prototype, "postConstruct", null);
var CSS_CELL = "ag-cell";
var CSS_AUTO_HEIGHT = "ag-cell-auto-height";
var CSS_NORMAL_HEIGHT = "ag-cell-normal-height";
var CSS_CELL_FOCUS = "ag-cell-focus";
var CSS_CELL_FIRST_RIGHT_PINNED = "ag-cell-first-right-pinned";
var CSS_CELL_LAST_LEFT_PINNED = "ag-cell-last-left-pinned";
var CSS_CELL_NOT_INLINE_EDITING = "ag-cell-not-inline-editing";
var CSS_COLUMN_HOVER = "ag-column-hover";
var CSS_CELL_WRAP_TEXT = "ag-cell-wrap-text";
var instanceIdSequence$3 = 0;
var CellCtrl = class extends BeanStub {
  constructor(column, rowNode, beans, rowCtrl) {
    super();
    this.cellRangeFeature = null;
    this.cellPositionFeature = null;
    this.cellCustomStyleFeature = null;
    this.tooltipFeature = null;
    this.cellMouseListenerFeature = null;
    this.cellKeyboardListenerFeature = null;
    this.suppressRefreshCell = false;
    this.onCellCompAttachedFuncs = [];
    this.column = column;
    this.rowNode = rowNode;
    this.beans = beans;
    this.rowCtrl = rowCtrl;
    this.instanceId = column.getId() + "-" + instanceIdSequence$3++;
    this.createCellPosition();
    this.addFeatures();
  }
  addFeatures() {
    this.cellPositionFeature = new CellPositionFeature(this, this.beans);
    this.addDestroyFunc(() => {
      var _a;
      (_a = this.cellPositionFeature) === null || _a === void 0 ? void 0 : _a.destroy();
      this.cellPositionFeature = null;
    });
    this.cellCustomStyleFeature = new CellCustomStyleFeature(this, this.beans);
    this.addDestroyFunc(() => {
      var _a;
      (_a = this.cellCustomStyleFeature) === null || _a === void 0 ? void 0 : _a.destroy();
      this.cellCustomStyleFeature = null;
    });
    this.cellMouseListenerFeature = new CellMouseListenerFeature(this, this.beans, this.column);
    this.addDestroyFunc(() => {
      var _a;
      (_a = this.cellMouseListenerFeature) === null || _a === void 0 ? void 0 : _a.destroy();
      this.cellMouseListenerFeature = null;
    });
    this.cellKeyboardListenerFeature = new CellKeyboardListenerFeature(this, this.beans, this.column, this.rowNode, this.rowCtrl);
    this.addDestroyFunc(() => {
      var _a;
      (_a = this.cellKeyboardListenerFeature) === null || _a === void 0 ? void 0 : _a.destroy();
      this.cellKeyboardListenerFeature = null;
    });
    const rangeSelectionEnabled = this.beans.rangeService && this.beans.gridOptionsService.isEnableRangeSelection();
    if (rangeSelectionEnabled) {
      this.cellRangeFeature = new CellRangeFeature(this.beans, this);
      this.addDestroyFunc(() => {
        var _a;
        (_a = this.cellRangeFeature) === null || _a === void 0 ? void 0 : _a.destroy();
        this.cellRangeFeature = null;
      });
    }
    if (this.column.isTooltipEnabled()) {
      this.addTooltipFeature();
    }
  }
  addTooltipFeature() {
    const getTooltipValue = () => {
      const colDef = this.column.getColDef();
      const data = this.rowNode.data;
      if (colDef.tooltipField && exists(data)) {
        return getValueUsingField(data, colDef.tooltipField, this.column.isTooltipFieldContainsDots());
      }
      const valueGetter = colDef.tooltipValueGetter;
      if (valueGetter) {
        return valueGetter({
          location: "cell",
          api: this.beans.gridOptionsService.api,
          columnApi: this.beans.gridOptionsService.columnApi,
          context: this.beans.gridOptionsService.context,
          colDef: this.column.getColDef(),
          column: this.column,
          rowIndex: this.cellPosition.rowIndex,
          node: this.rowNode,
          data: this.rowNode.data,
          value: this.value,
          valueFormatted: this.valueFormatted
        });
      }
      return null;
    };
    const tooltipCtrl = {
      getColumn: () => this.column,
      getColDef: () => this.column.getColDef(),
      getRowIndex: () => this.cellPosition.rowIndex,
      getRowNode: () => this.rowNode,
      getGui: () => this.getGui(),
      getLocation: () => "cell",
      getTooltipValue,
      getValueFormatted: () => this.valueFormatted
    };
    this.tooltipFeature = new TooltipFeature(tooltipCtrl, this.beans);
    this.addDestroyFunc(() => {
      var _a;
      (_a = this.tooltipFeature) === null || _a === void 0 ? void 0 : _a.destroy();
      this.tooltipFeature = null;
    });
  }
  setComp(comp, eGui, eCellWrapper, printLayout, startEditing) {
    var _a, _b, _c, _d;
    this.cellComp = comp;
    this.eGui = eGui;
    this.printLayout = printLayout;
    this.updateAndFormatValue(true);
    this.addDomData();
    this.onCellFocused();
    this.applyStaticCssClasses();
    this.setWrapText();
    this.onFirstRightPinnedChanged();
    this.onLastLeftPinnedChanged();
    this.onColumnHover();
    this.setupControlComps();
    if (eCellWrapper) {
      this.setupAutoHeight(eCellWrapper);
    }
    this.setAriaColIndex();
    if (!this.beans.gridOptionsService.is("suppressCellFocus")) {
      this.cellComp.setTabIndex(-1);
    }
    const colIdSanitised = escapeString(this.column.getId());
    this.cellComp.setColId(colIdSanitised);
    this.cellComp.setRole("gridcell");
    (_a = this.cellPositionFeature) === null || _a === void 0 ? void 0 : _a.setComp(eGui);
    (_b = this.cellCustomStyleFeature) === null || _b === void 0 ? void 0 : _b.setComp(comp);
    (_c = this.tooltipFeature) === null || _c === void 0 ? void 0 : _c.setComp(comp);
    (_d = this.cellKeyboardListenerFeature) === null || _d === void 0 ? void 0 : _d.setComp(this.eGui);
    if (this.cellRangeFeature) {
      this.cellRangeFeature.setComp(comp, eGui);
    }
    if (startEditing && this.isCellEditable()) {
      this.startEditing();
    } else {
      this.showValue();
    }
    if (this.onCellCompAttachedFuncs.length) {
      this.onCellCompAttachedFuncs.forEach((func) => func());
      this.onCellCompAttachedFuncs = [];
    }
  }
  setupAutoHeight(eCellWrapper) {
    if (!this.column.isAutoHeight()) {
      return;
    }
    const eParentCell = eCellWrapper.parentElement;
    const minRowHeight = this.beans.gridOptionsService.getRowHeightForNode(this.rowNode).height;
    const measureHeight = (timesCalled) => {
      if (this.editing) {
        return;
      }
      if (!this.isAlive()) {
        return;
      }
      const { paddingTop, paddingBottom, borderBottomWidth, borderTopWidth } = getElementSize(eParentCell);
      const extraHeight = paddingTop + paddingBottom + borderBottomWidth + borderTopWidth;
      const wrapperHeight = eCellWrapper.offsetHeight;
      const autoHeight = wrapperHeight + extraHeight;
      if (timesCalled < 5) {
        const doc = this.beans.gridOptionsService.getDocument();
        const notYetInDom = !doc || !doc.contains(eCellWrapper);
        const possiblyNoContentYet = autoHeight == 0;
        if (notYetInDom || possiblyNoContentYet) {
          this.beans.frameworkOverrides.setTimeout(() => measureHeight(timesCalled + 1), 0);
          return;
        }
      }
      const newHeight = Math.max(autoHeight, minRowHeight);
      this.rowNode.setRowAutoHeight(newHeight, this.column);
    };
    const listener = () => measureHeight(0);
    listener();
    const destroyResizeObserver = this.beans.resizeObserverService.observeResize(eCellWrapper, listener);
    this.addDestroyFunc(() => {
      destroyResizeObserver();
      this.rowNode.setRowAutoHeight(void 0, this.column);
    });
  }
  getInstanceId() {
    return this.instanceId;
  }
  showValue(forceNewCellRendererInstance = false) {
    const valueToDisplay = this.valueFormatted != null ? this.valueFormatted : this.value;
    const params = this.createCellRendererParams();
    const compDetails = this.beans.userComponentFactory.getCellRendererDetails(this.column.getColDef(), params);
    this.cellComp.setRenderDetails(compDetails, valueToDisplay, forceNewCellRendererInstance);
    this.refreshHandle();
  }
  setupControlComps() {
    const colDef = this.column.getColDef();
    this.includeSelection = this.isIncludeControl(colDef.checkboxSelection);
    this.includeRowDrag = this.isIncludeControl(colDef.rowDrag);
    this.includeDndSource = this.isIncludeControl(colDef.dndSource);
    this.cellComp.setIncludeSelection(this.includeSelection);
    this.cellComp.setIncludeDndSource(this.includeDndSource);
    this.cellComp.setIncludeRowDrag(this.includeRowDrag);
  }
  isForceWrapper() {
    const forceWrapper = this.beans.gridOptionsService.is("enableCellTextSelection") || this.column.isAutoHeight();
    return forceWrapper;
  }
  isIncludeControl(value) {
    const rowNodePinned = this.rowNode.rowPinned != null;
    const isFunc = typeof value === "function";
    const res = rowNodePinned ? false : isFunc || value === true;
    return res;
  }
  refreshShouldDestroy() {
    const colDef = this.column.getColDef();
    const selectionChanged = this.includeSelection != this.isIncludeControl(colDef.checkboxSelection);
    const rowDragChanged = this.includeRowDrag != this.isIncludeControl(colDef.rowDrag);
    const dndSourceChanged = this.includeDndSource != this.isIncludeControl(colDef.dndSource);
    return selectionChanged || rowDragChanged || dndSourceChanged;
  }
  startEditing(key = null, cellStartedEdit = false, event = null) {
    if (!this.isCellEditable() || this.editing) {
      return;
    }
    if (!this.cellComp) {
      this.onCellCompAttachedFuncs.push(() => {
        this.startEditing(key, cellStartedEdit, event);
      });
      return;
    }
    const editorParams = this.createCellEditorParams(key, cellStartedEdit);
    const colDef = this.column.getColDef();
    const compDetails = this.beans.userComponentFactory.getCellEditorDetails(colDef, editorParams);
    const popup = (compDetails === null || compDetails === void 0 ? void 0 : compDetails.popupFromSelector) != null ? compDetails.popupFromSelector : !!colDef.cellEditorPopup;
    const position = (compDetails === null || compDetails === void 0 ? void 0 : compDetails.popupPositionFromSelector) != null ? compDetails.popupPositionFromSelector : colDef.cellEditorPopupPosition;
    this.setEditing(true);
    this.cellComp.setEditDetails(compDetails, popup, position);
    const e = this.createEvent(event, Events.EVENT_CELL_EDITING_STARTED);
    this.beans.eventService.dispatchEvent(e);
  }
  setEditing(editing) {
    if (this.editing === editing) {
      return;
    }
    this.editing = editing;
    this.refreshHandle();
  }
  stopRowOrCellEdit(cancel = false) {
    if (this.beans.gridOptionsService.get("editType") === "fullRow") {
      this.rowCtrl.stopRowEditing(cancel);
    } else {
      this.stopEditing(cancel);
    }
  }
  onPopupEditorClosed() {
    if (!this.isEditing()) {
      return;
    }
    this.stopEditingAndFocus();
  }
  takeValueFromCellEditor(cancel) {
    const noValueResult = { newValueExists: false };
    if (cancel) {
      return noValueResult;
    }
    const cellEditor = this.cellComp.getCellEditor();
    if (!cellEditor) {
      return noValueResult;
    }
    const userWantsToCancel = cellEditor.isCancelAfterEnd && cellEditor.isCancelAfterEnd();
    if (userWantsToCancel) {
      return noValueResult;
    }
    const newValue = cellEditor.getValue();
    return {
      newValue,
      newValueExists: true
    };
  }
  saveNewValue(oldValue, newValue) {
    if (newValue === oldValue) {
      return false;
    }
    this.suppressRefreshCell = true;
    const valueChanged = this.rowNode.setDataValue(this.column, newValue, "edit");
    this.suppressRefreshCell = false;
    return valueChanged;
  }
  stopEditing(cancel = false) {
    if (!this.editing) {
      return false;
    }
    const { newValue, newValueExists } = this.takeValueFromCellEditor(cancel);
    const oldValue = this.rowNode.getValueFromValueService(this.column);
    let valueChanged = false;
    if (newValueExists) {
      valueChanged = this.saveNewValue(oldValue, newValue);
    }
    this.setEditing(false);
    this.cellComp.setEditDetails();
    this.updateAndFormatValue();
    this.refreshCell({ forceRefresh: true, suppressFlash: true });
    this.dispatchEditingStoppedEvent(oldValue, newValue, !cancel && !!valueChanged);
    return valueChanged;
  }
  dispatchEditingStoppedEvent(oldValue, newValue, valueChanged) {
    const editingStoppedEvent = Object.assign(Object.assign({}, this.createEvent(null, Events.EVENT_CELL_EDITING_STOPPED)), {
      oldValue,
      newValue,
      valueChanged
    });
    this.beans.eventService.dispatchEvent(editingStoppedEvent);
  }
  createCellEditorParams(key, cellStartedEdit) {
    return {
      value: this.rowNode.getValueFromValueService(this.column),
      eventKey: key,
      column: this.column,
      colDef: this.column.getColDef(),
      rowIndex: this.getCellPosition().rowIndex,
      node: this.rowNode,
      data: this.rowNode.data,
      api: this.beans.gridOptionsService.api,
      cellStartedEdit,
      columnApi: this.beans.gridOptionsService.columnApi,
      context: this.beans.gridOptionsService.context,
      onKeyDown: this.onKeyDown.bind(this),
      stopEditing: this.stopEditingAndFocus.bind(this),
      eGridCell: this.getGui(),
      parseValue: this.parseValue.bind(this),
      formatValue: this.formatValue.bind(this)
    };
  }
  createCellRendererParams() {
    const res = {
      value: this.value,
      valueFormatted: this.valueFormatted,
      getValue: () => this.rowNode.getValueFromValueService(this.column),
      setValue: (value) => this.beans.valueService.setValue(this.rowNode, this.column, value),
      formatValue: this.formatValue.bind(this),
      data: this.rowNode.data,
      node: this.rowNode,
      pinned: this.column.getPinned(),
      colDef: this.column.getColDef(),
      column: this.column,
      rowIndex: this.getCellPosition().rowIndex,
      api: this.beans.gridOptionsService.api,
      columnApi: this.beans.gridOptionsService.columnApi,
      context: this.beans.gridOptionsService.context,
      refreshCell: this.refreshCell.bind(this),
      eGridCell: this.getGui(),
      eParentOfValue: this.cellComp.getParentOfValue(),
      registerRowDragger: (rowDraggerElement, dragStartPixels, value, suppressVisibilityChange) => this.registerRowDragger(rowDraggerElement, dragStartPixels, suppressVisibilityChange)
    };
    return res;
  }
  parseValue(newValue) {
    return this.beans.valueParserService.parseValue(this.column, this.rowNode, newValue, this.getValue());
  }
  setFocusOutOnEditor() {
    if (!this.editing) {
      return;
    }
    const cellEditor = this.cellComp.getCellEditor();
    if (cellEditor && cellEditor.focusOut) {
      cellEditor.focusOut();
    }
  }
  setFocusInOnEditor() {
    if (!this.editing) {
      return;
    }
    const cellEditor = this.cellComp.getCellEditor();
    if (cellEditor && cellEditor.focusIn) {
      cellEditor.focusIn();
    } else {
      this.focusCell(true);
    }
  }
  onCellChanged(event) {
    if (!this.cellComp) {
      return;
    }
    const eventImpactsThisCell = event.column === this.column;
    if (eventImpactsThisCell) {
      this.refreshCell({});
    }
  }
  refreshCell(params) {
    var _a, _b, _c;
    if (this.suppressRefreshCell || this.editing) {
      return;
    }
    if (!this.cellComp) {
      return;
    }
    const colDef = this.column.getColDef();
    const newData = params != null && !!params.newData;
    const suppressFlash = params != null && !!params.suppressFlash || !!colDef.suppressCellFlash;
    const noValueProvided = colDef.field == null && colDef.valueGetter == null && colDef.showRowGroup == null;
    const forceRefresh = params && params.forceRefresh || noValueProvided || newData;
    const valuesDifferent = this.updateAndFormatValue();
    const dataNeedsUpdating = forceRefresh || valuesDifferent;
    if (dataNeedsUpdating) {
      this.showValue(newData);
      const processingFilterChange = this.beans.filterManager.isSuppressFlashingCellsBecauseFiltering();
      const flashCell = !suppressFlash && !processingFilterChange && (this.beans.gridOptionsService.is("enableCellChangeFlash") || colDef.enableCellChangeFlash);
      if (flashCell) {
        this.flashCell();
      }
      (_a = this.cellCustomStyleFeature) === null || _a === void 0 ? void 0 : _a.applyUserStyles();
      (_b = this.cellCustomStyleFeature) === null || _b === void 0 ? void 0 : _b.applyClassesFromColDef();
    }
    this.refreshToolTip();
    (_c = this.cellCustomStyleFeature) === null || _c === void 0 ? void 0 : _c.applyCellClassRules();
  }
  stopEditingAndFocus(suppressNavigateAfterEdit = false, shiftKey = false) {
    this.stopRowOrCellEdit();
    this.focusCell(true);
    if (!suppressNavigateAfterEdit) {
      this.navigateAfterEdit(shiftKey);
    }
  }
  navigateAfterEdit(shiftKey) {
    const enterNavigatesVerticallyAfterEdit = this.beans.gridOptionsService.is("enterNavigatesVerticallyAfterEdit");
    if (enterNavigatesVerticallyAfterEdit) {
      const key = shiftKey ? KeyCode.UP : KeyCode.DOWN;
      this.beans.navigationService.navigateToNextCell(null, key, this.getCellPosition(), false);
    }
  }
  flashCell(delays) {
    const flashDelay = delays && delays.flashDelay;
    const fadeDelay = delays && delays.fadeDelay;
    this.animateCell("data-changed", flashDelay, fadeDelay);
  }
  animateCell(cssName, flashDelay, fadeDelay) {
    var _a, _b;
    const fullName = `ag-cell-${cssName}`;
    const animationFullName = `ag-cell-${cssName}-animation`;
    const { gridOptionsService } = this.beans;
    if (!flashDelay) {
      flashDelay = (_a = gridOptionsService.getNum("cellFlashDelay")) !== null && _a !== void 0 ? _a : 500;
    }
    if (!exists(fadeDelay)) {
      fadeDelay = (_b = gridOptionsService.getNum("cellFadeDelay")) !== null && _b !== void 0 ? _b : 1e3;
    }
    this.cellComp.addOrRemoveCssClass(fullName, true);
    this.cellComp.addOrRemoveCssClass(animationFullName, false);
    window.setTimeout(() => {
      if (!this.isAlive()) {
        return;
      }
      this.cellComp.addOrRemoveCssClass(fullName, false);
      this.cellComp.addOrRemoveCssClass(animationFullName, true);
      this.eGui.style.transition = `background-color ${fadeDelay}ms`;
      window.setTimeout(() => {
        if (!this.isAlive()) {
          return;
        }
        this.cellComp.addOrRemoveCssClass(animationFullName, false);
        this.eGui.style.transition = "";
      }, fadeDelay);
    }, flashDelay);
  }
  onFlashCells(event) {
    if (!this.cellComp) {
      return;
    }
    const cellId = this.beans.cellPositionUtils.createId(this.getCellPosition());
    const shouldFlash = event.cells[cellId];
    if (shouldFlash) {
      this.animateCell("highlight");
    }
  }
  isCellEditable() {
    return this.column.isCellEditable(this.rowNode);
  }
  isSuppressFillHandle() {
    return this.column.isSuppressFillHandle();
  }
  formatValue(value) {
    const res = this.callValueFormatter(value);
    return res != null ? res : value;
  }
  callValueFormatter(value) {
    return this.beans.valueFormatterService.formatValue(this.column, this.rowNode, value);
  }
  updateAndFormatValue(force = false) {
    const oldValue = this.value;
    const oldValueFormatted = this.valueFormatted;
    this.value = this.rowNode.getValueFromValueService(this.column);
    this.valueFormatted = this.callValueFormatter(this.value);
    const valuesDifferent = force ? true : !this.valuesAreEqual(oldValue, this.value) || this.valueFormatted != oldValueFormatted;
    return valuesDifferent;
  }
  valuesAreEqual(val1, val2) {
    const colDef = this.column.getColDef();
    return colDef.equals ? colDef.equals(val1, val2) : val1 === val2;
  }
  getComp() {
    return this.cellComp;
  }
  getValue() {
    return this.value;
  }
  getValueFormatted() {
    return this.valueFormatted;
  }
  addDomData() {
    const element = this.getGui();
    this.beans.gridOptionsService.setDomData(element, CellCtrl.DOM_DATA_KEY_CELL_CTRL, this);
    this.addDestroyFunc(() => this.beans.gridOptionsService.setDomData(element, CellCtrl.DOM_DATA_KEY_CELL_CTRL, null));
  }
  createEvent(domEvent, eventType) {
    const event = {
      type: eventType,
      node: this.rowNode,
      data: this.rowNode.data,
      value: this.value,
      column: this.column,
      colDef: this.column.getColDef(),
      context: this.beans.gridOptionsService.context,
      api: this.beans.gridApi,
      columnApi: this.beans.columnApi,
      rowPinned: this.rowNode.rowPinned,
      event: domEvent,
      rowIndex: this.rowNode.rowIndex
    };
    return event;
  }
  processCharacter(event) {
    var _a;
    (_a = this.cellKeyboardListenerFeature) === null || _a === void 0 ? void 0 : _a.processCharacter(event);
  }
  onKeyDown(event) {
    var _a;
    (_a = this.cellKeyboardListenerFeature) === null || _a === void 0 ? void 0 : _a.onKeyDown(event);
  }
  onMouseEvent(eventName, mouseEvent) {
    var _a;
    (_a = this.cellMouseListenerFeature) === null || _a === void 0 ? void 0 : _a.onMouseEvent(eventName, mouseEvent);
  }
  getGui() {
    return this.eGui;
  }
  refreshToolTip() {
    var _a;
    (_a = this.tooltipFeature) === null || _a === void 0 ? void 0 : _a.refreshToolTip();
  }
  getColSpanningList() {
    return this.cellPositionFeature.getColSpanningList();
  }
  onLeftChanged() {
    var _a;
    if (!this.cellComp) {
      return;
    }
    (_a = this.cellPositionFeature) === null || _a === void 0 ? void 0 : _a.onLeftChanged();
  }
  onDisplayedColumnsChanged() {
    if (!this.eGui) {
      return;
    }
    this.setAriaColIndex();
  }
  setAriaColIndex() {
    const colIdx = this.beans.columnModel.getAriaColumnIndex(this.column);
    setAriaColIndex(this.getGui(), colIdx);
  }
  isSuppressNavigable() {
    return this.column.isSuppressNavigable(this.rowNode);
  }
  onWidthChanged() {
    var _a;
    return (_a = this.cellPositionFeature) === null || _a === void 0 ? void 0 : _a.onWidthChanged();
  }
  getColumn() {
    return this.column;
  }
  getRowNode() {
    return this.rowNode;
  }
  getBeans() {
    return this.beans;
  }
  isPrintLayout() {
    return this.printLayout;
  }
  appendChild(htmlElement) {
    this.eGui.appendChild(htmlElement);
  }
  refreshHandle() {
    if (this.cellRangeFeature) {
      this.cellRangeFeature.refreshHandle();
    }
  }
  getCellPosition() {
    return this.cellPosition;
  }
  isEditing() {
    return this.editing;
  }
  startRowOrCellEdit(key, event = null) {
    if (!this.cellComp) {
      return;
    }
    if (this.beans.gridOptionsService.get("editType") === "fullRow") {
      this.rowCtrl.startRowEditing(key, this);
    } else {
      this.startEditing(key, true, event);
    }
  }
  getRowCtrl() {
    return this.rowCtrl;
  }
  getRowPosition() {
    return {
      rowIndex: this.cellPosition.rowIndex,
      rowPinned: this.cellPosition.rowPinned
    };
  }
  updateRangeBordersIfRangeCount() {
    if (!this.cellComp) {
      return;
    }
    if (this.cellRangeFeature) {
      this.cellRangeFeature.updateRangeBordersIfRangeCount();
    }
  }
  onRangeSelectionChanged() {
    if (!this.cellComp) {
      return;
    }
    if (this.cellRangeFeature) {
      this.cellRangeFeature.onRangeSelectionChanged();
    }
  }
  isRangeSelectionEnabled() {
    return this.cellRangeFeature != null;
  }
  focusCell(forceBrowserFocus = false) {
    this.beans.focusService.setFocusedCell({
      rowIndex: this.getCellPosition().rowIndex,
      column: this.column,
      rowPinned: this.rowNode.rowPinned,
      forceBrowserFocus
    });
  }
  onRowIndexChanged() {
    this.createCellPosition();
    this.onCellFocused();
    if (this.cellRangeFeature) {
      this.cellRangeFeature.onRangeSelectionChanged();
    }
  }
  onFirstRightPinnedChanged() {
    if (!this.cellComp) {
      return;
    }
    const firstRightPinned = this.column.isFirstRightPinned();
    this.cellComp.addOrRemoveCssClass(CSS_CELL_FIRST_RIGHT_PINNED, firstRightPinned);
  }
  onLastLeftPinnedChanged() {
    if (!this.cellComp) {
      return;
    }
    const lastLeftPinned = this.column.isLastLeftPinned();
    this.cellComp.addOrRemoveCssClass(CSS_CELL_LAST_LEFT_PINNED, lastLeftPinned);
  }
  onCellFocused(event) {
    if (!this.cellComp || this.beans.gridOptionsService.is("suppressCellFocus")) {
      return;
    }
    const cellFocused = this.beans.focusService.isCellFocused(this.cellPosition);
    this.cellComp.addOrRemoveCssClass(CSS_CELL_FOCUS, cellFocused);
    if (cellFocused && event && event.forceBrowserFocus) {
      const focusEl = this.cellComp.getFocusableElement();
      focusEl.focus({ preventScroll: !!event.preventScrollOnBrowserFocus });
    }
    const fullRowEdit = this.beans.gridOptionsService.get("editType") === "fullRow";
    if (!cellFocused && !fullRowEdit && this.editing) {
      this.stopRowOrCellEdit();
    }
  }
  createCellPosition() {
    this.cellPosition = {
      rowIndex: this.rowNode.rowIndex,
      rowPinned: makeNull(this.rowNode.rowPinned),
      column: this.column
    };
  }
  applyStaticCssClasses() {
    this.cellComp.addOrRemoveCssClass(CSS_CELL, true);
    this.cellComp.addOrRemoveCssClass(CSS_CELL_NOT_INLINE_EDITING, true);
    const autoHeight = this.column.isAutoHeight() == true;
    this.cellComp.addOrRemoveCssClass(CSS_AUTO_HEIGHT, autoHeight);
    this.cellComp.addOrRemoveCssClass(CSS_NORMAL_HEIGHT, !autoHeight);
  }
  onColumnHover() {
    if (!this.cellComp) {
      return;
    }
    if (!this.beans.gridOptionsService.is("columnHoverHighlight")) {
      return;
    }
    const isHovered = this.beans.columnHoverService.isHovered(this.column);
    this.cellComp.addOrRemoveCssClass(CSS_COLUMN_HOVER, isHovered);
  }
  onColDefChanged() {
    if (!this.cellComp) {
      return;
    }
    this.setWrapText();
    if (!this.editing) {
      this.refreshCell({ forceRefresh: true, suppressFlash: true });
    }
  }
  setWrapText() {
    const value = this.column.getColDef().wrapText == true;
    this.cellComp.addOrRemoveCssClass(CSS_CELL_WRAP_TEXT, value);
  }
  dispatchCellContextMenuEvent(event) {
    const colDef = this.column.getColDef();
    const cellContextMenuEvent = this.createEvent(event, Events.EVENT_CELL_CONTEXT_MENU);
    this.beans.eventService.dispatchEvent(cellContextMenuEvent);
    if (colDef.onCellContextMenu) {
      window.setTimeout(() => colDef.onCellContextMenu(cellContextMenuEvent), 0);
    }
  }
  getCellRenderer() {
    return this.cellComp ? this.cellComp.getCellRenderer() : null;
  }
  getCellEditor() {
    return this.cellComp ? this.cellComp.getCellEditor() : null;
  }
  destroy() {
    this.onCellCompAttachedFuncs = [];
    super.destroy();
  }
  createSelectionCheckbox() {
    const cbSelectionComponent = new CheckboxSelectionComponent();
    this.beans.context.createBean(cbSelectionComponent);
    cbSelectionComponent.init({ rowNode: this.rowNode, column: this.column });
    return cbSelectionComponent;
  }
  createDndSource() {
    const dndSourceComp = new DndSourceComp(this.rowNode, this.column, this.eGui);
    this.beans.context.createBean(dndSourceComp);
    return dndSourceComp;
  }
  registerRowDragger(customElement, dragStartPixels, suppressVisibilityChange) {
    if (this.customRowDragComp) {
      this.customRowDragComp.setDragElement(customElement, dragStartPixels);
      return;
    }
    const newComp = this.createRowDragComp(customElement, dragStartPixels, suppressVisibilityChange);
    if (newComp) {
      this.customRowDragComp = newComp;
      this.addDestroyFunc(() => {
        this.beans.context.destroyBean(newComp);
        this.customRowDragComp = null;
      });
    }
  }
  createRowDragComp(customElement, dragStartPixels, suppressVisibilityChange) {
    const pagination = this.beans.gridOptionsService.is("pagination");
    const rowDragManaged = this.beans.gridOptionsService.is("rowDragManaged");
    const clientSideRowModelActive = this.beans.gridOptionsService.isRowModelType("clientSide");
    if (rowDragManaged) {
      if (!clientSideRowModelActive) {
        doOnce(() => console.warn("AG Grid: managed row dragging is only allowed in the Client Side Row Model"), "CellComp.addRowDragging");
        return;
      }
      if (pagination) {
        doOnce(() => console.warn("AG Grid: managed row dragging is not possible when doing pagination"), "CellComp.addRowDragging");
        return;
      }
    }
    const rowDragComp = new RowDragComp(() => this.value, this.rowNode, this.column, customElement, dragStartPixels, suppressVisibilityChange);
    this.beans.context.createBean(rowDragComp);
    return rowDragComp;
  }
};
CellCtrl.DOM_DATA_KEY_CELL_CTRL = "cellCtrl";
var RowType$1;
(function(RowType2) {
  RowType2["Normal"] = "Normal";
  RowType2["FullWidth"] = "FullWidth";
  RowType2["FullWidthLoading"] = "FullWidthLoading";
  RowType2["FullWidthGroup"] = "FullWidthGroup";
  RowType2["FullWidthDetail"] = "FullWidthDetail";
})(RowType$1 || (RowType$1 = {}));
var instanceIdSequence$2 = 0;
var RowCtrl = class extends BeanStub {
  constructor(rowNode, beans, animateIn, useAnimationFrameForCreate, printLayout) {
    super();
    this.allRowGuis = [];
    this.active = true;
    this.centerCellCtrls = { list: [], map: {} };
    this.leftCellCtrls = { list: [], map: {} };
    this.rightCellCtrls = { list: [], map: {} };
    this.slideInAnimation = {
      left: false,
      center: false,
      right: false,
      fullWidth: false
    };
    this.fadeInAnimation = {
      left: false,
      center: false,
      right: false,
      fullWidth: false
    };
    this.lastMouseDownOnDragger = false;
    this.updateColumnListsPending = false;
    this.businessKeySanitised = null;
    this.beans = beans;
    this.gridOptionsService = beans.gridOptionsService;
    this.rowNode = rowNode;
    this.paginationPage = beans.paginationProxy.getCurrentPage();
    this.useAnimationFrameForCreate = useAnimationFrameForCreate;
    this.printLayout = printLayout;
    this.instanceId = rowNode.id + "-" + instanceIdSequence$2++;
    this.setAnimateFlags(animateIn);
    this.initRowBusinessKey();
    this.rowFocused = beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    this.rowLevel = beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
    this.setRowType();
    this.addListeners();
  }
  initRowBusinessKey() {
    this.businessKeyForNodeFunc = this.gridOptionsService.get("getBusinessKeyForNode");
    this.updateRowBusinessKey();
  }
  updateRowBusinessKey() {
    if (typeof this.businessKeyForNodeFunc !== "function") {
      return;
    }
    const businessKey = this.businessKeyForNodeFunc(this.rowNode);
    this.businessKeySanitised = escapeString(businessKey);
  }
  isSticky() {
    return this.rowNode.sticky;
  }
  getBeans() {
    return this.beans;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setComp(rowComp, element, containerType) {
    const gui = { rowComp, element, containerType };
    this.allRowGuis.push(gui);
    if (containerType === RowContainerType.LEFT) {
      this.leftGui = gui;
    } else if (containerType === RowContainerType.RIGHT) {
      this.rightGui = gui;
    } else if (containerType === RowContainerType.FULL_WIDTH) {
      this.fullWidthGui = gui;
    } else {
      this.centerGui = gui;
    }
    this.initialiseRowComp(gui);
    if (this.rowType !== "FullWidthLoading" && !this.rowNode.rowPinned) {
      this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
    }
  }
  unsetComp(containerType) {
    this.allRowGuis = this.allRowGuis.filter((rowGui) => rowGui.containerType !== containerType);
    if (containerType === RowContainerType.LEFT) {
      this.leftGui = void 0;
    } else if (containerType === RowContainerType.RIGHT) {
      this.rightGui = void 0;
    } else if (containerType === RowContainerType.FULL_WIDTH) {
      this.fullWidthGui = void 0;
    }
  }
  isCacheable() {
    return this.rowType === RowType$1.FullWidthDetail && this.gridOptionsService.is("keepDetailRows");
  }
  setCached(cached) {
    const displayValue = cached ? "none" : "";
    this.allRowGuis.forEach((rg) => rg.element.style.display = displayValue);
  }
  initialiseRowComp(gui) {
    const gos = this.gridOptionsService;
    this.listenOnDomOrder(gui);
    this.onRowHeightChanged(gui);
    this.updateRowIndexes(gui);
    this.setFocusedClasses(gui);
    this.setStylesFromGridOptions(gui);
    if (gos.isRowSelection() && this.rowNode.selectable) {
      this.onRowSelected(gui);
    }
    this.updateColumnLists(!this.useAnimationFrameForCreate);
    const comp = gui.rowComp;
    comp.setRole("row");
    const initialRowClasses = this.getInitialRowClasses(gui.containerType);
    initialRowClasses.forEach((name) => comp.addOrRemoveCssClass(name, true));
    this.executeSlideAndFadeAnimations(gui);
    if (this.rowNode.group) {
      setAriaExpanded(gui.element, this.rowNode.expanded == true);
    }
    this.setRowCompRowId(comp);
    this.setRowCompRowBusinessKey(comp);
    if (this.isFullWidth() && !this.gridOptionsService.is("suppressCellFocus")) {
      comp.setTabIndex(-1);
    }
    gos.setDomData(gui.element, RowCtrl.DOM_DATA_KEY_ROW_CTRL, this);
    this.addDestroyFunc(() => gos.setDomData(gui.element, RowCtrl.DOM_DATA_KEY_ROW_CTRL, null));
    if (this.useAnimationFrameForCreate) {
      this.beans.animationFrameService.createTask(this.addHoverFunctionality.bind(this, gui.element), this.rowNode.rowIndex, "createTasksP2");
    } else {
      this.addHoverFunctionality(gui.element);
    }
    if (this.isFullWidth()) {
      this.setupFullWidth(gui);
    }
    if (gos.is("rowDragEntireRow")) {
      this.addRowDraggerToRow(gui);
    }
    if (this.useAnimationFrameForCreate) {
      this.beans.animationFrameService.addDestroyTask(() => {
        if (!this.isAlive()) {
          return;
        }
        gui.rowComp.addOrRemoveCssClass("ag-after-created", true);
      });
    }
    this.executeProcessRowPostCreateFunc();
  }
  setRowCompRowBusinessKey(comp) {
    if (this.businessKeySanitised == null) {
      return;
    }
    comp.setRowBusinessKey(this.businessKeySanitised);
  }
  setRowCompRowId(comp) {
    const rowId = escapeString(this.rowNode.id);
    if (rowId == null) {
      return;
    }
    comp.setRowId(rowId);
  }
  executeSlideAndFadeAnimations(gui) {
    const { containerType } = gui;
    const shouldSlide = this.slideInAnimation[containerType];
    if (shouldSlide) {
      executeNextVMTurn(() => {
        this.onTopChanged();
      });
      this.slideInAnimation[containerType] = false;
    }
    const shouldFade = this.fadeInAnimation[containerType];
    if (shouldFade) {
      executeNextVMTurn(() => {
        gui.rowComp.addOrRemoveCssClass("ag-opacity-zero", false);
      });
      this.fadeInAnimation[containerType] = false;
    }
  }
  addRowDraggerToRow(gui) {
    if (this.gridOptionsService.isEnableRangeSelection()) {
      doOnce(() => {
        console.warn("AG Grid: Setting `rowDragEntireRow: true` in the gridOptions doesn't work with `enableRangeSelection: true`");
      }, "rowDragAndRangeSelectionEnabled");
      return;
    }
    const translate = this.beans.localeService.getLocaleTextFunc();
    const rowDragComp = new RowDragComp(() => `1 ${translate("rowDragRow", "row")}`, this.rowNode, void 0, gui.element, void 0, true);
    this.createManagedBean(rowDragComp, this.beans.context);
  }
  setupFullWidth(gui) {
    const pinned = this.getPinnedForContainer(gui.containerType);
    const params = this.createFullWidthParams(gui.element, pinned);
    if (this.rowType == RowType$1.FullWidthDetail) {
      if (!ModuleRegistry.assertRegistered(ModuleNames.MasterDetailModule, "cell renderer 'agDetailCellRenderer' (for master detail)", this.beans.context.getGridId())) {
        return;
      }
    }
    let compDetails;
    switch (this.rowType) {
      case RowType$1.FullWidthDetail:
        compDetails = this.beans.userComponentFactory.getFullWidthDetailCellRendererDetails(params);
        break;
      case RowType$1.FullWidthGroup:
        compDetails = this.beans.userComponentFactory.getFullWidthGroupCellRendererDetails(params);
        break;
      case RowType$1.FullWidthLoading:
        compDetails = this.beans.userComponentFactory.getFullWidthLoadingCellRendererDetails(params);
        break;
      default:
        compDetails = this.beans.userComponentFactory.getFullWidthCellRendererDetails(params);
        break;
    }
    gui.rowComp.showFullWidth(compDetails);
  }
  isPrintLayout() {
    return this.printLayout;
  }
  getFullWidthCellRenderer() {
    var _a, _b;
    return (_b = (_a = this.fullWidthGui) === null || _a === void 0 ? void 0 : _a.rowComp) === null || _b === void 0 ? void 0 : _b.getFullWidthCellRenderer();
  }
  getCellElement(column) {
    const cellCtrl = this.getCellCtrl(column);
    return cellCtrl ? cellCtrl.getGui() : null;
  }
  executeProcessRowPostCreateFunc() {
    var _a;
    const func = this.gridOptionsService.getCallback("processRowPostCreate");
    if (!func || !this.areAllContainersReady()) {
      return;
    }
    const params = {
      eRow: (_a = this.centerGui) === null || _a === void 0 ? void 0 : _a.element,
      ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
      ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
      node: this.rowNode,
      rowIndex: this.rowNode.rowIndex,
      addRenderedRowListener: this.addEventListener.bind(this)
    };
    func(params);
  }
  areAllContainersReady() {
    const isLeftReady = !!this.leftGui || !this.beans.columnModel.isPinningLeft();
    const isCenterReady = !!this.centerGui;
    const isRightReady = !!this.rightGui || !this.beans.columnModel.isPinningRight();
    return isLeftReady && isCenterReady && isRightReady;
  }
  setRowType() {
    const isStub = this.rowNode.stub;
    const isFullWidthCell = this.rowNode.isFullWidthCell();
    const isDetailCell = this.beans.doingMasterDetail && this.rowNode.detail;
    const pivotMode = this.beans.columnModel.isPivotMode();
    const isGroupRow = !!this.rowNode.group && !this.rowNode.footer;
    const isFullWidthGroup = isGroupRow && this.gridOptionsService.isGroupUseEntireRow(pivotMode);
    if (isStub) {
      this.rowType = RowType$1.FullWidthLoading;
    } else if (isDetailCell) {
      this.rowType = RowType$1.FullWidthDetail;
    } else if (isFullWidthCell) {
      this.rowType = RowType$1.FullWidth;
    } else if (isFullWidthGroup) {
      this.rowType = RowType$1.FullWidthGroup;
    } else {
      this.rowType = RowType$1.Normal;
    }
  }
  updateColumnLists(suppressAnimationFrame = false, useFlushSync = false) {
    if (this.isFullWidth()) {
      return;
    }
    const noAnimation = suppressAnimationFrame || this.gridOptionsService.is("suppressAnimationFrame") || this.printLayout;
    if (noAnimation) {
      this.updateColumnListsImpl(useFlushSync);
      return;
    }
    if (this.updateColumnListsPending) {
      return;
    }
    this.beans.animationFrameService.createTask(() => {
      if (!this.active) {
        return;
      }
      this.updateColumnListsImpl(true);
    }, this.rowNode.rowIndex, "createTasksP1");
    this.updateColumnListsPending = true;
  }
  createCellCtrls(prev, cols, pinned = null) {
    const res = {
      list: [],
      map: {}
    };
    const addCell = (colInstanceId, cellCtrl) => {
      res.list.push(cellCtrl);
      res.map[colInstanceId] = cellCtrl;
    };
    cols.forEach((col) => {
      const colInstanceId = col.getInstanceId();
      let cellCtrl = prev.map[colInstanceId];
      if (!cellCtrl) {
        cellCtrl = new CellCtrl(col, this.rowNode, this.beans, this);
      }
      addCell(colInstanceId, cellCtrl);
    });
    prev.list.forEach((prevCellCtrl) => {
      const cellInResult = res.map[prevCellCtrl.getColumn().getInstanceId()] != null;
      if (cellInResult) {
        return;
      }
      const keepCell = !this.isCellEligibleToBeRemoved(prevCellCtrl, pinned);
      if (keepCell) {
        addCell(prevCellCtrl.getColumn().getInstanceId(), prevCellCtrl);
        return;
      }
      prevCellCtrl.destroy();
    });
    return res;
  }
  updateColumnListsImpl(useFlushSync = false) {
    this.updateColumnListsPending = false;
    const columnModel = this.beans.columnModel;
    if (this.printLayout) {
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, columnModel.getAllDisplayedColumns());
      this.leftCellCtrls = { list: [], map: {} };
      this.rightCellCtrls = { list: [], map: {} };
    } else {
      const centerCols = columnModel.getViewportCenterColumnsForRow(this.rowNode);
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, centerCols);
      const leftCols = columnModel.getDisplayedLeftColumnsForRow(this.rowNode);
      this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, leftCols, "left");
      const rightCols = columnModel.getDisplayedRightColumnsForRow(this.rowNode);
      this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, rightCols, "right");
    }
    this.allRowGuis.forEach((item) => {
      const cellControls = item.containerType === RowContainerType.LEFT ? this.leftCellCtrls : item.containerType === RowContainerType.RIGHT ? this.rightCellCtrls : this.centerCellCtrls;
      item.rowComp.setCellCtrls(cellControls.list, useFlushSync);
    });
  }
  isCellEligibleToBeRemoved(cellCtrl, nextContainerPinned) {
    const REMOVE_CELL = true;
    const KEEP_CELL = false;
    const column = cellCtrl.getColumn();
    if (column.getPinned() != nextContainerPinned) {
      return REMOVE_CELL;
    }
    const editing = cellCtrl.isEditing();
    const focused = this.beans.focusService.isCellFocused(cellCtrl.getCellPosition());
    const mightWantToKeepCell = editing || focused;
    if (mightWantToKeepCell) {
      const column2 = cellCtrl.getColumn();
      const displayedColumns = this.beans.columnModel.getAllDisplayedColumns();
      const cellStillDisplayed = displayedColumns.indexOf(column2) >= 0;
      return cellStillDisplayed ? KEEP_CELL : REMOVE_CELL;
    }
    return REMOVE_CELL;
  }
  listenOnDomOrder(gui) {
    const listener = () => {
      const isEnsureDomOrder = this.gridOptionsService.is("ensureDomOrder");
      const isPrintLayout = this.gridOptionsService.isDomLayout("print");
      gui.rowComp.setDomOrder(isEnsureDomOrder || isPrintLayout);
    };
    this.addManagedPropertyListener("domLayout", listener);
    listener();
  }
  setAnimateFlags(animateIn) {
    if (this.isSticky() || !animateIn) {
      return;
    }
    const oldRowTopExists = exists(this.rowNode.oldRowTop);
    const pinningLeft = this.beans.columnModel.isPinningLeft();
    const pinningRight = this.beans.columnModel.isPinningRight();
    if (oldRowTopExists) {
      this.slideInAnimation.center = true;
      this.slideInAnimation.left = pinningLeft;
      this.slideInAnimation.right = pinningRight;
    } else {
      this.fadeInAnimation.center = true;
      this.fadeInAnimation.left = pinningLeft;
      this.fadeInAnimation.right = pinningRight;
    }
  }
  isEditing() {
    return this.editingRow;
  }
  stopRowEditing(cancel) {
    this.stopEditing(cancel);
  }
  isFullWidth() {
    return this.rowType !== RowType$1.Normal;
  }
  getRowType() {
    return this.rowType;
  }
  refreshFullWidth() {
    const tryRefresh = (gui, pinned) => {
      if (!gui) {
        return true;
      }
      const cellRenderer = gui.rowComp.getFullWidthCellRenderer();
      if (!cellRenderer) {
        return false;
      }
      if (!cellRenderer.refresh) {
        return false;
      }
      const params = this.createFullWidthParams(gui.element, pinned);
      const refreshSucceeded = cellRenderer.refresh(params);
      return refreshSucceeded;
    };
    const fullWidthSuccess = tryRefresh(this.fullWidthGui, null);
    const centerSuccess = tryRefresh(this.centerGui, null);
    const leftSuccess = tryRefresh(this.leftGui, "left");
    const rightSuccess = tryRefresh(this.rightGui, "right");
    const allFullWidthRowsRefreshed = fullWidthSuccess && centerSuccess && leftSuccess && rightSuccess;
    return allFullWidthRowsRefreshed;
  }
  addListeners() {
    this.addManagedListener(this.rowNode, RowNode.EVENT_HEIGHT_CHANGED, () => this.onRowHeightChanged());
    this.addManagedListener(this.rowNode, RowNode.EVENT_ROW_SELECTED, () => this.onRowSelected());
    this.addManagedListener(this.rowNode, RowNode.EVENT_ROW_INDEX_CHANGED, this.onRowIndexChanged.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_TOP_CHANGED, this.onTopChanged.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_EXPANDED_CHANGED, this.updateExpandedCss.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_HAS_CHILDREN_CHANGED, this.updateExpandedCss.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_DATA_CHANGED, this.onRowNodeDataChanged.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_CELL_CHANGED, this.onRowNodeCellChanged.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_HIGHLIGHT_CHANGED, this.onRowNodeHighlightChanged.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_DRAGGING_CHANGED, this.onRowNodeDraggingChanged.bind(this));
    this.addManagedListener(this.rowNode, RowNode.EVENT_UI_LEVEL_CHANGED, this.onUiLevelChanged.bind(this));
    const eventService = this.beans.eventService;
    this.addManagedListener(eventService, Events.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED, this.onPaginationPixelOffsetChanged.bind(this));
    this.addManagedListener(eventService, Events.EVENT_HEIGHT_SCALE_CHANGED, this.onTopChanged.bind(this));
    this.addManagedListener(eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
    this.addManagedListener(eventService, Events.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this));
    this.addManagedListener(eventService, Events.EVENT_CELL_FOCUSED, this.onCellFocused.bind(this));
    this.addManagedListener(eventService, Events.EVENT_CELL_FOCUS_CLEARED, this.onCellFocusCleared.bind(this));
    this.addManagedListener(eventService, Events.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this));
    this.addManagedListener(eventService, Events.EVENT_MODEL_UPDATED, this.onModelUpdated.bind(this));
    this.addManagedListener(eventService, Events.EVENT_COLUMN_MOVED, this.onColumnMoved.bind(this));
    this.addListenersForCellComps();
  }
  onColumnMoved() {
    this.updateColumnLists();
  }
  addListenersForCellComps() {
    this.addManagedListener(this.rowNode, RowNode.EVENT_ROW_INDEX_CHANGED, () => {
      this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onRowIndexChanged());
    });
    this.addManagedListener(this.rowNode, RowNode.EVENT_CELL_CHANGED, (event) => {
      this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellChanged(event));
    });
  }
  onRowNodeDataChanged(event) {
    if (this.rowNode.detailNode) {
      this.beans.rowRenderer.refreshFullWidthRow(this.rowNode.detailNode);
    }
    if (this.isFullWidth()) {
      this.beans.rowRenderer.refreshFullWidthRow(this.rowNode);
      return;
    }
    this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.refreshCell({
      suppressFlash: !event.update,
      newData: !event.update
    }));
    this.allRowGuis.forEach((gui) => {
      this.setRowCompRowId(gui.rowComp);
      this.updateRowBusinessKey();
      this.setRowCompRowBusinessKey(gui.rowComp);
    });
    this.onRowSelected();
    this.postProcessCss();
  }
  onRowNodeCellChanged() {
    this.postProcessCss();
  }
  postProcessCss() {
    this.setStylesFromGridOptions();
    this.postProcessClassesFromGridOptions();
    this.postProcessRowClassRules();
    this.postProcessRowDragging();
  }
  onRowNodeHighlightChanged() {
    const highlighted = this.rowNode.highlighted;
    this.allRowGuis.forEach((gui) => {
      const aboveOn = highlighted === RowHighlightPosition.Above;
      const belowOn = highlighted === RowHighlightPosition.Below;
      gui.rowComp.addOrRemoveCssClass("ag-row-highlight-above", aboveOn);
      gui.rowComp.addOrRemoveCssClass("ag-row-highlight-below", belowOn);
    });
  }
  onRowNodeDraggingChanged() {
    this.postProcessRowDragging();
  }
  postProcessRowDragging() {
    const dragging = this.rowNode.dragging;
    this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass("ag-row-dragging", dragging));
  }
  updateExpandedCss() {
    const expandable = this.rowNode.isExpandable();
    const expanded = this.rowNode.expanded == true;
    this.allRowGuis.forEach((gui) => {
      gui.rowComp.addOrRemoveCssClass("ag-row-group", expandable);
      gui.rowComp.addOrRemoveCssClass("ag-row-group-expanded", expandable && expanded);
      gui.rowComp.addOrRemoveCssClass("ag-row-group-contracted", expandable && !expanded);
      setAriaExpanded(gui.element, expandable && expanded);
    });
  }
  onDisplayedColumnsChanged() {
    this.updateColumnLists(true);
    if (this.beans.columnModel.wasAutoRowHeightEverActive()) {
      this.rowNode.checkAutoHeights();
    }
  }
  onVirtualColumnsChanged() {
    this.updateColumnLists(false, true);
  }
  getRowPosition() {
    return {
      rowPinned: makeNull(this.rowNode.rowPinned),
      rowIndex: this.rowNode.rowIndex
    };
  }
  onKeyboardNavigate(keyboardEvent) {
    const currentFullWidthComp = this.allRowGuis.find((c) => c.element.contains(keyboardEvent.target));
    const currentFullWidthContainer = currentFullWidthComp ? currentFullWidthComp.element : null;
    const isFullWidthContainerFocused = currentFullWidthContainer === keyboardEvent.target;
    if (!isFullWidthContainerFocused) {
      return;
    }
    const node = this.rowNode;
    const lastFocusedCell = this.beans.focusService.getFocusedCell();
    const cellPosition = {
      rowIndex: node.rowIndex,
      rowPinned: node.rowPinned,
      column: lastFocusedCell && lastFocusedCell.column
    };
    this.beans.navigationService.navigateToNextCell(keyboardEvent, keyboardEvent.key, cellPosition, true);
    keyboardEvent.preventDefault();
  }
  onTabKeyDown(keyboardEvent) {
    if (keyboardEvent.defaultPrevented || isStopPropagationForAgGrid(keyboardEvent)) {
      return;
    }
    const currentFullWidthComp = this.allRowGuis.find((c) => c.element.contains(keyboardEvent.target));
    const currentFullWidthContainer = currentFullWidthComp ? currentFullWidthComp.element : null;
    const isFullWidthContainerFocused = currentFullWidthContainer === keyboardEvent.target;
    let nextEl = null;
    if (!isFullWidthContainerFocused) {
      nextEl = this.beans.focusService.findNextFocusableElement(currentFullWidthContainer, false, keyboardEvent.shiftKey);
    }
    if (this.isFullWidth() && isFullWidthContainerFocused || !nextEl) {
      this.beans.navigationService.onTabKeyDown(this, keyboardEvent);
    }
  }
  onFullWidthRowFocused(event) {
    var _a;
    const node = this.rowNode;
    const isFocused = !event ? false : this.isFullWidth() && event.rowIndex === node.rowIndex && event.rowPinned == node.rowPinned;
    const element = this.fullWidthGui ? this.fullWidthGui.element : (_a = this.centerGui) === null || _a === void 0 ? void 0 : _a.element;
    if (!element) {
      return;
    }
    element.classList.toggle("ag-full-width-focus", isFocused);
    if (isFocused) {
      element.focus({ preventScroll: true });
    }
  }
  refreshCell(cellCtrl) {
    this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, cellCtrl);
    this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, cellCtrl);
    this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, cellCtrl);
    this.updateColumnLists();
  }
  removeCellCtrl(prev, cellCtrlToRemove) {
    const res = {
      list: [],
      map: {}
    };
    prev.list.forEach((cellCtrl) => {
      if (cellCtrl === cellCtrlToRemove) {
        return;
      }
      res.list.push(cellCtrl);
      res.map[cellCtrl.getInstanceId()] = cellCtrl;
    });
    return res;
  }
  onMouseEvent(eventName, mouseEvent) {
    switch (eventName) {
      case "dblclick":
        this.onRowDblClick(mouseEvent);
        break;
      case "click":
        this.onRowClick(mouseEvent);
        break;
      case "touchstart":
      case "mousedown":
        this.onRowMouseDown(mouseEvent);
        break;
    }
  }
  createRowEvent(type, domEvent) {
    return {
      type,
      node: this.rowNode,
      data: this.rowNode.data,
      rowIndex: this.rowNode.rowIndex,
      rowPinned: this.rowNode.rowPinned,
      context: this.gridOptionsService.context,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      event: domEvent
    };
  }
  createRowEventWithSource(type, domEvent) {
    const event = this.createRowEvent(type, domEvent);
    event.source = this;
    return event;
  }
  onRowDblClick(mouseEvent) {
    if (isStopPropagationForAgGrid(mouseEvent)) {
      return;
    }
    const agEvent = this.createRowEventWithSource(Events.EVENT_ROW_DOUBLE_CLICKED, mouseEvent);
    this.beans.eventService.dispatchEvent(agEvent);
  }
  onRowMouseDown(mouseEvent) {
    this.lastMouseDownOnDragger = isElementChildOfClass(mouseEvent.target, "ag-row-drag", 3);
    if (!this.isFullWidth()) {
      return;
    }
    const node = this.rowNode;
    const columnModel = this.beans.columnModel;
    if (this.beans.rangeService) {
      this.beans.rangeService.removeAllCellRanges();
    }
    this.beans.focusService.setFocusedCell({
      rowIndex: node.rowIndex,
      column: columnModel.getAllDisplayedColumns()[0],
      rowPinned: node.rowPinned,
      forceBrowserFocus: true
    });
  }
  onRowClick(mouseEvent) {
    const stop = isStopPropagationForAgGrid(mouseEvent) || this.lastMouseDownOnDragger;
    if (stop) {
      return;
    }
    const agEvent = this.createRowEventWithSource(Events.EVENT_ROW_CLICKED, mouseEvent);
    this.beans.eventService.dispatchEvent(agEvent);
    const isMultiKey = mouseEvent.ctrlKey || mouseEvent.metaKey;
    const isShiftKey = mouseEvent.shiftKey;
    const groupSelectsChildren = this.gridOptionsService.is("groupSelectsChildren");
    if (groupSelectsChildren && this.rowNode.group || !this.rowNode.selectable || this.rowNode.rowPinned || !this.gridOptionsService.isRowSelection() || this.gridOptionsService.is("suppressRowClickSelection")) {
      return;
    }
    const multiSelectOnClick = this.gridOptionsService.is("rowMultiSelectWithClick");
    const rowDeselectionWithCtrl = !this.gridOptionsService.is("suppressRowDeselection");
    const source = "rowClicked";
    if (this.rowNode.isSelected()) {
      if (multiSelectOnClick) {
        this.rowNode.setSelectedParams({ newValue: false, event: mouseEvent, source });
      } else if (isMultiKey) {
        if (rowDeselectionWithCtrl) {
          this.rowNode.setSelectedParams({ newValue: false, event: mouseEvent, source });
        }
      } else {
        this.rowNode.setSelectedParams({ newValue: true, clearSelection: !isShiftKey, rangeSelect: isShiftKey, event: mouseEvent, source });
      }
    } else {
      const clearSelection = multiSelectOnClick ? false : !isMultiKey;
      this.rowNode.setSelectedParams({ newValue: true, clearSelection, rangeSelect: isShiftKey, event: mouseEvent, source });
    }
  }
  setupDetailRowAutoHeight(eDetailGui) {
    if (this.rowType !== RowType$1.FullWidthDetail) {
      return;
    }
    if (!this.gridOptionsService.is("detailRowAutoHeight")) {
      return;
    }
    const checkRowSizeFunc = () => {
      const clientHeight = eDetailGui.clientHeight;
      if (clientHeight != null && clientHeight > 0) {
        const updateRowHeightFunc = () => {
          this.rowNode.setRowHeight(clientHeight);
          if (this.beans.clientSideRowModel) {
            this.beans.clientSideRowModel.onRowHeightChanged();
          } else if (this.beans.serverSideRowModel) {
            this.beans.serverSideRowModel.onRowHeightChanged();
          }
        };
        this.beans.frameworkOverrides.setTimeout(updateRowHeightFunc, 0);
      }
    };
    const resizeObserverDestroyFunc = this.beans.resizeObserverService.observeResize(eDetailGui, checkRowSizeFunc);
    this.addDestroyFunc(resizeObserverDestroyFunc);
    checkRowSizeFunc();
  }
  createFullWidthParams(eRow, pinned) {
    const params = {
      fullWidth: true,
      data: this.rowNode.data,
      node: this.rowNode,
      value: this.rowNode.key,
      valueFormatted: this.rowNode.key,
      rowIndex: this.rowNode.rowIndex,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context,
      eGridCell: eRow,
      eParentOfValue: eRow,
      pinned,
      addRenderedRowListener: this.addEventListener.bind(this),
      registerRowDragger: (rowDraggerElement, dragStartPixels, value, suppressVisibilityChange) => this.addFullWidthRowDragging(rowDraggerElement, dragStartPixels, value, suppressVisibilityChange)
    };
    return params;
  }
  addFullWidthRowDragging(rowDraggerElement, dragStartPixels, value = "", suppressVisibilityChange) {
    if (!this.isFullWidth()) {
      return;
    }
    const rowDragComp = new RowDragComp(() => value, this.rowNode, void 0, rowDraggerElement, dragStartPixels, suppressVisibilityChange);
    this.createManagedBean(rowDragComp, this.beans.context);
  }
  onUiLevelChanged() {
    const newLevel = this.beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
    if (this.rowLevel != newLevel) {
      const classToAdd = "ag-row-level-" + newLevel;
      const classToRemove = "ag-row-level-" + this.rowLevel;
      this.allRowGuis.forEach((gui) => {
        gui.rowComp.addOrRemoveCssClass(classToAdd, true);
        gui.rowComp.addOrRemoveCssClass(classToRemove, false);
      });
    }
    this.rowLevel = newLevel;
  }
  isFirstRowOnPage() {
    return this.rowNode.rowIndex === this.beans.paginationProxy.getPageFirstRow();
  }
  isLastRowOnPage() {
    return this.rowNode.rowIndex === this.beans.paginationProxy.getPageLastRow();
  }
  onModelUpdated() {
    this.refreshFirstAndLastRowStyles();
  }
  refreshFirstAndLastRowStyles() {
    const newFirst = this.isFirstRowOnPage();
    const newLast = this.isLastRowOnPage();
    if (this.firstRowOnPage !== newFirst) {
      this.firstRowOnPage = newFirst;
      this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass("ag-row-first", newFirst));
    }
    if (this.lastRowOnPage !== newLast) {
      this.lastRowOnPage = newLast;
      this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass("ag-row-last", newLast));
    }
  }
  stopEditing(cancel = false) {
    if (this.stoppingRowEdit) {
      return;
    }
    const cellControls = this.getAllCellCtrls();
    const isRowEdit = this.editingRow;
    this.stoppingRowEdit = true;
    let fireRowEditEvent = false;
    for (const ctrl of cellControls) {
      const valueChanged = ctrl.stopEditing(cancel);
      if (isRowEdit && !cancel && !fireRowEditEvent && valueChanged) {
        fireRowEditEvent = true;
      }
    }
    if (fireRowEditEvent) {
      const event = this.createRowEvent(Events.EVENT_ROW_VALUE_CHANGED);
      this.beans.eventService.dispatchEvent(event);
    }
    if (isRowEdit) {
      this.setEditingRow(false);
    }
    this.stoppingRowEdit = false;
  }
  setInlineEditingCss(editing) {
    this.allRowGuis.forEach((gui) => {
      gui.rowComp.addOrRemoveCssClass("ag-row-inline-editing", editing);
      gui.rowComp.addOrRemoveCssClass("ag-row-not-inline-editing", !editing);
    });
  }
  setEditingRow(value) {
    this.editingRow = value;
    this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass("ag-row-editing", value));
    const event = value ? this.createRowEvent(Events.EVENT_ROW_EDITING_STARTED) : this.createRowEvent(Events.EVENT_ROW_EDITING_STOPPED);
    this.beans.eventService.dispatchEvent(event);
  }
  startRowEditing(key = null, sourceRenderedCell = null, event = null) {
    if (this.editingRow) {
      return;
    }
    const atLeastOneEditing = this.getAllCellCtrls().reduce((prev, cellCtrl) => {
      const cellStartedEdit = cellCtrl === sourceRenderedCell;
      if (cellStartedEdit) {
        cellCtrl.startEditing(key, cellStartedEdit, event);
      } else {
        cellCtrl.startEditing(null, cellStartedEdit, event);
      }
      if (prev) {
        return true;
      }
      return cellCtrl.isEditing();
    }, false);
    if (atLeastOneEditing) {
      this.setEditingRow(true);
    }
  }
  getAllCellCtrls() {
    if (this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0) {
      return this.centerCellCtrls.list;
    }
    const res = [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list];
    return res;
  }
  postProcessClassesFromGridOptions() {
    const cssClasses = this.beans.rowCssClassCalculator.processClassesFromGridOptions(this.rowNode);
    if (!cssClasses || !cssClasses.length) {
      return;
    }
    cssClasses.forEach((classStr) => {
      this.allRowGuis.forEach((c) => c.rowComp.addOrRemoveCssClass(classStr, true));
    });
  }
  postProcessRowClassRules() {
    this.beans.rowCssClassCalculator.processRowClassRules(this.rowNode, (className) => {
      this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass(className, true));
    }, (className) => {
      this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass(className, false));
    });
  }
  setStylesFromGridOptions(gui) {
    const rowStyles = this.processStylesFromGridOptions();
    this.forEachGui(gui, (gui2) => gui2.rowComp.setUserStyles(rowStyles));
  }
  getPinnedForContainer(rowContainerType) {
    const pinned = rowContainerType === RowContainerType.LEFT ? "left" : rowContainerType === RowContainerType.RIGHT ? "right" : null;
    return pinned;
  }
  getInitialRowClasses(rowContainerType) {
    const pinned = this.getPinnedForContainer(rowContainerType);
    const params = {
      rowNode: this.rowNode,
      rowFocused: this.rowFocused,
      fadeRowIn: this.fadeInAnimation[rowContainerType],
      rowIsEven: this.rowNode.rowIndex % 2 === 0,
      rowLevel: this.rowLevel,
      fullWidthRow: this.isFullWidth(),
      firstRowOnPage: this.isFirstRowOnPage(),
      lastRowOnPage: this.isLastRowOnPage(),
      printLayout: this.printLayout,
      expandable: this.rowNode.isExpandable(),
      pinned
    };
    return this.beans.rowCssClassCalculator.getInitialRowClasses(params);
  }
  processStylesFromGridOptions() {
    const rowStyle = this.gridOptionsService.get("rowStyle");
    if (rowStyle && typeof rowStyle === "function") {
      console.warn("AG Grid: rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead");
      return;
    }
    const rowStyleFunc = this.gridOptionsService.getCallback("getRowStyle");
    let rowStyleFuncResult;
    if (rowStyleFunc) {
      const params = {
        data: this.rowNode.data,
        node: this.rowNode,
        rowIndex: this.rowNode.rowIndex
      };
      rowStyleFuncResult = rowStyleFunc(params);
    }
    return Object.assign({}, rowStyle, rowStyleFuncResult);
  }
  onRowSelected(gui) {
    const selected = !!this.rowNode.isSelected();
    this.forEachGui(gui, (gui2) => {
      gui2.rowComp.addOrRemoveCssClass("ag-row-selected", selected);
      setAriaSelected(gui2.element, selected ? true : void 0);
      const ariaLabel = this.createAriaLabel();
      setAriaLabel(gui2.element, ariaLabel == null ? "" : ariaLabel);
    });
  }
  createAriaLabel() {
    const selected = this.rowNode.isSelected();
    if (selected && this.gridOptionsService.is("suppressRowDeselection")) {
      return void 0;
    }
    const translate = this.beans.localeService.getLocaleTextFunc();
    const label = translate(selected ? "ariaRowDeselect" : "ariaRowSelect", `Press SPACE to ${selected ? "deselect" : "select"} this row.`);
    return label;
  }
  isUseAnimationFrameForCreate() {
    return this.useAnimationFrameForCreate;
  }
  addHoverFunctionality(eRow) {
    if (!this.active) {
      return;
    }
    this.addManagedListener(eRow, "mouseenter", () => this.rowNode.onMouseEnter());
    this.addManagedListener(eRow, "mouseleave", () => this.rowNode.onMouseLeave());
    this.addManagedListener(this.rowNode, RowNode.EVENT_MOUSE_ENTER, () => {
      if (!this.beans.dragService.isDragging() && !this.gridOptionsService.is("suppressRowHoverHighlight")) {
        eRow.classList.add("ag-row-hover");
        this.rowNode.setHovered(true);
      }
    });
    this.addManagedListener(this.rowNode, RowNode.EVENT_MOUSE_LEAVE, () => {
      eRow.classList.remove("ag-row-hover");
      this.rowNode.setHovered(false);
    });
  }
  roundRowTopToBounds(rowTop) {
    const gridBodyCon = this.beans.ctrlsService.getGridBodyCtrl();
    const range = gridBodyCon.getScrollFeature().getVScrollPosition();
    const minPixel = this.applyPaginationOffset(range.top, true) - 100;
    const maxPixel = this.applyPaginationOffset(range.bottom, true) + 100;
    return Math.min(Math.max(minPixel, rowTop), maxPixel);
  }
  getFrameworkOverrides() {
    return this.beans.frameworkOverrides;
  }
  forEachGui(gui, callback) {
    const list = gui ? [gui] : this.allRowGuis;
    list.forEach(callback);
  }
  onRowHeightChanged(gui) {
    if (this.rowNode.rowHeight == null) {
      return;
    }
    const rowHeight = this.rowNode.rowHeight;
    const defaultRowHeight = this.beans.environment.getDefaultRowHeight();
    const isHeightFromFunc = this.gridOptionsService.isGetRowHeightFunction();
    const heightFromFunc = isHeightFromFunc ? this.gridOptionsService.getRowHeightForNode(this.rowNode).height : void 0;
    const lineHeight = heightFromFunc ? `${Math.min(defaultRowHeight, heightFromFunc) - 2}px` : void 0;
    this.forEachGui(gui, (gui2) => {
      gui2.element.style.height = `${rowHeight}px`;
      if (lineHeight) {
        gui2.element.style.setProperty("--ag-line-height", lineHeight);
      }
    });
  }
  addEventListener(eventType, listener) {
    super.addEventListener(eventType, listener);
  }
  removeEventListener(eventType, listener) {
    super.removeEventListener(eventType, listener);
  }
  destroyFirstPass() {
    this.active = false;
    if (this.gridOptionsService.isAnimateRows()) {
      this.setupRemoveAnimation();
    }
    this.rowNode.setHovered(false);
    const event = this.createRowEvent(Events.EVENT_VIRTUAL_ROW_REMOVED);
    this.dispatchEvent(event);
    this.beans.eventService.dispatchEvent(event);
    super.destroy();
  }
  setupRemoveAnimation() {
    if (this.isSticky()) {
      return;
    }
    const rowStillVisibleJustNotInViewport = this.rowNode.rowTop != null;
    if (rowStillVisibleJustNotInViewport) {
      const rowTop = this.roundRowTopToBounds(this.rowNode.rowTop);
      this.setRowTop(rowTop);
    } else {
      this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass("ag-opacity-zero", true));
    }
  }
  destroySecondPass() {
    this.allRowGuis.length = 0;
    const destroyCellCtrls = (ctrls) => {
      ctrls.list.forEach((c) => c.destroy());
      return { list: [], map: {} };
    };
    this.centerCellCtrls = destroyCellCtrls(this.centerCellCtrls);
    this.leftCellCtrls = destroyCellCtrls(this.leftCellCtrls);
    this.rightCellCtrls = destroyCellCtrls(this.rightCellCtrls);
  }
  setFocusedClasses(gui) {
    this.forEachGui(gui, (gui2) => {
      gui2.rowComp.addOrRemoveCssClass("ag-row-focus", this.rowFocused);
      gui2.rowComp.addOrRemoveCssClass("ag-row-no-focus", !this.rowFocused);
    });
  }
  onCellFocused() {
    this.onCellFocusChanged();
  }
  onCellFocusCleared() {
    this.onCellFocusChanged();
  }
  onCellFocusChanged() {
    const rowFocused = this.beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    if (rowFocused !== this.rowFocused) {
      this.rowFocused = rowFocused;
      this.setFocusedClasses();
    }
    if (!rowFocused && this.editingRow) {
      this.stopEditing(false);
    }
  }
  onPaginationChanged() {
    const currentPage = this.beans.paginationProxy.getCurrentPage();
    if (this.paginationPage !== currentPage) {
      this.paginationPage = currentPage;
      this.onTopChanged();
    }
    this.refreshFirstAndLastRowStyles();
  }
  onTopChanged() {
    this.setRowTop(this.rowNode.rowTop);
  }
  onPaginationPixelOffsetChanged() {
    this.onTopChanged();
  }
  applyPaginationOffset(topPx, reverse = false) {
    if (this.rowNode.isRowPinned()) {
      return topPx;
    }
    const pixelOffset = this.beans.paginationProxy.getPixelOffset();
    const multiplier = reverse ? 1 : -1;
    return topPx + pixelOffset * multiplier;
  }
  setRowTop(pixels) {
    if (this.printLayout) {
      return;
    }
    if (exists(pixels)) {
      const afterPaginationPixels = this.applyPaginationOffset(pixels);
      const afterScalingPixels = this.rowNode.isRowPinned() ? afterPaginationPixels : this.beans.rowContainerHeightService.getRealPixelPosition(afterPaginationPixels);
      const topPx = `${afterScalingPixels}px`;
      this.setRowTopStyle(topPx);
    }
  }
  getInitialRowTop(rowContainerType) {
    const suppressRowTransform = this.gridOptionsService.is("suppressRowTransform");
    return suppressRowTransform ? this.getInitialRowTopShared(rowContainerType) : void 0;
  }
  getInitialTransform(rowContainerType) {
    const suppressRowTransform = this.gridOptionsService.is("suppressRowTransform");
    return suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(rowContainerType)})`;
  }
  getInitialRowTopShared(rowContainerType) {
    if (this.printLayout) {
      return "";
    }
    let rowTop;
    if (this.isSticky()) {
      rowTop = this.rowNode.stickyRowTop;
    } else {
      const pixels = this.slideInAnimation[rowContainerType] ? this.roundRowTopToBounds(this.rowNode.oldRowTop) : this.rowNode.rowTop;
      const afterPaginationPixels = this.applyPaginationOffset(pixels);
      rowTop = this.rowNode.isRowPinned() ? afterPaginationPixels : this.beans.rowContainerHeightService.getRealPixelPosition(afterPaginationPixels);
    }
    return rowTop + "px";
  }
  setRowTopStyle(topPx) {
    const suppressRowTransform = this.gridOptionsService.is("suppressRowTransform");
    this.allRowGuis.forEach((gui) => suppressRowTransform ? gui.rowComp.setTop(topPx) : gui.rowComp.setTransform(`translateY(${topPx})`));
  }
  getRowNode() {
    return this.rowNode;
  }
  getCellCtrl(column) {
    let res = null;
    this.getAllCellCtrls().forEach((cellCtrl) => {
      if (cellCtrl.getColumn() == column) {
        res = cellCtrl;
      }
    });
    if (res != null) {
      return res;
    }
    this.getAllCellCtrls().forEach((cellCtrl) => {
      if (cellCtrl.getColSpanningList().indexOf(column) >= 0) {
        res = cellCtrl;
      }
    });
    return res;
  }
  onRowIndexChanged() {
    if (this.rowNode.rowIndex != null) {
      this.onCellFocusChanged();
      this.updateRowIndexes();
      this.postProcessCss();
    }
  }
  updateRowIndexes(gui) {
    const rowIndexStr = this.rowNode.getRowIndexString();
    const headerRowCount = this.beans.headerNavigationService.getHeaderRowCount();
    const rowIsEven = this.rowNode.rowIndex % 2 === 0;
    const ariaRowIndex = headerRowCount + this.rowNode.rowIndex + 1;
    this.forEachGui(gui, (c) => {
      c.rowComp.setRowIndex(rowIndexStr);
      c.rowComp.addOrRemoveCssClass("ag-row-even", rowIsEven);
      c.rowComp.addOrRemoveCssClass("ag-row-odd", !rowIsEven);
      setAriaRowIndex(c.element, ariaRowIndex);
    });
  }
  getPinnedLeftRowElement() {
    return this.leftGui ? this.leftGui.element : void 0;
  }
  getPinnedRightRowElement() {
    return this.rightGui ? this.rightGui.element : void 0;
  }
  getBodyRowElement() {
    return this.centerGui ? this.centerGui.element : void 0;
  }
  getFullWidthRowElement() {
    return this.fullWidthGui ? this.fullWidthGui.element : void 0;
  }
};
RowCtrl.DOM_DATA_KEY_ROW_CTRL = "renderedRow";
var __decorate$1M = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RowContainerEventsFeature = class extends BeanStub {
  constructor(element) {
    super();
    this.element = element;
  }
  postConstruct() {
    this.addKeyboardListeners();
    this.addMouseListeners();
    this.mockContextMenuForIPad();
  }
  addKeyboardListeners() {
    const eventName = "keydown";
    const listener = this.processKeyboardEvent.bind(this, eventName);
    this.addManagedListener(this.element, eventName, listener);
  }
  addMouseListeners() {
    const mouseDownEvent = isEventSupported("touchstart") ? "touchstart" : "mousedown";
    const eventNames = ["dblclick", "contextmenu", "mouseover", "mouseout", "click", mouseDownEvent];
    eventNames.forEach((eventName) => {
      const listener = this.processMouseEvent.bind(this, eventName);
      this.addManagedListener(this.element, eventName, listener);
    });
  }
  processMouseEvent(eventName, mouseEvent) {
    if (!this.mouseEventService.isEventFromThisGrid(mouseEvent) || isStopPropagationForAgGrid(mouseEvent)) {
      return;
    }
    const rowComp = this.getRowForEvent(mouseEvent);
    const cellCtrl = this.mouseEventService.getRenderedCellForEvent(mouseEvent);
    if (eventName === "contextmenu") {
      this.handleContextMenuMouseEvent(mouseEvent, null, rowComp, cellCtrl);
    } else {
      if (cellCtrl) {
        cellCtrl.onMouseEvent(eventName, mouseEvent);
      }
      if (rowComp) {
        rowComp.onMouseEvent(eventName, mouseEvent);
      }
    }
  }
  mockContextMenuForIPad() {
    if (!isIOSUserAgent()) {
      return;
    }
    const touchListener = new TouchListener(this.element);
    const longTapListener = (event) => {
      const rowComp = this.getRowForEvent(event.touchEvent);
      const cellComp = this.mouseEventService.getRenderedCellForEvent(event.touchEvent);
      this.handleContextMenuMouseEvent(null, event.touchEvent, rowComp, cellComp);
    };
    this.addManagedListener(touchListener, TouchListener.EVENT_LONG_TAP, longTapListener);
    this.addDestroyFunc(() => touchListener.destroy());
  }
  getRowForEvent(event) {
    let sourceElement = event.target;
    while (sourceElement) {
      const rowCon = this.gridOptionsService.getDomData(sourceElement, RowCtrl.DOM_DATA_KEY_ROW_CTRL);
      if (rowCon) {
        return rowCon;
      }
      sourceElement = sourceElement.parentElement;
    }
    return null;
  }
  handleContextMenuMouseEvent(mouseEvent, touchEvent, rowComp, cellCtrl) {
    const rowNode = rowComp ? rowComp.getRowNode() : null;
    const column = cellCtrl ? cellCtrl.getColumn() : null;
    let value = null;
    if (column) {
      const event = mouseEvent ? mouseEvent : touchEvent;
      cellCtrl.dispatchCellContextMenuEvent(event);
      value = this.valueService.getValue(column, rowNode);
    }
    const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
    const anchorToElement = cellCtrl ? cellCtrl.getGui() : gridBodyCon.getGridBodyElement();
    if (this.contextMenuFactory) {
      this.contextMenuFactory.onContextMenu(mouseEvent, touchEvent, rowNode, column, value, anchorToElement);
    }
  }
  getControlsForEventTarget(target) {
    return {
      cellCtrl: getCtrlForEventTarget(this.gridOptionsService, target, CellCtrl.DOM_DATA_KEY_CELL_CTRL),
      rowCtrl: getCtrlForEventTarget(this.gridOptionsService, target, RowCtrl.DOM_DATA_KEY_ROW_CTRL)
    };
  }
  processKeyboardEvent(eventName, keyboardEvent) {
    const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(keyboardEvent.target);
    if (keyboardEvent.defaultPrevented) {
      return;
    }
    if (cellCtrl) {
      this.processCellKeyboardEvent(cellCtrl, eventName, keyboardEvent);
    } else if (rowCtrl && rowCtrl.isFullWidth()) {
      this.processFullWidthRowKeyboardEvent(rowCtrl, eventName, keyboardEvent);
    }
  }
  processCellKeyboardEvent(cellCtrl, eventName, keyboardEvent) {
    const rowNode = cellCtrl.getRowNode();
    const column = cellCtrl.getColumn();
    const editing = cellCtrl.isEditing();
    const gridProcessingAllowed = !isUserSuppressingKeyboardEvent(this.gridOptionsService, keyboardEvent, rowNode, column, editing);
    if (gridProcessingAllowed) {
      if (eventName === "keydown") {
        const wasScrollKey = !editing && this.navigationService.handlePageScrollingKey(keyboardEvent);
        if (!wasScrollKey) {
          cellCtrl.onKeyDown(keyboardEvent);
        }
        this.doGridOperations(keyboardEvent, cellCtrl.isEditing());
        if (isEventFromPrintableCharacter(keyboardEvent)) {
          cellCtrl.processCharacter(keyboardEvent);
        }
      }
    }
    if (eventName === "keydown") {
      const cellKeyDownEvent = cellCtrl.createEvent(keyboardEvent, Events.EVENT_CELL_KEY_DOWN);
      this.eventService.dispatchEvent(cellKeyDownEvent);
    }
  }
  processFullWidthRowKeyboardEvent(rowComp, eventName, keyboardEvent) {
    const rowNode = rowComp.getRowNode();
    const focusedCell = this.focusService.getFocusedCell();
    const column = focusedCell && focusedCell.column;
    const gridProcessingAllowed = !isUserSuppressingKeyboardEvent(this.gridOptionsService, keyboardEvent, rowNode, column, false);
    if (gridProcessingAllowed) {
      const key = keyboardEvent.key;
      if (eventName === "keydown") {
        switch (key) {
          case KeyCode.PAGE_HOME:
          case KeyCode.PAGE_END:
            this.navigationService.handlePageScrollingKey(keyboardEvent);
            break;
          case KeyCode.UP:
          case KeyCode.DOWN:
            rowComp.onKeyboardNavigate(keyboardEvent);
            break;
          case KeyCode.TAB:
            rowComp.onTabKeyDown(keyboardEvent);
            break;
        }
      }
    }
    if (eventName === "keydown") {
      const cellKeyDownEvent = rowComp.createRowEvent(Events.EVENT_CELL_KEY_DOWN, keyboardEvent);
      this.eventService.dispatchEvent(cellKeyDownEvent);
    }
  }
  doGridOperations(keyboardEvent, editing) {
    if (!keyboardEvent.ctrlKey && !keyboardEvent.metaKey) {
      return;
    }
    if (editing) {
      return;
    }
    if (!this.mouseEventService.isEventFromThisGrid(keyboardEvent)) {
      return;
    }
    const keyCode = normaliseQwertyAzerty(keyboardEvent);
    if (keyCode === KeyCode.A) {
      return this.onCtrlAndA(keyboardEvent);
    }
    if (keyCode === KeyCode.C) {
      return this.onCtrlAndC(keyboardEvent);
    }
    if (keyCode === KeyCode.D) {
      return this.onCtrlAndD(keyboardEvent);
    }
    if (keyCode === KeyCode.V) {
      return this.onCtrlAndV(keyboardEvent);
    }
    if (keyCode === KeyCode.X) {
      return this.onCtrlAndX(keyboardEvent);
    }
    if (keyCode === KeyCode.Y) {
      return this.onCtrlAndY();
    }
    if (keyCode === KeyCode.Z) {
      return this.onCtrlAndZ(keyboardEvent);
    }
  }
  onCtrlAndA(event) {
    const { pinnedRowModel, paginationProxy, rangeService } = this;
    if (rangeService && paginationProxy.isRowsToRender()) {
      const [isEmptyPinnedTop, isEmptyPinnedBottom] = [
        pinnedRowModel.isEmpty("top"),
        pinnedRowModel.isEmpty("bottom")
      ];
      const floatingStart = isEmptyPinnedTop ? null : "top";
      let floatingEnd;
      let rowEnd;
      if (isEmptyPinnedBottom) {
        floatingEnd = null;
        rowEnd = this.paginationProxy.getRowCount() - 1;
      } else {
        floatingEnd = "bottom";
        rowEnd = pinnedRowModel.getPinnedBottomRowData().length - 1;
      }
      const allDisplayedColumns = this.columnModel.getAllDisplayedColumns();
      if (missingOrEmpty(allDisplayedColumns)) {
        return;
      }
      rangeService.setCellRange({
        rowStartIndex: 0,
        rowStartPinned: floatingStart,
        rowEndIndex: rowEnd,
        rowEndPinned: floatingEnd,
        columnStart: allDisplayedColumns[0],
        columnEnd: last(allDisplayedColumns)
      });
    }
    event.preventDefault();
  }
  onCtrlAndC(event) {
    if (!this.clipboardService || this.gridOptionsService.is("enableCellTextSelection")) {
      return;
    }
    const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(event.target);
    if ((cellCtrl === null || cellCtrl === void 0 ? void 0 : cellCtrl.isEditing()) || (rowCtrl === null || rowCtrl === void 0 ? void 0 : rowCtrl.isEditing())) {
      return;
    }
    event.preventDefault();
    this.clipboardService.copyToClipboard();
  }
  onCtrlAndX(event) {
    if (!this.clipboardService || this.gridOptionsService.is("enableCellTextSelection") || this.gridOptionsService.is("suppressCutToClipboard")) {
      return;
    }
    const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(event.target);
    if ((cellCtrl === null || cellCtrl === void 0 ? void 0 : cellCtrl.isEditing()) || (rowCtrl === null || rowCtrl === void 0 ? void 0 : rowCtrl.isEditing())) {
      return;
    }
    event.preventDefault();
    this.clipboardService.cutToClipboard(void 0, "ui");
  }
  onCtrlAndV(event) {
    const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(event.target);
    if ((cellCtrl === null || cellCtrl === void 0 ? void 0 : cellCtrl.isEditing()) || (rowCtrl === null || rowCtrl === void 0 ? void 0 : rowCtrl.isEditing())) {
      return;
    }
    if (this.clipboardService && !this.gridOptionsService.is("suppressClipboardPaste")) {
      this.clipboardService.pasteFromClipboard();
    }
  }
  onCtrlAndD(event) {
    if (this.clipboardService && !this.gridOptionsService.is("suppressClipboardPaste")) {
      this.clipboardService.copyRangeDown();
    }
    event.preventDefault();
  }
  onCtrlAndZ(event) {
    if (!this.gridOptionsService.is("undoRedoCellEditing")) {
      return;
    }
    event.preventDefault();
    if (event.shiftKey) {
      this.undoRedoService.redo("ui");
    } else {
      this.undoRedoService.undo("ui");
    }
  }
  onCtrlAndY() {
    this.undoRedoService.redo("ui");
  }
};
__decorate$1M([
  Autowired("mouseEventService")
], RowContainerEventsFeature.prototype, "mouseEventService", void 0);
__decorate$1M([
  Autowired("valueService")
], RowContainerEventsFeature.prototype, "valueService", void 0);
__decorate$1M([
  Optional("contextMenuFactory")
], RowContainerEventsFeature.prototype, "contextMenuFactory", void 0);
__decorate$1M([
  Autowired("ctrlsService")
], RowContainerEventsFeature.prototype, "ctrlsService", void 0);
__decorate$1M([
  Autowired("navigationService")
], RowContainerEventsFeature.prototype, "navigationService", void 0);
__decorate$1M([
  Autowired("focusService")
], RowContainerEventsFeature.prototype, "focusService", void 0);
__decorate$1M([
  Autowired("undoRedoService")
], RowContainerEventsFeature.prototype, "undoRedoService", void 0);
__decorate$1M([
  Autowired("columnModel")
], RowContainerEventsFeature.prototype, "columnModel", void 0);
__decorate$1M([
  Autowired("paginationProxy")
], RowContainerEventsFeature.prototype, "paginationProxy", void 0);
__decorate$1M([
  Autowired("pinnedRowModel")
], RowContainerEventsFeature.prototype, "pinnedRowModel", void 0);
__decorate$1M([
  Optional("rangeService")
], RowContainerEventsFeature.prototype, "rangeService", void 0);
__decorate$1M([
  Optional("clipboardService")
], RowContainerEventsFeature.prototype, "clipboardService", void 0);
__decorate$1M([
  PostConstruct
], RowContainerEventsFeature.prototype, "postConstruct", null);
var __decorate$1L = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ViewportSizeFeature = class extends BeanStub {
  constructor(centerContainerCtrl) {
    super();
    this.centerContainerCtrl = centerContainerCtrl;
  }
  postConstruct() {
    this.ctrlsService.whenReady(() => {
      this.gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
      this.listenForResize();
    });
    this.addManagedListener(this.eventService, Events.EVENT_SCROLLBAR_WIDTH_CHANGED, this.onScrollbarWidthChanged.bind(this));
  }
  listenForResize() {
    const listener = () => this.onCenterViewportResized();
    this.centerContainerCtrl.registerViewportResizeListener(listener);
    this.gridBodyCtrl.registerBodyViewportResizeListener(listener);
  }
  onScrollbarWidthChanged() {
    this.checkViewportAndScrolls();
  }
  onCenterViewportResized() {
    if (this.centerContainerCtrl.isViewportVisible()) {
      this.checkViewportAndScrolls();
      const newWidth = this.centerContainerCtrl.getCenterWidth();
      if (newWidth !== this.centerWidth) {
        this.centerWidth = newWidth;
        this.columnModel.refreshFlexedColumns({ viewportWidth: this.centerWidth, updateBodyWidths: true, fireResizedEvent: true });
      }
    } else {
      this.bodyHeight = 0;
    }
  }
  checkViewportAndScrolls() {
    this.updateScrollVisibleService();
    this.checkBodyHeight();
    this.onHorizontalViewportChanged();
    this.gridBodyCtrl.getScrollFeature().checkScrollLeft();
  }
  getBodyHeight() {
    return this.bodyHeight;
  }
  checkBodyHeight() {
    const eBodyViewport = this.gridBodyCtrl.getBodyViewportElement();
    const bodyHeight = getInnerHeight(eBodyViewport);
    if (this.bodyHeight !== bodyHeight) {
      this.bodyHeight = bodyHeight;
      const event = {
        type: Events.EVENT_BODY_HEIGHT_CHANGED
      };
      this.eventService.dispatchEvent(event);
    }
  }
  updateScrollVisibleService() {
    this.updateScrollVisibleServiceImpl();
    setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
  }
  updateScrollVisibleServiceImpl() {
    const params = {
      horizontalScrollShowing: this.isHorizontalScrollShowing(),
      verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
    };
    this.scrollVisibleService.setScrollsVisible(params);
  }
  isHorizontalScrollShowing() {
    return this.centerContainerCtrl.isHorizontalScrollShowing();
  }
  onHorizontalViewportChanged() {
    const scrollWidth = this.centerContainerCtrl.getCenterWidth();
    const scrollPosition = this.centerContainerCtrl.getViewportScrollLeft();
    this.columnModel.setViewportPosition(scrollWidth, scrollPosition);
  }
};
__decorate$1L([
  Autowired("ctrlsService")
], ViewportSizeFeature.prototype, "ctrlsService", void 0);
__decorate$1L([
  Autowired("columnModel")
], ViewportSizeFeature.prototype, "columnModel", void 0);
__decorate$1L([
  Autowired("scrollVisibleService")
], ViewportSizeFeature.prototype, "scrollVisibleService", void 0);
__decorate$1L([
  PostConstruct
], ViewportSizeFeature.prototype, "postConstruct", null);
var __decorate$1K = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SetPinnedLeftWidthFeature = class extends BeanStub {
  constructor(element) {
    super();
    this.element = element;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, Events.EVENT_LEFT_PINNED_WIDTH_CHANGED, this.onPinnedLeftWidthChanged.bind(this));
  }
  onPinnedLeftWidthChanged() {
    const leftWidth = this.pinnedWidthService.getPinnedLeftWidth();
    const displayed = leftWidth > 0;
    setDisplayed(this.element, displayed);
    setFixedWidth(this.element, leftWidth);
  }
  getWidth() {
    return this.pinnedWidthService.getPinnedLeftWidth();
  }
};
__decorate$1K([
  Autowired("pinnedWidthService")
], SetPinnedLeftWidthFeature.prototype, "pinnedWidthService", void 0);
__decorate$1K([
  PostConstruct
], SetPinnedLeftWidthFeature.prototype, "postConstruct", null);
var __decorate$1J = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SetPinnedRightWidthFeature = class extends BeanStub {
  constructor(element) {
    super();
    this.element = element;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED, this.onPinnedRightWidthChanged.bind(this));
  }
  onPinnedRightWidthChanged() {
    const rightWidth = this.pinnedWidthService.getPinnedRightWidth();
    const displayed = rightWidth > 0;
    setDisplayed(this.element, displayed);
    setFixedWidth(this.element, rightWidth);
  }
  getWidth() {
    return this.pinnedWidthService.getPinnedRightWidth();
  }
};
__decorate$1J([
  Autowired("pinnedWidthService")
], SetPinnedRightWidthFeature.prototype, "pinnedWidthService", void 0);
__decorate$1J([
  PostConstruct
], SetPinnedRightWidthFeature.prototype, "postConstruct", null);
var __decorate$1I = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SetHeightFeature = class extends BeanStub {
  constructor(eContainer, eWrapper) {
    super();
    this.eContainer = eContainer;
    this.eWrapper = eWrapper;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, Events.EVENT_ROW_CONTAINER_HEIGHT_CHANGED, this.onHeightChanged.bind(this));
  }
  onHeightChanged() {
    const height = this.maxDivHeightScaler.getUiContainerHeight();
    const heightString = height != null ? `${height}px` : ``;
    this.eContainer.style.height = heightString;
    if (this.eWrapper) {
      this.eWrapper.style.height = heightString;
    }
  }
};
__decorate$1I([
  Autowired("rowContainerHeightService")
], SetHeightFeature.prototype, "maxDivHeightScaler", void 0);
__decorate$1I([
  PostConstruct
], SetHeightFeature.prototype, "postConstruct", null);
var __decorate$1H = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DragListenerFeature = class extends BeanStub {
  constructor(eContainer) {
    super();
    this.eContainer = eContainer;
  }
  postConstruct() {
    if (!this.gridOptionsService.isEnableRangeSelection() || missing(this.rangeService)) {
      return;
    }
    const params = {
      eElement: this.eContainer,
      onDragStart: this.rangeService.onDragStart.bind(this.rangeService),
      onDragStop: this.rangeService.onDragStop.bind(this.rangeService),
      onDragging: this.rangeService.onDragging.bind(this.rangeService)
    };
    this.dragService.addDragSource(params);
    this.addDestroyFunc(() => this.dragService.removeDragSource(params));
  }
};
__decorate$1H([
  Optional("rangeService")
], DragListenerFeature.prototype, "rangeService", void 0);
__decorate$1H([
  Autowired("dragService")
], DragListenerFeature.prototype, "dragService", void 0);
__decorate$1H([
  PostConstruct
], DragListenerFeature.prototype, "postConstruct", null);
var __decorate$1G = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CenterWidthFeature = class extends BeanStub {
  constructor(callback, addSpacer = false) {
    super();
    this.callback = callback;
    this.addSpacer = addSpacer;
  }
  postConstruct() {
    const listener = this.setWidth.bind(this);
    this.addManagedPropertyListener("domLayout", listener);
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, listener);
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, listener);
    this.addManagedListener(this.eventService, Events.EVENT_LEFT_PINNED_WIDTH_CHANGED, listener);
    if (this.addSpacer) {
      this.addManagedListener(this.eventService, Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED, listener);
      this.addManagedListener(this.eventService, Events.EVENT_SCROLL_VISIBILITY_CHANGED, listener);
      this.addManagedListener(this.eventService, Events.EVENT_SCROLLBAR_WIDTH_CHANGED, listener);
    }
    this.setWidth();
  }
  setWidth() {
    const { columnModel } = this;
    const printLayout = this.gridOptionsService.isDomLayout("print");
    const centerWidth = columnModel.getBodyContainerWidth();
    const leftWidth = columnModel.getDisplayedColumnsLeftWidth();
    const rightWidth = columnModel.getDisplayedColumnsRightWidth();
    let totalWidth;
    if (printLayout) {
      totalWidth = centerWidth + leftWidth + rightWidth;
    } else {
      totalWidth = centerWidth;
      if (this.addSpacer) {
        const relevantWidth = this.gridOptionsService.is("enableRtl") ? leftWidth : rightWidth;
        if (relevantWidth === 0 && this.scrollVisibleService.isVerticalScrollShowing()) {
          totalWidth += this.gridOptionsService.getScrollbarWidth();
        }
      }
    }
    this.callback(totalWidth);
  }
};
__decorate$1G([
  Autowired("columnModel")
], CenterWidthFeature.prototype, "columnModel", void 0);
__decorate$1G([
  Autowired("scrollVisibleService")
], CenterWidthFeature.prototype, "scrollVisibleService", void 0);
__decorate$1G([
  PostConstruct
], CenterWidthFeature.prototype, "postConstruct", null);
var __decorate$1F = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RowContainerName;
(function(RowContainerName2) {
  RowContainerName2["LEFT"] = "left";
  RowContainerName2["RIGHT"] = "right";
  RowContainerName2["CENTER"] = "center";
  RowContainerName2["FULL_WIDTH"] = "fullWidth";
  RowContainerName2["TOP_LEFT"] = "topLeft";
  RowContainerName2["TOP_RIGHT"] = "topRight";
  RowContainerName2["TOP_CENTER"] = "topCenter";
  RowContainerName2["TOP_FULL_WIDTH"] = "topFullWidth";
  RowContainerName2["STICKY_TOP_LEFT"] = "stickyTopLeft";
  RowContainerName2["STICKY_TOP_RIGHT"] = "stickyTopRight";
  RowContainerName2["STICKY_TOP_CENTER"] = "stickyTopCenter";
  RowContainerName2["STICKY_TOP_FULL_WIDTH"] = "stickyTopFullWidth";
  RowContainerName2["BOTTOM_LEFT"] = "bottomLeft";
  RowContainerName2["BOTTOM_RIGHT"] = "bottomRight";
  RowContainerName2["BOTTOM_CENTER"] = "bottomCenter";
  RowContainerName2["BOTTOM_FULL_WIDTH"] = "bottomFullWidth";
})(RowContainerName || (RowContainerName = {}));
var RowContainerType;
(function(RowContainerType2) {
  RowContainerType2["LEFT"] = "left";
  RowContainerType2["RIGHT"] = "right";
  RowContainerType2["CENTER"] = "center";
  RowContainerType2["FULL_WIDTH"] = "fullWidth";
})(RowContainerType || (RowContainerType = {}));
function getRowContainerTypeForName(name) {
  switch (name) {
    case RowContainerName.CENTER:
    case RowContainerName.TOP_CENTER:
    case RowContainerName.STICKY_TOP_CENTER:
    case RowContainerName.BOTTOM_CENTER:
      return RowContainerType.CENTER;
    case RowContainerName.LEFT:
    case RowContainerName.TOP_LEFT:
    case RowContainerName.STICKY_TOP_LEFT:
    case RowContainerName.BOTTOM_LEFT:
      return RowContainerType.LEFT;
    case RowContainerName.RIGHT:
    case RowContainerName.TOP_RIGHT:
    case RowContainerName.STICKY_TOP_RIGHT:
    case RowContainerName.BOTTOM_RIGHT:
      return RowContainerType.RIGHT;
    case RowContainerName.FULL_WIDTH:
    case RowContainerName.TOP_FULL_WIDTH:
    case RowContainerName.STICKY_TOP_FULL_WIDTH:
    case RowContainerName.BOTTOM_FULL_WIDTH:
      return RowContainerType.FULL_WIDTH;
    default:
      throw Error("Invalid Row Container Type");
  }
}
var ContainerCssClasses = convertToMap([
  [RowContainerName.CENTER, "ag-center-cols-container"],
  [RowContainerName.LEFT, "ag-pinned-left-cols-container"],
  [RowContainerName.RIGHT, "ag-pinned-right-cols-container"],
  [RowContainerName.FULL_WIDTH, "ag-full-width-container"],
  [RowContainerName.TOP_CENTER, "ag-floating-top-container"],
  [RowContainerName.TOP_LEFT, "ag-pinned-left-floating-top"],
  [RowContainerName.TOP_RIGHT, "ag-pinned-right-floating-top"],
  [RowContainerName.TOP_FULL_WIDTH, "ag-floating-top-full-width-container"],
  [RowContainerName.STICKY_TOP_CENTER, "ag-sticky-top-container"],
  [RowContainerName.STICKY_TOP_LEFT, "ag-pinned-left-sticky-top"],
  [RowContainerName.STICKY_TOP_RIGHT, "ag-pinned-right-sticky-top"],
  [RowContainerName.STICKY_TOP_FULL_WIDTH, "ag-sticky-top-full-width-container"],
  [RowContainerName.BOTTOM_CENTER, "ag-floating-bottom-container"],
  [RowContainerName.BOTTOM_LEFT, "ag-pinned-left-floating-bottom"],
  [RowContainerName.BOTTOM_RIGHT, "ag-pinned-right-floating-bottom"],
  [RowContainerName.BOTTOM_FULL_WIDTH, "ag-floating-bottom-full-width-container"]
]);
var ViewportCssClasses = convertToMap([
  [RowContainerName.CENTER, "ag-center-cols-viewport"],
  [RowContainerName.TOP_CENTER, "ag-floating-top-viewport"],
  [RowContainerName.STICKY_TOP_CENTER, "ag-sticky-top-viewport"],
  [RowContainerName.BOTTOM_CENTER, "ag-floating-bottom-viewport"]
]);
var WrapperCssClasses = convertToMap([
  [RowContainerName.CENTER, "ag-center-cols-clipper"]
]);
var RowContainerCtrl = class extends BeanStub {
  constructor(name) {
    super();
    this.visible = true;
    this.EMPTY_CTRLS = [];
    this.name = name;
    this.isFullWithContainer = this.name === RowContainerName.TOP_FULL_WIDTH || this.name === RowContainerName.STICKY_TOP_FULL_WIDTH || this.name === RowContainerName.BOTTOM_FULL_WIDTH || this.name === RowContainerName.FULL_WIDTH;
  }
  static getRowContainerCssClasses(name) {
    const containerClass = ContainerCssClasses.get(name);
    const viewportClass = ViewportCssClasses.get(name);
    const wrapperClass = WrapperCssClasses.get(name);
    return { container: containerClass, viewport: viewportClass, wrapper: wrapperClass };
  }
  static getPinned(name) {
    switch (name) {
      case RowContainerName.BOTTOM_LEFT:
      case RowContainerName.TOP_LEFT:
      case RowContainerName.STICKY_TOP_LEFT:
      case RowContainerName.LEFT:
        return "left";
      case RowContainerName.BOTTOM_RIGHT:
      case RowContainerName.TOP_RIGHT:
      case RowContainerName.STICKY_TOP_RIGHT:
      case RowContainerName.RIGHT:
        return "right";
      default:
        return null;
    }
  }
  postConstruct() {
    this.enableRtl = this.gridOptionsService.is("enableRtl");
    this.embedFullWidthRows = this.gridOptionsService.is("embedFullWidthRows");
    this.forContainers([RowContainerName.CENTER], () => this.viewportSizeFeature = this.createManagedBean(new ViewportSizeFeature(this)));
  }
  registerWithCtrlsService() {
    switch (this.name) {
      case RowContainerName.CENTER:
        this.ctrlsService.registerCenterRowContainerCtrl(this);
        break;
      case RowContainerName.LEFT:
        this.ctrlsService.registerLeftRowContainerCtrl(this);
        break;
      case RowContainerName.RIGHT:
        this.ctrlsService.registerRightRowContainerCtrl(this);
        break;
      case RowContainerName.TOP_CENTER:
        this.ctrlsService.registerTopCenterRowContainerCtrl(this);
        break;
      case RowContainerName.TOP_LEFT:
        this.ctrlsService.registerTopLeftRowContainerCon(this);
        break;
      case RowContainerName.TOP_RIGHT:
        this.ctrlsService.registerTopRightRowContainerCtrl(this);
        break;
      case RowContainerName.STICKY_TOP_CENTER:
        this.ctrlsService.registerStickyTopCenterRowContainerCtrl(this);
        break;
      case RowContainerName.STICKY_TOP_LEFT:
        this.ctrlsService.registerStickyTopLeftRowContainerCon(this);
        break;
      case RowContainerName.STICKY_TOP_RIGHT:
        this.ctrlsService.registerStickyTopRightRowContainerCtrl(this);
        break;
      case RowContainerName.BOTTOM_CENTER:
        this.ctrlsService.registerBottomCenterRowContainerCtrl(this);
        break;
      case RowContainerName.BOTTOM_LEFT:
        this.ctrlsService.registerBottomLeftRowContainerCtrl(this);
        break;
      case RowContainerName.BOTTOM_RIGHT:
        this.ctrlsService.registerBottomRightRowContainerCtrl(this);
        break;
    }
  }
  forContainers(names, callback) {
    if (names.indexOf(this.name) >= 0) {
      callback();
    }
  }
  getContainerElement() {
    return this.eContainer;
  }
  getViewportSizeFeature() {
    return this.viewportSizeFeature;
  }
  setComp(view, eContainer, eViewport, eWrapper) {
    this.comp = view;
    this.eContainer = eContainer;
    this.eViewport = eViewport;
    this.eWrapper = eWrapper;
    this.createManagedBean(new RowContainerEventsFeature(this.eContainer));
    this.addPreventScrollWhileDragging();
    this.listenOnDomOrder();
    this.stopHScrollOnPinnedRows();
    const allTopNoFW = [RowContainerName.TOP_CENTER, RowContainerName.TOP_LEFT, RowContainerName.TOP_RIGHT];
    const allStickyTopNoFW = [RowContainerName.STICKY_TOP_CENTER, RowContainerName.STICKY_TOP_LEFT, RowContainerName.STICKY_TOP_RIGHT];
    const allBottomNoFW = [RowContainerName.BOTTOM_CENTER, RowContainerName.BOTTOM_LEFT, RowContainerName.BOTTOM_RIGHT];
    const allMiddleNoFW = [RowContainerName.CENTER, RowContainerName.LEFT, RowContainerName.RIGHT];
    const allNoFW = [...allTopNoFW, ...allBottomNoFW, ...allMiddleNoFW, ...allStickyTopNoFW];
    const allMiddle = [RowContainerName.CENTER, RowContainerName.LEFT, RowContainerName.RIGHT, RowContainerName.FULL_WIDTH];
    const allCenter = [RowContainerName.CENTER, RowContainerName.TOP_CENTER, RowContainerName.STICKY_TOP_CENTER, RowContainerName.BOTTOM_CENTER];
    const allLeft = [RowContainerName.LEFT, RowContainerName.BOTTOM_LEFT, RowContainerName.TOP_LEFT, RowContainerName.STICKY_TOP_LEFT];
    const allRight = [RowContainerName.RIGHT, RowContainerName.BOTTOM_RIGHT, RowContainerName.TOP_RIGHT, RowContainerName.STICKY_TOP_RIGHT];
    this.forContainers(allLeft, () => {
      this.pinnedWidthFeature = this.createManagedBean(new SetPinnedLeftWidthFeature(this.eContainer));
      this.addManagedListener(this.eventService, Events.EVENT_LEFT_PINNED_WIDTH_CHANGED, () => this.onPinnedWidthChanged());
    });
    this.forContainers(allRight, () => {
      this.pinnedWidthFeature = this.createManagedBean(new SetPinnedRightWidthFeature(this.eContainer));
      this.addManagedListener(this.eventService, Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED, () => this.onPinnedWidthChanged());
    });
    this.forContainers(allMiddle, () => this.createManagedBean(new SetHeightFeature(this.eContainer, this.eWrapper)));
    this.forContainers(allNoFW, () => this.createManagedBean(new DragListenerFeature(this.eContainer)));
    this.forContainers(allCenter, () => this.createManagedBean(new CenterWidthFeature((width) => this.comp.setContainerWidth(`${width}px`))));
    if (isInvisibleScrollbar()) {
      this.forContainers([RowContainerName.CENTER], () => {
        const pinnedWidthChangedEvent = this.enableRtl ? Events.EVENT_LEFT_PINNED_WIDTH_CHANGED : Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED;
        this.addManagedListener(this.eventService, pinnedWidthChangedEvent, () => this.refreshPaddingForFakeScrollbar());
      });
      this.refreshPaddingForFakeScrollbar();
    }
    this.addListeners();
    this.registerWithCtrlsService();
  }
  refreshPaddingForFakeScrollbar() {
    const { enableRtl, columnModel, name, eWrapper, eContainer } = this;
    const sideToCheck = enableRtl ? RowContainerName.LEFT : RowContainerName.RIGHT;
    this.forContainers([RowContainerName.CENTER, sideToCheck], () => {
      const pinnedWidth = columnModel.getContainerWidth(sideToCheck);
      const marginSide = enableRtl ? "marginLeft" : "marginRight";
      if (name === RowContainerName.CENTER) {
        eWrapper.style[marginSide] = pinnedWidth ? "0px" : "16px";
      } else {
        eContainer.style[marginSide] = pinnedWidth ? "16px" : "0px";
      }
    });
  }
  addListeners() {
    this.addManagedListener(this.eventService, Events.EVENT_SCROLL_VISIBILITY_CHANGED, () => this.onScrollVisibilityChanged());
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, () => this.onDisplayedColumnsChanged());
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, () => this.onDisplayedColumnsWidthChanged());
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_ROWS_CHANGED, (params) => this.onDisplayedRowsChanged(params.afterScroll));
    this.onScrollVisibilityChanged();
    this.onDisplayedColumnsChanged();
    this.onDisplayedColumnsWidthChanged();
    this.onDisplayedRowsChanged();
  }
  listenOnDomOrder() {
    const allStickyContainers = [RowContainerName.STICKY_TOP_CENTER, RowContainerName.STICKY_TOP_LEFT, RowContainerName.STICKY_TOP_RIGHT, RowContainerName.STICKY_TOP_FULL_WIDTH];
    const isStickContainer = allStickyContainers.indexOf(this.name) >= 0;
    if (isStickContainer) {
      this.comp.setDomOrder(true);
      return;
    }
    const listener = () => {
      const isEnsureDomOrder = this.gridOptionsService.is("ensureDomOrder");
      const isPrintLayout = this.gridOptionsService.isDomLayout("print");
      this.comp.setDomOrder(isEnsureDomOrder || isPrintLayout);
    };
    this.addManagedPropertyListener("domLayout", listener);
    listener();
  }
  stopHScrollOnPinnedRows() {
    this.forContainers([RowContainerName.TOP_CENTER, RowContainerName.STICKY_TOP_CENTER, RowContainerName.BOTTOM_CENTER], () => {
      const resetScrollLeft = () => this.eViewport.scrollLeft = 0;
      this.addManagedListener(this.eViewport, "scroll", resetScrollLeft);
    });
  }
  onDisplayedColumnsChanged() {
    this.forContainers([RowContainerName.CENTER], () => this.onHorizontalViewportChanged());
  }
  onDisplayedColumnsWidthChanged() {
    this.forContainers([RowContainerName.CENTER], () => this.onHorizontalViewportChanged());
  }
  onScrollVisibilityChanged() {
    const scrollWidth = this.gridOptionsService.getScrollbarWidth() || 0;
    if (this.name === RowContainerName.CENTER) {
      const visible = this.scrollVisibleService.isHorizontalScrollShowing();
      const scrollbarWidth = visible ? scrollWidth : 0;
      const size = scrollbarWidth == 0 ? "100%" : `calc(100% + ${scrollbarWidth}px)`;
      this.animationFrameService.requestAnimationFrame(() => this.comp.setViewportHeight(size));
    }
    if (this.name === RowContainerName.FULL_WIDTH) {
      const pad = isInvisibleScrollbar() ? 16 : 0;
      const size = `calc(100% - ${pad}px)`;
      this.eContainer.style.setProperty("width", size);
    }
  }
  addPreventScrollWhileDragging() {
    const preventScroll = (e) => {
      if (this.dragService.isDragging()) {
        if (e.cancelable) {
          e.preventDefault();
        }
      }
    };
    this.eContainer.addEventListener("touchmove", preventScroll, { passive: false });
    this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", preventScroll));
  }
  onHorizontalViewportChanged() {
    const scrollWidth = this.getCenterWidth();
    const scrollPosition = this.getCenterViewportScrollLeft();
    this.columnModel.setViewportPosition(scrollWidth, scrollPosition);
  }
  getCenterWidth() {
    return getInnerWidth(this.eViewport);
  }
  getCenterViewportScrollLeft() {
    return getScrollLeft(this.eViewport, this.enableRtl);
  }
  registerViewportResizeListener(listener) {
    const unsubscribeFromResize = this.resizeObserverService.observeResize(this.eViewport, listener);
    this.addDestroyFunc(() => unsubscribeFromResize());
  }
  isViewportVisible() {
    return isVisible(this.eViewport);
  }
  getViewportScrollLeft() {
    return getScrollLeft(this.eViewport, this.enableRtl);
  }
  isHorizontalScrollShowing() {
    const isAlwaysShowHorizontalScroll = this.gridOptionsService.is("alwaysShowHorizontalScroll");
    return isAlwaysShowHorizontalScroll || isHorizontalScrollShowing(this.eViewport);
  }
  getViewportElement() {
    return this.eViewport;
  }
  setContainerTranslateX(amount) {
    this.eContainer.style.transform = `translateX(${amount}px)`;
  }
  getHScrollPosition() {
    const res = {
      left: this.eViewport.scrollLeft,
      right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
    };
    return res;
  }
  setCenterViewportScrollLeft(value) {
    setScrollLeft(this.eViewport, value, this.enableRtl);
  }
  isContainerVisible() {
    const pinned = RowContainerCtrl.getPinned(this.name);
    return !pinned || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
  }
  onPinnedWidthChanged() {
    const visible = this.isContainerVisible();
    if (this.visible != visible) {
      this.visible = visible;
      this.onDisplayedRowsChanged();
    }
    if (isInvisibleScrollbar()) {
      this.refreshPaddingForFakeScrollbar();
    }
  }
  onDisplayedRowsChanged(useFlushSync = false) {
    if (this.visible) {
      const printLayout = this.gridOptionsService.isDomLayout("print");
      const doesRowMatch = (rowCtrl) => {
        const fullWidthRow = rowCtrl.isFullWidth();
        const embedFW = this.embedFullWidthRows || printLayout;
        const match = this.isFullWithContainer ? !embedFW && fullWidthRow : embedFW || !fullWidthRow;
        return match;
      };
      const rowsThisContainer = this.getRowCtrls().filter(doesRowMatch);
      this.comp.setRowCtrls(rowsThisContainer, useFlushSync);
    } else {
      this.comp.setRowCtrls(this.EMPTY_CTRLS, false);
    }
  }
  getRowCtrls() {
    switch (this.name) {
      case RowContainerName.TOP_CENTER:
      case RowContainerName.TOP_LEFT:
      case RowContainerName.TOP_RIGHT:
      case RowContainerName.TOP_FULL_WIDTH:
        return this.rowRenderer.getTopRowCtrls();
      case RowContainerName.STICKY_TOP_CENTER:
      case RowContainerName.STICKY_TOP_LEFT:
      case RowContainerName.STICKY_TOP_RIGHT:
      case RowContainerName.STICKY_TOP_FULL_WIDTH:
        return this.rowRenderer.getStickyTopRowCtrls();
      case RowContainerName.BOTTOM_CENTER:
      case RowContainerName.BOTTOM_LEFT:
      case RowContainerName.BOTTOM_RIGHT:
      case RowContainerName.BOTTOM_FULL_WIDTH:
        return this.rowRenderer.getBottomRowCtrls();
      default:
        return this.rowRenderer.getRowCtrls();
    }
  }
};
__decorate$1F([
  Autowired("scrollVisibleService")
], RowContainerCtrl.prototype, "scrollVisibleService", void 0);
__decorate$1F([
  Autowired("dragService")
], RowContainerCtrl.prototype, "dragService", void 0);
__decorate$1F([
  Autowired("ctrlsService")
], RowContainerCtrl.prototype, "ctrlsService", void 0);
__decorate$1F([
  Autowired("columnModel")
], RowContainerCtrl.prototype, "columnModel", void 0);
__decorate$1F([
  Autowired("resizeObserverService")
], RowContainerCtrl.prototype, "resizeObserverService", void 0);
__decorate$1F([
  Autowired("animationFrameService")
], RowContainerCtrl.prototype, "animationFrameService", void 0);
__decorate$1F([
  Autowired("rowRenderer")
], RowContainerCtrl.prototype, "rowRenderer", void 0);
__decorate$1F([
  PostConstruct
], RowContainerCtrl.prototype, "postConstruct", null);
var __decorate$1E = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GRID_BODY_TEMPLATE = `<div class="ag-root ag-unselectable" role="treegrid">
        <ag-header-root ref="gridHeader"></ag-header-root>
        <div class="ag-floating-top" ref="eTop" role="presentation">
            <ag-row-container ref="topLeftContainer" name="${RowContainerName.TOP_LEFT}"></ag-row-container>
            <ag-row-container ref="topCenterContainer" name="${RowContainerName.TOP_CENTER}"></ag-row-container>
            <ag-row-container ref="topRightContainer" name="${RowContainerName.TOP_RIGHT}"></ag-row-container>
            <ag-row-container ref="topFullWidthContainer" name="${RowContainerName.TOP_FULL_WIDTH}"></ag-row-container>
        </div>
        <div class="ag-body" ref="eBody" role="presentation">
            <div class="ag-body-clipper" ref="eBodyClipper" role="presentation">
                <div class="ag-body-viewport" ref="eBodyViewport" role="presentation">
                    <ag-row-container ref="leftContainer" name="${RowContainerName.LEFT}"></ag-row-container>
                    <ag-row-container ref="centerContainer" name="${RowContainerName.CENTER}"></ag-row-container>
                    <ag-row-container ref="rightContainer" name="${RowContainerName.RIGHT}"></ag-row-container>
                    <ag-row-container ref="fullWidthContainer" name="${RowContainerName.FULL_WIDTH}"></ag-row-container>
                </div>
            </div>
            <ag-fake-vertical-scroll></ag-fake-vertical-scroll>
        </div>
        <div class="ag-sticky-top" ref="eStickyTop" role="presentation">
            <ag-row-container ref="stickyTopLeftContainer" name="${RowContainerName.STICKY_TOP_LEFT}"></ag-row-container>
            <ag-row-container ref="stickyTopCenterContainer" name="${RowContainerName.STICKY_TOP_CENTER}"></ag-row-container>
            <ag-row-container ref="stickyTopRightContainer" name="${RowContainerName.STICKY_TOP_RIGHT}"></ag-row-container>
            <ag-row-container ref="stickyTopFullWidthContainer" name="${RowContainerName.STICKY_TOP_FULL_WIDTH}"></ag-row-container>
        </div>
        <div class="ag-floating-bottom" ref="eBottom" role="presentation">
            <ag-row-container ref="bottomLeftContainer" name="${RowContainerName.BOTTOM_LEFT}"></ag-row-container>
            <ag-row-container ref="bottomCenterContainer" name="${RowContainerName.BOTTOM_CENTER}"></ag-row-container>
            <ag-row-container ref="bottomRightContainer" name="${RowContainerName.BOTTOM_RIGHT}"></ag-row-container>
            <ag-row-container ref="bottomFullWidthContainer" name="${RowContainerName.BOTTOM_FULL_WIDTH}"></ag-row-container>
        </div>
        <ag-fake-horizontal-scroll></ag-fake-horizontal-scroll>
        <ag-overlay-wrapper></ag-overlay-wrapper>
    </div>`;
var GridBodyComp = class extends Component {
  constructor() {
    super(GRID_BODY_TEMPLATE);
  }
  init() {
    const setHeight = (height, element) => {
      const heightString = `${height}px`;
      element.style.minHeight = heightString;
      element.style.height = heightString;
    };
    const compProxy = {
      setRowAnimationCssOnBodyViewport: (cssClass, animate) => this.setRowAnimationCssOnBodyViewport(cssClass, animate),
      setColumnCount: (count) => setAriaColCount(this.getGui(), count),
      setRowCount: (count) => setAriaRowCount(this.getGui(), count),
      setTopHeight: (height) => setHeight(height, this.eTop),
      setBottomHeight: (height) => setHeight(height, this.eBottom),
      setTopDisplay: (display) => this.eTop.style.display = display,
      setBottomDisplay: (display) => this.eBottom.style.display = display,
      setStickyTopHeight: (height) => this.eStickyTop.style.height = height,
      setStickyTopTop: (top) => this.eStickyTop.style.top = top,
      setStickyTopWidth: (width) => this.eStickyTop.style.width = width,
      setColumnMovingCss: (cssClass, flag) => this.addOrRemoveCssClass(cssClass, flag),
      updateLayoutClasses: (cssClass, params) => {
        const classLists = [
          this.eBodyViewport.classList,
          this.eBodyClipper.classList,
          this.eBody.classList
        ];
        classLists.forEach((classList) => {
          classList.toggle(LayoutCssClasses.AUTO_HEIGHT, params.autoHeight);
          classList.toggle(LayoutCssClasses.NORMAL, params.normal);
          classList.toggle(LayoutCssClasses.PRINT, params.print);
        });
        this.addOrRemoveCssClass(LayoutCssClasses.AUTO_HEIGHT, params.autoHeight);
        this.addOrRemoveCssClass(LayoutCssClasses.NORMAL, params.normal);
        this.addOrRemoveCssClass(LayoutCssClasses.PRINT, params.print);
      },
      setAlwaysVerticalScrollClass: (cssClass, on) => this.eBodyViewport.classList.toggle(CSS_CLASS_FORCE_VERTICAL_SCROLL, on),
      registerBodyViewportResizeListener: (listener) => {
        const unsubscribeFromResize = this.resizeObserverService.observeResize(this.eBodyViewport, listener);
        this.addDestroyFunc(() => unsubscribeFromResize());
      },
      setPinnedTopBottomOverflowY: (overflow) => this.eTop.style.overflowY = this.eBottom.style.overflowY = overflow,
      setCellSelectableCss: (cssClass, selectable) => {
        [this.eTop, this.eBodyViewport, this.eBottom].forEach((ct) => ct.classList.toggle(cssClass, selectable));
      },
      setBodyViewportWidth: (width) => this.eBodyViewport.style.width = width
    };
    this.ctrl = this.createManagedBean(new GridBodyCtrl());
    this.ctrl.setComp(compProxy, this.getGui(), this.eBodyViewport, this.eTop, this.eBottom, this.eStickyTop);
    if (this.rangeService || this.gridOptionsService.get("rowSelection") === "multiple") {
      setAriaMultiSelectable(this.getGui(), true);
    }
  }
  setRowAnimationCssOnBodyViewport(cssClass, animateRows) {
    const bodyViewportClassList = this.eBodyViewport.classList;
    bodyViewportClassList.toggle(RowAnimationCssClasses.ANIMATION_ON, animateRows);
    bodyViewportClassList.toggle(RowAnimationCssClasses.ANIMATION_OFF, !animateRows);
  }
  getFloatingTopBottom() {
    return [this.eTop, this.eBottom];
  }
};
__decorate$1E([
  Autowired("resizeObserverService")
], GridBodyComp.prototype, "resizeObserverService", void 0);
__decorate$1E([
  Optional("rangeService")
], GridBodyComp.prototype, "rangeService", void 0);
__decorate$1E([
  RefSelector("eBodyViewport")
], GridBodyComp.prototype, "eBodyViewport", void 0);
__decorate$1E([
  RefSelector("eStickyTop")
], GridBodyComp.prototype, "eStickyTop", void 0);
__decorate$1E([
  RefSelector("eTop")
], GridBodyComp.prototype, "eTop", void 0);
__decorate$1E([
  RefSelector("eBottom")
], GridBodyComp.prototype, "eBottom", void 0);
__decorate$1E([
  RefSelector("gridHeader")
], GridBodyComp.prototype, "headerRootComp", void 0);
__decorate$1E([
  RefSelector("eBodyClipper")
], GridBodyComp.prototype, "eBodyClipper", void 0);
__decorate$1E([
  RefSelector("eBody")
], GridBodyComp.prototype, "eBody", void 0);
__decorate$1E([
  PostConstruct
], GridBodyComp.prototype, "init", null);
var __decorate$1D = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ScrollVisibleService = class ScrollVisibleService2 extends BeanStub {
  postConstruct() {
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));
  }
  onDisplayedColumnsChanged() {
    this.update();
  }
  onDisplayedColumnsWidthChanged() {
    this.update();
  }
  update() {
    this.updateImpl();
    setTimeout(this.updateImpl.bind(this), 500);
  }
  updateImpl() {
    const centerRowCtrl = this.ctrlsService.getCenterRowContainerCtrl();
    if (!centerRowCtrl) {
      return;
    }
    const params = {
      horizontalScrollShowing: centerRowCtrl.isHorizontalScrollShowing(),
      verticalScrollShowing: this.isVerticalScrollShowing()
    };
    this.setScrollsVisible(params);
  }
  setScrollsVisible(params) {
    const atLeastOneDifferent = this.horizontalScrollShowing !== params.horizontalScrollShowing || this.verticalScrollShowing !== params.verticalScrollShowing;
    if (atLeastOneDifferent) {
      this.horizontalScrollShowing = params.horizontalScrollShowing;
      this.verticalScrollShowing = params.verticalScrollShowing;
      const event = {
        type: Events.EVENT_SCROLL_VISIBILITY_CHANGED
      };
      this.eventService.dispatchEvent(event);
    }
  }
  isHorizontalScrollShowing() {
    return this.horizontalScrollShowing;
  }
  isVerticalScrollShowing() {
    return this.verticalScrollShowing;
  }
};
__decorate$1D([
  Autowired("ctrlsService")
], ScrollVisibleService.prototype, "ctrlsService", void 0);
__decorate$1D([
  PostConstruct
], ScrollVisibleService.prototype, "postConstruct", null);
ScrollVisibleService = __decorate$1D([
  Bean("scrollVisibleService")
], ScrollVisibleService);
var __decorate$1C = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var MouseEventService_1;
var MouseEventService = MouseEventService_1 = class MouseEventService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.gridInstanceId = MouseEventService_1.gridInstanceSequence.next();
  }
  stampTopLevelGridCompWithGridInstance(eGridDiv) {
    eGridDiv[MouseEventService_1.GRID_DOM_KEY] = this.gridInstanceId;
  }
  getRenderedCellForEvent(event) {
    return getCtrlForEventTarget(this.gridOptionsService, event.target, CellCtrl.DOM_DATA_KEY_CELL_CTRL);
  }
  isEventFromThisGrid(event) {
    const res = this.isElementInThisGrid(event.target);
    return res;
  }
  isElementInThisGrid(element) {
    let pointer = element;
    while (pointer) {
      const instanceId = pointer[MouseEventService_1.GRID_DOM_KEY];
      if (exists(instanceId)) {
        const eventFromThisGrid = instanceId === this.gridInstanceId;
        return eventFromThisGrid;
      }
      pointer = pointer.parentElement;
    }
    return false;
  }
  getCellPositionForEvent(event) {
    const cellComp = this.getRenderedCellForEvent(event);
    return cellComp ? cellComp.getCellPosition() : null;
  }
  getNormalisedPosition(event) {
    const gridPanelHasScrolls = this.gridOptionsService.isDomLayout("normal");
    const e = event;
    let x;
    let y;
    if (e.clientX != null || e.clientY != null) {
      x = e.clientX;
      y = e.clientY;
    } else {
      x = e.x;
      y = e.y;
    }
    if (gridPanelHasScrolls) {
      const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
      const vRange = gridBodyCon.getScrollFeature().getVScrollPosition();
      const hRange = gridBodyCon.getScrollFeature().getHScrollPosition();
      x += hRange.left;
      y += vRange.top;
    }
    return { x, y };
  }
};
MouseEventService.gridInstanceSequence = new NumberSequence();
MouseEventService.GRID_DOM_KEY = "__ag_grid_instance";
__decorate$1C([
  Autowired("ctrlsService")
], MouseEventService.prototype, "ctrlsService", void 0);
MouseEventService = MouseEventService_1 = __decorate$1C([
  Bean("mouseEventService")
], MouseEventService);
var __decorate$1B = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NavigationService = class NavigationService2 extends BeanStub {
  constructor() {
    super();
    this.onPageDown = throttle(this.onPageDown, 100);
    this.onPageUp = throttle(this.onPageUp, 100);
  }
  postConstruct() {
    this.ctrlsService.whenReady((p) => {
      this.gridBodyCon = p.gridBodyCtrl;
    });
  }
  handlePageScrollingKey(event) {
    const key = event.key;
    const alt = event.altKey;
    const ctrl = event.ctrlKey || event.metaKey;
    const rangeServiceShouldHandleShift = !!this.rangeService && event.shiftKey;
    const currentCell = this.mouseEventService.getCellPositionForEvent(event);
    let processed = false;
    switch (key) {
      case KeyCode.PAGE_HOME:
      case KeyCode.PAGE_END:
        if (!ctrl && !alt) {
          this.onHomeOrEndKey(key);
          processed = true;
        }
        break;
      case KeyCode.LEFT:
      case KeyCode.RIGHT:
      case KeyCode.UP:
      case KeyCode.DOWN:
        if (!currentCell) {
          return false;
        }
        if (ctrl && !alt && !rangeServiceShouldHandleShift) {
          this.onCtrlUpDownLeftRight(key, currentCell);
          processed = true;
        }
        break;
      case KeyCode.PAGE_DOWN:
        if (!currentCell) {
          return false;
        }
        if (!ctrl && !alt) {
          this.onPageDown(currentCell);
          processed = true;
        }
        break;
      case KeyCode.PAGE_UP:
        if (!currentCell) {
          return false;
        }
        if (!ctrl && !alt) {
          this.onPageUp(currentCell);
          processed = true;
        }
        break;
    }
    if (processed) {
      event.preventDefault();
    }
    return processed;
  }
  navigateTo(navigateParams) {
    const { scrollIndex, scrollType, scrollColumn, focusIndex, focusColumn } = navigateParams;
    if (exists(scrollColumn) && !scrollColumn.isPinned()) {
      this.gridBodyCon.getScrollFeature().ensureColumnVisible(scrollColumn);
    }
    if (exists(scrollIndex)) {
      this.gridBodyCon.getScrollFeature().ensureIndexVisible(scrollIndex, scrollType);
    }
    if (!navigateParams.isAsync) {
      this.gridBodyCon.getScrollFeature().ensureIndexVisible(focusIndex);
    }
    this.focusService.setFocusedCell({ rowIndex: focusIndex, column: focusColumn, rowPinned: null, forceBrowserFocus: true });
    if (this.rangeService) {
      const cellPosition = { rowIndex: focusIndex, rowPinned: null, column: focusColumn };
      this.rangeService.setRangeToCell(cellPosition);
    }
  }
  onPageDown(gridCell) {
    const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
    const scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();
    const pixelsInOnePage = this.getViewportHeight();
    const pagingPixelOffset = this.paginationProxy.getPixelOffset();
    const currentPageBottomPixel = scrollPosition.top + pixelsInOnePage;
    const currentPageBottomRow = this.paginationProxy.getRowIndexAtPixel(currentPageBottomPixel + pagingPixelOffset);
    if (this.columnModel.isAutoRowHeightActive()) {
      this.navigateToNextPageWithAutoHeight(gridCell, currentPageBottomRow);
    } else {
      this.navigateToNextPage(gridCell, currentPageBottomRow);
    }
  }
  onPageUp(gridCell) {
    const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
    const scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();
    const pagingPixelOffset = this.paginationProxy.getPixelOffset();
    const currentPageTopPixel = scrollPosition.top;
    const currentPageTopRow = this.paginationProxy.getRowIndexAtPixel(currentPageTopPixel + pagingPixelOffset);
    if (this.columnModel.isAutoRowHeightActive()) {
      this.navigateToNextPageWithAutoHeight(gridCell, currentPageTopRow, true);
    } else {
      this.navigateToNextPage(gridCell, currentPageTopRow, true);
    }
  }
  navigateToNextPage(gridCell, scrollIndex, up = false) {
    const pixelsInOnePage = this.getViewportHeight();
    const firstRow = this.paginationProxy.getPageFirstRow();
    const lastRow = this.paginationProxy.getPageLastRow();
    const pagingPixelOffset = this.paginationProxy.getPixelOffset();
    const currentRowNode = this.paginationProxy.getRow(gridCell.rowIndex);
    const rowPixelDiff = up ? (currentRowNode === null || currentRowNode === void 0 ? void 0 : currentRowNode.rowHeight) - pixelsInOnePage - pagingPixelOffset : pixelsInOnePage - pagingPixelOffset;
    const nextCellPixel = (currentRowNode === null || currentRowNode === void 0 ? void 0 : currentRowNode.rowTop) + rowPixelDiff;
    let focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);
    if (focusIndex === gridCell.rowIndex) {
      const diff = up ? -1 : 1;
      scrollIndex = focusIndex = gridCell.rowIndex + diff;
    }
    let scrollType;
    if (up) {
      scrollType = "bottom";
      if (focusIndex < firstRow) {
        focusIndex = firstRow;
      }
      if (scrollIndex < firstRow) {
        scrollIndex = firstRow;
      }
    } else {
      scrollType = "top";
      if (focusIndex > lastRow) {
        focusIndex = lastRow;
      }
      if (scrollIndex > lastRow) {
        scrollIndex = lastRow;
      }
    }
    if (this.isRowTallerThanView(focusIndex)) {
      scrollIndex = focusIndex;
      scrollType = "top";
    }
    this.navigateTo({
      scrollIndex,
      scrollType,
      scrollColumn: null,
      focusIndex,
      focusColumn: gridCell.column
    });
  }
  navigateToNextPageWithAutoHeight(gridCell, scrollIndex, up = false) {
    this.navigateTo({
      scrollIndex,
      scrollType: up ? "bottom" : "top",
      scrollColumn: null,
      focusIndex: scrollIndex,
      focusColumn: gridCell.column
    });
    setTimeout(() => {
      const focusIndex = this.getNextFocusIndexForAutoHeight(gridCell, up);
      this.navigateTo({
        scrollIndex,
        scrollType: up ? "bottom" : "top",
        scrollColumn: null,
        focusIndex,
        focusColumn: gridCell.column,
        isAsync: true
      });
    }, 50);
  }
  getNextFocusIndexForAutoHeight(gridCell, up = false) {
    var _a;
    const step = up ? -1 : 1;
    const pixelsInOnePage = this.getViewportHeight();
    const lastRowIndex = this.paginationProxy.getPageLastRow();
    let pixelSum = 0;
    let currentIndex = gridCell.rowIndex;
    while (currentIndex >= 0 && currentIndex <= lastRowIndex) {
      const currentCell = this.paginationProxy.getRow(currentIndex);
      if (currentCell) {
        const currentCellHeight = (_a = currentCell.rowHeight) !== null && _a !== void 0 ? _a : 0;
        if (pixelSum + currentCellHeight > pixelsInOnePage) {
          break;
        }
        pixelSum += currentCellHeight;
      }
      currentIndex += step;
    }
    return Math.max(0, Math.min(currentIndex, lastRowIndex));
  }
  getViewportHeight() {
    const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
    const scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();
    const scrollbarWidth = this.gridOptionsService.getScrollbarWidth();
    let pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;
    if (this.ctrlsService.getCenterRowContainerCtrl().isHorizontalScrollShowing()) {
      pixelsInOnePage -= scrollbarWidth;
    }
    return pixelsInOnePage;
  }
  isRowTallerThanView(rowIndex) {
    const rowNode = this.paginationProxy.getRow(rowIndex);
    if (!rowNode) {
      return false;
    }
    const rowHeight = rowNode.rowHeight;
    if (typeof rowHeight !== "number") {
      return false;
    }
    return rowHeight > this.getViewportHeight();
  }
  onCtrlUpDownLeftRight(key, gridCell) {
    const cellToFocus = this.cellNavigationService.getNextCellToFocus(key, gridCell, true);
    const { rowIndex, column } = cellToFocus;
    this.navigateTo({
      scrollIndex: rowIndex,
      scrollType: null,
      scrollColumn: column,
      focusIndex: rowIndex,
      focusColumn: column
    });
  }
  onHomeOrEndKey(key) {
    const homeKey = key === KeyCode.PAGE_HOME;
    const allColumns = this.columnModel.getAllDisplayedColumns();
    const columnToSelect = homeKey ? allColumns[0] : last(allColumns);
    const scrollIndex = homeKey ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();
    this.navigateTo({
      scrollIndex,
      scrollType: null,
      scrollColumn: columnToSelect,
      focusIndex: scrollIndex,
      focusColumn: columnToSelect
    });
  }
  onTabKeyDown(previous, keyboardEvent) {
    const backwards = keyboardEvent.shiftKey;
    const movedToNextCell = this.tabToNextCellCommon(previous, backwards, keyboardEvent);
    if (movedToNextCell) {
      keyboardEvent.preventDefault();
      return;
    }
    if (backwards) {
      const { rowIndex, rowPinned } = previous.getRowPosition();
      const firstRow = rowPinned ? rowIndex === 0 : rowIndex === this.paginationProxy.getPageFirstRow();
      if (firstRow) {
        if (this.gridOptionsService.getNum("headerHeight") === 0) {
          this.focusService.focusNextGridCoreContainer(true, true);
        } else {
          keyboardEvent.preventDefault();
          this.focusService.focusLastHeader(keyboardEvent);
        }
      }
    } else {
      if (previous instanceof CellCtrl) {
        previous.focusCell(true);
      }
      if (this.focusService.focusNextGridCoreContainer(backwards)) {
        keyboardEvent.preventDefault();
      }
    }
  }
  tabToNextCell(backwards, event) {
    const focusedCell = this.focusService.getFocusedCell();
    if (!focusedCell) {
      return false;
    }
    let cellOrRow = this.getCellByPosition(focusedCell);
    if (!cellOrRow) {
      cellOrRow = this.rowRenderer.getRowByPosition(focusedCell);
      if (!cellOrRow || !cellOrRow.isFullWidth()) {
        return false;
      }
    }
    return this.tabToNextCellCommon(cellOrRow, backwards, event);
  }
  tabToNextCellCommon(previous, backwards, event) {
    let editing = previous.isEditing();
    if (!editing && previous instanceof CellCtrl) {
      const cell = previous;
      const row = cell.getRowCtrl();
      if (row) {
        editing = row.isEditing();
      }
    }
    let res;
    if (editing) {
      if (this.gridOptionsService.get("editType") === "fullRow") {
        res = this.moveToNextEditingRow(previous, backwards, event);
      } else {
        res = this.moveToNextEditingCell(previous, backwards, event);
      }
    } else {
      res = this.moveToNextCellNotEditing(previous, backwards);
    }
    return res || !!this.focusService.getFocusedHeader();
  }
  moveToNextEditingCell(previousCell, backwards, event = null) {
    const previousPos = previousCell.getCellPosition();
    previousCell.getGui().focus();
    previousCell.stopEditing();
    const nextCell = this.findNextCellToFocusOn(previousPos, backwards, true);
    if (nextCell == null) {
      return false;
    }
    nextCell.startEditing(null, true, event);
    nextCell.focusCell(false);
    return true;
  }
  moveToNextEditingRow(previousCell, backwards, event = null) {
    const previousPos = previousCell.getCellPosition();
    const nextCell = this.findNextCellToFocusOn(previousPos, backwards, true);
    if (nextCell == null) {
      return false;
    }
    const nextPos = nextCell.getCellPosition();
    const previousEditable = this.isCellEditable(previousPos);
    const nextEditable = this.isCellEditable(nextPos);
    const rowsMatch = nextPos && previousPos.rowIndex === nextPos.rowIndex && previousPos.rowPinned === nextPos.rowPinned;
    if (previousEditable) {
      previousCell.setFocusOutOnEditor();
    }
    if (!rowsMatch) {
      const pRow = previousCell.getRowCtrl();
      pRow.stopEditing();
      const nRow = nextCell.getRowCtrl();
      nRow.startRowEditing(void 0, void 0, event);
    }
    if (nextEditable) {
      nextCell.setFocusInOnEditor();
      nextCell.focusCell();
    } else {
      nextCell.focusCell(true);
    }
    return true;
  }
  moveToNextCellNotEditing(previousCell, backwards) {
    const displayedColumns = this.columnModel.getAllDisplayedColumns();
    let cellPos;
    if (previousCell instanceof RowCtrl) {
      cellPos = Object.assign(Object.assign({}, previousCell.getRowPosition()), { column: backwards ? displayedColumns[0] : last(displayedColumns) });
    } else {
      cellPos = previousCell.getCellPosition();
    }
    const nextCell = this.findNextCellToFocusOn(cellPos, backwards, false);
    if (nextCell instanceof CellCtrl) {
      nextCell.focusCell(true);
    } else if (nextCell) {
      return this.tryToFocusFullWidthRow(nextCell.getRowPosition(), backwards);
    }
    return exists(nextCell);
  }
  findNextCellToFocusOn(previousPosition, backwards, startEditing) {
    let nextPosition = previousPosition;
    while (true) {
      if (previousPosition !== nextPosition) {
        previousPosition = nextPosition;
      }
      if (!backwards) {
        nextPosition = this.getLastCellOfColSpan(nextPosition);
      }
      nextPosition = this.cellNavigationService.getNextTabbedCell(nextPosition, backwards);
      const userFunc = this.gridOptionsService.getCallback("tabToNextCell");
      if (exists(userFunc)) {
        const params = {
          backwards,
          editing: startEditing,
          previousCellPosition: previousPosition,
          nextCellPosition: nextPosition ? nextPosition : null
        };
        const userCell = userFunc(params);
        if (exists(userCell)) {
          if (userCell.floating) {
            doOnce(() => {
              console.warn(`AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?`);
            }, "no floating in userCell");
            userCell.rowPinned = userCell.floating;
          }
          nextPosition = {
            rowIndex: userCell.rowIndex,
            column: userCell.column,
            rowPinned: userCell.rowPinned
          };
        } else {
          nextPosition = null;
        }
      }
      if (!nextPosition) {
        return null;
      }
      if (nextPosition.rowIndex < 0) {
        const headerLen = this.headerNavigationService.getHeaderRowCount();
        this.focusService.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: headerLen + nextPosition.rowIndex,
            column: nextPosition.column
          }
        });
        return null;
      }
      const fullRowEdit = this.gridOptionsService.get("editType") === "fullRow";
      if (startEditing && !fullRowEdit) {
        const cellIsEditable = this.isCellEditable(nextPosition);
        if (!cellIsEditable) {
          continue;
        }
      }
      this.ensureCellVisible(nextPosition);
      const nextCell = this.getCellByPosition(nextPosition);
      if (!nextCell) {
        const row = this.rowRenderer.getRowByPosition(nextPosition);
        if (!row || !row.isFullWidth() || startEditing) {
          continue;
        }
        return row;
      }
      if (nextCell.isSuppressNavigable()) {
        continue;
      }
      if (this.rangeService) {
        this.rangeService.setRangeToCell(nextPosition);
      }
      return nextCell;
    }
  }
  isCellEditable(cell) {
    const rowNode = this.lookupRowNodeForCell(cell);
    if (rowNode) {
      return cell.column.isCellEditable(rowNode);
    }
    return false;
  }
  getCellByPosition(cellPosition) {
    const rowCtrl = this.rowRenderer.getRowByPosition(cellPosition);
    if (!rowCtrl) {
      return null;
    }
    return rowCtrl.getCellCtrl(cellPosition.column);
  }
  lookupRowNodeForCell(cell) {
    if (cell.rowPinned === "top") {
      return this.pinnedRowModel.getPinnedTopRow(cell.rowIndex);
    }
    if (cell.rowPinned === "bottom") {
      return this.pinnedRowModel.getPinnedBottomRow(cell.rowIndex);
    }
    return this.paginationProxy.getRow(cell.rowIndex);
  }
  navigateToNextCell(event, key, currentCell, allowUserOverride) {
    let nextCell = currentCell;
    let hitEdgeOfGrid = false;
    while (nextCell && (nextCell === currentCell || !this.isValidNavigateCell(nextCell))) {
      if (this.gridOptionsService.is("enableRtl")) {
        if (key === KeyCode.LEFT) {
          nextCell = this.getLastCellOfColSpan(nextCell);
        }
      } else if (key === KeyCode.RIGHT) {
        nextCell = this.getLastCellOfColSpan(nextCell);
      }
      nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell);
      hitEdgeOfGrid = missing(nextCell);
    }
    if (hitEdgeOfGrid && event && event.key === KeyCode.UP) {
      nextCell = {
        rowIndex: -1,
        rowPinned: null,
        column: currentCell.column
      };
    }
    if (allowUserOverride) {
      const userFunc = this.gridOptionsService.getCallback("navigateToNextCell");
      if (exists(userFunc)) {
        const params = {
          key,
          previousCellPosition: currentCell,
          nextCellPosition: nextCell ? nextCell : null,
          event
        };
        const userCell = userFunc(params);
        if (exists(userCell)) {
          if (userCell.floating) {
            doOnce(() => {
              console.warn(`AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?`);
            }, "no floating in userCell");
            userCell.rowPinned = userCell.floating;
          }
          nextCell = {
            rowPinned: userCell.rowPinned,
            rowIndex: userCell.rowIndex,
            column: userCell.column
          };
        } else {
          nextCell = null;
        }
      }
    }
    if (!nextCell) {
      return;
    }
    if (nextCell.rowIndex < 0) {
      const headerLen = this.headerNavigationService.getHeaderRowCount();
      this.focusService.focusHeaderPosition({
        headerPosition: { headerRowIndex: headerLen + nextCell.rowIndex, column: currentCell.column },
        event: event || void 0
      });
      return;
    }
    const normalisedPosition = this.getNormalisedPosition(nextCell);
    if (normalisedPosition) {
      this.focusPosition(normalisedPosition);
    } else {
      this.tryToFocusFullWidthRow(nextCell);
    }
  }
  getNormalisedPosition(cellPosition) {
    this.ensureCellVisible(cellPosition);
    const cellCtrl = this.getCellByPosition(cellPosition);
    if (!cellCtrl) {
      return null;
    }
    cellPosition = cellCtrl.getCellPosition();
    this.ensureCellVisible(cellPosition);
    return cellPosition;
  }
  tryToFocusFullWidthRow(position, backwards = false) {
    const displayedColumns = this.columnModel.getAllDisplayedColumns();
    const rowComp = this.rowRenderer.getRowByPosition(position);
    if (!rowComp || !rowComp.isFullWidth()) {
      return false;
    }
    const currentCellFocused = this.focusService.getFocusedCell();
    const cellPosition = {
      rowIndex: position.rowIndex,
      rowPinned: position.rowPinned,
      column: position.column || (backwards ? last(displayedColumns) : displayedColumns[0])
    };
    this.focusPosition(cellPosition);
    const fromBelow = currentCellFocused != null ? this.rowPositionUtils.before(cellPosition, currentCellFocused) : false;
    const focusEvent = {
      type: Events.EVENT_FULL_WIDTH_ROW_FOCUSED,
      rowIndex: cellPosition.rowIndex,
      rowPinned: cellPosition.rowPinned,
      column: cellPosition.column,
      isFullWidthCell: true,
      floating: cellPosition.rowPinned,
      fromBelow
    };
    this.eventService.dispatchEvent(focusEvent);
    return true;
  }
  focusPosition(cellPosition) {
    this.focusService.setFocusedCell({
      rowIndex: cellPosition.rowIndex,
      column: cellPosition.column,
      rowPinned: cellPosition.rowPinned,
      forceBrowserFocus: true
    });
    if (this.rangeService) {
      this.rangeService.setRangeToCell(cellPosition);
    }
  }
  isValidNavigateCell(cell) {
    const rowNode = this.rowPositionUtils.getRowNode(cell);
    return !!rowNode;
  }
  getLastCellOfColSpan(cell) {
    const cellCtrl = this.getCellByPosition(cell);
    if (!cellCtrl) {
      return cell;
    }
    const colSpanningList = cellCtrl.getColSpanningList();
    if (colSpanningList.length === 1) {
      return cell;
    }
    return {
      rowIndex: cell.rowIndex,
      column: last(colSpanningList),
      rowPinned: cell.rowPinned
    };
  }
  ensureCellVisible(gridCell) {
    const isGroupStickyEnabled = this.gridOptionsService.isGroupRowsSticky();
    const rowNode = this.rowModel.getRow(gridCell.rowIndex);
    const skipScrollToRow = isGroupStickyEnabled && (rowNode === null || rowNode === void 0 ? void 0 : rowNode.sticky);
    if (!skipScrollToRow && missing(gridCell.rowPinned)) {
      this.gridBodyCon.getScrollFeature().ensureIndexVisible(gridCell.rowIndex);
    }
    if (!gridCell.column.isPinned()) {
      this.gridBodyCon.getScrollFeature().ensureColumnVisible(gridCell.column);
    }
  }
};
__decorate$1B([
  Autowired("mouseEventService")
], NavigationService.prototype, "mouseEventService", void 0);
__decorate$1B([
  Autowired("paginationProxy")
], NavigationService.prototype, "paginationProxy", void 0);
__decorate$1B([
  Autowired("focusService")
], NavigationService.prototype, "focusService", void 0);
__decorate$1B([
  Optional("rangeService")
], NavigationService.prototype, "rangeService", void 0);
__decorate$1B([
  Autowired("columnModel")
], NavigationService.prototype, "columnModel", void 0);
__decorate$1B([
  Autowired("rowModel")
], NavigationService.prototype, "rowModel", void 0);
__decorate$1B([
  Autowired("ctrlsService")
], NavigationService.prototype, "ctrlsService", void 0);
__decorate$1B([
  Autowired("rowRenderer")
], NavigationService.prototype, "rowRenderer", void 0);
__decorate$1B([
  Autowired("headerNavigationService")
], NavigationService.prototype, "headerNavigationService", void 0);
__decorate$1B([
  Autowired("rowPositionUtils")
], NavigationService.prototype, "rowPositionUtils", void 0);
__decorate$1B([
  Autowired("cellNavigationService")
], NavigationService.prototype, "cellNavigationService", void 0);
__decorate$1B([
  Autowired("pinnedRowModel")
], NavigationService.prototype, "pinnedRowModel", void 0);
__decorate$1B([
  PostConstruct
], NavigationService.prototype, "postConstruct", null);
NavigationService = __decorate$1B([
  Bean("navigationService")
], NavigationService);
var __decorate$1A = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PopupEditorWrapper = class extends PopupComponent {
  constructor(params) {
    super(`<div class="ag-popup-editor" tabindex="-1"/>`);
    this.params = params;
  }
  postConstruct() {
    this.gridOptionsService.setDomData(this.getGui(), PopupEditorWrapper.DOM_KEY_POPUP_EDITOR_WRAPPER, true);
    this.addKeyDownListener();
  }
  addKeyDownListener() {
    const eGui = this.getGui();
    const params = this.params;
    const listener = (event) => {
      if (!isUserSuppressingKeyboardEvent(this.gridOptionsService, event, params.node, params.column, true)) {
        params.onKeyDown(event);
      }
    };
    this.addManagedListener(eGui, "keydown", listener);
  }
};
PopupEditorWrapper.DOM_KEY_POPUP_EDITOR_WRAPPER = "popupEditorWrapper";
__decorate$1A([
  PostConstruct
], PopupEditorWrapper.prototype, "postConstruct", null);
var CellComp = class extends Component {
  constructor(beans, cellCtrl, printLayout, eRow, editingRow) {
    super();
    this.rendererVersion = 0;
    this.editorVersion = 0;
    this.beans = beans;
    this.column = cellCtrl.getColumn();
    this.rowNode = cellCtrl.getRowNode();
    this.rowCtrl = cellCtrl.getRowCtrl();
    this.eRow = eRow;
    this.setTemplate(`<div comp-id="${this.getCompId()}"/>`);
    const eGui = this.getGui();
    this.forceWrapper = cellCtrl.isForceWrapper();
    this.refreshWrapper(false);
    const setAttribute = (name, value, element) => {
      const actualElement = element ? element : eGui;
      if (value != null && value != "") {
        actualElement.setAttribute(name, value);
      } else {
        actualElement.removeAttribute(name);
      }
    };
    const compProxy = {
      addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
      setUserStyles: (styles) => addStylesToElement(eGui, styles),
      getFocusableElement: () => this.getFocusableElement(),
      setTabIndex: (tabIndex) => setAttribute("tabindex", tabIndex.toString()),
      setRole: (role) => setAriaRole(eGui, role),
      setColId: (colId) => setAttribute("col-id", colId),
      setTitle: (title) => setAttribute("title", title),
      setIncludeSelection: (include) => this.includeSelection = include,
      setIncludeRowDrag: (include) => this.includeRowDrag = include,
      setIncludeDndSource: (include) => this.includeDndSource = include,
      setRenderDetails: (compDetails, valueToDisplay, force) => this.setRenderDetails(compDetails, valueToDisplay, force),
      setEditDetails: (compDetails, popup, position) => this.setEditDetails(compDetails, popup, position),
      getCellEditor: () => this.cellEditor || null,
      getCellRenderer: () => this.cellRenderer || null,
      getParentOfValue: () => this.getParentOfValue()
    };
    this.cellCtrl = cellCtrl;
    cellCtrl.setComp(compProxy, this.getGui(), this.eCellWrapper, printLayout, editingRow);
  }
  getParentOfValue() {
    if (this.eCellValue) {
      return this.eCellValue;
    }
    if (this.eCellWrapper) {
      return this.eCellWrapper;
    }
    return this.getGui();
  }
  setRenderDetails(compDetails, valueToDisplay, forceNewCellRendererInstance) {
    const isInlineEditing = this.cellEditor && !this.cellEditorPopupWrapper;
    if (isInlineEditing) {
      return;
    }
    this.firstRender = this.firstRender == null;
    const controlWrapperChanged = this.refreshWrapper(false);
    this.refreshEditStyles(false);
    if (compDetails) {
      const neverRefresh = forceNewCellRendererInstance || controlWrapperChanged;
      const cellRendererRefreshSuccessful = neverRefresh ? false : this.refreshCellRenderer(compDetails);
      if (!cellRendererRefreshSuccessful) {
        this.destroyRenderer();
        this.createCellRendererInstance(compDetails);
      }
    } else {
      this.destroyRenderer();
      this.insertValueWithoutCellRenderer(valueToDisplay);
    }
  }
  setEditDetails(compDetails, popup, position) {
    if (compDetails) {
      this.createCellEditorInstance(compDetails, popup, position);
    } else {
      this.destroyEditor();
    }
  }
  removeControls() {
    this.checkboxSelectionComp = this.beans.context.destroyBean(this.checkboxSelectionComp);
    this.dndSourceComp = this.beans.context.destroyBean(this.dndSourceComp);
    this.rowDraggingComp = this.beans.context.destroyBean(this.rowDraggingComp);
  }
  refreshWrapper(editing) {
    const providingControls = this.includeRowDrag || this.includeDndSource || this.includeSelection;
    const usingWrapper = providingControls || this.forceWrapper;
    const putWrapperIn = usingWrapper && this.eCellWrapper == null;
    if (putWrapperIn) {
      this.eCellWrapper = loadTemplate(`<div class="ag-cell-wrapper" role="presentation"></div>`);
      this.getGui().appendChild(this.eCellWrapper);
    }
    const takeWrapperOut = !usingWrapper && this.eCellWrapper != null;
    if (takeWrapperOut) {
      removeFromParent(this.eCellWrapper);
      this.eCellWrapper = void 0;
    }
    this.addOrRemoveCssClass("ag-cell-value", !usingWrapper);
    const usingCellValue = !editing && usingWrapper;
    const putCellValueIn = usingCellValue && this.eCellValue == null;
    if (putCellValueIn) {
      this.eCellValue = loadTemplate(`<span class="ag-cell-value" role="presentation"></span>`);
      this.eCellWrapper.appendChild(this.eCellValue);
    }
    const takeCellValueOut = !usingCellValue && this.eCellValue != null;
    if (takeCellValueOut) {
      removeFromParent(this.eCellValue);
      this.eCellValue = void 0;
    }
    const templateChanged = putWrapperIn || takeWrapperOut || putCellValueIn || takeCellValueOut;
    if (templateChanged) {
      this.removeControls();
    }
    if (!editing) {
      if (providingControls) {
        this.addControls();
      }
    }
    return templateChanged;
  }
  addControls() {
    if (this.includeRowDrag) {
      if (this.rowDraggingComp == null) {
        this.rowDraggingComp = this.cellCtrl.createRowDragComp();
        if (this.rowDraggingComp) {
          this.eCellWrapper.insertBefore(this.rowDraggingComp.getGui(), this.eCellValue);
        }
      }
    }
    if (this.includeDndSource) {
      if (this.dndSourceComp == null) {
        this.dndSourceComp = this.cellCtrl.createDndSource();
        this.eCellWrapper.insertBefore(this.dndSourceComp.getGui(), this.eCellValue);
      }
    }
    if (this.includeSelection) {
      if (this.checkboxSelectionComp == null) {
        this.checkboxSelectionComp = this.cellCtrl.createSelectionCheckbox();
        this.eCellWrapper.insertBefore(this.checkboxSelectionComp.getGui(), this.eCellValue);
      }
    }
  }
  createCellEditorInstance(compDetails, popup, position) {
    const versionCopy = this.editorVersion;
    const cellEditorPromise = compDetails.newAgStackInstance();
    if (!cellEditorPromise) {
      return;
    }
    const { params } = compDetails;
    cellEditorPromise.then((c) => this.afterCellEditorCreated(versionCopy, c, params, popup, position));
    const cellEditorAsync = missing(this.cellEditor);
    if (cellEditorAsync && params.cellStartedEdit) {
      this.cellCtrl.focusCell(true);
    }
  }
  insertValueWithoutCellRenderer(valueToDisplay) {
    const eParent = this.getParentOfValue();
    clearElement(eParent);
    const escapedValue = valueToDisplay != null ? escapeString(valueToDisplay) : null;
    if (escapedValue != null) {
      eParent.innerHTML = escapedValue;
    }
  }
  destroyEditorAndRenderer() {
    this.destroyRenderer();
    this.destroyEditor();
  }
  destroyRenderer() {
    const { context } = this.beans;
    this.cellRenderer = context.destroyBean(this.cellRenderer);
    removeFromParent(this.cellRendererGui);
    this.cellRendererGui = null;
    this.rendererVersion++;
  }
  destroyEditor() {
    const { context } = this.beans;
    if (this.hideEditorPopup) {
      this.hideEditorPopup();
    }
    this.hideEditorPopup = void 0;
    this.cellEditor = context.destroyBean(this.cellEditor);
    this.cellEditorPopupWrapper = context.destroyBean(this.cellEditorPopupWrapper);
    removeFromParent(this.cellEditorGui);
    this.cellEditorGui = null;
    this.editorVersion++;
  }
  refreshCellRenderer(compClassAndParams) {
    if (this.cellRenderer == null || this.cellRenderer.refresh == null) {
      return false;
    }
    if (this.cellRendererClass !== compClassAndParams.componentClass) {
      return false;
    }
    const result = this.cellRenderer.refresh(compClassAndParams.params);
    return result === true || result === void 0;
  }
  createCellRendererInstance(compDetails) {
    const suppressAnimationFrame = this.beans.gridOptionsService.is("suppressAnimationFrame");
    const useTaskService = !suppressAnimationFrame;
    const displayComponentVersionCopy = this.rendererVersion;
    const { componentClass } = compDetails;
    const createCellRendererFunc = () => {
      const staleTask = this.rendererVersion !== displayComponentVersionCopy || !this.isAlive();
      if (staleTask) {
        return;
      }
      const componentPromise = compDetails.newAgStackInstance();
      const callback = this.afterCellRendererCreated.bind(this, displayComponentVersionCopy, componentClass);
      if (componentPromise) {
        componentPromise.then(callback);
      }
    };
    if (useTaskService && this.firstRender) {
      this.beans.animationFrameService.createTask(createCellRendererFunc, this.rowNode.rowIndex, "createTasksP2");
    } else {
      createCellRendererFunc();
    }
  }
  getCtrl() {
    return this.cellCtrl;
  }
  getRowCtrl() {
    return this.rowCtrl;
  }
  getCellRenderer() {
    return this.cellRenderer;
  }
  getCellEditor() {
    return this.cellEditor;
  }
  afterCellRendererCreated(cellRendererVersion, cellRendererClass, cellRenderer) {
    const staleTask = !this.isAlive() || cellRendererVersion !== this.rendererVersion;
    if (staleTask) {
      this.beans.context.destroyBean(cellRenderer);
      return;
    }
    this.cellRenderer = cellRenderer;
    this.cellRendererClass = cellRendererClass;
    this.cellRendererGui = this.cellRenderer.getGui();
    if (this.cellRendererGui != null) {
      const eParent = this.getParentOfValue();
      clearElement(eParent);
      eParent.appendChild(this.cellRendererGui);
    }
  }
  afterCellEditorCreated(requestVersion, cellEditor, params, popup, position) {
    const staleComp = requestVersion !== this.editorVersion;
    if (staleComp) {
      this.beans.context.destroyBean(cellEditor);
      return;
    }
    const editingCancelledByUserComp = cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart();
    if (editingCancelledByUserComp) {
      this.beans.context.destroyBean(cellEditor);
      this.cellCtrl.stopEditing(true);
      return;
    }
    if (!cellEditor.getGui) {
      console.warn(`AG Grid: cellEditor for column ${this.column.getId()} is missing getGui() method`);
      this.beans.context.destroyBean(cellEditor);
      return;
    }
    this.cellEditor = cellEditor;
    this.cellEditorGui = cellEditor.getGui();
    const cellEditorInPopup = popup || cellEditor.isPopup !== void 0 && cellEditor.isPopup();
    if (cellEditorInPopup) {
      this.addPopupCellEditor(params, position);
    } else {
      this.addInCellEditor();
    }
    this.refreshEditStyles(true, cellEditorInPopup);
    if (cellEditor.afterGuiAttached) {
      cellEditor.afterGuiAttached();
    }
  }
  refreshEditStyles(editing, isPopup) {
    var _a;
    this.addOrRemoveCssClass("ag-cell-inline-editing", editing && !isPopup);
    this.addOrRemoveCssClass("ag-cell-popup-editing", editing && !!isPopup);
    this.addOrRemoveCssClass("ag-cell-not-inline-editing", !editing || !!isPopup);
    (_a = this.rowCtrl) === null || _a === void 0 ? void 0 : _a.setInlineEditingCss(editing);
  }
  addInCellEditor() {
    const eGui = this.getGui();
    const eDocument = this.beans.gridOptionsService.getDocument();
    if (eGui.contains(eDocument.activeElement)) {
      eGui.focus();
    }
    this.destroyRenderer();
    this.refreshWrapper(true);
    this.clearParentOfValue();
    if (this.cellEditorGui) {
      const eParent = this.getParentOfValue();
      eParent.appendChild(this.cellEditorGui);
    }
  }
  addPopupCellEditor(params, position) {
    if (this.beans.gridOptionsService.get("editType") === "fullRow") {
      console.warn("AG Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both - either turn off fullRowEdit, or stop using popup editors.");
    }
    const cellEditor = this.cellEditor;
    this.cellEditorPopupWrapper = this.beans.context.createBean(new PopupEditorWrapper(params));
    const ePopupGui = this.cellEditorPopupWrapper.getGui();
    if (this.cellEditorGui) {
      ePopupGui.appendChild(this.cellEditorGui);
    }
    const popupService = this.beans.popupService;
    const useModelPopup = this.beans.gridOptionsService.is("stopEditingWhenCellsLoseFocus");
    const positionToUse = position != null ? position : cellEditor.getPopupPosition ? cellEditor.getPopupPosition() : "over";
    const isRtl = this.beans.gridOptionsService.is("enableRtl");
    const positionParams = {
      ePopup: ePopupGui,
      column: this.column,
      rowNode: this.rowNode,
      type: "popupCellEditor",
      eventSource: this.getGui(),
      position: positionToUse,
      alignSide: isRtl ? "right" : "left",
      keepWithinBounds: true
    };
    const positionCallback = popupService.positionPopupByComponent.bind(popupService, positionParams);
    const translate = this.beans.localeService.getLocaleTextFunc();
    const addPopupRes = popupService.addPopup({
      modal: useModelPopup,
      eChild: ePopupGui,
      closeOnEsc: true,
      closedCallback: () => {
        this.cellCtrl.onPopupEditorClosed();
      },
      anchorToElement: this.getGui(),
      positionCallback,
      ariaLabel: translate("ariaLabelCellEditor", "Cell Editor")
    });
    if (addPopupRes) {
      this.hideEditorPopup = addPopupRes.hideFunc;
    }
  }
  detach() {
    this.eRow.removeChild(this.getGui());
  }
  destroy() {
    this.cellCtrl.stopEditing();
    this.destroyEditorAndRenderer();
    this.removeControls();
    super.destroy();
  }
  clearParentOfValue() {
    const eGui = this.getGui();
    const eDocument = this.beans.gridOptionsService.getDocument();
    if (eGui.contains(eDocument.activeElement) && browserSupportsPreventScroll()) {
      eGui.focus({ preventScroll: true });
    }
    clearElement(this.getParentOfValue());
  }
};
var RowComp = class extends Component {
  constructor(ctrl, beans, containerType) {
    super();
    this.cellComps = {};
    this.beans = beans;
    this.rowCtrl = ctrl;
    this.setTemplate(`<div comp-id="${this.getCompId()}" style="${this.getInitialStyle(containerType)}"/>`);
    const eGui = this.getGui();
    const style = eGui.style;
    const compProxy = {
      setDomOrder: (domOrder) => this.domOrder = domOrder,
      setCellCtrls: (cellCtrls) => this.setCellCtrls(cellCtrls),
      showFullWidth: (compDetails) => this.showFullWidth(compDetails),
      getFullWidthCellRenderer: () => this.getFullWidthCellRenderer(),
      addOrRemoveCssClass: (name, on) => this.addOrRemoveCssClass(name, on),
      setUserStyles: (styles) => addStylesToElement(eGui, styles),
      setTop: (top) => style.top = top,
      setTransform: (transform) => style.transform = transform,
      setRowIndex: (rowIndex) => eGui.setAttribute("row-index", rowIndex),
      setRole: (role) => setAriaRole(eGui, role),
      setRowId: (rowId) => eGui.setAttribute("row-id", rowId),
      setRowBusinessKey: (businessKey) => eGui.setAttribute("row-business-key", businessKey),
      setTabIndex: (tabIndex) => eGui.setAttribute("tabindex", tabIndex.toString())
    };
    ctrl.setComp(compProxy, this.getGui(), containerType);
    this.addDestroyFunc(() => {
      ctrl.unsetComp(containerType);
    });
  }
  getInitialStyle(containerType) {
    const transform = this.rowCtrl.getInitialTransform(containerType);
    const top = this.rowCtrl.getInitialRowTop(containerType);
    return transform ? `transform: ${transform}` : `top: ${top}`;
  }
  showFullWidth(compDetails) {
    const callback = (cellRenderer) => {
      if (this.isAlive()) {
        const eGui = cellRenderer.getGui();
        this.getGui().appendChild(eGui);
        this.rowCtrl.setupDetailRowAutoHeight(eGui);
        this.setFullWidthRowComp(cellRenderer);
      } else {
        this.beans.context.destroyBean(cellRenderer);
      }
    };
    const res = compDetails.newAgStackInstance();
    if (!res) {
      return;
    }
    res.then(callback);
  }
  setCellCtrls(cellCtrls) {
    const cellsToRemove = Object.assign({}, this.cellComps);
    cellCtrls.forEach((cellCtrl) => {
      const key = cellCtrl.getInstanceId();
      const existingCellComp = this.cellComps[key];
      if (existingCellComp == null) {
        this.newCellComp(cellCtrl);
      } else {
        cellsToRemove[key] = null;
      }
    });
    const cellCompsToRemove = getAllValuesInObject(cellsToRemove).filter((cellComp) => cellComp != null);
    this.destroyCells(cellCompsToRemove);
    this.ensureDomOrder(cellCtrls);
  }
  ensureDomOrder(cellCtrls) {
    if (!this.domOrder) {
      return;
    }
    const elementsInOrder = [];
    cellCtrls.forEach((cellCtrl) => {
      const cellComp = this.cellComps[cellCtrl.getInstanceId()];
      if (cellComp) {
        elementsInOrder.push(cellComp.getGui());
      }
    });
    setDomChildOrder(this.getGui(), elementsInOrder);
  }
  newCellComp(cellCtrl) {
    const cellComp = new CellComp(this.beans, cellCtrl, this.rowCtrl.isPrintLayout(), this.getGui(), this.rowCtrl.isEditing());
    this.cellComps[cellCtrl.getInstanceId()] = cellComp;
    this.getGui().appendChild(cellComp.getGui());
  }
  destroy() {
    super.destroy();
    this.destroyAllCells();
  }
  destroyAllCells() {
    const cellsToDestroy = getAllValuesInObject(this.cellComps).filter((cp) => cp != null);
    this.destroyCells(cellsToDestroy);
  }
  setFullWidthRowComp(fullWidthRowComponent) {
    if (this.fullWidthCellRenderer) {
      console.error("AG Grid - should not be setting fullWidthRowComponent twice");
    }
    this.fullWidthCellRenderer = fullWidthRowComponent;
    this.addDestroyFunc(() => {
      this.fullWidthCellRenderer = this.beans.context.destroyBean(this.fullWidthCellRenderer);
    });
  }
  getFullWidthCellRenderer() {
    return this.fullWidthCellRenderer;
  }
  destroyCells(cellComps) {
    cellComps.forEach((cellComp) => {
      if (!cellComp) {
        return;
      }
      const instanceId = cellComp.getCtrl().getInstanceId();
      if (this.cellComps[instanceId] !== cellComp) {
        return;
      }
      cellComp.detach();
      cellComp.destroy();
      this.cellComps[instanceId] = null;
    });
  }
};
var __decorate$1z = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function templateFactory() {
  const name = Component.elementGettingCreated.getAttribute("name");
  const cssClasses = RowContainerCtrl.getRowContainerCssClasses(name);
  let res;
  const template1 = name === RowContainerName.CENTER;
  const template2 = name === RowContainerName.TOP_CENTER || name === RowContainerName.STICKY_TOP_CENTER || name === RowContainerName.BOTTOM_CENTER;
  if (template1) {
    res = `<div class="${cssClasses.wrapper}" ref="eWrapper" role="presentation">
                <div class="${cssClasses.viewport}" ref="eViewport" role="presentation">
                    <div class="${cssClasses.container}" ref="eContainer"></div>
                </div>
            </div>`;
  } else if (template2) {
    res = `<div class="${cssClasses.viewport}" ref="eViewport" role="presentation">
                <div class="${cssClasses.container}" ref="eContainer"></div>
            </div>`;
  } else {
    res = `<div class="${cssClasses.container}" ref="eContainer"></div>`;
  }
  return res;
}
var RowContainerComp = class extends Component {
  constructor() {
    super(templateFactory());
    this.rowComps = {};
    this.name = Component.elementGettingCreated.getAttribute("name");
    this.type = getRowContainerTypeForName(this.name);
  }
  postConstruct() {
    const compProxy = {
      setViewportHeight: (height) => this.eViewport.style.height = height,
      setRowCtrls: (rowCtrls) => this.setRowCtrls(rowCtrls),
      setDomOrder: (domOrder) => {
        this.domOrder = domOrder;
      },
      setContainerWidth: (width) => this.eContainer.style.width = width
    };
    const ctrl = this.createManagedBean(new RowContainerCtrl(this.name));
    ctrl.setComp(compProxy, this.eContainer, this.eViewport, this.eWrapper);
  }
  preDestroy() {
    this.setRowCtrls([]);
  }
  setRowCtrls(rowCtrls) {
    const oldRows = Object.assign({}, this.rowComps);
    this.rowComps = {};
    this.lastPlacedElement = null;
    const processRow = (rowCon) => {
      const instanceId = rowCon.getInstanceId();
      const existingRowComp = oldRows[instanceId];
      if (existingRowComp) {
        this.rowComps[instanceId] = existingRowComp;
        delete oldRows[instanceId];
        this.ensureDomOrder(existingRowComp.getGui());
      } else {
        const rowComp = new RowComp(rowCon, this.beans, this.type);
        this.rowComps[instanceId] = rowComp;
        this.appendRow(rowComp.getGui());
      }
    };
    rowCtrls.forEach(processRow);
    getAllValuesInObject(oldRows).forEach((oldRowComp) => {
      this.eContainer.removeChild(oldRowComp.getGui());
      oldRowComp.destroy();
    });
    setAriaRole(this.eContainer, rowCtrls.length ? "rowgroup" : "presentation");
  }
  appendRow(element) {
    if (this.domOrder) {
      insertWithDomOrder(this.eContainer, element, this.lastPlacedElement);
    } else {
      this.eContainer.appendChild(element);
    }
    this.lastPlacedElement = element;
  }
  ensureDomOrder(eRow) {
    if (this.domOrder) {
      ensureDomOrder(this.eContainer, eRow, this.lastPlacedElement);
      this.lastPlacedElement = eRow;
    }
  }
};
__decorate$1z([
  Autowired("beans")
], RowContainerComp.prototype, "beans", void 0);
__decorate$1z([
  RefSelector("eViewport")
], RowContainerComp.prototype, "eViewport", void 0);
__decorate$1z([
  RefSelector("eContainer")
], RowContainerComp.prototype, "eContainer", void 0);
__decorate$1z([
  RefSelector("eWrapper")
], RowContainerComp.prototype, "eWrapper", void 0);
__decorate$1z([
  PostConstruct
], RowContainerComp.prototype, "postConstruct", null);
__decorate$1z([
  PreDestroy
], RowContainerComp.prototype, "preDestroy", null);
var __decorate$1y = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BodyDropPivotTarget = class {
  constructor(pinned) {
    this.columnsToAggregate = [];
    this.columnsToGroup = [];
    this.columnsToPivot = [];
    this.pinned = pinned;
  }
  onDragEnter(draggingEvent) {
    this.clearColumnsList();
    if (this.gridOptionsService.is("functionsReadOnly")) {
      return;
    }
    const dragColumns = draggingEvent.dragItem.columns;
    if (!dragColumns) {
      return;
    }
    dragColumns.forEach((column) => {
      if (!column.isPrimary()) {
        return;
      }
      if (column.isAnyFunctionActive()) {
        return;
      }
      if (column.isAllowValue()) {
        this.columnsToAggregate.push(column);
      } else if (column.isAllowRowGroup()) {
        this.columnsToGroup.push(column);
      } else if (column.isAllowPivot()) {
        this.columnsToPivot.push(column);
      }
    });
  }
  getIconName() {
    const totalColumns = this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length;
    if (totalColumns > 0) {
      return this.pinned ? DragAndDropService.ICON_PINNED : DragAndDropService.ICON_MOVE;
    }
    return null;
  }
  onDragLeave(draggingEvent) {
    this.clearColumnsList();
  }
  clearColumnsList() {
    this.columnsToAggregate.length = 0;
    this.columnsToGroup.length = 0;
    this.columnsToPivot.length = 0;
  }
  onDragging(draggingEvent) {
  }
  onDragStop(draggingEvent) {
    if (this.columnsToAggregate.length > 0) {
      this.columnModel.addValueColumns(this.columnsToAggregate, "toolPanelDragAndDrop");
    }
    if (this.columnsToGroup.length > 0) {
      this.columnModel.addRowGroupColumns(this.columnsToGroup, "toolPanelDragAndDrop");
    }
    if (this.columnsToPivot.length > 0) {
      this.columnModel.addPivotColumns(this.columnsToPivot, "toolPanelDragAndDrop");
    }
  }
};
__decorate$1y([
  Autowired("columnModel")
], BodyDropPivotTarget.prototype, "columnModel", void 0);
__decorate$1y([
  Autowired("gridOptionsService")
], BodyDropPivotTarget.prototype, "gridOptionsService", void 0);
var __decorate$1x = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var MoveColumnFeature = class {
  constructor(pinned, eContainer) {
    this.needToMoveLeft = false;
    this.needToMoveRight = false;
    this.lastMovedInfo = null;
    this.pinned = pinned;
    this.eContainer = eContainer;
    this.centerContainer = !exists(pinned);
  }
  init() {
    this.ctrlsService.whenReady(() => {
      this.gridBodyCon = this.ctrlsService.getGridBodyCtrl();
    });
  }
  getIconName() {
    return this.pinned ? DragAndDropService.ICON_PINNED : DragAndDropService.ICON_MOVE;
  }
  onDragEnter(draggingEvent) {
    const columns = draggingEvent.dragItem.columns;
    const dragCameFromToolPanel = draggingEvent.dragSource.type === DragSourceType.ToolPanel;
    if (dragCameFromToolPanel) {
      this.setColumnsVisible(columns, true, "uiColumnDragged");
    } else {
      const visibleState = draggingEvent.dragItem.visibleState;
      const visibleColumns = (columns || []).filter((column) => visibleState[column.getId()]);
      this.setColumnsVisible(visibleColumns, true, "uiColumnDragged");
    }
    this.setColumnsPinned(columns, this.pinned, "uiColumnDragged");
    this.onDragging(draggingEvent, true, true);
  }
  onDragLeave() {
    this.ensureIntervalCleared();
    this.lastMovedInfo = null;
  }
  setColumnsVisible(columns, visible, source = "api") {
    if (columns) {
      const allowedCols = columns.filter((c) => !c.getColDef().lockVisible);
      this.columnModel.setColumnsVisible(allowedCols, visible, source);
    }
  }
  setColumnsPinned(columns, pinned, source = "api") {
    if (columns) {
      const allowedCols = columns.filter((c) => !c.getColDef().lockPinned);
      this.columnModel.setColumnsPinned(allowedCols, pinned, source);
    }
  }
  onDragStop() {
    this.onDragging(this.lastDraggingEvent, false, true, true);
    this.ensureIntervalCleared();
    this.lastMovedInfo = null;
  }
  normaliseX(x) {
    if (this.gridOptionsService.is("enableRtl")) {
      const clientWidth = this.eContainer.clientWidth;
      x = clientWidth - x;
    }
    if (this.centerContainer) {
      x += this.ctrlsService.getCenterRowContainerCtrl().getCenterViewportScrollLeft();
    }
    return x;
  }
  checkCenterForScrolling(xAdjustedForScroll) {
    if (this.centerContainer) {
      const firstVisiblePixel = this.ctrlsService.getCenterRowContainerCtrl().getCenterViewportScrollLeft();
      const lastVisiblePixel = firstVisiblePixel + this.ctrlsService.getCenterRowContainerCtrl().getCenterWidth();
      if (this.gridOptionsService.is("enableRtl")) {
        this.needToMoveRight = xAdjustedForScroll < firstVisiblePixel + 50;
        this.needToMoveLeft = xAdjustedForScroll > lastVisiblePixel - 50;
      } else {
        this.needToMoveLeft = xAdjustedForScroll < firstVisiblePixel + 50;
        this.needToMoveRight = xAdjustedForScroll > lastVisiblePixel - 50;
      }
      if (this.needToMoveLeft || this.needToMoveRight) {
        this.ensureIntervalStarted();
      } else {
        this.ensureIntervalCleared();
      }
    }
  }
  onDragging(draggingEvent = this.lastDraggingEvent, fromEnter = false, fakeEvent = false, finished = false) {
    var _a;
    if (finished) {
      if (this.lastMovedInfo) {
        const { columns, toIndex } = this.lastMovedInfo;
        this.moveColumns(columns, toIndex, "uiColumnMoved", true);
      }
      return;
    }
    this.lastDraggingEvent = draggingEvent;
    if (missing(draggingEvent.hDirection)) {
      return;
    }
    const mouseX = this.normaliseX(draggingEvent.x);
    if (!fromEnter) {
      this.checkCenterForScrolling(mouseX);
    }
    const hDirection = this.normaliseDirection(draggingEvent.hDirection);
    const dragSourceType = draggingEvent.dragSource.type;
    const allMovingColumns = ((_a = draggingEvent.dragSource.getDragItem().columns) === null || _a === void 0 ? void 0 : _a.filter((col) => {
      if (col.getColDef().lockPinned) {
        return col.getPinned() == this.pinned;
      }
      return true;
    })) || [];
    this.attemptMoveColumns({ dragSourceType, allMovingColumns, hDirection, mouseX, fromEnter, fakeEvent });
  }
  normaliseDirection(hDirection) {
    if (this.gridOptionsService.is("enableRtl")) {
      switch (hDirection) {
        case HorizontalDirection.Left:
          return HorizontalDirection.Right;
        case HorizontalDirection.Right:
          return HorizontalDirection.Left;
        default:
          console.error(`AG Grid: Unknown direction ${hDirection}`);
      }
    } else {
      return hDirection;
    }
  }
  attemptMoveColumns(params) {
    const { dragSourceType, hDirection, mouseX, fromEnter, fakeEvent } = params;
    const draggingLeft = hDirection === HorizontalDirection.Left;
    const draggingRight = hDirection === HorizontalDirection.Right;
    let { allMovingColumns } = params;
    if (dragSourceType === DragSourceType.HeaderCell) {
      let newCols = [];
      allMovingColumns.forEach((col) => {
        let movingGroup = null;
        let parent = col.getParent();
        while (parent != null && parent.getDisplayedLeafColumns().length === 1) {
          movingGroup = parent;
          parent = parent.getParent();
        }
        if (movingGroup != null) {
          const providedColumnGroup = movingGroup.getProvidedColumnGroup();
          providedColumnGroup.getLeafColumns().forEach((newCol) => {
            if (!newCols.includes(newCol)) {
              newCols.push(newCol);
            }
          });
        } else if (!newCols.includes(col)) {
          newCols.push(col);
        }
      });
      allMovingColumns = newCols;
    }
    const allMovingColumnsOrdered = allMovingColumns.slice();
    this.columnModel.sortColumnsLikeGridColumns(allMovingColumnsOrdered);
    const validMoves = this.calculateValidMoves(allMovingColumnsOrdered, draggingRight, mouseX);
    const oldIndex = this.calculateOldIndex(allMovingColumnsOrdered);
    if (validMoves.length === 0) {
      return;
    }
    const firstValidMove = validMoves[0];
    let constrainDirection = oldIndex !== null && !fromEnter;
    if (dragSourceType == DragSourceType.HeaderCell) {
      constrainDirection = oldIndex !== null;
    }
    if (constrainDirection && !fakeEvent) {
      if (draggingLeft && firstValidMove >= oldIndex) {
        return;
      }
      if (draggingRight && firstValidMove <= oldIndex) {
        return;
      }
    }
    const displayedCols = this.columnModel.getAllDisplayedColumns();
    let potentialMoves = [];
    let targetOrder = null;
    for (let i = 0; i < validMoves.length; i++) {
      const move = validMoves[i];
      const order = this.columnModel.getProposedColumnOrder(allMovingColumnsOrdered, move);
      if (!this.columnModel.doesOrderPassRules(order)) {
        continue;
      }
      const displayedOrder = order.filter((col) => displayedCols.includes(col));
      if (targetOrder === null) {
        targetOrder = displayedOrder;
      } else if (!_.areEqual(displayedOrder, targetOrder)) {
        break;
      }
      const fragCount = this.groupFragCount(order);
      potentialMoves.push({ move, fragCount });
    }
    if (potentialMoves.length === 0) {
      return;
    }
    potentialMoves.sort((a, b) => a.fragCount - b.fragCount);
    this.moveColumns(allMovingColumns, potentialMoves[0].move, "uiColumnMoved", false);
  }
  calculateOldIndex(movingCols) {
    const gridCols = this.columnModel.getAllGridColumns();
    const indexes = sortNumerically(movingCols.map((col) => gridCols.indexOf(col)));
    const firstIndex = indexes[0];
    const lastIndex = last(indexes);
    const spread = lastIndex - firstIndex;
    const gapsExist = spread !== indexes.length - 1;
    return gapsExist ? null : firstIndex;
  }
  moveColumns(columns, toIndex, source, finished) {
    this.columnModel.moveColumns(columns, toIndex, source, finished);
    this.lastMovedInfo = finished ? null : { columns, toIndex };
  }
  groupFragCount(columns) {
    function parents(col) {
      let result = [];
      let parent = col.getOriginalParent();
      while (parent != null) {
        result.push(parent);
        parent = parent.getOriginalParent();
      }
      return result;
    }
    let count = 0;
    for (let i = 0; i < columns.length - 1; i++) {
      let a = parents(columns[i]);
      let b = parents(columns[i + 1]);
      [a, b] = a.length > b.length ? [a, b] : [b, a];
      a.forEach((parent) => {
        if (b.indexOf(parent) === -1) {
          count++;
        }
      });
    }
    return count;
  }
  calculateValidMoves(movingCols, draggingRight, mouseX) {
    const isMoveBlocked = this.gridOptionsService.is("suppressMovableColumns") || movingCols.some((col) => col.getColDef().suppressMovable);
    if (isMoveBlocked) {
      return [];
    }
    const allDisplayedCols = this.columnModel.getDisplayedColumns(this.pinned);
    const allGridCols = this.columnModel.getAllGridColumns();
    const movingDisplayedCols = allDisplayedCols.filter((col) => includes(movingCols, col));
    const otherDisplayedCols = allDisplayedCols.filter((col) => !includes(movingCols, col));
    const otherGridCols = allGridCols.filter((col) => !includes(movingCols, col));
    let displayIndex = 0;
    let availableWidth = mouseX;
    if (draggingRight) {
      let widthOfMovingDisplayedCols = 0;
      movingDisplayedCols.forEach((col) => widthOfMovingDisplayedCols += col.getActualWidth());
      availableWidth -= widthOfMovingDisplayedCols;
    }
    if (availableWidth > 0) {
      for (let i = 0; i < otherDisplayedCols.length; i++) {
        const col = otherDisplayedCols[i];
        availableWidth -= col.getActualWidth();
        if (availableWidth < 0) {
          break;
        }
        displayIndex++;
      }
      if (draggingRight) {
        displayIndex++;
      }
    }
    let firstValidMove;
    if (displayIndex > 0) {
      const leftColumn = otherDisplayedCols[displayIndex - 1];
      firstValidMove = otherGridCols.indexOf(leftColumn) + 1;
    } else {
      firstValidMove = otherGridCols.indexOf(otherDisplayedCols[0]);
      if (firstValidMove === -1) {
        firstValidMove = 0;
      }
    }
    const validMoves = [firstValidMove];
    const numberComparator = (a, b) => a - b;
    if (draggingRight) {
      let pointer = firstValidMove + 1;
      const lastIndex = allGridCols.length - 1;
      while (pointer <= lastIndex) {
        validMoves.push(pointer);
        pointer++;
      }
      validMoves.sort(numberComparator);
    } else {
      let pointer = firstValidMove;
      const lastIndex = allGridCols.length - 1;
      let displacedCol = allGridCols[pointer];
      while (pointer <= lastIndex && this.isColumnHidden(allDisplayedCols, displacedCol)) {
        pointer++;
        validMoves.push(pointer);
        displacedCol = allGridCols[pointer];
      }
      pointer = firstValidMove - 1;
      const firstDisplayIndex = 0;
      while (pointer >= firstDisplayIndex) {
        validMoves.push(pointer);
        pointer--;
      }
      validMoves.sort(numberComparator).reverse();
    }
    return validMoves;
  }
  isColumnHidden(displayedColumns, col) {
    return displayedColumns.indexOf(col) < 0;
  }
  ensureIntervalStarted() {
    if (!this.movingIntervalId) {
      this.intervalCount = 0;
      this.failedMoveAttempts = 0;
      this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100);
      if (this.needToMoveLeft) {
        this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_LEFT, true);
      } else {
        this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_RIGHT, true);
      }
    }
  }
  ensureIntervalCleared() {
    if (this.movingIntervalId) {
      window.clearInterval(this.movingIntervalId);
      this.movingIntervalId = null;
      this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_MOVE);
    }
  }
  moveInterval() {
    let pixelsToMove;
    this.intervalCount++;
    pixelsToMove = 10 + this.intervalCount * 5;
    if (pixelsToMove > 100) {
      pixelsToMove = 100;
    }
    let pixelsMoved = null;
    const scrollFeature = this.gridBodyCon.getScrollFeature();
    if (this.needToMoveLeft) {
      pixelsMoved = scrollFeature.scrollHorizontally(-pixelsToMove);
    } else if (this.needToMoveRight) {
      pixelsMoved = scrollFeature.scrollHorizontally(pixelsToMove);
    }
    if (pixelsMoved !== 0) {
      this.onDragging(this.lastDraggingEvent);
      this.failedMoveAttempts = 0;
    } else {
      this.failedMoveAttempts++;
      const columns = this.lastDraggingEvent.dragItem.columns;
      const columnsThatCanPin = columns.filter((c) => !c.getColDef().lockPinned);
      if (columnsThatCanPin.length > 0) {
        this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_PINNED);
        if (this.failedMoveAttempts > 7) {
          const pinType = this.needToMoveLeft ? "left" : "right";
          this.setColumnsPinned(columnsThatCanPin, pinType, "uiColumnDragged");
          this.dragAndDropService.nudge();
        }
      }
    }
  }
};
__decorate$1x([
  Autowired("columnModel")
], MoveColumnFeature.prototype, "columnModel", void 0);
__decorate$1x([
  Autowired("dragAndDropService")
], MoveColumnFeature.prototype, "dragAndDropService", void 0);
__decorate$1x([
  Autowired("gridOptionsService")
], MoveColumnFeature.prototype, "gridOptionsService", void 0);
__decorate$1x([
  Autowired("ctrlsService")
], MoveColumnFeature.prototype, "ctrlsService", void 0);
__decorate$1x([
  PostConstruct
], MoveColumnFeature.prototype, "init", null);
var __decorate$1w = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BodyDropTarget = class extends BeanStub {
  constructor(pinned, eContainer) {
    super();
    this.pinned = pinned;
    this.eContainer = eContainer;
  }
  postConstruct() {
    this.ctrlsService.whenReady((p) => {
      switch (this.pinned) {
        case "left":
          this.eSecondaryContainers = [
            [p.gridBodyCtrl.getBodyViewportElement(), p.leftRowContainerCtrl.getContainerElement()],
            [p.bottomLeftRowContainerCtrl.getContainerElement()],
            [p.topLeftRowContainerCtrl.getContainerElement()]
          ];
          break;
        case "right":
          this.eSecondaryContainers = [
            [p.gridBodyCtrl.getBodyViewportElement(), p.rightRowContainerCtrl.getContainerElement()],
            [p.bottomRightRowContainerCtrl.getContainerElement()],
            [p.topRightRowContainerCtrl.getContainerElement()]
          ];
          break;
        default:
          this.eSecondaryContainers = [
            [p.gridBodyCtrl.getBodyViewportElement(), p.centerRowContainerCtrl.getViewportElement()],
            [p.bottomCenterRowContainerCtrl.getViewportElement()],
            [p.topCenterRowContainerCtrl.getViewportElement()]
          ];
          break;
      }
    });
  }
  isInterestedIn(type) {
    return type === DragSourceType.HeaderCell || type === DragSourceType.ToolPanel && this.gridOptionsService.is("allowDragFromColumnsToolPanel");
  }
  getSecondaryContainers() {
    return this.eSecondaryContainers;
  }
  getContainer() {
    return this.eContainer;
  }
  init() {
    this.moveColumnFeature = this.createManagedBean(new MoveColumnFeature(this.pinned, this.eContainer));
    this.bodyDropPivotTarget = this.createManagedBean(new BodyDropPivotTarget(this.pinned));
    this.dragAndDropService.addDropTarget(this);
  }
  getIconName() {
    return this.currentDropListener.getIconName();
  }
  isDropColumnInPivotMode(draggingEvent) {
    return this.columnModel.isPivotMode() && draggingEvent.dragSource.type === DragSourceType.ToolPanel;
  }
  onDragEnter(draggingEvent) {
    this.currentDropListener = this.isDropColumnInPivotMode(draggingEvent) ? this.bodyDropPivotTarget : this.moveColumnFeature;
    this.currentDropListener.onDragEnter(draggingEvent);
  }
  onDragLeave(params) {
    this.currentDropListener.onDragLeave(params);
  }
  onDragging(params) {
    this.currentDropListener.onDragging(params);
  }
  onDragStop(params) {
    this.currentDropListener.onDragStop(params);
  }
};
__decorate$1w([
  Autowired("dragAndDropService")
], BodyDropTarget.prototype, "dragAndDropService", void 0);
__decorate$1w([
  Autowired("columnModel")
], BodyDropTarget.prototype, "columnModel", void 0);
__decorate$1w([
  Autowired("ctrlsService")
], BodyDropTarget.prototype, "ctrlsService", void 0);
__decorate$1w([
  PostConstruct
], BodyDropTarget.prototype, "postConstruct", null);
__decorate$1w([
  PostConstruct
], BodyDropTarget.prototype, "init", null);
var CssClassApplier = class {
  static getHeaderClassesFromColDef(abstractColDef, gridOptionsService, column, columnGroup) {
    if (missing(abstractColDef)) {
      return [];
    }
    return this.getColumnClassesFromCollDef(abstractColDef.headerClass, abstractColDef, gridOptionsService, column, columnGroup);
  }
  static getToolPanelClassesFromColDef(abstractColDef, gridOptionsService, column, columnGroup) {
    if (missing(abstractColDef)) {
      return [];
    }
    return this.getColumnClassesFromCollDef(abstractColDef.toolPanelClass, abstractColDef, gridOptionsService, column, columnGroup);
  }
  static getClassParams(abstractColDef, gridOptionsService, column, columnGroup) {
    return {
      colDef: abstractColDef,
      column,
      columnGroup,
      api: gridOptionsService.api,
      columnApi: gridOptionsService.columnApi,
      context: gridOptionsService.context
    };
  }
  static getColumnClassesFromCollDef(classesOrFunc, abstractColDef, gridOptionsService, column, columnGroup) {
    if (missing(classesOrFunc)) {
      return [];
    }
    let classToUse;
    if (typeof classesOrFunc === "function") {
      const params = this.getClassParams(abstractColDef, gridOptionsService, column, columnGroup);
      classToUse = classesOrFunc(params);
    } else {
      classToUse = classesOrFunc;
    }
    if (typeof classToUse === "string") {
      return [classToUse];
    }
    if (Array.isArray(classToUse)) {
      return [...classToUse];
    }
    return [];
  }
};
var __decorate$1v = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HeaderCellComp = class extends AbstractHeaderCellComp {
  constructor(ctrl) {
    super(HeaderCellComp.TEMPLATE, ctrl);
    this.headerCompVersion = 0;
    this.column = ctrl.getColumnGroupChild();
    this.pinned = ctrl.getPinned();
  }
  postConstruct() {
    const eGui = this.getGui();
    const setAttribute = (name, value, element) => {
      const actualElement = element ? element : eGui;
      if (value != null && value != "") {
        actualElement.setAttribute(name, value);
      } else {
        actualElement.removeAttribute(name);
      }
    };
    const compProxy = {
      setWidth: (width) => eGui.style.width = width,
      addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
      setColId: (id) => setAttribute("col-id", id),
      setTitle: (title) => setAttribute("title", title),
      setAriaDescription: (label) => setAriaDescription(eGui, label),
      setAriaSort: (sort) => sort ? setAriaSort(eGui, sort) : removeAriaSort(eGui),
      setUserCompDetails: (compDetails) => this.setUserCompDetails(compDetails),
      getUserCompInstance: () => this.headerComp
    };
    this.ctrl.setComp(compProxy, this.getGui(), this.eResize, this.eHeaderCompWrapper);
    const selectAllGui = this.ctrl.getSelectAllGui();
    this.eResize.insertAdjacentElement("afterend", selectAllGui);
  }
  destroyHeaderComp() {
    if (this.headerComp) {
      this.eHeaderCompWrapper.removeChild(this.headerCompGui);
      this.headerComp = this.destroyBean(this.headerComp);
      this.headerCompGui = void 0;
    }
  }
  setUserCompDetails(compDetails) {
    this.headerCompVersion++;
    const versionCopy = this.headerCompVersion;
    compDetails.newAgStackInstance().then((comp) => this.afterCompCreated(versionCopy, comp));
  }
  afterCompCreated(version, headerComp) {
    if (version != this.headerCompVersion || !this.isAlive()) {
      this.destroyBean(headerComp);
      return;
    }
    this.destroyHeaderComp();
    this.headerComp = headerComp;
    this.headerCompGui = headerComp.getGui();
    this.eHeaderCompWrapper.appendChild(this.headerCompGui);
    this.ctrl.setDragSource(this.getGui());
  }
};
HeaderCellComp.TEMPLATE = `<div class="ag-header-cell" role="columnheader" tabindex="-1">
            <div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
            <div ref="eHeaderCompWrapper" class="ag-header-cell-comp-wrapper" role="presentation"></div>
        </div>`;
__decorate$1v([
  RefSelector("eResize")
], HeaderCellComp.prototype, "eResize", void 0);
__decorate$1v([
  RefSelector("eHeaderCompWrapper")
], HeaderCellComp.prototype, "eHeaderCompWrapper", void 0);
__decorate$1v([
  PostConstruct
], HeaderCellComp.prototype, "postConstruct", null);
__decorate$1v([
  PreDestroy
], HeaderCellComp.prototype, "destroyHeaderComp", null);
var __decorate$1u = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HeaderGroupCellComp = class extends AbstractHeaderCellComp {
  constructor(ctrl) {
    super(HeaderGroupCellComp.TEMPLATE, ctrl);
  }
  postConstruct() {
    const eGui = this.getGui();
    const setAttribute = (key, value) => value != void 0 ? eGui.setAttribute(key, value) : eGui.removeAttribute(key);
    const compProxy = {
      addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
      setResizableDisplayed: (displayed) => setDisplayed(this.eResize, displayed),
      setWidth: (width) => eGui.style.width = width,
      setColId: (id) => eGui.setAttribute("col-id", id),
      setAriaExpanded: (expanded) => setAttribute("aria-expanded", expanded),
      setTitle: (title) => setAttribute("title", title),
      setUserCompDetails: (details) => this.setUserCompDetails(details)
    };
    this.ctrl.setComp(compProxy, eGui, this.eResize);
  }
  setUserCompDetails(details) {
    details.newAgStackInstance().then((comp) => this.afterHeaderCompCreated(comp));
  }
  afterHeaderCompCreated(headerGroupComp) {
    const destroyFunc = () => this.destroyBean(headerGroupComp);
    if (!this.isAlive()) {
      destroyFunc();
      return;
    }
    const eGui = this.getGui();
    const eHeaderGroupGui = headerGroupComp.getGui();
    eGui.appendChild(eHeaderGroupGui);
    this.addDestroyFunc(destroyFunc);
    this.ctrl.setDragSource(eGui);
  }
};
HeaderGroupCellComp.TEMPLATE = `<div class="ag-header-group-cell" role="columnheader" tabindex="-1">
            <div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
        </div>`;
__decorate$1u([
  Autowired("userComponentFactory")
], HeaderGroupCellComp.prototype, "userComponentFactory", void 0);
__decorate$1u([
  RefSelector("eResize")
], HeaderGroupCellComp.prototype, "eResize", void 0);
__decorate$1u([
  PostConstruct
], HeaderGroupCellComp.prototype, "postConstruct", null);
var __decorate$1t = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HeaderRowType;
(function(HeaderRowType2) {
  HeaderRowType2["COLUMN_GROUP"] = "group";
  HeaderRowType2["COLUMN"] = "column";
  HeaderRowType2["FLOATING_FILTER"] = "filter";
})(HeaderRowType || (HeaderRowType = {}));
var HeaderRowComp = class extends Component {
  constructor(ctrl) {
    super();
    this.headerComps = {};
    const extraClass = ctrl.getType() == HeaderRowType.COLUMN_GROUP ? `ag-header-row-column-group` : ctrl.getType() == HeaderRowType.FLOATING_FILTER ? `ag-header-row-column-filter` : `ag-header-row-column`;
    this.setTemplate(`<div class="ag-header-row ${extraClass}" role="row"></div>`);
    this.ctrl = ctrl;
  }
  init() {
    const compProxy = {
      setTransform: (transform) => this.getGui().style.transform = transform,
      setHeight: (height) => this.getGui().style.height = height,
      setTop: (top) => this.getGui().style.top = top,
      setHeaderCtrls: (ctrls) => this.setHeaderCtrls(ctrls),
      setWidth: (width) => this.getGui().style.width = width,
      setAriaRowIndex: (rowIndex) => setAriaRowIndex(this.getGui(), rowIndex)
    };
    this.ctrl.setComp(compProxy);
  }
  destroyHeaderCtrls() {
    this.setHeaderCtrls([]);
  }
  setHeaderCtrls(ctrls) {
    if (!this.isAlive()) {
      return;
    }
    const oldComps = this.headerComps;
    this.headerComps = {};
    ctrls.forEach((ctrl) => {
      const id = ctrl.getInstanceId();
      let comp = oldComps[id];
      delete oldComps[id];
      if (comp == null) {
        comp = this.createHeaderComp(ctrl);
        this.getGui().appendChild(comp.getGui());
      }
      this.headerComps[id] = comp;
    });
    iterateObject(oldComps, (id, comp) => {
      this.getGui().removeChild(comp.getGui());
      this.destroyBean(comp);
    });
    const isEnsureDomOrder = this.gridOptionsService.is("ensureDomOrder");
    const isPrintLayout = this.gridOptionsService.isDomLayout("print");
    if (isEnsureDomOrder || isPrintLayout) {
      const comps = getAllValuesInObject(this.headerComps);
      comps.sort((a, b) => {
        const leftA = a.getCtrl().getColumnGroupChild().getLeft();
        const leftB = b.getCtrl().getColumnGroupChild().getLeft();
        return leftA - leftB;
      });
      const elementsInOrder = comps.map((c) => c.getGui());
      setDomChildOrder(this.getGui(), elementsInOrder);
    }
  }
  createHeaderComp(headerCtrl) {
    let result;
    switch (this.ctrl.getType()) {
      case HeaderRowType.COLUMN_GROUP:
        result = new HeaderGroupCellComp(headerCtrl);
        break;
      case HeaderRowType.FLOATING_FILTER:
        result = new HeaderFilterCellComp(headerCtrl);
        break;
      default:
        result = new HeaderCellComp(headerCtrl);
        break;
    }
    this.createBean(result);
    result.setParentComponent(this);
    return result;
  }
};
__decorate$1t([
  PostConstruct
], HeaderRowComp.prototype, "init", null);
__decorate$1t([
  PreDestroy
], HeaderRowComp.prototype, "destroyHeaderCtrls", null);
var __decorate$1s = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var instanceIdSequence$1 = 0;
var AbstractHeaderCellCtrl = class extends BeanStub {
  constructor(columnGroupChild, parentRowCtrl) {
    super();
    this.lastFocusEvent = null;
    this.columnGroupChild = columnGroupChild;
    this.parentRowCtrl = parentRowCtrl;
    this.instanceId = columnGroupChild.getUniqueId() + "-" + instanceIdSequence$1++;
  }
  shouldStopEventPropagation(e) {
    const { headerRowIndex, column } = this.focusService.getFocusedHeader();
    return isUserSuppressingHeaderKeyboardEvent(this.gridOptionsService, e, headerRowIndex, column);
  }
  getWrapperHasFocus() {
    const eDocument = this.gridOptionsService.getDocument();
    const activeEl = eDocument.activeElement;
    return activeEl === this.eGui;
  }
  setGui(eGui) {
    this.eGui = eGui;
    this.addDomData();
  }
  handleKeyDown(e) {
    const wrapperHasFocus = this.getWrapperHasFocus();
    switch (e.key) {
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAGE_HOME:
      case KeyCode.PAGE_END:
        if (wrapperHasFocus) {
          e.preventDefault();
        }
    }
  }
  addDomData() {
    const key = AbstractHeaderCellCtrl.DOM_DATA_KEY_HEADER_CTRL;
    this.gridOptionsService.setDomData(this.eGui, key, this);
    this.addDestroyFunc(() => this.gridOptionsService.setDomData(this.eGui, key, null));
  }
  getGui() {
    return this.eGui;
  }
  focus(event) {
    if (!this.eGui) {
      return false;
    }
    this.lastFocusEvent = event || null;
    this.eGui.focus();
    return true;
  }
  getRowIndex() {
    return this.parentRowCtrl.getRowIndex();
  }
  getParentRowCtrl() {
    return this.parentRowCtrl;
  }
  getPinned() {
    return this.parentRowCtrl.getPinned();
  }
  getInstanceId() {
    return this.instanceId;
  }
  getColumnGroupChild() {
    return this.columnGroupChild;
  }
};
AbstractHeaderCellCtrl.DOM_DATA_KEY_HEADER_CTRL = "headerCtrl";
__decorate$1s([
  Autowired("focusService")
], AbstractHeaderCellCtrl.prototype, "focusService", void 0);
__decorate$1s([
  Autowired("beans")
], AbstractHeaderCellCtrl.prototype, "beans", void 0);
__decorate$1s([
  Autowired("userComponentFactory")
], AbstractHeaderCellCtrl.prototype, "userComponentFactory", void 0);
var __decorate$1r = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SetLeftFeature = class extends BeanStub {
  constructor(columnOrGroup, eCell, beans, colsSpanning) {
    super();
    this.columnOrGroup = columnOrGroup;
    this.eCell = eCell;
    this.ariaEl = this.eCell.querySelector("[role=columnheader]") || this.eCell;
    this.colsSpanning = colsSpanning;
    this.beans = beans;
  }
  setColsSpanning(colsSpanning) {
    this.colsSpanning = colsSpanning;
    this.onLeftChanged();
  }
  getColumnOrGroup() {
    if (this.beans.gridOptionsService.is("enableRtl") && this.colsSpanning) {
      return last(this.colsSpanning);
    }
    return this.columnOrGroup;
  }
  postConstruct() {
    this.addManagedListener(this.columnOrGroup, Column.EVENT_LEFT_CHANGED, this.onLeftChanged.bind(this));
    this.setLeftFirstTime();
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onLeftChanged.bind(this));
    this.addManagedPropertyListener("domLayout", this.onLeftChanged.bind(this));
  }
  setLeftFirstTime() {
    const suppressMoveAnimation = this.beans.gridOptionsService.is("suppressColumnMoveAnimation");
    const oldLeftExists = exists(this.columnOrGroup.getOldLeft());
    const animateColumnMove = this.beans.columnAnimationService.isActive() && oldLeftExists && !suppressMoveAnimation;
    if (animateColumnMove) {
      this.animateInLeft();
    } else {
      this.onLeftChanged();
    }
  }
  animateInLeft() {
    const colOrGroup = this.getColumnOrGroup();
    const left = colOrGroup.getLeft();
    const oldLeft = colOrGroup.getOldLeft();
    const oldActualLeft = this.modifyLeftForPrintLayout(colOrGroup, oldLeft);
    const actualLeft = this.modifyLeftForPrintLayout(colOrGroup, left);
    this.setLeft(oldActualLeft);
    this.actualLeft = actualLeft;
    this.beans.columnAnimationService.executeNextVMTurn(() => {
      if (this.actualLeft === actualLeft) {
        this.setLeft(actualLeft);
      }
    });
  }
  onLeftChanged() {
    const colOrGroup = this.getColumnOrGroup();
    const left = colOrGroup.getLeft();
    this.actualLeft = this.modifyLeftForPrintLayout(colOrGroup, left);
    this.setLeft(this.actualLeft);
  }
  modifyLeftForPrintLayout(colOrGroup, leftPosition) {
    const printLayout = this.beans.gridOptionsService.isDomLayout("print");
    if (!printLayout) {
      return leftPosition;
    }
    if (colOrGroup.getPinned() === "left") {
      return leftPosition;
    }
    const leftWidth = this.beans.columnModel.getDisplayedColumnsLeftWidth();
    if (colOrGroup.getPinned() === "right") {
      const bodyWidth = this.beans.columnModel.getBodyContainerWidth();
      return leftWidth + bodyWidth + leftPosition;
    }
    return leftWidth + leftPosition;
  }
  setLeft(value) {
    if (exists(value)) {
      this.eCell.style.left = `${value}px`;
    }
    let indexColumn;
    if (this.columnOrGroup instanceof Column) {
      indexColumn = this.columnOrGroup;
    } else {
      const columnGroup = this.columnOrGroup;
      const children = columnGroup.getLeafColumns();
      if (!children.length) {
        return;
      }
      if (children.length > 1) {
        setAriaColSpan(this.ariaEl, children.length);
      }
      indexColumn = children[0];
    }
    const index = this.beans.columnModel.getAriaColumnIndex(indexColumn);
    setAriaColIndex(this.ariaEl, index);
  }
};
__decorate$1r([
  PostConstruct
], SetLeftFeature.prototype, "postConstruct", null);
var __decorate$1q = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HoverFeature = class extends BeanStub {
  constructor(columns, element) {
    super();
    this.columns = columns;
    this.element = element;
  }
  postConstruct() {
    if (this.gridOptionsService.is("columnHoverHighlight")) {
      this.addMouseHoverListeners();
    }
  }
  addMouseHoverListeners() {
    this.addManagedListener(this.element, "mouseout", this.onMouseOut.bind(this));
    this.addManagedListener(this.element, "mouseover", this.onMouseOver.bind(this));
  }
  onMouseOut() {
    this.columnHoverService.clearMouseOver();
  }
  onMouseOver() {
    this.columnHoverService.setMouseOver(this.columns);
  }
};
__decorate$1q([
  Autowired("columnHoverService")
], HoverFeature.prototype, "columnHoverService", void 0);
__decorate$1q([
  PostConstruct
], HoverFeature.prototype, "postConstruct", null);
var __decorate$1p = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HeaderFilterCellCtrl = class extends AbstractHeaderCellCtrl {
  constructor(column, parentRowCtrl) {
    super(column, parentRowCtrl);
    this.iconCreated = false;
    this.column = column;
  }
  setComp(comp, eGui, eButtonShowMainFilter, eFloatingFilterBody) {
    super.setGui(eGui);
    this.comp = comp;
    this.eButtonShowMainFilter = eButtonShowMainFilter;
    this.eFloatingFilterBody = eFloatingFilterBody;
    this.setupActive();
    this.setupWidth();
    this.setupLeft();
    this.setupHover();
    this.setupFocus();
    this.setupAria();
    this.setupFilterButton();
    this.setupUserComp();
    this.setupSyncWithFilter();
    this.setupUi();
    this.addManagedListener(this.eButtonShowMainFilter, "click", this.showParentFilter.bind(this));
    this.setupFilterChangedListener();
    this.addManagedListener(this.column, Column.EVENT_COL_DEF_CHANGED, this.onColDefChanged.bind(this));
  }
  setupActive() {
    const colDef = this.column.getColDef();
    const filterExists = !!colDef.filter;
    const floatingFilterExists = !!colDef.floatingFilter;
    this.active = filterExists && floatingFilterExists;
  }
  setupUi() {
    this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active);
    this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton);
    this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton);
    if (!this.active || this.iconCreated) {
      return;
    }
    const eMenuIcon = createIconNoSpan("filter", this.gridOptionsService, this.column);
    if (eMenuIcon) {
      this.iconCreated = true;
      this.eButtonShowMainFilter.appendChild(eMenuIcon);
    }
  }
  setupFocus() {
    this.createManagedBean(new ManagedFocusFeature(this.eGui, {
      shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
      onTabKeyDown: this.onTabKeyDown.bind(this),
      handleKeyDown: this.handleKeyDown.bind(this),
      onFocusIn: this.onFocusIn.bind(this)
    }));
  }
  setupAria() {
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    setAriaLabel(this.eButtonShowMainFilter, localeTextFunc("ariaFilterMenuOpen", "Open Filter Menu"));
  }
  onTabKeyDown(e) {
    const eDocument = this.gridOptionsService.getDocument();
    const activeEl = eDocument.activeElement;
    const wrapperHasFocus = activeEl === this.eGui;
    if (wrapperHasFocus) {
      return;
    }
    const nextFocusableEl = this.focusService.findNextFocusableElement(this.eGui, null, e.shiftKey);
    if (nextFocusableEl) {
      this.beans.headerNavigationService.scrollToColumn(this.column);
      e.preventDefault();
      nextFocusableEl.focus();
      return;
    }
    const nextFocusableColumn = this.findNextColumnWithFloatingFilter(e.shiftKey);
    if (!nextFocusableColumn) {
      return;
    }
    if (this.focusService.focusHeaderPosition({
      headerPosition: {
        headerRowIndex: this.getParentRowCtrl().getRowIndex(),
        column: nextFocusableColumn
      },
      event: e
    })) {
      e.preventDefault();
    }
  }
  findNextColumnWithFloatingFilter(backwards) {
    const columModel = this.beans.columnModel;
    let nextCol = this.column;
    do {
      nextCol = backwards ? columModel.getDisplayedColBefore(nextCol) : columModel.getDisplayedColAfter(nextCol);
      if (!nextCol) {
        break;
      }
    } while (!nextCol.getColDef().filter || !nextCol.getColDef().floatingFilter);
    return nextCol;
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const wrapperHasFocus = this.getWrapperHasFocus();
    switch (e.key) {
      case KeyCode.UP:
      case KeyCode.DOWN:
        if (!wrapperHasFocus) {
          e.preventDefault();
        }
      case KeyCode.LEFT:
      case KeyCode.RIGHT:
        if (wrapperHasFocus) {
          return;
        }
        e.stopPropagation();
      case KeyCode.ENTER:
        if (wrapperHasFocus) {
          if (this.focusService.focusInto(this.eGui)) {
            e.preventDefault();
          }
        }
        break;
      case KeyCode.ESCAPE:
        if (!wrapperHasFocus) {
          this.eGui.focus();
        }
    }
  }
  onFocusIn(e) {
    const isRelatedWithin = this.eGui.contains(e.relatedTarget);
    if (isRelatedWithin) {
      return;
    }
    const notFromHeaderWrapper = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter");
    const fromWithinHeader = !!e.relatedTarget && isElementChildOfClass(e.relatedTarget, "ag-floating-filter");
    if (notFromHeaderWrapper && fromWithinHeader && e.target === this.eGui) {
      const lastFocusEvent = this.lastFocusEvent;
      const fromTab = !!(lastFocusEvent && lastFocusEvent.key === KeyCode.TAB);
      if (lastFocusEvent && fromTab) {
        const shouldFocusLast = lastFocusEvent.shiftKey;
        this.focusService.focusInto(this.eGui, shouldFocusLast);
      }
    }
    const rowIndex = this.getRowIndex();
    this.beans.focusService.setFocusedHeader(rowIndex, this.column);
  }
  setupHover() {
    this.createManagedBean(new HoverFeature([this.column], this.eGui));
    const listener = () => {
      if (!this.gridOptionsService.is("columnHoverHighlight")) {
        return;
      }
      const hovered = this.columnHoverService.isHovered(this.column);
      this.comp.addOrRemoveCssClass("ag-column-hover", hovered);
    };
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HOVER_CHANGED, listener);
    listener();
  }
  setupLeft() {
    const setLeftFeature = new SetLeftFeature(this.column, this.eGui, this.beans);
    this.createManagedBean(setLeftFeature);
  }
  setupFilterButton() {
    const colDef = this.column.getColDef();
    this.suppressFilterButton = colDef.floatingFilterComponentParams ? !!colDef.floatingFilterComponentParams.suppressFilterButton : false;
  }
  setupUserComp() {
    if (!this.active) {
      return;
    }
    const compDetails = this.filterManager.getFloatingFilterCompDetails(this.column, () => this.showParentFilter());
    if (compDetails) {
      this.setCompDetails(compDetails);
    }
  }
  setCompDetails(compDetails) {
    this.userCompDetails = compDetails;
    this.comp.setCompDetails(compDetails);
  }
  showParentFilter() {
    const eventSource = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
    this.menuFactory.showMenuAfterButtonClick(this.column, eventSource, "floatingFilter", "filterMenuTab", ["filterMenuTab"]);
  }
  setupSyncWithFilter() {
    if (!this.active) {
      return;
    }
    const syncWithFilter = (filterChangedEvent) => {
      const compPromise = this.comp.getFloatingFilterComp();
      if (!compPromise) {
        return;
      }
      compPromise.then((comp) => {
        if (comp) {
          const parentModel = this.filterManager.getCurrentFloatingFilterParentModel(this.column);
          comp.onParentModelChanged(parentModel, filterChangedEvent);
        }
      });
    };
    this.destroySyncListener = this.addManagedListener(this.column, Column.EVENT_FILTER_CHANGED, syncWithFilter);
    if (this.filterManager.isFilterActive(this.column)) {
      syncWithFilter(null);
    }
  }
  setupWidth() {
    const listener = () => {
      const width = `${this.column.getActualWidth()}px`;
      this.comp.setWidth(width);
    };
    this.addManagedListener(this.column, Column.EVENT_WIDTH_CHANGED, listener);
    listener();
  }
  setupFilterChangedListener() {
    if (this.active) {
      this.destroyFilterChangedListener = this.addManagedListener(this.column, Column.EVENT_FILTER_CHANGED, this.updateFilterButton.bind(this));
    }
  }
  updateFilterButton() {
    if (!this.suppressFilterButton && this.comp) {
      this.comp.setButtonWrapperDisplayed(this.filterManager.isFilterAllowed(this.column));
    }
  }
  onColDefChanged() {
    var _a, _b;
    const wasActive = this.active;
    this.setupActive();
    const becomeActive = !wasActive && this.active;
    if (wasActive && !this.active) {
      (_a = this.destroySyncListener) === null || _a === void 0 ? void 0 : _a.call(this);
      (_b = this.destroyFilterChangedListener) === null || _b === void 0 ? void 0 : _b.call(this);
    }
    const newCompDetails = this.active ? this.filterManager.getFloatingFilterCompDetails(this.column, () => this.showParentFilter()) : null;
    const compPromise = this.comp.getFloatingFilterComp();
    if (!compPromise || !newCompDetails) {
      this.updateCompDetails(newCompDetails, becomeActive);
    } else {
      compPromise.then((compInstance) => {
        var _a2;
        if (!compInstance || ((_a2 = this.userCompDetails) === null || _a2 === void 0 ? void 0 : _a2.componentClass) !== newCompDetails.componentClass) {
          this.updateCompDetails(newCompDetails, becomeActive);
        }
      });
    }
  }
  updateCompDetails(compDetails, becomeActive) {
    this.setCompDetails(compDetails);
    this.setupFilterButton();
    this.setupUi();
    if (becomeActive) {
      this.setupSyncWithFilter();
      this.setupFilterChangedListener();
    }
  }
};
__decorate$1p([
  Autowired("filterManager")
], HeaderFilterCellCtrl.prototype, "filterManager", void 0);
__decorate$1p([
  Autowired("columnHoverService")
], HeaderFilterCellCtrl.prototype, "columnHoverService", void 0);
__decorate$1p([
  Autowired("menuFactory")
], HeaderFilterCellCtrl.prototype, "menuFactory", void 0);
var __decorate$1o = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ResizeFeature = class extends BeanStub {
  constructor(pinned, column, eResize, comp, ctrl) {
    super();
    this.pinned = pinned;
    this.column = column;
    this.eResize = eResize;
    this.comp = comp;
    this.ctrl = ctrl;
  }
  postConstruct() {
    const colDef = this.column.getColDef();
    const destroyResizeFuncs = [];
    let canResize;
    let canAutosize;
    const addResize = () => {
      setDisplayed(this.eResize, canResize);
      if (!canResize) {
        return;
      }
      const finishedWithResizeFunc = this.horizontalResizeService.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, false),
        onResizeEnd: this.onResizing.bind(this, true)
      });
      destroyResizeFuncs.push(finishedWithResizeFunc);
      if (canAutosize) {
        const skipHeaderOnAutoSize = this.gridOptionsService.is("skipHeaderOnAutoSize");
        const autoSizeColListener = () => {
          this.columnModel.autoSizeColumn(this.column, skipHeaderOnAutoSize, "uiColumnResized");
        };
        this.eResize.addEventListener("dblclick", autoSizeColListener);
        const touchListener = new TouchListener(this.eResize);
        touchListener.addEventListener(TouchListener.EVENT_DOUBLE_TAP, autoSizeColListener);
        this.addDestroyFunc(() => {
          this.eResize.removeEventListener("dblclick", autoSizeColListener);
          touchListener.removeEventListener(TouchListener.EVENT_DOUBLE_TAP, autoSizeColListener);
          touchListener.destroy();
        });
      }
    };
    const removeResize = () => {
      destroyResizeFuncs.forEach((f) => f());
      destroyResizeFuncs.length = 0;
    };
    const refresh = () => {
      const resize = this.column.isResizable();
      const autoSize = !this.gridOptionsService.is("suppressAutoSize") && !colDef.suppressAutoSize;
      const propertyChange = resize !== canResize || autoSize !== canAutosize;
      if (propertyChange) {
        canResize = resize;
        canAutosize = autoSize;
        removeResize();
        addResize();
      }
    };
    refresh();
    this.addDestroyFunc(removeResize);
    this.ctrl.addRefreshFunction(refresh);
  }
  onResizing(finished, resizeAmount) {
    const resizeAmountNormalised = this.normaliseResizeAmount(resizeAmount);
    const columnWidths = [{ key: this.column, newWidth: this.resizeStartWidth + resizeAmountNormalised }];
    this.columnModel.setColumnWidths(columnWidths, this.resizeWithShiftKey, finished, "uiColumnResized");
    if (finished) {
      this.comp.addOrRemoveCssClass("ag-column-resizing", false);
    }
  }
  onResizeStart(shiftKey) {
    this.resizeStartWidth = this.column.getActualWidth();
    this.resizeWithShiftKey = shiftKey;
    this.comp.addOrRemoveCssClass("ag-column-resizing", true);
  }
  normaliseResizeAmount(dragChange) {
    let result = dragChange;
    const notPinningLeft = this.pinned !== "left";
    const pinningRight = this.pinned === "right";
    if (this.gridOptionsService.is("enableRtl")) {
      if (notPinningLeft) {
        result *= -1;
      }
    } else {
      if (pinningRight) {
        result *= -1;
      }
    }
    return result;
  }
};
__decorate$1o([
  Autowired("horizontalResizeService")
], ResizeFeature.prototype, "horizontalResizeService", void 0);
__decorate$1o([
  Autowired("columnModel")
], ResizeFeature.prototype, "columnModel", void 0);
__decorate$1o([
  PostConstruct
], ResizeFeature.prototype, "postConstruct", null);
var __decorate$1n = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SelectAllFeature = class extends BeanStub {
  constructor(column) {
    super();
    this.cbSelectAllVisible = false;
    this.processingEventFromCheckbox = false;
    this.column = column;
    const colDef = column.getColDef();
    this.filteredOnly = !!(colDef === null || colDef === void 0 ? void 0 : colDef.headerCheckboxSelectionFilteredOnly);
    this.currentPageOnly = !!(colDef === null || colDef === void 0 ? void 0 : colDef.headerCheckboxSelectionCurrentPageOnly);
  }
  onSpaceKeyDown(e) {
    const checkbox = this.cbSelectAll;
    const eDocument = this.gridOptionsService.getDocument();
    if (checkbox.isDisplayed() && !checkbox.getGui().contains(eDocument.activeElement)) {
      e.preventDefault();
      checkbox.setValue(!checkbox.getValue());
    }
  }
  getCheckboxGui() {
    return this.cbSelectAll.getGui();
  }
  setComp(ctrl) {
    this.headerCellCtrl = ctrl;
    this.cbSelectAll = this.createManagedBean(new AgCheckbox());
    this.cbSelectAll.addCssClass("ag-header-select-all");
    setAriaRole(this.cbSelectAll.getGui(), "presentation");
    this.showOrHideSelectAll();
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.showOrHideSelectAll.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.showOrHideSelectAll.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_SELECTION_CHANGED, this.onSelectionChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_PAGINATION_CHANGED, this.onSelectionChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, this.onModelChanged.bind(this));
    this.addManagedListener(this.cbSelectAll, AgCheckbox.EVENT_CHANGED, this.onCbSelectAll.bind(this));
    setAriaHidden(this.cbSelectAll.getGui(), true);
    this.cbSelectAll.getInputElement().setAttribute("tabindex", "-1");
    this.refreshSelectAllLabel();
  }
  showOrHideSelectAll() {
    this.cbSelectAllVisible = this.isCheckboxSelection();
    this.cbSelectAll.setDisplayed(this.cbSelectAllVisible, { skipAriaHidden: true });
    if (this.cbSelectAllVisible) {
      this.checkRightRowModelType("selectAllCheckbox");
      this.updateStateOfCheckbox();
    }
    this.refreshSelectAllLabel();
  }
  onModelChanged() {
    if (!this.cbSelectAllVisible) {
      return;
    }
    this.updateStateOfCheckbox();
  }
  onSelectionChanged() {
    if (!this.cbSelectAllVisible) {
      return;
    }
    this.updateStateOfCheckbox();
  }
  updateStateOfCheckbox() {
    if (this.processingEventFromCheckbox) {
      return;
    }
    this.processingEventFromCheckbox = true;
    const allSelected = this.selectionService.getSelectAllState(this.filteredOnly, this.currentPageOnly);
    this.cbSelectAll.setValue(allSelected);
    this.refreshSelectAllLabel();
    this.processingEventFromCheckbox = false;
  }
  refreshSelectAllLabel() {
    const translate = this.localeService.getLocaleTextFunc();
    const checked = this.cbSelectAll.getValue();
    const ariaStatus = checked ? translate("ariaChecked", "checked") : translate("ariaUnchecked", "unchecked");
    const ariaLabel = translate("ariaRowSelectAll", "Press Space to toggle all rows selection");
    if (!this.cbSelectAllVisible) {
      this.headerCellCtrl.setAriaDescriptionProperty("selectAll", null);
    } else {
      this.headerCellCtrl.setAriaDescriptionProperty("selectAll", `${ariaLabel} (${ariaStatus})`);
    }
    this.cbSelectAll.setInputAriaLabel(`${ariaLabel} (${ariaStatus})`);
    this.headerCellCtrl.refreshAriaDescription();
  }
  checkRightRowModelType(feature) {
    const rowModelType = this.rowModel.getType();
    const rowModelMatches = rowModelType === "clientSide" || rowModelType === "serverSide";
    if (!rowModelMatches) {
      console.warn(`AG Grid: ${feature} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${rowModelType}.`);
      return false;
    }
    return true;
  }
  onCbSelectAll() {
    if (this.processingEventFromCheckbox) {
      return;
    }
    if (!this.cbSelectAllVisible) {
      return;
    }
    const value = this.cbSelectAll.getValue();
    let source = "uiSelectAll";
    if (this.currentPageOnly)
      source = "uiSelectAllCurrentPage";
    else if (this.filteredOnly)
      source = "uiSelectAllFiltered";
    const params = {
      source,
      justFiltered: this.filteredOnly,
      justCurrentPage: this.currentPageOnly
    };
    if (value) {
      this.selectionService.selectAllRowNodes(params);
    } else {
      this.selectionService.deselectAllRowNodes(params);
    }
  }
  isCheckboxSelection() {
    let result = this.column.getColDef().headerCheckboxSelection;
    if (typeof result === "function") {
      const func = result;
      const params = {
        column: this.column,
        colDef: this.column.getColDef(),
        columnApi: this.columnApi,
        api: this.gridApi,
        context: this.gridOptionsService.context
      };
      result = func(params);
    }
    if (result) {
      return this.checkRightRowModelType("headerCheckboxSelection");
    }
    return false;
  }
};
__decorate$1n([
  Autowired("gridApi")
], SelectAllFeature.prototype, "gridApi", void 0);
__decorate$1n([
  Autowired("columnApi")
], SelectAllFeature.prototype, "columnApi", void 0);
__decorate$1n([
  Autowired("rowModel")
], SelectAllFeature.prototype, "rowModel", void 0);
__decorate$1n([
  Autowired("selectionService")
], SelectAllFeature.prototype, "selectionService", void 0);
var __decorate$1m = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HeaderCellCtrl = class extends AbstractHeaderCellCtrl {
  constructor(column, parentRowCtrl) {
    super(column, parentRowCtrl);
    this.refreshFunctions = [];
    this.userHeaderClasses = /* @__PURE__ */ new Set();
    this.ariaDescriptionProperties = /* @__PURE__ */ new Map();
    this.column = column;
  }
  setComp(comp, eGui, eResize, eHeaderCompWrapper) {
    super.setGui(eGui);
    this.comp = comp;
    this.updateState();
    this.setupWidth();
    this.setupMovingCss();
    this.setupMenuClass();
    this.setupSortableClass();
    this.setupWrapTextClass();
    this.refreshSpanHeaderHeight();
    this.setupAutoHeight(eHeaderCompWrapper);
    this.addColumnHoverListener();
    this.setupFilterCss();
    this.setupColId();
    this.setupClassesFromColDef();
    this.setupTooltip();
    this.addActiveHeaderMouseListeners();
    this.setupSelectAll();
    this.setupUserComp();
    this.refreshAria();
    this.createManagedBean(new ResizeFeature(this.getPinned(), this.column, eResize, comp, this));
    this.createManagedBean(new HoverFeature([this.column], eGui));
    this.createManagedBean(new SetLeftFeature(this.column, eGui, this.beans));
    this.createManagedBean(new ManagedFocusFeature(eGui, {
      shouldStopEventPropagation: (e) => this.shouldStopEventPropagation(e),
      onTabKeyDown: () => null,
      handleKeyDown: this.handleKeyDown.bind(this),
      onFocusIn: this.onFocusIn.bind(this),
      onFocusOut: this.onFocusOut.bind(this)
    }));
    this.addManagedListener(this.column, Column.EVENT_COL_DEF_CHANGED, this.onColDefChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.onColumnValueChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onColumnRowGroupChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.onColumnPivotChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_HEADER_HEIGHT_CHANGED, this.onHeaderHeightChanged.bind(this));
  }
  setupUserComp() {
    const compDetails = this.lookupUserCompDetails();
    this.setCompDetails(compDetails);
  }
  setCompDetails(compDetails) {
    this.userCompDetails = compDetails;
    this.comp.setUserCompDetails(compDetails);
  }
  lookupUserCompDetails() {
    const params = this.createParams();
    const colDef = this.column.getColDef();
    return this.userComponentFactory.getHeaderCompDetails(colDef, params);
  }
  createParams() {
    const colDef = this.column.getColDef();
    const params = {
      column: this.column,
      displayName: this.displayName,
      enableSorting: colDef.sortable,
      enableMenu: this.menuEnabled,
      showColumnMenu: (source) => {
        this.gridApi.showColumnMenuAfterButtonClick(this.column, source);
      },
      progressSort: (multiSort) => {
        this.sortController.progressSort(this.column, !!multiSort, "uiColumnSorted");
      },
      setSort: (sort, multiSort) => {
        this.sortController.setSortForColumn(this.column, sort, !!multiSort, "uiColumnSorted");
      },
      api: this.gridApi,
      columnApi: this.columnApi,
      context: this.gridOptionsService.context,
      eGridHeader: this.getGui()
    };
    return params;
  }
  setupSelectAll() {
    this.selectAllFeature = this.createManagedBean(new SelectAllFeature(this.column));
    this.selectAllFeature.setComp(this);
  }
  getSelectAllGui() {
    return this.selectAllFeature.getCheckboxGui();
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    if (e.key === KeyCode.SPACE) {
      this.selectAllFeature.onSpaceKeyDown(e);
    }
    if (e.key === KeyCode.ENTER) {
      this.onEnterKeyDown(e);
    }
  }
  onEnterKeyDown(e) {
    const headerComp = this.comp.getUserCompInstance();
    if (!headerComp) {
      return;
    }
    if (e.ctrlKey || e.metaKey) {
      if (this.menuEnabled && headerComp.showMenu) {
        e.preventDefault();
        headerComp.showMenu();
      }
    } else if (this.sortable) {
      const multiSort = e.shiftKey;
      this.sortController.progressSort(this.column, multiSort, "uiColumnSorted");
    }
  }
  isMenuEnabled() {
    return this.menuEnabled;
  }
  onFocusIn(e) {
    if (!this.getGui().contains(e.relatedTarget)) {
      const rowIndex = this.getRowIndex();
      this.focusService.setFocusedHeader(rowIndex, this.column);
    }
    this.setActiveHeader(true);
  }
  onFocusOut(e) {
    if (this.getGui().contains(e.relatedTarget)) {
      return;
    }
    this.setActiveHeader(false);
  }
  setupTooltip() {
    const tooltipCtrl = {
      getColumn: () => this.column,
      getColDef: () => this.column.getColDef(),
      getGui: () => this.eGui,
      getLocation: () => "header",
      getTooltipValue: () => {
        const res = this.column.getColDef().headerTooltip;
        return res;
      }
    };
    const tooltipFeature = this.createManagedBean(new TooltipFeature(tooltipCtrl, this.beans));
    tooltipFeature.setComp(this.comp);
    this.refreshFunctions.push(() => tooltipFeature.refreshToolTip());
  }
  setupClassesFromColDef() {
    const refreshHeaderClasses = () => {
      const colDef = this.column.getColDef();
      const classes = CssClassApplier.getHeaderClassesFromColDef(colDef, this.gridOptionsService, this.column, null);
      const oldClasses = this.userHeaderClasses;
      this.userHeaderClasses = new Set(classes);
      classes.forEach((c) => {
        if (oldClasses.has(c)) {
          oldClasses.delete(c);
        } else {
          this.comp.addOrRemoveCssClass(c, true);
        }
      });
      oldClasses.forEach((c) => this.comp.addOrRemoveCssClass(c, false));
    };
    this.refreshFunctions.push(refreshHeaderClasses);
    refreshHeaderClasses();
  }
  setDragSource(eSource) {
    this.dragSourceElement = eSource;
    this.removeDragSource();
    if (!eSource) {
      return;
    }
    if (!this.draggable) {
      return;
    }
    const hideColumnOnExit = !this.gridOptionsService.is("suppressDragLeaveHidesColumns");
    this.moveDragSource = {
      type: DragSourceType.HeaderCell,
      eElement: eSource,
      defaultIconName: hideColumnOnExit ? DragAndDropService.ICON_HIDE : DragAndDropService.ICON_NOT_ALLOWED,
      getDragItem: () => this.createDragItem(),
      dragItemName: this.displayName,
      onDragStarted: () => this.column.setMoving(true, "uiColumnMoved"),
      onDragStopped: () => this.column.setMoving(false, "uiColumnMoved"),
      onGridEnter: (dragItem) => {
        var _a;
        if (hideColumnOnExit) {
          const unlockedColumns = ((_a = dragItem === null || dragItem === void 0 ? void 0 : dragItem.columns) === null || _a === void 0 ? void 0 : _a.filter((col) => !col.getColDef().lockVisible)) || [];
          this.columnModel.setColumnsVisible(unlockedColumns, true, "uiColumnMoved");
        }
      },
      onGridExit: (dragItem) => {
        var _a;
        if (hideColumnOnExit) {
          const unlockedColumns = ((_a = dragItem === null || dragItem === void 0 ? void 0 : dragItem.columns) === null || _a === void 0 ? void 0 : _a.filter((col) => !col.getColDef().lockVisible)) || [];
          this.columnModel.setColumnsVisible(unlockedColumns, false, "uiColumnMoved");
        }
      }
    };
    this.dragAndDropService.addDragSource(this.moveDragSource, true);
  }
  createDragItem() {
    const visibleState = {};
    visibleState[this.column.getId()] = this.column.isVisible();
    return {
      columns: [this.column],
      visibleState
    };
  }
  removeDragSource() {
    if (this.moveDragSource) {
      this.dragAndDropService.removeDragSource(this.moveDragSource);
      this.moveDragSource = void 0;
    }
  }
  onColDefChanged() {
    this.refresh();
  }
  updateState() {
    const colDef = this.column.getColDef();
    this.menuEnabled = this.menuFactory.isMenuEnabled(this.column) && !colDef.suppressMenu;
    this.sortable = colDef.sortable;
    this.displayName = this.calculateDisplayName();
    this.draggable = this.workOutDraggable();
  }
  addRefreshFunction(func) {
    this.refreshFunctions.push(func);
  }
  refresh() {
    this.updateState();
    this.refreshHeaderComp();
    this.refreshAria();
    this.refreshFunctions.forEach((f) => f());
  }
  refreshHeaderComp() {
    const newCompDetails = this.lookupUserCompDetails();
    const compInstance = this.comp.getUserCompInstance();
    const attemptRefresh = compInstance != null && this.userCompDetails.componentClass == newCompDetails.componentClass;
    const headerCompRefreshed = attemptRefresh ? this.attemptHeaderCompRefresh(newCompDetails.params) : false;
    if (headerCompRefreshed) {
      this.setDragSource(this.dragSourceElement);
    } else {
      this.setCompDetails(newCompDetails);
    }
  }
  attemptHeaderCompRefresh(params) {
    const headerComp = this.comp.getUserCompInstance();
    if (!headerComp) {
      return false;
    }
    if (!headerComp.refresh) {
      return false;
    }
    const res = headerComp.refresh(params);
    return res;
  }
  calculateDisplayName() {
    return this.columnModel.getDisplayNameForColumn(this.column, "header", true);
  }
  checkDisplayName() {
    if (this.displayName !== this.calculateDisplayName()) {
      this.refresh();
    }
  }
  workOutDraggable() {
    const colDef = this.column.getColDef();
    const isSuppressMovableColumns = this.gridOptionsService.is("suppressMovableColumns");
    const colCanMove = !isSuppressMovableColumns && !colDef.suppressMovable && !colDef.lockPosition;
    return !!colCanMove || !!colDef.enableRowGroup || !!colDef.enablePivot;
  }
  onColumnRowGroupChanged() {
    this.checkDisplayName();
  }
  onColumnPivotChanged() {
    this.checkDisplayName();
  }
  onColumnValueChanged() {
    this.checkDisplayName();
  }
  setupWidth() {
    const listener = () => {
      const columnWidth = this.column.getActualWidth();
      this.comp.setWidth(`${columnWidth}px`);
    };
    this.addManagedListener(this.column, Column.EVENT_WIDTH_CHANGED, listener);
    listener();
  }
  setupMovingCss() {
    const listener = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
    };
    this.addManagedListener(this.column, Column.EVENT_MOVING_CHANGED, listener);
    listener();
  }
  setupMenuClass() {
    const listener = () => {
      this.comp.addOrRemoveCssClass("ag-column-menu-visible", this.column.isMenuVisible());
    };
    this.addManagedListener(this.column, Column.EVENT_MENU_VISIBLE_CHANGED, listener);
    listener();
  }
  setupSortableClass() {
    const updateSortableCssClass = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-sortable", !!this.sortable);
    };
    updateSortableCssClass();
    this.addRefreshFunction(updateSortableCssClass);
    this.addManagedListener(this.eventService, Column.EVENT_SORT_CHANGED, this.refreshAriaSort.bind(this));
  }
  setupWrapTextClass() {
    const listener = () => {
      const wrapText = !!this.column.getColDef().wrapHeaderText;
      this.comp.addOrRemoveCssClass("ag-header-cell-wrap-text", wrapText);
    };
    listener();
    this.addRefreshFunction(listener);
  }
  onHeaderHeightChanged() {
    this.refreshSpanHeaderHeight();
  }
  refreshSpanHeaderHeight() {
    const { eGui, column, comp, columnModel, gridOptionsService } = this;
    if (!column.isSpanHeaderHeight()) {
      return;
    }
    const { numberOfParents, isSpanningTotal } = this.getColumnGroupPaddingInfo();
    comp.addOrRemoveCssClass("ag-header-span-height", numberOfParents > 0);
    if (numberOfParents === 0) {
      return;
    }
    comp.addOrRemoveCssClass("ag-header-span-total", isSpanningTotal);
    const pivotMode = gridOptionsService.is("pivotMode");
    const groupHeaderHeight = pivotMode ? columnModel.getPivotGroupHeaderHeight() : columnModel.getGroupHeaderHeight();
    const headerHeight = columnModel.getColumnHeaderRowHeight();
    const extraHeight = numberOfParents * groupHeaderHeight;
    eGui.style.setProperty("top", `${-extraHeight}px`);
    eGui.style.setProperty("height", `${headerHeight + extraHeight}px`);
  }
  getColumnGroupPaddingInfo() {
    let parent = this.column.getParent();
    if (!parent || !parent.isPadding()) {
      return { numberOfParents: 0, isSpanningTotal: false };
    }
    const numberOfParents = parent.getPaddingLevel() + 1;
    let isSpanningTotal = true;
    while (parent) {
      if (!parent.isPadding()) {
        isSpanningTotal = false;
        break;
      }
      parent = parent.getParent();
    }
    return { numberOfParents, isSpanningTotal };
  }
  setupAutoHeight(wrapperElement) {
    const measureHeight = (timesCalled) => {
      if (!this.isAlive()) {
        return;
      }
      const { paddingTop, paddingBottom, borderBottomWidth, borderTopWidth } = getElementSize(this.getGui());
      const extraHeight = paddingTop + paddingBottom + borderBottomWidth + borderTopWidth;
      const wrapperHeight = wrapperElement.offsetHeight;
      const autoHeight = wrapperHeight + extraHeight;
      if (timesCalled < 5) {
        const doc = this.beans.gridOptionsService.getDocument();
        const notYetInDom = !doc || !doc.contains(wrapperElement);
        const possiblyNoContentYet = autoHeight == 0;
        if (notYetInDom || possiblyNoContentYet) {
          this.beans.frameworkOverrides.setTimeout(() => measureHeight(timesCalled + 1), 0);
          return;
        }
      }
      this.columnModel.setColumnHeaderHeight(this.column, autoHeight);
    };
    let isMeasuring = false;
    let stopResizeObserver;
    const checkMeasuring = () => {
      const newValue = this.column.isAutoHeaderHeight();
      if (newValue && !isMeasuring) {
        startMeasuring();
      }
      if (!newValue && isMeasuring) {
        stopMeasuring();
      }
    };
    const startMeasuring = () => {
      isMeasuring = true;
      measureHeight(0);
      this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", true);
      stopResizeObserver = this.resizeObserverService.observeResize(wrapperElement, () => measureHeight(0));
    };
    const stopMeasuring = () => {
      isMeasuring = false;
      if (stopResizeObserver) {
        stopResizeObserver();
      }
      this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", false);
      stopResizeObserver = void 0;
    };
    checkMeasuring();
    this.addDestroyFunc(() => stopMeasuring());
    this.addManagedListener(this.column, Column.EVENT_WIDTH_CHANGED, () => isMeasuring && measureHeight(0));
    this.addManagedListener(this.eventService, Column.EVENT_SORT_CHANGED, () => {
      if (isMeasuring) {
        this.beans.frameworkOverrides.setTimeout(() => measureHeight(0));
      }
    });
    this.addRefreshFunction(checkMeasuring);
  }
  refreshAriaSort() {
    if (this.sortable) {
      const translate = this.localeService.getLocaleTextFunc();
      const sort = this.sortController.getDisplaySortForColumn(this.column) || null;
      this.comp.setAriaSort(getAriaSortState(sort));
      this.setAriaDescriptionProperty("sort", translate("ariaSortableColumn", "Press ENTER to sort."));
    } else {
      this.comp.setAriaSort();
      this.setAriaDescriptionProperty("sort", null);
    }
  }
  refreshAriaMenu() {
    if (this.menuEnabled) {
      const translate = this.localeService.getLocaleTextFunc();
      this.setAriaDescriptionProperty("menu", translate("ariaMenuColumn", "Press CTRL ENTER to open column menu."));
    } else {
      this.setAriaDescriptionProperty("menu", null);
    }
  }
  setAriaDescriptionProperty(property, value) {
    if (value != null) {
      this.ariaDescriptionProperties.set(property, value);
    } else {
      this.ariaDescriptionProperties.delete(property);
    }
  }
  refreshAriaDescription() {
    const descriptionArray = Array.from(this.ariaDescriptionProperties.values());
    this.comp.setAriaDescription(descriptionArray.length ? descriptionArray.join(" ") : void 0);
  }
  refreshAria() {
    this.refreshAriaSort();
    this.refreshAriaMenu();
    this.refreshAriaDescription();
  }
  addColumnHoverListener() {
    const listener = () => {
      if (!this.gridOptionsService.is("columnHoverHighlight")) {
        return;
      }
      const isHovered = this.columnHoverService.isHovered(this.column);
      this.comp.addOrRemoveCssClass("ag-column-hover", isHovered);
    };
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HOVER_CHANGED, listener);
    listener();
  }
  setupFilterCss() {
    const listener = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-filtered", this.column.isFilterActive());
    };
    this.addManagedListener(this.column, Column.EVENT_FILTER_ACTIVE_CHANGED, listener);
    listener();
  }
  setupColId() {
    this.comp.setColId(this.column.getColId());
  }
  addActiveHeaderMouseListeners() {
    const listener = (e) => this.setActiveHeader(e.type === "mouseenter");
    this.addManagedListener(this.getGui(), "mouseenter", listener);
    this.addManagedListener(this.getGui(), "mouseleave", listener);
  }
  setActiveHeader(active) {
    this.comp.addOrRemoveCssClass("ag-header-active", active);
  }
};
__decorate$1m([
  Autowired("columnModel")
], HeaderCellCtrl.prototype, "columnModel", void 0);
__decorate$1m([
  Autowired("columnHoverService")
], HeaderCellCtrl.prototype, "columnHoverService", void 0);
__decorate$1m([
  Autowired("sortController")
], HeaderCellCtrl.prototype, "sortController", void 0);
__decorate$1m([
  Autowired("menuFactory")
], HeaderCellCtrl.prototype, "menuFactory", void 0);
__decorate$1m([
  Autowired("dragAndDropService")
], HeaderCellCtrl.prototype, "dragAndDropService", void 0);
__decorate$1m([
  Autowired("resizeObserverService")
], HeaderCellCtrl.prototype, "resizeObserverService", void 0);
__decorate$1m([
  Autowired("gridApi")
], HeaderCellCtrl.prototype, "gridApi", void 0);
__decorate$1m([
  Autowired("columnApi")
], HeaderCellCtrl.prototype, "columnApi", void 0);
__decorate$1m([
  PreDestroy
], HeaderCellCtrl.prototype, "removeDragSource", null);
var __decorate$1l = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GroupResizeFeature = class extends BeanStub {
  constructor(comp, eResize, pinned, columnGroup) {
    super();
    this.eResize = eResize;
    this.comp = comp;
    this.pinned = pinned;
    this.columnGroup = columnGroup;
  }
  postConstruct() {
    if (!this.columnGroup.isResizable()) {
      this.comp.setResizableDisplayed(false);
      return;
    }
    const finishedWithResizeFunc = this.horizontalResizeService.addResizeBar({
      eResizeBar: this.eResize,
      onResizeStart: this.onResizeStart.bind(this),
      onResizing: this.onResizing.bind(this, false),
      onResizeEnd: this.onResizing.bind(this, true)
    });
    this.addDestroyFunc(finishedWithResizeFunc);
    if (!this.gridOptionsService.is("suppressAutoSize")) {
      const skipHeaderOnAutoSize = this.gridOptionsService.is("skipHeaderOnAutoSize");
      this.eResize.addEventListener("dblclick", () => {
        const keys2 = [];
        const leafCols = this.columnGroup.getDisplayedLeafColumns();
        leafCols.forEach((column) => {
          if (!column.getColDef().suppressAutoSize) {
            keys2.push(column.getColId());
          }
        });
        if (keys2.length > 0) {
          this.columnModel.autoSizeColumns({
            columns: keys2,
            skipHeader: skipHeaderOnAutoSize,
            stopAtGroup: this.columnGroup,
            source: "uiColumnResized"
          });
        }
        this.resizeLeafColumnsToFit("uiColumnResized");
      });
    }
  }
  onResizeStart(shiftKey) {
    this.calculateInitialValues();
    let takeFromGroup = null;
    if (shiftKey) {
      takeFromGroup = this.columnModel.getDisplayedGroupAfter(this.columnGroup);
    }
    if (takeFromGroup) {
      const takeFromLeafCols = takeFromGroup.getDisplayedLeafColumns();
      this.resizeTakeFromCols = takeFromLeafCols.filter((col) => col.isResizable());
      this.resizeTakeFromStartWidth = 0;
      this.resizeTakeFromCols.forEach((col) => this.resizeTakeFromStartWidth += col.getActualWidth());
      this.resizeTakeFromRatios = [];
      this.resizeTakeFromCols.forEach((col) => this.resizeTakeFromRatios.push(col.getActualWidth() / this.resizeTakeFromStartWidth));
    } else {
      this.resizeTakeFromCols = null;
      this.resizeTakeFromStartWidth = null;
      this.resizeTakeFromRatios = null;
    }
    this.comp.addOrRemoveCssClass("ag-column-resizing", true);
  }
  onResizing(finished, resizeAmount, source = "uiColumnResized") {
    const resizeAmountNormalised = this.normaliseDragChange(resizeAmount);
    const width = this.resizeStartWidth + resizeAmountNormalised;
    this.resizeColumns(width, source, finished);
  }
  resizeLeafColumnsToFit(source) {
    const preferredSize = this.autoWidthCalculator.getPreferredWidthForColumnGroup(this.columnGroup);
    this.calculateInitialValues();
    if (preferredSize > this.resizeStartWidth) {
      this.resizeColumns(preferredSize, source, true);
    }
  }
  resizeColumns(totalWidth, source, finished = true) {
    const resizeSets = [];
    resizeSets.push({
      columns: this.resizeCols,
      ratios: this.resizeRatios,
      width: totalWidth
    });
    if (this.resizeTakeFromCols) {
      const diff = totalWidth - this.resizeStartWidth;
      resizeSets.push({
        columns: this.resizeTakeFromCols,
        ratios: this.resizeTakeFromRatios,
        width: this.resizeTakeFromStartWidth - diff
      });
    }
    this.columnModel.resizeColumnSets({
      resizeSets,
      finished,
      source
    });
    if (finished) {
      this.comp.addOrRemoveCssClass("ag-column-resizing", false);
    }
  }
  calculateInitialValues() {
    const leafCols = this.columnGroup.getDisplayedLeafColumns();
    this.resizeCols = leafCols.filter((col) => col.isResizable());
    this.resizeStartWidth = 0;
    this.resizeCols.forEach((col) => this.resizeStartWidth += col.getActualWidth());
    this.resizeRatios = [];
    this.resizeCols.forEach((col) => this.resizeRatios.push(col.getActualWidth() / this.resizeStartWidth));
  }
  normaliseDragChange(dragChange) {
    let result = dragChange;
    if (this.gridOptionsService.is("enableRtl")) {
      if (this.pinned !== "left") {
        result *= -1;
      }
    } else if (this.pinned === "right") {
      result *= -1;
    }
    return result;
  }
};
__decorate$1l([
  Autowired("horizontalResizeService")
], GroupResizeFeature.prototype, "horizontalResizeService", void 0);
__decorate$1l([
  Autowired("autoWidthCalculator")
], GroupResizeFeature.prototype, "autoWidthCalculator", void 0);
__decorate$1l([
  Autowired("columnModel")
], GroupResizeFeature.prototype, "columnModel", void 0);
__decorate$1l([
  PostConstruct
], GroupResizeFeature.prototype, "postConstruct", null);
var __decorate$1k = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GroupWidthFeature = class extends BeanStub {
  constructor(comp, columnGroup) {
    super();
    this.removeChildListenersFuncs = [];
    this.columnGroup = columnGroup;
    this.comp = comp;
  }
  postConstruct() {
    this.addListenersToChildrenColumns();
    this.addManagedListener(this.columnGroup, ColumnGroup.EVENT_DISPLAYED_CHILDREN_CHANGED, this.onDisplayedChildrenChanged.bind(this));
    this.onWidthChanged();
    this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
  }
  addListenersToChildrenColumns() {
    this.removeListenersOnChildrenColumns();
    const widthChangedListener = this.onWidthChanged.bind(this);
    this.columnGroup.getLeafColumns().forEach((column) => {
      column.addEventListener("widthChanged", widthChangedListener);
      column.addEventListener("visibleChanged", widthChangedListener);
      this.removeChildListenersFuncs.push(() => {
        column.removeEventListener("widthChanged", widthChangedListener);
        column.removeEventListener("visibleChanged", widthChangedListener);
      });
    });
  }
  removeListenersOnChildrenColumns() {
    this.removeChildListenersFuncs.forEach((func) => func());
    this.removeChildListenersFuncs = [];
  }
  onDisplayedChildrenChanged() {
    this.addListenersToChildrenColumns();
    this.onWidthChanged();
  }
  onWidthChanged() {
    const columnWidth = this.columnGroup.getActualWidth();
    this.comp.setWidth(`${columnWidth}px`);
    this.comp.addOrRemoveCssClass("ag-hidden", columnWidth === 0);
  }
};
__decorate$1k([
  PostConstruct
], GroupWidthFeature.prototype, "postConstruct", null);
var __decorate$1j = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HeaderGroupCellCtrl = class extends AbstractHeaderCellCtrl {
  constructor(columnGroup, parentRowCtrl) {
    super(columnGroup, parentRowCtrl);
    this.columnGroup = columnGroup;
  }
  setComp(comp, eGui, eResize) {
    super.setGui(eGui);
    this.comp = comp;
    this.displayName = this.columnModel.getDisplayNameForColumnGroup(this.columnGroup, "header");
    this.addClasses();
    this.addAttributes();
    this.setupMovingCss();
    this.setupExpandable();
    this.setupTooltip();
    this.setupUserComp();
    const pinned = this.getParentRowCtrl().getPinned();
    const leafCols = this.columnGroup.getProvidedColumnGroup().getLeafColumns();
    this.createManagedBean(new HoverFeature(leafCols, eGui));
    this.createManagedBean(new SetLeftFeature(this.columnGroup, eGui, this.beans));
    this.createManagedBean(new GroupWidthFeature(comp, this.columnGroup));
    this.groupResizeFeature = this.createManagedBean(new GroupResizeFeature(comp, eResize, pinned, this.columnGroup));
    this.createManagedBean(new ManagedFocusFeature(eGui, {
      shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
      onTabKeyDown: () => void 0,
      handleKeyDown: this.handleKeyDown.bind(this),
      onFocusIn: this.onFocusIn.bind(this)
    }));
  }
  resizeLeafColumnsToFit(source) {
    if (!this.groupResizeFeature) {
      return;
    }
    this.groupResizeFeature.resizeLeafColumnsToFit(source);
  }
  setupUserComp() {
    let displayName = this.displayName;
    const params = {
      displayName: this.displayName,
      columnGroup: this.columnGroup,
      setExpanded: (expanded) => {
        this.columnModel.setColumnGroupOpened(this.columnGroup.getProvidedColumnGroup(), expanded, "gridInitializing");
      },
      api: this.gridApi,
      columnApi: this.columnApi,
      context: this.gridOptionsService.context
    };
    if (!displayName) {
      let columnGroup = this.columnGroup;
      const leafCols = columnGroup.getLeafColumns();
      while (columnGroup.getParent() && columnGroup.getParent().getLeafColumns().length === leafCols.length) {
        columnGroup = columnGroup.getParent();
      }
      const colGroupDef = columnGroup.getColGroupDef();
      if (colGroupDef) {
        displayName = colGroupDef.headerName;
      }
      if (!displayName) {
        displayName = leafCols ? this.columnModel.getDisplayNameForColumn(leafCols[0], "header", true) : "";
      }
    }
    const compDetails = this.userComponentFactory.getHeaderGroupCompDetails(params);
    this.comp.setUserCompDetails(compDetails);
  }
  setupTooltip() {
    const colGroupDef = this.columnGroup.getColGroupDef();
    const tooltipCtrl = {
      getColumn: () => this.columnGroup,
      getGui: () => this.eGui,
      getLocation: () => "headerGroup",
      getTooltipValue: () => colGroupDef && colGroupDef.headerTooltip
    };
    if (colGroupDef) {
      tooltipCtrl.getColDef = () => colGroupDef;
    }
    const tooltipFeature = this.createManagedBean(new TooltipFeature(tooltipCtrl, this.beans));
    tooltipFeature.setComp(this.comp);
  }
  setupExpandable() {
    const providedColGroup = this.columnGroup.getProvidedColumnGroup();
    this.refreshExpanded();
    this.addManagedListener(providedColGroup, ProvidedColumnGroup.EVENT_EXPANDABLE_CHANGED, this.refreshExpanded.bind(this));
    this.addManagedListener(providedColGroup, ProvidedColumnGroup.EVENT_EXPANDED_CHANGED, this.refreshExpanded.bind(this));
  }
  refreshExpanded() {
    const column = this.columnGroup;
    this.expandable = column.isExpandable();
    const expanded = column.isExpanded();
    if (this.expandable) {
      this.comp.setAriaExpanded(expanded ? "true" : "false");
    } else {
      this.comp.setAriaExpanded(void 0);
    }
  }
  addAttributes() {
    this.comp.setColId(this.columnGroup.getUniqueId());
  }
  addClasses() {
    const colGroupDef = this.columnGroup.getColGroupDef();
    const classes = CssClassApplier.getHeaderClassesFromColDef(colGroupDef, this.gridOptionsService, null, this.columnGroup);
    if (this.columnGroup.isPadding()) {
      classes.push("ag-header-group-cell-no-group");
      const leafCols = this.columnGroup.getLeafColumns();
      if (leafCols.every((col) => col.isSpanHeaderHeight())) {
        classes.push("ag-header-span-height");
      }
    } else {
      classes.push("ag-header-group-cell-with-group");
    }
    classes.forEach((c) => this.comp.addOrRemoveCssClass(c, true));
  }
  setupMovingCss() {
    const providedColumnGroup = this.columnGroup.getProvidedColumnGroup();
    const leafColumns = providedColumnGroup.getLeafColumns();
    const listener = () => this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.columnGroup.isMoving());
    leafColumns.forEach((col) => {
      this.addManagedListener(col, Column.EVENT_MOVING_CHANGED, listener);
    });
    listener();
  }
  onFocusIn(e) {
    if (!this.eGui.contains(e.relatedTarget)) {
      const rowIndex = this.getRowIndex();
      this.beans.focusService.setFocusedHeader(rowIndex, this.columnGroup);
    }
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const wrapperHasFocus = this.getWrapperHasFocus();
    if (!this.expandable || !wrapperHasFocus) {
      return;
    }
    if (e.key === KeyCode.ENTER) {
      const column = this.columnGroup;
      const newExpandedValue = !column.isExpanded();
      this.columnModel.setColumnGroupOpened(column.getProvidedColumnGroup(), newExpandedValue, "uiColumnExpanded");
    }
  }
  setDragSource(eHeaderGroup) {
    if (this.isSuppressMoving()) {
      return;
    }
    const allLeafColumns = this.columnGroup.getProvidedColumnGroup().getLeafColumns();
    const hideColumnOnExit = !this.gridOptionsService.is("suppressDragLeaveHidesColumns");
    const dragSource = {
      type: DragSourceType.HeaderCell,
      eElement: eHeaderGroup,
      defaultIconName: hideColumnOnExit ? DragAndDropService.ICON_HIDE : DragAndDropService.ICON_NOT_ALLOWED,
      dragItemName: this.displayName,
      getDragItem: this.getDragItemForGroup.bind(this),
      onDragStarted: () => allLeafColumns.forEach((col) => col.setMoving(true, "uiColumnDragged")),
      onDragStopped: () => allLeafColumns.forEach((col) => col.setMoving(false, "uiColumnDragged")),
      onGridEnter: (dragItem) => {
        var _a;
        if (hideColumnOnExit) {
          const unlockedColumns = ((_a = dragItem === null || dragItem === void 0 ? void 0 : dragItem.columns) === null || _a === void 0 ? void 0 : _a.filter((col) => !col.getColDef().lockVisible)) || [];
          this.columnModel.setColumnsVisible(unlockedColumns, true, "uiColumnMoved");
        }
      },
      onGridExit: (dragItem) => {
        var _a;
        if (hideColumnOnExit) {
          const unlockedColumns = ((_a = dragItem === null || dragItem === void 0 ? void 0 : dragItem.columns) === null || _a === void 0 ? void 0 : _a.filter((col) => !col.getColDef().lockVisible)) || [];
          this.columnModel.setColumnsVisible(unlockedColumns, false, "uiColumnMoved");
        }
      }
    };
    this.dragAndDropService.addDragSource(dragSource, true);
    this.addDestroyFunc(() => this.dragAndDropService.removeDragSource(dragSource));
  }
  getDragItemForGroup() {
    const allColumnsOriginalOrder = this.columnGroup.getProvidedColumnGroup().getLeafColumns();
    const visibleState = {};
    allColumnsOriginalOrder.forEach((column) => visibleState[column.getId()] = column.isVisible());
    const allColumnsCurrentOrder = [];
    this.columnModel.getAllDisplayedColumns().forEach((column) => {
      if (allColumnsOriginalOrder.indexOf(column) >= 0) {
        allColumnsCurrentOrder.push(column);
        removeFromArray(allColumnsOriginalOrder, column);
      }
    });
    allColumnsOriginalOrder.forEach((column) => allColumnsCurrentOrder.push(column));
    return {
      columns: allColumnsCurrentOrder,
      visibleState
    };
  }
  isSuppressMoving() {
    let childSuppressesMoving = false;
    this.columnGroup.getLeafColumns().forEach((column) => {
      if (column.getColDef().suppressMovable || column.getColDef().lockPosition) {
        childSuppressesMoving = true;
      }
    });
    const result = childSuppressesMoving || this.gridOptionsService.is("suppressMovableColumns");
    return result;
  }
};
__decorate$1j([
  Autowired("columnModel")
], HeaderGroupCellCtrl.prototype, "columnModel", void 0);
__decorate$1j([
  Autowired("dragAndDropService")
], HeaderGroupCellCtrl.prototype, "dragAndDropService", void 0);
__decorate$1j([
  Autowired("gridApi")
], HeaderGroupCellCtrl.prototype, "gridApi", void 0);
__decorate$1j([
  Autowired("columnApi")
], HeaderGroupCellCtrl.prototype, "columnApi", void 0);
var __decorate$1i = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var instanceIdSequence = 0;
var HeaderRowCtrl = class extends BeanStub {
  constructor(rowIndex, pinned, type) {
    super();
    this.instanceId = instanceIdSequence++;
    this.headerCellCtrls = {};
    this.rowIndex = rowIndex;
    this.pinned = pinned;
    this.type = type;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setComp(comp) {
    this.comp = comp;
    this.onRowHeightChanged();
    this.onVirtualColumnsChanged();
    this.setWidth();
    this.addEventListeners();
    if (isBrowserSafari()) {
      this.comp.setTransform("translateZ(0)");
    }
    comp.setAriaRowIndex(this.rowIndex + 1);
  }
  addEventListeners() {
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_RESIZED, this.onColumnResized.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HEADER_HEIGHT_CHANGED, this.onRowHeightChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_GRID_STYLES_CHANGED, this.onRowHeightChanged.bind(this));
    this.addManagedPropertyListener("domLayout", this.onDisplayedColumnsChanged.bind(this));
    this.addManagedPropertyListener("headerHeight", this.onRowHeightChanged.bind(this));
    this.addManagedPropertyListener("pivotHeaderHeight", this.onRowHeightChanged.bind(this));
    this.addManagedPropertyListener("groupHeaderHeight", this.onRowHeightChanged.bind(this));
    this.addManagedPropertyListener("pivotGroupHeaderHeight", this.onRowHeightChanged.bind(this));
    this.addManagedPropertyListener("floatingFiltersHeight", this.onRowHeightChanged.bind(this));
  }
  getHeaderCellCtrl(column) {
    return values(this.headerCellCtrls).find((cellCtrl) => cellCtrl.getColumnGroupChild() === column);
  }
  onDisplayedColumnsChanged() {
    this.onVirtualColumnsChanged();
    this.setWidth();
    this.onRowHeightChanged();
  }
  getType() {
    return this.type;
  }
  onColumnResized() {
    this.setWidth();
  }
  setWidth() {
    const width = this.getWidthForRow();
    this.comp.setWidth(`${width}px`);
  }
  getWidthForRow() {
    const printLayout = this.gridOptionsService.isDomLayout("print");
    if (printLayout) {
      const pinned = this.pinned != null;
      if (pinned) {
        return 0;
      }
      return this.columnModel.getContainerWidth("right") + this.columnModel.getContainerWidth("left") + this.columnModel.getContainerWidth(null);
    }
    return this.columnModel.getContainerWidth(this.pinned);
  }
  onRowHeightChanged() {
    let headerRowCount = this.columnModel.getHeaderRowCount();
    const sizes = [];
    let numberOfFloating = 0;
    if (this.columnModel.hasFloatingFilters()) {
      headerRowCount++;
      numberOfFloating = 1;
    }
    const groupHeight = this.columnModel.getColumnGroupHeaderRowHeight();
    const headerHeight = this.columnModel.getColumnHeaderRowHeight();
    const numberOfNonGroups = 1 + numberOfFloating;
    const numberOfGroups = headerRowCount - numberOfNonGroups;
    for (let i = 0; i < numberOfGroups; i++) {
      sizes.push(groupHeight);
    }
    sizes.push(headerHeight);
    for (let i = 0; i < numberOfFloating; i++) {
      sizes.push(this.columnModel.getFloatingFiltersHeight());
    }
    let topOffset = 0;
    for (let i = 0; i < this.rowIndex; i++) {
      topOffset += sizes[i];
    }
    const thisRowHeight = sizes[this.rowIndex] + "px";
    this.comp.setTop(topOffset + "px");
    this.comp.setHeight(thisRowHeight);
  }
  getPinned() {
    return this.pinned;
  }
  getRowIndex() {
    return this.rowIndex;
  }
  onVirtualColumnsChanged() {
    const oldCtrls = this.headerCellCtrls;
    this.headerCellCtrls = {};
    const columns = this.getColumnsInViewport();
    columns.forEach((child) => {
      if (child.isEmptyGroup()) {
        return;
      }
      const idOfChild = child.getUniqueId();
      let headerCtrl = oldCtrls[idOfChild];
      delete oldCtrls[idOfChild];
      const forOldColumn = headerCtrl && headerCtrl.getColumnGroupChild() != child;
      if (forOldColumn) {
        this.destroyBean(headerCtrl);
        headerCtrl = void 0;
      }
      if (headerCtrl == null) {
        switch (this.type) {
          case HeaderRowType.FLOATING_FILTER:
            headerCtrl = this.createBean(new HeaderFilterCellCtrl(child, this));
            break;
          case HeaderRowType.COLUMN_GROUP:
            headerCtrl = this.createBean(new HeaderGroupCellCtrl(child, this));
            break;
          default:
            headerCtrl = this.createBean(new HeaderCellCtrl(child, this));
            break;
        }
      }
      this.headerCellCtrls[idOfChild] = headerCtrl;
    });
    const isFocusedAndDisplayed = (ctrl) => {
      const isFocused = this.focusService.isHeaderWrapperFocused(ctrl);
      if (!isFocused) {
        return false;
      }
      const isDisplayed = this.columnModel.isDisplayed(ctrl.getColumnGroupChild());
      return isDisplayed;
    };
    iterateObject(oldCtrls, (id, oldCtrl) => {
      const keepCtrl = isFocusedAndDisplayed(oldCtrl);
      if (keepCtrl) {
        this.headerCellCtrls[id] = oldCtrl;
      } else {
        this.destroyBean(oldCtrl);
      }
    });
    const ctrlsToDisplay = getAllValuesInObject(this.headerCellCtrls);
    this.comp.setHeaderCtrls(ctrlsToDisplay);
  }
  getColumnsInViewport() {
    const printLayout = this.gridOptionsService.isDomLayout("print");
    return printLayout ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
  }
  getColumnsInViewportPrintLayout() {
    if (this.pinned != null) {
      return [];
    }
    let viewportColumns = [];
    const actualDepth = this.getActualDepth();
    ["left", null, "right"].forEach((pinned) => {
      const items = this.columnModel.getVirtualHeaderGroupRow(pinned, actualDepth);
      viewportColumns = viewportColumns.concat(items);
    });
    return viewportColumns;
  }
  getActualDepth() {
    return this.type == HeaderRowType.FLOATING_FILTER ? this.rowIndex - 1 : this.rowIndex;
  }
  getColumnsInViewportNormalLayout() {
    return this.columnModel.getVirtualHeaderGroupRow(this.pinned, this.getActualDepth());
  }
  focusHeader(column, event) {
    const allCtrls = getAllValuesInObject(this.headerCellCtrls);
    const ctrl = allCtrls.find((ctrl2) => ctrl2.getColumnGroupChild() == column);
    if (!ctrl) {
      return false;
    }
    ctrl.focus(event);
    return true;
  }
  destroy() {
    iterateObject(this.headerCellCtrls, (key, ctrl) => {
      this.destroyBean(ctrl);
    });
    this.headerCellCtrls = {};
    super.destroy();
  }
};
__decorate$1i([
  Autowired("columnModel")
], HeaderRowCtrl.prototype, "columnModel", void 0);
__decorate$1i([
  Autowired("focusService")
], HeaderRowCtrl.prototype, "focusService", void 0);
var __decorate$1h = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HeaderRowContainerCtrl = class extends BeanStub {
  constructor(pinned) {
    super();
    this.hidden = false;
    this.includeFloatingFilter = false;
    this.groupsRowCtrls = [];
    this.pinned = pinned;
  }
  setComp(comp, eGui) {
    this.comp = comp;
    this.eViewport = eGui;
    this.setupCenterWidth();
    this.setupPinnedWidth();
    this.setupDragAndDrop(this.eViewport);
    this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
    this.ctrlsService.registerHeaderContainer(this, this.pinned);
    if (this.columnModel.isReady()) {
      this.refresh();
    }
  }
  setupDragAndDrop(dropContainer) {
    const bodyDropTarget = new BodyDropTarget(this.pinned, dropContainer);
    this.createManagedBean(bodyDropTarget);
  }
  refresh(keepColumns = false) {
    const sequence = new NumberSequence();
    const focusedHeaderPosition = this.focusService.getFocusHeaderToUseAfterRefresh();
    const refreshColumnGroups = () => {
      const groupRowCount = this.columnModel.getHeaderRowCount() - 1;
      this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
      for (let i = 0; i < groupRowCount; i++) {
        const ctrl = this.createBean(new HeaderRowCtrl(sequence.next(), this.pinned, HeaderRowType.COLUMN_GROUP));
        this.groupsRowCtrls.push(ctrl);
      }
    };
    const refreshColumns = () => {
      const rowIndex = sequence.next();
      const needNewInstance = !this.hidden && (this.columnsRowCtrl == null || !keepColumns || this.columnsRowCtrl.getRowIndex() !== rowIndex);
      const shouldDestroyInstance = needNewInstance || this.hidden;
      if (shouldDestroyInstance) {
        this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
      }
      if (needNewInstance) {
        this.columnsRowCtrl = this.createBean(new HeaderRowCtrl(rowIndex, this.pinned, HeaderRowType.COLUMN));
      }
    };
    const refreshFilters = () => {
      this.includeFloatingFilter = this.columnModel.hasFloatingFilters() && !this.hidden;
      const destroyPreviousComp = () => {
        this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
      };
      if (!this.includeFloatingFilter) {
        destroyPreviousComp();
        return;
      }
      const rowIndex = sequence.next();
      if (this.filtersRowCtrl) {
        const rowIndexMismatch = this.filtersRowCtrl.getRowIndex() !== rowIndex;
        if (!keepColumns || rowIndexMismatch) {
          destroyPreviousComp();
        }
      }
      if (!this.filtersRowCtrl) {
        this.filtersRowCtrl = this.createBean(new HeaderRowCtrl(rowIndex, this.pinned, HeaderRowType.FLOATING_FILTER));
      }
    };
    refreshColumnGroups();
    refreshColumns();
    refreshFilters();
    const allCtrls = this.getAllCtrls();
    this.comp.setCtrls(allCtrls);
    this.restoreFocusOnHeader(focusedHeaderPosition);
  }
  restoreFocusOnHeader(position) {
    if (position == null || position.column.getPinned() != this.pinned) {
      return;
    }
    this.focusService.focusHeaderPosition({ headerPosition: position });
  }
  getAllCtrls() {
    const res = [...this.groupsRowCtrls];
    if (this.columnsRowCtrl) {
      res.push(this.columnsRowCtrl);
    }
    if (this.filtersRowCtrl) {
      res.push(this.filtersRowCtrl);
    }
    return res;
  }
  onGridColumnsChanged() {
    this.refresh(true);
  }
  onDisplayedColumnsChanged() {
    const includeFloatingFilter = this.columnModel.hasFloatingFilters() && !this.hidden;
    if (this.includeFloatingFilter !== includeFloatingFilter) {
      this.refresh(true);
    }
  }
  setupCenterWidth() {
    if (this.pinned != null) {
      return;
    }
    this.createManagedBean(new CenterWidthFeature((width) => this.comp.setCenterWidth(`${width}px`), true));
  }
  setHorizontalScroll(offset) {
    this.comp.setViewportScrollLeft(offset);
  }
  setupPinnedWidth() {
    if (this.pinned == null) {
      return;
    }
    const pinningLeft = this.pinned === "left";
    const pinningRight = this.pinned === "right";
    this.hidden = true;
    const listener = () => {
      const width = pinningLeft ? this.pinnedWidthService.getPinnedLeftWidth() : this.pinnedWidthService.getPinnedRightWidth();
      if (width == null) {
        return;
      }
      const hidden = width == 0;
      const hiddenChanged = this.hidden !== hidden;
      const isRtl = this.gridOptionsService.is("enableRtl");
      const scrollbarWidth = this.gridOptionsService.getScrollbarWidth();
      const addPaddingForScrollbar = this.scrollVisibleService.isVerticalScrollShowing() && (isRtl && pinningLeft || !isRtl && pinningRight);
      const widthWithPadding = addPaddingForScrollbar ? width + scrollbarWidth : width;
      this.comp.setPinnedContainerWidth(`${widthWithPadding}px`);
      this.comp.setDisplayed(!hidden);
      if (hiddenChanged) {
        this.hidden = hidden;
        this.refresh();
      }
    };
    this.addManagedListener(this.eventService, Events.EVENT_LEFT_PINNED_WIDTH_CHANGED, listener);
    this.addManagedListener(this.eventService, Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED, listener);
    this.addManagedListener(this.eventService, Events.EVENT_SCROLL_VISIBILITY_CHANGED, listener);
    this.addManagedListener(this.eventService, Events.EVENT_SCROLLBAR_WIDTH_CHANGED, listener);
  }
  getHeaderCtrlForColumn(column) {
    if (column instanceof Column) {
      if (!this.columnsRowCtrl) {
        return;
      }
      return this.columnsRowCtrl.getHeaderCellCtrl(column);
    }
    if (this.groupsRowCtrls.length === 0) {
      return;
    }
    for (let i = 0; i < this.groupsRowCtrls.length; i++) {
      const ctrl = this.groupsRowCtrls[i].getHeaderCellCtrl(column);
      if (ctrl) {
        return ctrl;
      }
    }
  }
  getHtmlElementForColumnHeader(column) {
    const cellCtrl = this.getHeaderCtrlForColumn(column);
    if (!cellCtrl) {
      return null;
    }
    return cellCtrl.getGui();
  }
  getRowType(rowIndex) {
    const allCtrls = this.getAllCtrls();
    const ctrl = allCtrls[rowIndex];
    return ctrl ? ctrl.getType() : void 0;
  }
  focusHeader(rowIndex, column, event) {
    const allCtrls = this.getAllCtrls();
    const ctrl = allCtrls[rowIndex];
    if (!ctrl) {
      return false;
    }
    return ctrl.focusHeader(column, event);
  }
  getRowCount() {
    return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
  }
  destroy() {
    if (this.filtersRowCtrl) {
      this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
    }
    if (this.columnsRowCtrl) {
      this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
    }
    if (this.groupsRowCtrls && this.groupsRowCtrls.length) {
      this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
    }
    super.destroy();
  }
};
__decorate$1h([
  Autowired("ctrlsService")
], HeaderRowContainerCtrl.prototype, "ctrlsService", void 0);
__decorate$1h([
  Autowired("scrollVisibleService")
], HeaderRowContainerCtrl.prototype, "scrollVisibleService", void 0);
__decorate$1h([
  Autowired("pinnedWidthService")
], HeaderRowContainerCtrl.prototype, "pinnedWidthService", void 0);
__decorate$1h([
  Autowired("columnModel")
], HeaderRowContainerCtrl.prototype, "columnModel", void 0);
__decorate$1h([
  Autowired("focusService")
], HeaderRowContainerCtrl.prototype, "focusService", void 0);
var __decorate$1g = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HeaderRowContainerComp = class extends Component {
  constructor(pinned) {
    super();
    this.headerRowComps = {};
    this.rowCompsList = [];
    this.pinned = pinned;
  }
  init() {
    this.selectAndSetTemplate();
    const compProxy = {
      setDisplayed: (displayed) => this.setDisplayed(displayed),
      setCtrls: (ctrls) => this.setCtrls(ctrls),
      setCenterWidth: (width) => this.eCenterContainer.style.width = width,
      setViewportScrollLeft: (left) => this.getGui().scrollLeft = left,
      setPinnedContainerWidth: (width) => {
        const eGui = this.getGui();
        eGui.style.width = width;
        eGui.style.maxWidth = width;
        eGui.style.minWidth = width;
      }
    };
    const ctrl = this.createManagedBean(new HeaderRowContainerCtrl(this.pinned));
    ctrl.setComp(compProxy, this.getGui());
  }
  selectAndSetTemplate() {
    const pinnedLeft = this.pinned == "left";
    const pinnedRight = this.pinned == "right";
    const template = pinnedLeft ? HeaderRowContainerComp.PINNED_LEFT_TEMPLATE : pinnedRight ? HeaderRowContainerComp.PINNED_RIGHT_TEMPLATE : HeaderRowContainerComp.CENTER_TEMPLATE;
    this.setTemplate(template);
    this.eRowContainer = this.eCenterContainer ? this.eCenterContainer : this.getGui();
  }
  destroyRowComps() {
    this.setCtrls([]);
  }
  destroyRowComp(rowComp) {
    this.destroyBean(rowComp);
    this.eRowContainer.removeChild(rowComp.getGui());
  }
  setCtrls(ctrls) {
    const oldRowComps = this.headerRowComps;
    this.headerRowComps = {};
    this.rowCompsList = [];
    let prevGui;
    const appendEnsuringDomOrder = (rowComp) => {
      const eGui = rowComp.getGui();
      const notAlreadyIn = eGui.parentElement != this.eRowContainer;
      if (notAlreadyIn) {
        this.eRowContainer.appendChild(eGui);
      }
      if (prevGui) {
        ensureDomOrder(this.eRowContainer, eGui, prevGui);
      }
      prevGui = eGui;
    };
    ctrls.forEach((ctrl) => {
      const ctrlId = ctrl.getInstanceId();
      const existingComp = oldRowComps[ctrlId];
      delete oldRowComps[ctrlId];
      const rowComp = existingComp ? existingComp : this.createBean(new HeaderRowComp(ctrl));
      this.headerRowComps[ctrlId] = rowComp;
      this.rowCompsList.push(rowComp);
      appendEnsuringDomOrder(rowComp);
    });
    getAllValuesInObject(oldRowComps).forEach((c) => this.destroyRowComp(c));
  }
};
HeaderRowContainerComp.PINNED_LEFT_TEMPLATE = `<div class="ag-pinned-left-header" role="presentation"></div>`;
HeaderRowContainerComp.PINNED_RIGHT_TEMPLATE = `<div class="ag-pinned-right-header" role="presentation"></div>`;
HeaderRowContainerComp.CENTER_TEMPLATE = `<div class="ag-header-viewport" role="presentation">
            <div class="ag-header-container" ref="eCenterContainer" role="rowgroup"></div>
        </div>`;
__decorate$1g([
  RefSelector("eCenterContainer")
], HeaderRowContainerComp.prototype, "eCenterContainer", void 0);
__decorate$1g([
  PostConstruct
], HeaderRowContainerComp.prototype, "init", null);
__decorate$1g([
  PreDestroy
], HeaderRowContainerComp.prototype, "destroyRowComps", null);
var __decorate$1f = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HeaderNavigationDirection;
(function(HeaderNavigationDirection2) {
  HeaderNavigationDirection2[HeaderNavigationDirection2["UP"] = 0] = "UP";
  HeaderNavigationDirection2[HeaderNavigationDirection2["DOWN"] = 1] = "DOWN";
  HeaderNavigationDirection2[HeaderNavigationDirection2["LEFT"] = 2] = "LEFT";
  HeaderNavigationDirection2[HeaderNavigationDirection2["RIGHT"] = 3] = "RIGHT";
})(HeaderNavigationDirection || (HeaderNavigationDirection = {}));
var HeaderNavigationService = class HeaderNavigationService2 extends BeanStub {
  postConstruct() {
    this.ctrlsService.whenReady((p) => {
      this.gridBodyCon = p.gridBodyCtrl;
    });
  }
  getHeaderRowCount() {
    const centerHeaderContainer = this.ctrlsService.getHeaderRowContainerCtrl();
    return centerHeaderContainer ? centerHeaderContainer.getRowCount() : 0;
  }
  navigateVertically(direction, fromHeader, event) {
    if (!fromHeader) {
      fromHeader = this.focusService.getFocusedHeader();
    }
    if (!fromHeader) {
      return false;
    }
    const { headerRowIndex, column } = fromHeader;
    const rowLen = this.getHeaderRowCount();
    const isUp = direction === HeaderNavigationDirection.UP;
    let { nextRow, nextFocusColumn } = isUp ? this.headerPositionUtils.getColumnVisibleParent(column, headerRowIndex) : this.headerPositionUtils.getColumnVisibleChild(column, headerRowIndex);
    let skipColumn = false;
    if (nextRow < 0) {
      nextRow = 0;
      nextFocusColumn = column;
      skipColumn = true;
    }
    if (nextRow >= rowLen) {
      nextRow = -1;
    }
    if (!skipColumn && !nextFocusColumn) {
      return false;
    }
    return this.focusService.focusHeaderPosition({
      headerPosition: { headerRowIndex: nextRow, column: nextFocusColumn },
      allowUserOverride: true,
      event
    });
  }
  navigateHorizontally(direction, fromTab = false, event) {
    const focusedHeader = this.focusService.getFocusedHeader();
    const isLeft = direction === HeaderNavigationDirection.LEFT;
    const isRtl = this.gridOptionsService.is("enableRtl");
    let nextHeader;
    let normalisedDirection;
    if (isLeft !== isRtl) {
      normalisedDirection = "Before";
      nextHeader = this.headerPositionUtils.findHeader(focusedHeader, normalisedDirection);
    } else {
      normalisedDirection = "After";
      nextHeader = this.headerPositionUtils.findHeader(focusedHeader, normalisedDirection);
    }
    if (nextHeader || !fromTab) {
      return this.focusService.focusHeaderPosition({
        headerPosition: nextHeader,
        direction: normalisedDirection,
        fromTab,
        allowUserOverride: true,
        event
      });
    }
    return this.focusNextHeaderRow(focusedHeader, normalisedDirection, event);
  }
  focusNextHeaderRow(focusedHeader, direction, event) {
    const currentIndex = focusedHeader.headerRowIndex;
    let nextPosition = null;
    let nextRowIndex;
    if (direction === "Before") {
      if (currentIndex > 0) {
        nextRowIndex = currentIndex - 1;
        nextPosition = this.headerPositionUtils.findColAtEdgeForHeaderRow(nextRowIndex, "end");
      }
    } else {
      nextRowIndex = currentIndex + 1;
      nextPosition = this.headerPositionUtils.findColAtEdgeForHeaderRow(nextRowIndex, "start");
    }
    return this.focusService.focusHeaderPosition({
      headerPosition: nextPosition,
      direction,
      fromTab: true,
      allowUserOverride: true,
      event
    });
  }
  scrollToColumn(column, direction = "After") {
    if (column.getPinned()) {
      return;
    }
    let columnToScrollTo;
    if (column instanceof ColumnGroup) {
      const columns = column.getDisplayedLeafColumns();
      columnToScrollTo = direction === "Before" ? last(columns) : columns[0];
    } else {
      columnToScrollTo = column;
    }
    this.gridBodyCon.getScrollFeature().ensureColumnVisible(columnToScrollTo);
  }
};
__decorate$1f([
  Autowired("focusService")
], HeaderNavigationService.prototype, "focusService", void 0);
__decorate$1f([
  Autowired("headerPositionUtils")
], HeaderNavigationService.prototype, "headerPositionUtils", void 0);
__decorate$1f([
  Autowired("ctrlsService")
], HeaderNavigationService.prototype, "ctrlsService", void 0);
__decorate$1f([
  PostConstruct
], HeaderNavigationService.prototype, "postConstruct", null);
HeaderNavigationService = __decorate$1f([
  Bean("headerNavigationService")
], HeaderNavigationService);
var __decorate$1e = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GridHeaderCtrl = class extends BeanStub {
  setComp(comp, eGui, eFocusableElement) {
    this.comp = comp;
    this.eGui = eGui;
    this.createManagedBean(new ManagedFocusFeature(eFocusableElement, {
      onTabKeyDown: this.onTabKeyDown.bind(this),
      handleKeyDown: this.handleKeyDown.bind(this),
      onFocusOut: this.onFocusOut.bind(this)
    }));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onPivotModeChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
    this.onPivotModeChanged();
    this.setupHeaderHeight();
    this.ctrlsService.registerGridHeaderCtrl(this);
  }
  setupHeaderHeight() {
    const listener = this.setHeaderHeight.bind(this);
    listener();
    this.addManagedPropertyListener("headerHeight", listener);
    this.addManagedPropertyListener("pivotHeaderHeight", listener);
    this.addManagedPropertyListener("groupHeaderHeight", listener);
    this.addManagedPropertyListener("pivotGroupHeaderHeight", listener);
    this.addManagedPropertyListener("floatingFiltersHeight", listener);
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, listener);
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HEADER_HEIGHT_CHANGED, listener);
    this.addManagedListener(this.eventService, Events.EVENT_GRID_STYLES_CHANGED, listener);
  }
  getHeaderHeight() {
    return this.headerHeight;
  }
  setHeaderHeight() {
    const { columnModel } = this;
    let numberOfFloating = 0;
    let headerRowCount = columnModel.getHeaderRowCount();
    let totalHeaderHeight;
    const hasFloatingFilters = columnModel.hasFloatingFilters();
    if (hasFloatingFilters) {
      headerRowCount++;
      numberOfFloating = 1;
    }
    const groupHeight = this.columnModel.getColumnGroupHeaderRowHeight();
    const headerHeight = this.columnModel.getColumnHeaderRowHeight();
    const numberOfNonGroups = 1 + numberOfFloating;
    const numberOfGroups = headerRowCount - numberOfNonGroups;
    totalHeaderHeight = numberOfFloating * columnModel.getFloatingFiltersHeight();
    totalHeaderHeight += numberOfGroups * groupHeight;
    totalHeaderHeight += headerHeight;
    if (this.headerHeight === totalHeaderHeight) {
      return;
    }
    this.headerHeight = totalHeaderHeight;
    const px = `${totalHeaderHeight + 1}px`;
    this.comp.setHeightAndMinHeight(px);
    this.eventService.dispatchEvent({
      type: Events.EVENT_HEADER_HEIGHT_CHANGED
    });
  }
  onPivotModeChanged() {
    const pivotMode = this.columnModel.isPivotMode();
    this.comp.addOrRemoveCssClass("ag-pivot-on", pivotMode);
    this.comp.addOrRemoveCssClass("ag-pivot-off", !pivotMode);
  }
  onDisplayedColumnsChanged() {
    const columns = this.columnModel.getAllDisplayedColumns();
    const shouldAllowOverflow = columns.some((col) => col.isSpanHeaderHeight());
    this.comp.addOrRemoveCssClass("ag-header-allow-overflow", shouldAllowOverflow);
  }
  onTabKeyDown(e) {
    const isRtl = this.gridOptionsService.is("enableRtl");
    const direction = e.shiftKey !== isRtl ? HeaderNavigationDirection.LEFT : HeaderNavigationDirection.RIGHT;
    if (this.headerNavigationService.navigateHorizontally(direction, true, e) || this.focusService.focusNextGridCoreContainer(e.shiftKey)) {
      e.preventDefault();
    }
  }
  handleKeyDown(e) {
    let direction = null;
    switch (e.key) {
      case KeyCode.LEFT:
        direction = HeaderNavigationDirection.LEFT;
      case KeyCode.RIGHT:
        if (!exists(direction)) {
          direction = HeaderNavigationDirection.RIGHT;
        }
        this.headerNavigationService.navigateHorizontally(direction, false, e);
        break;
      case KeyCode.UP:
        direction = HeaderNavigationDirection.UP;
      case KeyCode.DOWN:
        if (!exists(direction)) {
          direction = HeaderNavigationDirection.DOWN;
        }
        if (this.headerNavigationService.navigateVertically(direction, null, e)) {
          e.preventDefault();
        }
        break;
      default:
        return;
    }
  }
  onFocusOut(e) {
    const eDocument = this.gridOptionsService.getDocument();
    const { relatedTarget } = e;
    if (!relatedTarget && this.eGui.contains(eDocument.activeElement)) {
      return;
    }
    if (!this.eGui.contains(relatedTarget)) {
      this.focusService.clearFocusedHeader();
    }
  }
};
__decorate$1e([
  Autowired("headerNavigationService")
], GridHeaderCtrl.prototype, "headerNavigationService", void 0);
__decorate$1e([
  Autowired("focusService")
], GridHeaderCtrl.prototype, "focusService", void 0);
__decorate$1e([
  Autowired("columnModel")
], GridHeaderCtrl.prototype, "columnModel", void 0);
__decorate$1e([
  Autowired("ctrlsService")
], GridHeaderCtrl.prototype, "ctrlsService", void 0);
var __decorate$1d = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GridHeaderComp = class extends Component {
  constructor() {
    super(GridHeaderComp.TEMPLATE);
  }
  postConstruct() {
    const compProxy = {
      addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
      setHeightAndMinHeight: (height) => {
        this.getGui().style.height = height;
        this.getGui().style.minHeight = height;
      }
    };
    const ctrl = this.createManagedBean(new GridHeaderCtrl());
    ctrl.setComp(compProxy, this.getGui(), this.getFocusableElement());
    const addContainer = (container) => {
      this.createManagedBean(container);
      this.appendChild(container);
    };
    addContainer(new HeaderRowContainerComp("left"));
    addContainer(new HeaderRowContainerComp(null));
    addContainer(new HeaderRowContainerComp("right"));
  }
};
GridHeaderComp.TEMPLATE = `<div class="ag-header" role="presentation"/>`;
__decorate$1d([
  PostConstruct
], GridHeaderComp.prototype, "postConstruct", null);
var __decorate$1c = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HorizontalResizeService = class HorizontalResizeService2 extends BeanStub {
  addResizeBar(params) {
    const dragSource = {
      dragStartPixels: params.dragStartPixels || 0,
      eElement: params.eResizeBar,
      onDragStart: this.onDragStart.bind(this, params),
      onDragStop: this.onDragStop.bind(this, params),
      onDragging: this.onDragging.bind(this, params)
    };
    this.dragService.addDragSource(dragSource, true);
    const finishedWithResizeFunc = () => this.dragService.removeDragSource(dragSource);
    return finishedWithResizeFunc;
  }
  onDragStart(params, mouseEvent) {
    this.dragStartX = mouseEvent.clientX;
    this.setResizeIcons();
    const shiftKey = mouseEvent instanceof MouseEvent && mouseEvent.shiftKey === true;
    params.onResizeStart(shiftKey);
  }
  setResizeIcons() {
    const ctrl = this.ctrlsService.getGridCtrl();
    ctrl.setResizeCursor(true);
    ctrl.disableUserSelect(true);
  }
  onDragStop(params, mouseEvent) {
    params.onResizeEnd(this.resizeAmount);
    this.resetIcons();
  }
  resetIcons() {
    const ctrl = this.ctrlsService.getGridCtrl();
    ctrl.setResizeCursor(false);
    ctrl.disableUserSelect(false);
  }
  onDragging(params, mouseEvent) {
    this.resizeAmount = mouseEvent.clientX - this.dragStartX;
    params.onResizing(this.resizeAmount);
  }
};
__decorate$1c([
  Autowired("dragService")
], HorizontalResizeService.prototype, "dragService", void 0);
__decorate$1c([
  Autowired("ctrlsService")
], HorizontalResizeService.prototype, "ctrlsService", void 0);
HorizontalResizeService = __decorate$1c([
  Bean("horizontalResizeService")
], HorizontalResizeService);
var __decorate$1b = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var StandardMenuFactory = class StandardMenuFactory2 extends BeanStub {
  hideActiveMenu() {
    if (this.hidePopup) {
      this.hidePopup();
    }
  }
  showMenuAfterMouseEvent(column, mouseEvent) {
    this.showPopup(column, (eMenu) => {
      this.popupService.positionPopupUnderMouseEvent({
        column,
        type: "columnMenu",
        mouseEvent,
        ePopup: eMenu
      });
    }, "columnMenu", mouseEvent.target);
  }
  showMenuAfterButtonClick(column, eventSource, containerType) {
    this.showPopup(column, (eMenu) => {
      this.popupService.positionPopupByComponent({
        type: containerType,
        eventSource,
        ePopup: eMenu,
        keepWithinBounds: true,
        position: "under",
        column
      });
    }, containerType, eventSource);
  }
  showPopup(column, positionCallback, containerType, eventSource) {
    const filterWrapper = this.filterManager.getOrCreateFilterWrapper(column, "COLUMN_MENU");
    if (!filterWrapper) {
      throw new Error("AG Grid - unable to show popup filter, filter instantiation failed");
    }
    const eMenu = document.createElement("div");
    setAriaRole(eMenu, "presentation");
    eMenu.classList.add("ag-menu");
    this.tabListener = this.addManagedListener(eMenu, "keydown", (e) => this.trapFocusWithin(e, eMenu));
    filterWrapper.guiPromise.then((gui) => eMenu.appendChild(gui));
    let hidePopup;
    const afterGuiDetached = () => {
      var _a;
      return (_a = filterWrapper.filterPromise) === null || _a === void 0 ? void 0 : _a.then((filter) => {
        var _a2;
        return (_a2 = filter === null || filter === void 0 ? void 0 : filter.afterGuiDetached) === null || _a2 === void 0 ? void 0 : _a2.call(filter);
      });
    };
    const anchorToElement = eventSource || this.ctrlsService.getGridBodyCtrl().getGui();
    const closedCallback = (e) => {
      column.setMenuVisible(false, "contextMenu");
      const isKeyboardEvent = e instanceof KeyboardEvent;
      if (this.tabListener) {
        this.tabListener = this.tabListener();
      }
      if (isKeyboardEvent && eventSource && isVisible(eventSource)) {
        const focusableEl = this.focusService.findTabbableParent(eventSource);
        if (focusableEl) {
          focusableEl.focus();
        }
      }
      afterGuiDetached();
    };
    const translate = this.localeService.getLocaleTextFunc();
    const addPopupRes = this.popupService.addPopup({
      modal: true,
      eChild: eMenu,
      closeOnEsc: true,
      closedCallback,
      positionCallback: () => positionCallback(eMenu),
      anchorToElement,
      ariaLabel: translate("ariaLabelColumnMenu", "Column Menu")
    });
    if (addPopupRes) {
      this.hidePopup = hidePopup = addPopupRes.hideFunc;
    }
    filterWrapper.filterPromise.then((filter) => {
      positionCallback(eMenu);
      if (filter.afterGuiAttached) {
        filter.afterGuiAttached({ container: containerType, hidePopup });
      }
    });
    column.setMenuVisible(true, "contextMenu");
  }
  trapFocusWithin(e, menu) {
    if (e.key !== KeyCode.TAB || e.defaultPrevented || this.focusService.findNextFocusableElement(menu, false, e.shiftKey)) {
      return;
    }
    e.preventDefault();
    this.focusService.focusInto(menu, e.shiftKey);
  }
  isMenuEnabled(column) {
    return column.isFilterAllowed() && column.getMenuTabs(["filterMenuTab"]).includes("filterMenuTab");
  }
};
__decorate$1b([
  Autowired("filterManager")
], StandardMenuFactory.prototype, "filterManager", void 0);
__decorate$1b([
  Autowired("popupService")
], StandardMenuFactory.prototype, "popupService", void 0);
__decorate$1b([
  Autowired("focusService")
], StandardMenuFactory.prototype, "focusService", void 0);
__decorate$1b([
  Autowired("ctrlsService")
], StandardMenuFactory.prototype, "ctrlsService", void 0);
StandardMenuFactory = __decorate$1b([
  Bean("menuFactory")
], StandardMenuFactory);
var __decorate$1a = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TabbedLayout = class extends Component {
  constructor(params) {
    super(TabbedLayout.getTemplate(params.cssClass));
    this.items = [];
    this.tabbedItemScrollMap = /* @__PURE__ */ new Map();
    this.params = params;
    if (params.items) {
      params.items.forEach((item) => this.addItem(item));
    }
  }
  postConstruct() {
    this.createManagedBean(new ManagedFocusFeature(this.getFocusableElement(), {
      onTabKeyDown: this.onTabKeyDown.bind(this),
      handleKeyDown: this.handleKeyDown.bind(this)
    }));
    this.addDestroyFunc(() => {
      var _a, _b, _c;
      return (_c = (_b = (_a = this.activeItem) === null || _a === void 0 ? void 0 : _a.tabbedItem) === null || _b === void 0 ? void 0 : _b.afterDetachedCallback) === null || _c === void 0 ? void 0 : _c.call(_b);
    });
  }
  static getTemplate(cssClass) {
    return `<div class="ag-tabs ${cssClass}">
            <div ref="eHeader" role="tablist" class="ag-tabs-header ${cssClass ? `${cssClass}-header` : ""}"></div>
            <div ref="eBody" role="presentation" class="ag-tabs-body ${cssClass ? `${cssClass}-body` : ""}"></div>
        </div>`;
  }
  handleKeyDown(e) {
    const eDocument = this.gridOptionsService.getDocument();
    switch (e.key) {
      case KeyCode.RIGHT:
      case KeyCode.LEFT:
        if (!this.eHeader.contains(eDocument.activeElement)) {
          return;
        }
        const isRightKey = e.key === KeyCode.RIGHT;
        const isRtl = this.gridOptionsService.is("enableRtl");
        const currentPosition = this.items.indexOf(this.activeItem);
        const nextPosition = isRightKey !== isRtl ? Math.min(currentPosition + 1, this.items.length - 1) : Math.max(currentPosition - 1, 0);
        if (currentPosition === nextPosition) {
          return;
        }
        e.preventDefault();
        const nextItem = this.items[nextPosition];
        this.showItemWrapper(nextItem);
        nextItem.eHeaderButton.focus();
        break;
      case KeyCode.UP:
      case KeyCode.DOWN:
        e.stopPropagation();
        break;
    }
  }
  onTabKeyDown(e) {
    if (e.defaultPrevented) {
      return;
    }
    const { focusService, eHeader, eBody, activeItem } = this;
    const eDocument = this.gridOptionsService.getDocument();
    const activeElement = eDocument.activeElement;
    const target = e.target;
    e.preventDefault();
    if (eHeader.contains(activeElement)) {
      focusService.focusInto(eBody, e.shiftKey);
      return;
    }
    let nextEl = null;
    if (focusService.isTargetUnderManagedComponent(eBody, target)) {
      if (e.shiftKey) {
        nextEl = this.focusService.findFocusableElementBeforeTabGuard(eBody, target);
      }
      if (!nextEl) {
        nextEl = activeItem.eHeaderButton;
      }
    }
    if (!nextEl && eBody.contains(activeElement)) {
      nextEl = focusService.findNextFocusableElement(eBody, false, e.shiftKey);
      if (!nextEl) {
        nextEl = activeItem.eHeaderButton;
      }
    }
    if (nextEl) {
      nextEl.focus();
    }
  }
  setAfterAttachedParams(params) {
    this.afterAttachedParams = params;
  }
  showFirstItem() {
    if (this.items.length > 0) {
      this.showItemWrapper(this.items[0]);
    }
  }
  addItem(item) {
    const eHeaderButton = document.createElement("span");
    setAriaRole(eHeaderButton, "tab");
    eHeaderButton.setAttribute("tabIndex", "-1");
    eHeaderButton.appendChild(item.title);
    eHeaderButton.classList.add("ag-tab");
    this.eHeader.appendChild(eHeaderButton);
    setAriaLabel(eHeaderButton, item.titleLabel);
    const wrapper = {
      tabbedItem: item,
      eHeaderButton
    };
    this.items.push(wrapper);
    eHeaderButton.addEventListener("click", this.showItemWrapper.bind(this, wrapper));
  }
  showItem(tabbedItem) {
    const itemWrapper = this.items.find((wrapper) => wrapper.tabbedItem === tabbedItem);
    if (itemWrapper) {
      this.showItemWrapper(itemWrapper);
    }
  }
  showItemWrapper(wrapper) {
    var _a, _b;
    const { tabbedItem, eHeaderButton } = wrapper;
    if (this.params.onItemClicked) {
      this.params.onItemClicked({ item: tabbedItem });
    }
    if (this.activeItem === wrapper) {
      callIfPresent(this.params.onActiveItemClicked);
      return;
    }
    if (this.lastScrollListener) {
      this.lastScrollListener = this.lastScrollListener();
    }
    clearElement(this.eBody);
    tabbedItem.bodyPromise.then((body) => {
      this.eBody.appendChild(body);
      const onlyUnmanaged = !this.focusService.isKeyboardMode();
      this.focusService.focusInto(this.eBody, false, onlyUnmanaged);
      if (tabbedItem.afterAttachedCallback) {
        tabbedItem.afterAttachedCallback(this.afterAttachedParams);
      }
      if (this.params.keepScrollPosition) {
        const scrollableContainer = tabbedItem.getScrollableContainer && tabbedItem.getScrollableContainer() || body;
        this.lastScrollListener = this.addManagedListener(scrollableContainer, "scroll", () => {
          this.tabbedItemScrollMap.set(tabbedItem.name, scrollableContainer.scrollTop);
        });
        const scrollPosition = this.tabbedItemScrollMap.get(tabbedItem.name);
        if (scrollPosition !== void 0) {
          setTimeout(() => {
            scrollableContainer.scrollTop = scrollPosition;
          }, 0);
        }
      }
    });
    if (this.activeItem) {
      this.activeItem.eHeaderButton.classList.remove("ag-tab-selected");
      (_b = (_a = this.activeItem.tabbedItem).afterDetachedCallback) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    eHeaderButton.classList.add("ag-tab-selected");
    this.activeItem = wrapper;
  }
};
__decorate$1a([
  Autowired("focusService")
], TabbedLayout.prototype, "focusService", void 0);
__decorate$1a([
  RefSelector("eHeader")
], TabbedLayout.prototype, "eHeader", void 0);
__decorate$1a([
  RefSelector("eBody")
], TabbedLayout.prototype, "eBody", void 0);
__decorate$1a([
  PostConstruct
], TabbedLayout.prototype, "postConstruct", null);
var __decorate$19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DEBOUNCE_DELAY = 50;
var ResizeObserverService = class ResizeObserverService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.polyfillFunctions = [];
  }
  observeResize(element, callback) {
    const win = this.gridOptionsService.getWindow();
    const useBrowserResizeObserver = () => {
      const resizeObserver = new win.ResizeObserver(callback);
      resizeObserver.observe(element);
      return () => resizeObserver.disconnect();
    };
    const usePolyfill = () => {
      let widthLastTime = offsetWidth(element);
      let heightLastTime = offsetHeight(element);
      let running = true;
      const periodicallyCheckWidthAndHeight = () => {
        if (running) {
          const newWidth = offsetWidth(element);
          const newHeight = offsetHeight(element);
          const changed = newWidth !== widthLastTime || newHeight !== heightLastTime;
          if (changed) {
            widthLastTime = newWidth;
            heightLastTime = newHeight;
            callback();
          }
          this.doNextPolyfillTurn(periodicallyCheckWidthAndHeight);
        }
      };
      periodicallyCheckWidthAndHeight();
      return () => running = false;
    };
    const suppressResize = this.gridOptionsService.is("suppressBrowserResizeObserver");
    const resizeObserverExists = !!win.ResizeObserver;
    if (resizeObserverExists && !suppressResize) {
      return useBrowserResizeObserver();
    }
    return usePolyfill();
  }
  doNextPolyfillTurn(func) {
    this.polyfillFunctions.push(func);
    this.schedulePolyfill();
  }
  schedulePolyfill() {
    if (this.polyfillScheduled) {
      return;
    }
    const executeAllFuncs = () => {
      const funcs = this.polyfillFunctions;
      this.polyfillScheduled = false;
      this.polyfillFunctions = [];
      funcs.forEach((f) => f());
    };
    this.polyfillScheduled = true;
    this.getFrameworkOverrides().setTimeout(executeAllFuncs, DEBOUNCE_DELAY);
  }
};
ResizeObserverService = __decorate$19([
  Bean("resizeObserverService")
], ResizeObserverService);
var __decorate$18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AnimationFrameService = class AnimationFrameService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.createTasksP1 = { list: [], sorted: false };
    this.createTasksP2 = { list: [], sorted: false };
    this.destroyTasks = [];
    this.ticking = false;
    this.scrollGoingDown = true;
    this.lastPage = 0;
    this.lastScrollTop = 0;
    this.taskCount = 0;
    this.cancelledTasks = /* @__PURE__ */ new Set();
  }
  setScrollTop(scrollTop) {
    const isPaginationActive = this.gridOptionsService.is("pagination");
    this.scrollGoingDown = scrollTop >= this.lastScrollTop;
    if (isPaginationActive && scrollTop === 0) {
      const currentPage = this.paginationProxy.getCurrentPage();
      if (currentPage !== this.lastPage) {
        this.lastPage = currentPage;
        this.scrollGoingDown = true;
      }
    }
    this.lastScrollTop = scrollTop;
  }
  init() {
    this.useAnimationFrame = !this.gridOptionsService.is("suppressAnimationFrame");
  }
  isOn() {
    return this.useAnimationFrame;
  }
  verifyAnimationFrameOn(methodName) {
    if (this.useAnimationFrame === false) {
      console.warn(`AG Grid: AnimationFrameService.${methodName} called but animation frames are off`);
    }
  }
  createTask(task, index, list) {
    this.verifyAnimationFrameOn(list);
    const taskItem = { task, index, createOrder: ++this.taskCount };
    this.addTaskToList(this[list], taskItem);
    this.schedule();
  }
  cancelTask(task) {
    this.cancelledTasks.add(task);
  }
  addTaskToList(taskList, task) {
    taskList.list.push(task);
    taskList.sorted = false;
  }
  sortTaskList(taskList) {
    if (taskList.sorted) {
      return;
    }
    const sortDirection = this.scrollGoingDown ? 1 : -1;
    taskList.list.sort((a, b) => a.index !== b.index ? sortDirection * (b.index - a.index) : b.createOrder - a.createOrder);
    taskList.sorted = true;
  }
  addDestroyTask(task) {
    this.verifyAnimationFrameOn("createTasksP3");
    this.destroyTasks.push(task);
    this.schedule();
  }
  executeFrame(millis) {
    this.verifyAnimationFrameOn("executeFrame");
    const p1TaskList = this.createTasksP1;
    const p1Tasks = p1TaskList.list;
    const p2TaskList = this.createTasksP2;
    const p2Tasks = p2TaskList.list;
    const destroyTasks = this.destroyTasks;
    const frameStart = new Date().getTime();
    let duration = new Date().getTime() - frameStart;
    const noMaxMillis = millis <= 0;
    const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
    while (noMaxMillis || duration < millis) {
      const gridBodyDidSomething = gridBodyCon.getScrollFeature().scrollGridIfNeeded();
      if (!gridBodyDidSomething) {
        let task;
        if (p1Tasks.length) {
          this.sortTaskList(p1TaskList);
          task = p1Tasks.pop().task;
        } else if (p2Tasks.length) {
          this.sortTaskList(p2TaskList);
          task = p2Tasks.pop().task;
        } else if (destroyTasks.length) {
          task = destroyTasks.pop();
        } else {
          this.cancelledTasks.clear();
          break;
        }
        if (!this.cancelledTasks.has(task)) {
          task();
        }
      }
      duration = new Date().getTime() - frameStart;
    }
    if (p1Tasks.length || p2Tasks.length || destroyTasks.length) {
      this.requestFrame();
    } else {
      this.stopTicking();
    }
  }
  stopTicking() {
    this.ticking = false;
  }
  flushAllFrames() {
    if (!this.useAnimationFrame) {
      return;
    }
    this.executeFrame(-1);
  }
  schedule() {
    if (!this.useAnimationFrame) {
      return;
    }
    if (!this.ticking) {
      this.ticking = true;
      this.requestFrame();
    }
  }
  requestFrame() {
    const callback = this.executeFrame.bind(this, 60);
    this.requestAnimationFrame(callback);
  }
  requestAnimationFrame(callback) {
    const win = this.gridOptionsService.getWindow();
    if (win.requestAnimationFrame) {
      win.requestAnimationFrame(callback);
    } else if (win.webkitRequestAnimationFrame) {
      win.webkitRequestAnimationFrame(callback);
    } else {
      win.setTimeout(callback, 0);
    }
  }
  isQueueEmpty() {
    return !this.ticking;
  }
  debounce(func) {
    let pending = false;
    return () => {
      if (!this.isOn()) {
        this.getFrameworkOverrides().setTimeout(func, 0);
        return;
      }
      if (pending) {
        return;
      }
      pending = true;
      this.addDestroyTask(() => {
        pending = false;
        func();
      });
    };
  }
};
__decorate$18([
  Autowired("ctrlsService")
], AnimationFrameService.prototype, "ctrlsService", void 0);
__decorate$18([
  Autowired("paginationProxy")
], AnimationFrameService.prototype, "paginationProxy", void 0);
__decorate$18([
  PostConstruct
], AnimationFrameService.prototype, "init", null);
AnimationFrameService = __decorate$18([
  Bean("animationFrameService")
], AnimationFrameService);
var __decorate$17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AutoWidthCalculator = class AutoWidthCalculator2 extends BeanStub {
  postConstruct() {
    this.ctrlsService.whenReady((p) => {
      this.centerRowContainerCtrl = p.centerRowContainerCtrl;
    });
  }
  getPreferredWidthForColumn(column, skipHeader) {
    const eHeaderCell = this.getHeaderCellForColumn(column);
    if (!eHeaderCell) {
      return -1;
    }
    const elements = this.rowRenderer.getAllCellsForColumn(column);
    if (!skipHeader) {
      elements.push(eHeaderCell);
    }
    return this.addElementsToContainerAndGetWidth(elements);
  }
  getPreferredWidthForColumnGroup(columnGroup) {
    const eHeaderCell = this.getHeaderCellForColumn(columnGroup);
    if (!eHeaderCell) {
      return -1;
    }
    return this.addElementsToContainerAndGetWidth([eHeaderCell]);
  }
  addElementsToContainerAndGetWidth(elements) {
    const eDummyContainer = document.createElement("form");
    eDummyContainer.style.position = "fixed";
    const eBodyContainer = this.centerRowContainerCtrl.getContainerElement();
    eBodyContainer.appendChild(eDummyContainer);
    elements.forEach((el) => this.cloneItemIntoDummy(el, eDummyContainer));
    const dummyContainerWidth = eDummyContainer.offsetWidth;
    eBodyContainer.removeChild(eDummyContainer);
    const autoSizePadding = this.getAutoSizePadding();
    return dummyContainerWidth + autoSizePadding;
  }
  getAutoSizePadding() {
    const value = this.gridOptionsService.getNum("autoSizePadding");
    return value != null && value >= 0 ? value : 20;
  }
  getHeaderCellForColumn(column) {
    let element = null;
    this.ctrlsService.getHeaderRowContainerCtrls().forEach((container) => {
      const res = container.getHtmlElementForColumnHeader(column);
      if (res != null) {
        element = res;
      }
    });
    return element;
  }
  cloneItemIntoDummy(eCell, eDummyContainer) {
    const eCellClone = eCell.cloneNode(true);
    eCellClone.style.width = "";
    eCellClone.style.position = "static";
    eCellClone.style.left = "";
    const eCloneParent = document.createElement("div");
    const eCloneParentClassList = eCloneParent.classList;
    const isHeader = ["ag-header-cell", "ag-header-group-cell"].some((cls) => eCellClone.classList.contains(cls));
    if (isHeader) {
      eCloneParentClassList.add("ag-header", "ag-header-row");
      eCloneParent.style.position = "static";
    } else {
      eCloneParentClassList.add("ag-row");
    }
    let pointer = eCell.parentElement;
    while (pointer) {
      const isRow = ["ag-header-row", "ag-row"].some((cls) => pointer.classList.contains(cls));
      if (isRow) {
        for (let i = 0; i < pointer.classList.length; i++) {
          const item = pointer.classList[i];
          if (item != "ag-row-position-absolute") {
            eCloneParentClassList.add(item);
          }
        }
        break;
      }
      pointer = pointer.parentElement;
    }
    eCloneParent.appendChild(eCellClone);
    eDummyContainer.appendChild(eCloneParent);
  }
};
__decorate$17([
  Autowired("rowRenderer")
], AutoWidthCalculator.prototype, "rowRenderer", void 0);
__decorate$17([
  Autowired("ctrlsService")
], AutoWidthCalculator.prototype, "ctrlsService", void 0);
__decorate$17([
  Autowired("rowCssClassCalculator")
], AutoWidthCalculator.prototype, "rowCssClassCalculator", void 0);
__decorate$17([
  PostConstruct
], AutoWidthCalculator.prototype, "postConstruct", null);
AutoWidthCalculator = __decorate$17([
  Bean("autoWidthCalculator")
], AutoWidthCalculator);
var __decorate$16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var StickyRowFeature = class extends BeanStub {
  constructor(createRowCon, destroyRowCtrls) {
    super();
    this.createRowCon = createRowCon;
    this.destroyRowCtrls = destroyRowCtrls;
    this.stickyRowCtrls = [];
    this.containerHeight = 0;
  }
  postConstruct() {
    this.isClientSide = this.rowModel.getType() === "clientSide";
    this.ctrlsService.whenReady((params) => {
      this.gridBodyCtrl = params.gridBodyCtrl;
    });
  }
  getStickyRowCtrls() {
    return this.stickyRowCtrls;
  }
  checkStickyRows() {
    let height = 0;
    if (!this.gridOptionsService.isGroupRowsSticky()) {
      this.refreshNodesAndContainerHeight([], height);
      return;
    }
    const stickyRows = [];
    const firstPixel = this.rowRenderer.getFirstVisibleVerticalPixel();
    const addStickyRow = (stickyRow) => {
      var _a, _b, _c;
      stickyRows.push(stickyRow);
      let lastChildBottom;
      if (this.isClientSide) {
        let lastAncestor = stickyRow;
        while (lastAncestor.expanded) {
          if (lastAncestor.master) {
            lastAncestor = lastAncestor.detailNode;
          } else if (lastAncestor.childrenAfterSort) {
            if (lastAncestor.childrenAfterSort.length === 0) {
              break;
            }
            lastAncestor = last(lastAncestor.childrenAfterSort);
          }
        }
        lastChildBottom = lastAncestor.rowTop + lastAncestor.rowHeight;
      } else {
        if (stickyRow.master) {
          lastChildBottom = stickyRow.detailNode.rowTop + stickyRow.detailNode.rowHeight;
        } else {
          const storeBounds = (_a = stickyRow.childStore) === null || _a === void 0 ? void 0 : _a.getStoreBounds();
          lastChildBottom = ((_b = storeBounds === null || storeBounds === void 0 ? void 0 : storeBounds.heightPx) !== null && _b !== void 0 ? _b : 0) + ((_c = storeBounds === null || storeBounds === void 0 ? void 0 : storeBounds.topPx) !== null && _c !== void 0 ? _c : 0);
        }
      }
      const stickRowBottom = firstPixel + height + stickyRow.rowHeight;
      if (lastChildBottom < stickRowBottom) {
        stickyRow.stickyRowTop = height + (lastChildBottom - stickRowBottom);
      } else {
        stickyRow.stickyRowTop = height;
      }
      height = 0;
      stickyRows.forEach((rowNode) => {
        const thisRowLastPx = rowNode.stickyRowTop + rowNode.rowHeight;
        if (height < thisRowLastPx) {
          height = thisRowLastPx;
        }
      });
    };
    while (true) {
      const firstPixelAfterStickyRows = firstPixel + height;
      const firstIndex = this.rowModel.getRowIndexAtPixel(firstPixelAfterStickyRows);
      const firstRow = this.rowModel.getRow(firstIndex);
      if (firstRow == null) {
        break;
      }
      if (firstRow.level < 0) {
        break;
      }
      const parents = [];
      let p = firstRow.parent;
      while (p.level >= 0) {
        parents.push(p);
        p = p.parent;
      }
      const firstMissingParent = parents.reverse().find((parent) => stickyRows.indexOf(parent) < 0 && parent.displayed);
      if (firstMissingParent) {
        addStickyRow(firstMissingParent);
        continue;
      }
      if (firstRow.isExpandable() && firstRow.expanded && firstRow.rowTop < firstPixelAfterStickyRows) {
        addStickyRow(firstRow);
        continue;
      }
      break;
    }
    this.refreshNodesAndContainerHeight(stickyRows, height);
  }
  refreshStickyNode(stickRowNode) {
    const allStickyNodes = [];
    for (let i = 0; i < this.stickyRowCtrls.length; i++) {
      const currentNode = this.stickyRowCtrls[i].getRowNode();
      if (currentNode !== stickRowNode) {
        allStickyNodes.push(currentNode);
      }
    }
    this.refreshNodesAndContainerHeight(allStickyNodes, this.containerHeight);
    this.checkStickyRows();
  }
  refreshNodesAndContainerHeight(allStickyNodes, height) {
    const removedCtrls = this.stickyRowCtrls.filter((ctrl) => allStickyNodes.indexOf(ctrl.getRowNode()) === -1);
    const addedNodes = allStickyNodes.filter((rowNode) => this.stickyRowCtrls.findIndex((ctrl) => ctrl.getRowNode() === rowNode) === -1);
    const ctrlsToDestroy = {};
    removedCtrls.forEach((removedCtrl) => {
      ctrlsToDestroy[removedCtrl.getRowNode().id] = removedCtrl;
      this.stickyRowCtrls = this.stickyRowCtrls.filter((ctrl) => ctrl !== removedCtrl);
    });
    for (const ctrl of Object.values(ctrlsToDestroy)) {
      ctrl.getRowNode().sticky = false;
    }
    this.destroyRowCtrls(ctrlsToDestroy, false);
    const newCtrls = addedNodes.map((rowNode) => {
      rowNode.sticky = true;
      return this.createRowCon(rowNode, false, false);
    });
    this.stickyRowCtrls.push(...newCtrls);
    this.stickyRowCtrls.forEach((ctrl) => ctrl.setRowTop(ctrl.getRowNode().stickyRowTop));
    this.stickyRowCtrls.sort((a, b) => b.getRowNode().rowIndex - a.getRowNode().rowIndex);
    if (this.containerHeight !== height) {
      this.containerHeight = height;
      this.gridBodyCtrl.setStickyTopHeight(height);
    }
  }
};
__decorate$16([
  Autowired("rowModel")
], StickyRowFeature.prototype, "rowModel", void 0);
__decorate$16([
  Autowired("rowRenderer")
], StickyRowFeature.prototype, "rowRenderer", void 0);
__decorate$16([
  Autowired("ctrlsService")
], StickyRowFeature.prototype, "ctrlsService", void 0);
__decorate$16([
  PostConstruct
], StickyRowFeature.prototype, "postConstruct", null);
var __decorate$15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DEFAULT_KEEP_DETAIL_ROW_COUNT = 10;
var RowRenderer = class RowRenderer2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.destroyFuncsForColumnListeners = [];
    this.rowCtrlsByRowIndex = {};
    this.zombieRowCtrls = {};
    this.allRowCtrls = [];
    this.topRowCtrls = [];
    this.bottomRowCtrls = [];
    this.refreshInProgress = false;
    this.dataFirstRenderedFired = false;
  }
  postConstruct() {
    this.ctrlsService.whenReady(() => {
      this.gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
      this.initialise();
    });
  }
  initialise() {
    this.addManagedListener(this.eventService, Events.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL, this.onBodyScroll.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_BODY_HEIGHT_CHANGED, this.redrawAfterScroll.bind(this));
    this.addManagedPropertyListener("domLayout", this.onDomLayoutChanged.bind(this));
    this.addManagedPropertyListener("rowClass", this.redrawRows.bind(this));
    if (this.gridOptionsService.isGroupRowsSticky()) {
      const rowModelType = this.rowModel.getType();
      if (rowModelType === "clientSide" || rowModelType === "serverSide") {
        this.stickyRowFeature = this.createManagedBean(new StickyRowFeature(this.createRowCon.bind(this), this.destroyRowCtrls.bind(this)));
      }
    }
    this.registerCellEventListeners();
    this.initialiseCache();
    this.printLayout = this.gridOptionsService.isDomLayout("print");
    this.embedFullWidthRows = this.printLayout || this.gridOptionsService.is("embedFullWidthRows");
    this.redrawAfterModelUpdate();
  }
  initialiseCache() {
    if (this.gridOptionsService.is("keepDetailRows")) {
      const countProp = this.getKeepDetailRowsCount();
      const count = countProp != null ? countProp : 3;
      this.cachedRowCtrls = new RowCtrlCache(count);
    }
  }
  getKeepDetailRowsCount() {
    const keepDetailRowsCount = this.gridOptionsService.getNum("keepDetailRowsCount");
    if (exists(keepDetailRowsCount) && keepDetailRowsCount > 0) {
      return keepDetailRowsCount;
    }
    return DEFAULT_KEEP_DETAIL_ROW_COUNT;
  }
  getRowCtrls() {
    return this.allRowCtrls;
  }
  getStickyTopRowCtrls() {
    if (!this.stickyRowFeature) {
      return [];
    }
    return this.stickyRowFeature.getStickyRowCtrls();
  }
  updateAllRowCtrls() {
    const liveList = getAllValuesInObject(this.rowCtrlsByRowIndex);
    const isEnsureDomOrder = this.gridOptionsService.is("ensureDomOrder");
    const isPrintLayout = this.gridOptionsService.isDomLayout("print");
    if (isEnsureDomOrder || isPrintLayout) {
      liveList.sort((a, b) => a.getRowNode().rowIndex - b.getRowNode.rowIndex);
    }
    const zombieList = getAllValuesInObject(this.zombieRowCtrls);
    const cachedList = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];
    this.allRowCtrls = [...liveList, ...zombieList, ...cachedList];
  }
  onCellFocusChanged(event) {
    this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellFocused(event));
    this.getFullWidthRowCtrls().forEach((rowCtrl) => rowCtrl.onFullWidthRowFocused(event));
  }
  registerCellEventListeners() {
    this.addManagedListener(this.eventService, Events.EVENT_CELL_FOCUSED, (event) => {
      this.onCellFocusChanged(event);
    });
    this.addManagedListener(this.eventService, Events.EVENT_CELL_FOCUS_CLEARED, () => {
      this.onCellFocusChanged();
    });
    this.addManagedListener(this.eventService, Events.EVENT_FLASH_CELLS, (event) => {
      this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onFlashCells(event));
    });
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HOVER_CHANGED, () => {
      this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onColumnHover());
    });
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, () => {
      this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onDisplayedColumnsChanged());
    });
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, () => {
      if (this.printLayout) {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onLeftChanged());
      }
    });
    const rangeSelectionEnabled = this.gridOptionsService.isEnableRangeSelection();
    if (rangeSelectionEnabled) {
      this.addManagedListener(this.eventService, Events.EVENT_RANGE_SELECTION_CHANGED, () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onRangeSelectionChanged());
      });
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.updateRangeBordersIfRangeCount());
      });
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PINNED, () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.updateRangeBordersIfRangeCount());
      });
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.updateRangeBordersIfRangeCount());
      });
    }
    this.refreshListenersToColumnsForCellComps();
    this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this));
    this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
  }
  removeGridColumnListeners() {
    this.destroyFuncsForColumnListeners.forEach((func) => func());
    this.destroyFuncsForColumnListeners.length = 0;
  }
  refreshListenersToColumnsForCellComps() {
    this.removeGridColumnListeners();
    const cols = this.columnModel.getAllGridColumns();
    if (!cols) {
      return;
    }
    cols.forEach((col) => {
      const forEachCellWithThisCol = (callback) => {
        this.getAllCellCtrls().forEach((cellCtrl) => {
          if (cellCtrl.getColumn() === col) {
            callback(cellCtrl);
          }
        });
      };
      const leftChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onLeftChanged());
      };
      const widthChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onWidthChanged());
      };
      const firstRightPinnedChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onFirstRightPinnedChanged());
      };
      const lastLeftPinnedChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onLastLeftPinnedChanged());
      };
      const colDefChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onColDefChanged());
      };
      col.addEventListener("leftChanged", leftChangedListener);
      col.addEventListener("widthChanged", widthChangedListener);
      col.addEventListener("firstRightPinnedChanged", firstRightPinnedChangedListener);
      col.addEventListener("lastLeftPinnedChanged", lastLeftPinnedChangedListener);
      col.addEventListener("colDefChanged", colDefChangedListener);
      this.destroyFuncsForColumnListeners.push(() => {
        col.removeEventListener("leftChanged", leftChangedListener);
        col.removeEventListener("widthChanged", widthChangedListener);
        col.removeEventListener("firstRightPinnedChanged", firstRightPinnedChangedListener);
        col.removeEventListener("lastLeftPinnedChanged", lastLeftPinnedChangedListener);
        col.removeEventListener("colDefChanged", colDefChangedListener);
      });
    });
  }
  onDomLayoutChanged() {
    const printLayout = this.gridOptionsService.isDomLayout("print");
    const embedFullWidthRows = printLayout || this.gridOptionsService.is("embedFullWidthRows");
    const destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;
    this.printLayout = printLayout;
    this.embedFullWidthRows = embedFullWidthRows;
    if (destroyRows) {
      this.redrawAfterModelUpdate({ domLayoutChanged: true });
    }
  }
  datasourceChanged() {
    this.firstRenderedRow = 0;
    this.lastRenderedRow = -1;
    const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(rowIndexesToRemove);
  }
  onPageLoaded(event) {
    const params = {
      recycleRows: event.keepRenderedRows,
      animate: event.animate,
      newData: event.newData,
      newPage: event.newPage,
      onlyBody: true
    };
    this.redrawAfterModelUpdate(params);
  }
  getAllCellsForColumn(column) {
    const res = [];
    this.getAllRowCtrls().forEach((rowCtrl) => {
      const eCell = rowCtrl.getCellElement(column);
      if (eCell) {
        res.push(eCell);
      }
    });
    return res;
  }
  refreshFloatingRowComps() {
    this.refreshFloatingRows(this.topRowCtrls, this.pinnedRowModel.getPinnedTopRowData());
    this.refreshFloatingRows(this.bottomRowCtrls, this.pinnedRowModel.getPinnedBottomRowData());
  }
  getTopRowCtrls() {
    return this.topRowCtrls;
  }
  getBottomRowCtrls() {
    return this.bottomRowCtrls;
  }
  refreshFloatingRows(rowComps, rowNodes) {
    rowComps.forEach((row) => {
      row.destroyFirstPass();
      row.destroySecondPass();
    });
    rowComps.length = 0;
    if (!rowNodes) {
      return;
    }
    rowNodes.forEach((rowNode) => {
      const rowCtrl = new RowCtrl(rowNode, this.beans, false, false, this.printLayout);
      rowComps.push(rowCtrl);
    });
  }
  onPinnedRowDataChanged() {
    const params = {
      recycleRows: true
    };
    this.redrawAfterModelUpdate(params);
  }
  getRenderedIndexesForRowNodes(rowNodes) {
    const result = [];
    if (missing(rowNodes)) {
      return result;
    }
    iterateObject(this.rowCtrlsByRowIndex, (index, renderedRow) => {
      const rowNode = renderedRow.getRowNode();
      if (rowNodes.indexOf(rowNode) >= 0) {
        result.push(index);
      }
    });
    return result;
  }
  redrawRows(rowNodes) {
    const partialRefresh = rowNodes != null && rowNodes.length > 0;
    if (partialRefresh) {
      const indexesToRemove = this.getRenderedIndexesForRowNodes(rowNodes);
      this.removeRowCtrls(indexesToRemove);
    }
    this.redrawAfterModelUpdate({
      recycleRows: partialRefresh
    });
  }
  getCellToRestoreFocusToAfterRefresh(params) {
    const focusedCell = (params === null || params === void 0 ? void 0 : params.suppressKeepFocus) ? null : this.focusService.getFocusCellToUseAfterRefresh();
    if (focusedCell == null) {
      return null;
    }
    const eDocument = this.gridOptionsService.getDocument();
    const activeElement = eDocument.activeElement;
    const cellDomData = this.gridOptionsService.getDomData(activeElement, CellCtrl.DOM_DATA_KEY_CELL_CTRL);
    const rowDomData = this.gridOptionsService.getDomData(activeElement, RowCtrl.DOM_DATA_KEY_ROW_CTRL);
    const gridElementFocused = cellDomData || rowDomData;
    return gridElementFocused ? focusedCell : null;
  }
  redrawAfterModelUpdate(params = {}) {
    this.getLockOnRefresh();
    const focusedCell = this.getCellToRestoreFocusToAfterRefresh(params);
    this.updateContainerHeights();
    this.scrollToTopIfNewData(params);
    const recycleRows = !params.domLayoutChanged && !!params.recycleRows;
    const animate = params.animate && this.gridOptionsService.isAnimateRows();
    const rowsToRecycle = recycleRows ? this.recycleRows() : null;
    if (!recycleRows) {
      this.removeAllRowComps();
    }
    this.redraw(rowsToRecycle, animate);
    this.gridBodyCtrl.updateRowCount();
    if (!params.onlyBody) {
      this.refreshFloatingRowComps();
    }
    this.dispatchDisplayedRowsChanged();
    if (focusedCell != null) {
      this.restoreFocusedCell(focusedCell);
    }
    this.releaseLockOnRefresh();
  }
  scrollToTopIfNewData(params) {
    const scrollToTop = params.newData || params.newPage;
    const suppressScrollToTop = this.gridOptionsService.is("suppressScrollOnNewData");
    if (scrollToTop && !suppressScrollToTop) {
      this.gridBodyCtrl.getScrollFeature().scrollToTop();
    }
  }
  updateContainerHeights() {
    if (this.printLayout) {
      this.rowContainerHeightService.setModelHeight(null);
      return;
    }
    let containerHeight = this.paginationProxy.getCurrentPageHeight();
    if (containerHeight === 0) {
      containerHeight = 1;
    }
    this.rowContainerHeightService.setModelHeight(containerHeight);
  }
  getLockOnRefresh() {
    if (this.refreshInProgress) {
      throw new Error("AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. Your code probably called a grid API method while the grid was in the render stage. To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). To see what part of your code that caused the refresh check this stacktrace.");
    }
    this.refreshInProgress = true;
  }
  releaseLockOnRefresh() {
    this.refreshInProgress = false;
  }
  isRefreshInProgress() {
    return this.refreshInProgress;
  }
  restoreFocusedCell(cellPosition) {
    if (cellPosition) {
      this.onCellFocusChanged({
        rowIndex: cellPosition.rowIndex,
        column: cellPosition.column,
        rowPinned: cellPosition.rowPinned,
        forceBrowserFocus: true,
        preventScrollOnBrowserFocus: true,
        api: this.beans.gridApi,
        columnApi: this.beans.columnApi,
        context: this.beans.gridOptionsService.context,
        type: "mock"
      });
    }
  }
  stopEditing(cancel = false) {
    this.getAllRowCtrls().forEach((rowCtrl) => {
      rowCtrl.stopEditing(cancel);
    });
  }
  getAllCellCtrls() {
    const res = [];
    const rowCtrls = this.getAllRowCtrls();
    const rowCtrlsLength = rowCtrls.length;
    for (let i = 0; i < rowCtrlsLength; i++) {
      const cellCtrls = rowCtrls[i].getAllCellCtrls();
      const cellCtrlsLength = cellCtrls.length;
      for (let j = 0; j < cellCtrlsLength; j++) {
        res.push(cellCtrls[j]);
      }
    }
    return res;
  }
  getAllRowCtrls() {
    const stickyRowCtrls = this.stickyRowFeature && this.stickyRowFeature.getStickyRowCtrls() || [];
    const res = [...this.topRowCtrls, ...this.bottomRowCtrls, ...stickyRowCtrls];
    for (const key of Object.keys(this.rowCtrlsByRowIndex)) {
      res.push(this.rowCtrlsByRowIndex[key]);
    }
    return res;
  }
  addRenderedRowListener(eventName, rowIndex, callback) {
    const rowComp = this.rowCtrlsByRowIndex[rowIndex];
    if (rowComp) {
      rowComp.addEventListener(eventName, callback);
    }
  }
  flashCells(params = {}) {
    const { flashDelay, fadeDelay } = params;
    this.getCellCtrls(params.rowNodes, params.columns).forEach((cellCtrl) => cellCtrl.flashCell({ flashDelay, fadeDelay }));
  }
  refreshCells(params = {}) {
    const refreshCellParams = {
      forceRefresh: params.force,
      newData: false,
      suppressFlash: params.suppressFlash
    };
    this.getCellCtrls(params.rowNodes, params.columns).forEach((cellCtrl) => {
      if (cellCtrl.refreshShouldDestroy()) {
        const rowCtrl = cellCtrl.getRowCtrl();
        if (rowCtrl) {
          rowCtrl.refreshCell(cellCtrl);
        }
      } else {
        cellCtrl.refreshCell(refreshCellParams);
      }
    });
    this.refreshFullWidthRows(params.rowNodes);
  }
  getCellRendererInstances(params) {
    var _a;
    const cellRenderers = this.getCellCtrls(params.rowNodes, params.columns).map((cellCtrl) => cellCtrl.getCellRenderer()).filter((renderer) => renderer != null);
    if ((_a = params.columns) === null || _a === void 0 ? void 0 : _a.length) {
      return cellRenderers;
    }
    const fullWidthRenderers = [];
    const rowIdMap = this.mapRowNodes(params.rowNodes);
    this.getAllRowCtrls().forEach((rowCtrl) => {
      if (rowIdMap && !this.isRowInMap(rowCtrl.getRowNode(), rowIdMap)) {
        return;
      }
      if (!rowCtrl.isFullWidth()) {
        return;
      }
      const fullWidthRenderer = rowCtrl.getFullWidthCellRenderer();
      if (fullWidthRenderer) {
        fullWidthRenderers.push(fullWidthRenderer);
      }
    });
    return [...fullWidthRenderers, ...cellRenderers];
  }
  getCellEditorInstances(params) {
    const res = [];
    this.getCellCtrls(params.rowNodes, params.columns).forEach((cellCtrl) => {
      const cellEditor = cellCtrl.getCellEditor();
      if (cellEditor) {
        res.push(cellEditor);
      }
    });
    return res;
  }
  getEditingCells() {
    const res = [];
    this.getAllCellCtrls().forEach((cellCtrl) => {
      if (cellCtrl.isEditing()) {
        const cellPosition = cellCtrl.getCellPosition();
        res.push(cellPosition);
      }
    });
    return res;
  }
  mapRowNodes(rowNodes) {
    if (!rowNodes) {
      return;
    }
    const res = {
      top: {},
      bottom: {},
      normal: {}
    };
    rowNodes.forEach((rowNode) => {
      const id = rowNode.id;
      if (rowNode.rowPinned === "top") {
        res.top[id] = rowNode;
      } else if (rowNode.rowPinned === "bottom") {
        res.bottom[id] = rowNode;
      } else {
        res.normal[id] = rowNode;
      }
    });
    return res;
  }
  isRowInMap(rowNode, rowIdsMap) {
    const id = rowNode.id;
    const floating = rowNode.rowPinned;
    if (floating === "bottom") {
      return rowIdsMap.bottom[id] != null;
    }
    if (floating === "top") {
      return rowIdsMap.top[id] != null;
    }
    return rowIdsMap.normal[id] != null;
  }
  getCellCtrls(rowNodes, columns) {
    const rowIdsMap = this.mapRowNodes(rowNodes);
    const res = [];
    let colIdsMap;
    if (exists(columns)) {
      colIdsMap = {};
      columns.forEach((colKey) => {
        const column = this.columnModel.getGridColumn(colKey);
        if (exists(column)) {
          colIdsMap[column.getId()] = true;
        }
      });
    }
    const processRow = (rowCtrl) => {
      const rowNode = rowCtrl.getRowNode();
      if (rowIdsMap != null && !this.isRowInMap(rowNode, rowIdsMap)) {
        return;
      }
      rowCtrl.getAllCellCtrls().forEach((cellCtrl) => {
        const colId = cellCtrl.getColumn().getId();
        const excludeColFromRefresh = colIdsMap && !colIdsMap[colId];
        if (excludeColFromRefresh) {
          return;
        }
        res.push(cellCtrl);
      });
    };
    this.getAllRowCtrls().forEach((row) => processRow(row));
    return res;
  }
  destroy() {
    this.removeAllRowComps();
    super.destroy();
  }
  removeAllRowComps() {
    const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(rowIndexesToRemove);
  }
  recycleRows() {
    const stubNodeIndexes = [];
    iterateObject(this.rowCtrlsByRowIndex, (index, rowComp) => {
      const stubNode = rowComp.getRowNode().id == null;
      if (stubNode) {
        stubNodeIndexes.push(index);
      }
    });
    this.removeRowCtrls(stubNodeIndexes);
    const ctrlsByIdMap = {};
    iterateObject(this.rowCtrlsByRowIndex, (index, rowComp) => {
      const rowNode = rowComp.getRowNode();
      ctrlsByIdMap[rowNode.id] = rowComp;
    });
    this.rowCtrlsByRowIndex = {};
    return ctrlsByIdMap;
  }
  removeRowCtrls(rowsToRemove) {
    rowsToRemove.forEach((indexToRemove) => {
      const rowCtrl = this.rowCtrlsByRowIndex[indexToRemove];
      if (rowCtrl) {
        rowCtrl.destroyFirstPass();
        rowCtrl.destroySecondPass();
      }
      delete this.rowCtrlsByRowIndex[indexToRemove];
    });
  }
  onBodyScroll(e) {
    if (e.direction !== "vertical") {
      return;
    }
    this.redrawAfterScroll();
  }
  redrawAfterScroll() {
    let cellFocused;
    if (this.stickyRowFeature && browserSupportsPreventScroll()) {
      cellFocused = this.getCellToRestoreFocusToAfterRefresh() || void 0;
    }
    this.getLockOnRefresh();
    this.redraw(null, false, true);
    this.releaseLockOnRefresh();
    this.dispatchDisplayedRowsChanged(true);
    if (cellFocused != null) {
      const newFocusedCell = this.getCellToRestoreFocusToAfterRefresh();
      if (cellFocused != null && newFocusedCell == null) {
        this.animationFrameService.flushAllFrames();
        this.restoreFocusedCell(cellFocused);
      }
    }
  }
  removeRowCompsNotToDraw(indexesToDraw) {
    const indexesToDrawMap = {};
    indexesToDraw.forEach((index) => indexesToDrawMap[index] = true);
    const existingIndexes = Object.keys(this.rowCtrlsByRowIndex);
    const indexesNotToDraw = existingIndexes.filter((index) => !indexesToDrawMap[index]);
    this.removeRowCtrls(indexesNotToDraw);
  }
  calculateIndexesToDraw(rowsToRecycle) {
    let indexesToDraw = createArrayOfNumbers(this.firstRenderedRow, this.lastRenderedRow);
    const checkRowToDraw = (indexStr, rowComp) => {
      const index = rowComp.getRowNode().rowIndex;
      if (index == null) {
        return;
      }
      if (index < this.firstRenderedRow || index > this.lastRenderedRow) {
        if (this.doNotUnVirtualiseRow(rowComp)) {
          indexesToDraw.push(index);
        }
      }
    };
    iterateObject(this.rowCtrlsByRowIndex, checkRowToDraw);
    iterateObject(rowsToRecycle, checkRowToDraw);
    indexesToDraw.sort((a, b) => a - b);
    indexesToDraw = indexesToDraw.filter((index) => {
      const rowNode = this.paginationProxy.getRow(index);
      return rowNode && !rowNode.sticky;
    });
    return indexesToDraw;
  }
  redraw(rowsToRecycle, animate = false, afterScroll = false) {
    this.rowContainerHeightService.updateOffset();
    this.workOutFirstAndLastRowsToRender();
    if (this.stickyRowFeature) {
      this.stickyRowFeature.checkStickyRows();
    }
    const indexesToDraw = this.calculateIndexesToDraw(rowsToRecycle);
    this.removeRowCompsNotToDraw(indexesToDraw);
    if (this.printLayout) {
      animate = false;
    }
    indexesToDraw.forEach((rowIndex) => {
      this.createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll);
    });
    if (rowsToRecycle) {
      const useAnimationFrame = afterScroll && !this.gridOptionsService.is("suppressAnimationFrame") && !this.printLayout;
      if (useAnimationFrame) {
        this.beans.animationFrameService.addDestroyTask(() => {
          this.destroyRowCtrls(rowsToRecycle, animate);
          this.updateAllRowCtrls();
          this.dispatchDisplayedRowsChanged();
        });
      } else {
        this.destroyRowCtrls(rowsToRecycle, animate);
      }
    }
    this.updateAllRowCtrls();
  }
  dispatchDisplayedRowsChanged(afterScroll = false) {
    const event = { type: Events.EVENT_DISPLAYED_ROWS_CHANGED, afterScroll };
    this.eventService.dispatchEvent(event);
  }
  onDisplayedColumnsChanged() {
    const pinningLeft = this.columnModel.isPinningLeft();
    const pinningRight = this.columnModel.isPinningRight();
    const atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;
    if (atLeastOneChanged) {
      this.pinningLeft = pinningLeft;
      this.pinningRight = pinningRight;
      if (this.embedFullWidthRows) {
        this.redrawFullWidthEmbeddedRows();
      }
    }
  }
  redrawFullWidthEmbeddedRows() {
    const rowsToRemove = [];
    this.getFullWidthRowCtrls().forEach((fullWidthCtrl) => {
      const rowIndex = fullWidthCtrl.getRowNode().rowIndex;
      rowsToRemove.push(rowIndex.toString());
    });
    this.refreshFloatingRowComps();
    this.removeRowCtrls(rowsToRemove);
    this.redrawAfterScroll();
  }
  getFullWidthRowCtrls(rowNodes) {
    const rowNodesMap = this.mapRowNodes(rowNodes);
    return this.getAllRowCtrls().filter((rowCtrl) => {
      if (!rowCtrl.isFullWidth()) {
        return false;
      }
      const rowNode = rowCtrl.getRowNode();
      if (rowNodesMap != null && !this.isRowInMap(rowNode, rowNodesMap)) {
        return false;
      }
      return true;
    });
  }
  refreshFullWidthRow(rowNode) {
    this.refreshFullWidthRows([rowNode]);
  }
  refreshFullWidthRows(rowNodes) {
    const fullWidthCtrls = this.getFullWidthRowCtrls(rowNodes);
    let redraw = false;
    const indicesToForce = [];
    fullWidthCtrls.forEach((fullWidthCtrl) => {
      const refreshed = fullWidthCtrl.refreshFullWidth();
      if (refreshed) {
        return;
      }
      const node = fullWidthCtrl.getRowNode();
      if (node.sticky) {
        this.stickyRowFeature.refreshStickyNode(node);
      } else {
        indicesToForce.push(node.rowIndex);
      }
      redraw = true;
    });
    if (indicesToForce.length > 0) {
      this.removeRowCtrls(indicesToForce);
    }
    if (redraw) {
      this.redrawAfterScroll();
    }
  }
  createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll) {
    let rowNode;
    let rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
    if (!rowCtrl) {
      rowNode = this.paginationProxy.getRow(rowIndex);
      if (exists(rowNode) && exists(rowsToRecycle) && rowsToRecycle[rowNode.id] && rowNode.alreadyRendered) {
        rowCtrl = rowsToRecycle[rowNode.id];
        rowsToRecycle[rowNode.id] = null;
      }
    }
    const creatingNewRowCtrl = !rowCtrl;
    if (creatingNewRowCtrl) {
      if (!rowNode) {
        rowNode = this.paginationProxy.getRow(rowIndex);
      }
      if (exists(rowNode)) {
        rowCtrl = this.createRowCon(rowNode, animate, afterScroll);
      } else {
        return;
      }
    }
    if (rowNode) {
      rowNode.alreadyRendered = true;
    }
    this.rowCtrlsByRowIndex[rowIndex] = rowCtrl;
    return rowCtrl;
  }
  destroyRowCtrls(rowCtrlsMap, animate) {
    const executeInAWhileFuncs = [];
    iterateObject(rowCtrlsMap, (nodeId, rowCtrl) => {
      if (!rowCtrl) {
        return;
      }
      if (this.cachedRowCtrls && rowCtrl.isCacheable()) {
        this.cachedRowCtrls.addRow(rowCtrl);
        return;
      }
      rowCtrl.destroyFirstPass();
      if (animate) {
        this.zombieRowCtrls[rowCtrl.getInstanceId()] = rowCtrl;
        executeInAWhileFuncs.push(() => {
          rowCtrl.destroySecondPass();
          delete this.zombieRowCtrls[rowCtrl.getInstanceId()];
        });
      } else {
        rowCtrl.destroySecondPass();
      }
    });
    if (animate) {
      executeInAWhileFuncs.push(() => {
        this.updateAllRowCtrls();
        this.dispatchDisplayedRowsChanged();
      });
      executeInAWhile(executeInAWhileFuncs);
    }
  }
  getRowBuffer() {
    let rowBuffer = this.gridOptionsService.getNum("rowBuffer");
    if (typeof rowBuffer === "number") {
      if (rowBuffer < 0) {
        doOnce(() => console.warn(`AG Grid: rowBuffer should not be negative`), "warn rowBuffer negative");
        rowBuffer = 0;
        this.gridOptionsService.set("rowBuffer", 0);
      }
    } else {
      rowBuffer = 10;
    }
    return rowBuffer;
  }
  getRowBufferInPixels() {
    const rowsToBuffer = this.getRowBuffer();
    const defaultRowHeight = this.gridOptionsService.getRowHeightAsNumber();
    return rowsToBuffer * defaultRowHeight;
  }
  workOutFirstAndLastRowsToRender() {
    let newFirst;
    let newLast;
    if (!this.paginationProxy.isRowsToRender()) {
      newFirst = 0;
      newLast = -1;
    } else if (this.printLayout) {
      newFirst = this.paginationProxy.getPageFirstRow();
      newLast = this.paginationProxy.getPageLastRow();
    } else {
      const bufferPixels = this.getRowBufferInPixels();
      const gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
      const suppressRowVirtualisation = this.gridOptionsService.is("suppressRowVirtualisation");
      let rowHeightsChanged = false;
      let firstPixel;
      let lastPixel;
      do {
        const paginationOffset = this.paginationProxy.getPixelOffset();
        const { pageFirstPixel, pageLastPixel } = this.paginationProxy.getCurrentPagePixelRange();
        const divStretchOffset = this.rowContainerHeightService.getDivStretchOffset();
        const bodyVRange = gridBodyCtrl.getScrollFeature().getVScrollPosition();
        const bodyTopPixel = bodyVRange.top;
        const bodyBottomPixel = bodyVRange.bottom;
        if (suppressRowVirtualisation) {
          firstPixel = pageFirstPixel + divStretchOffset;
          lastPixel = pageLastPixel + divStretchOffset;
        } else {
          firstPixel = Math.max(bodyTopPixel + paginationOffset - bufferPixels, pageFirstPixel) + divStretchOffset;
          lastPixel = Math.min(bodyBottomPixel + paginationOffset + bufferPixels, pageLastPixel) + divStretchOffset;
        }
        this.firstVisibleVPixel = Math.max(bodyTopPixel + paginationOffset, pageFirstPixel) + divStretchOffset;
        rowHeightsChanged = this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);
      } while (rowHeightsChanged);
      let firstRowIndex = this.paginationProxy.getRowIndexAtPixel(firstPixel);
      let lastRowIndex = this.paginationProxy.getRowIndexAtPixel(lastPixel);
      const pageFirstRow = this.paginationProxy.getPageFirstRow();
      const pageLastRow = this.paginationProxy.getPageLastRow();
      if (firstRowIndex < pageFirstRow) {
        firstRowIndex = pageFirstRow;
      }
      if (lastRowIndex > pageLastRow) {
        lastRowIndex = pageLastRow;
      }
      newFirst = firstRowIndex;
      newLast = lastRowIndex;
    }
    const rowLayoutNormal = this.gridOptionsService.isDomLayout("normal");
    const suppressRowCountRestriction = this.gridOptionsService.is("suppressMaxRenderedRowRestriction");
    const rowBufferMaxSize = Math.max(this.getRowBuffer(), 500);
    if (rowLayoutNormal && !suppressRowCountRestriction) {
      if (newLast - newFirst > rowBufferMaxSize) {
        newLast = newFirst + rowBufferMaxSize;
      }
    }
    const firstDiffers = newFirst !== this.firstRenderedRow;
    const lastDiffers = newLast !== this.lastRenderedRow;
    if (firstDiffers || lastDiffers) {
      this.firstRenderedRow = newFirst;
      this.lastRenderedRow = newLast;
      const event = {
        type: Events.EVENT_VIEWPORT_CHANGED,
        firstRow: newFirst,
        lastRow: newLast
      };
      this.eventService.dispatchEvent(event);
    }
  }
  dispatchFirstDataRenderedEvent() {
    if (this.dataFirstRenderedFired) {
      return;
    }
    this.dataFirstRenderedFired = true;
    const event = {
      type: Events.EVENT_FIRST_DATA_RENDERED,
      firstRow: this.firstRenderedRow,
      lastRow: this.lastRenderedRow
    };
    window.requestAnimationFrame(() => {
      this.beans.eventService.dispatchEvent(event);
    });
  }
  ensureAllRowsInRangeHaveHeightsCalculated(topPixel, bottomPixel) {
    const res = this.paginationProxy.ensureRowHeightsValid(topPixel, bottomPixel, -1, -1);
    if (res) {
      this.updateContainerHeights();
    }
    return res;
  }
  getFirstVisibleVerticalPixel() {
    return this.firstVisibleVPixel;
  }
  getFirstVirtualRenderedRow() {
    return this.firstRenderedRow;
  }
  getLastVirtualRenderedRow() {
    return this.lastRenderedRow;
  }
  doNotUnVirtualiseRow(rowComp) {
    const REMOVE_ROW = false;
    const KEEP_ROW = true;
    const rowNode = rowComp.getRowNode();
    const rowHasFocus = this.focusService.isRowNodeFocused(rowNode);
    const rowIsEditing = rowComp.isEditing();
    const rowIsDetail = rowNode.detail;
    const mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail;
    if (!mightWantToKeepRow) {
      return REMOVE_ROW;
    }
    const rowNodePresent = this.paginationProxy.isRowPresent(rowNode);
    return rowNodePresent ? KEEP_ROW : REMOVE_ROW;
  }
  createRowCon(rowNode, animate, afterScroll) {
    const rowCtrlFromCache = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(rowNode) : null;
    if (rowCtrlFromCache) {
      return rowCtrlFromCache;
    }
    const suppressAnimationFrame = this.gridOptionsService.is("suppressAnimationFrame");
    const useAnimationFrameForCreate = afterScroll && !suppressAnimationFrame && !this.printLayout;
    const res = new RowCtrl(rowNode, this.beans, animate, useAnimationFrameForCreate, this.printLayout);
    return res;
  }
  getRenderedNodes() {
    const renderedRows = this.rowCtrlsByRowIndex;
    return Object.keys(renderedRows).map((key) => renderedRows[key].getRowNode());
  }
  getRowByPosition(rowPosition) {
    let rowCtrl;
    const { rowIndex } = rowPosition;
    switch (rowPosition.rowPinned) {
      case "top":
        rowCtrl = this.topRowCtrls[rowIndex];
        break;
      case "bottom":
        rowCtrl = this.bottomRowCtrls[rowIndex];
        break;
      default:
        rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
        if (!rowCtrl) {
          rowCtrl = this.getStickyTopRowCtrls().find((ctrl) => ctrl.getRowNode().rowIndex === rowIndex) || null;
        }
        break;
    }
    return rowCtrl;
  }
  getRowNode(gridRow) {
    switch (gridRow.rowPinned) {
      case "top":
        return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];
      case "bottom":
        return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];
      default:
        return this.rowModel.getRow(gridRow.rowIndex);
    }
  }
  isRangeInRenderedViewport(startIndex, endIndex) {
    const parentClosed = startIndex == null || endIndex == null;
    if (parentClosed) {
      return false;
    }
    const blockAfterViewport = startIndex > this.lastRenderedRow;
    const blockBeforeViewport = endIndex < this.firstRenderedRow;
    const blockInsideViewport = !blockBeforeViewport && !blockAfterViewport;
    return blockInsideViewport;
  }
};
__decorate$15([
  Autowired("animationFrameService")
], RowRenderer.prototype, "animationFrameService", void 0);
__decorate$15([
  Autowired("paginationProxy")
], RowRenderer.prototype, "paginationProxy", void 0);
__decorate$15([
  Autowired("columnModel")
], RowRenderer.prototype, "columnModel", void 0);
__decorate$15([
  Autowired("pinnedRowModel")
], RowRenderer.prototype, "pinnedRowModel", void 0);
__decorate$15([
  Autowired("rowModel")
], RowRenderer.prototype, "rowModel", void 0);
__decorate$15([
  Autowired("focusService")
], RowRenderer.prototype, "focusService", void 0);
__decorate$15([
  Autowired("beans")
], RowRenderer.prototype, "beans", void 0);
__decorate$15([
  Autowired("rowContainerHeightService")
], RowRenderer.prototype, "rowContainerHeightService", void 0);
__decorate$15([
  Autowired("ctrlsService")
], RowRenderer.prototype, "ctrlsService", void 0);
__decorate$15([
  PostConstruct
], RowRenderer.prototype, "postConstruct", null);
RowRenderer = __decorate$15([
  Bean("rowRenderer")
], RowRenderer);
var RowCtrlCache = class {
  constructor(maxCount) {
    this.entriesMap = {};
    this.entriesList = [];
    this.maxCount = maxCount;
  }
  addRow(rowCtrl) {
    this.entriesMap[rowCtrl.getRowNode().id] = rowCtrl;
    this.entriesList.push(rowCtrl);
    rowCtrl.setCached(true);
    if (this.entriesList.length > this.maxCount) {
      const rowCtrlToDestroy = this.entriesList[0];
      rowCtrlToDestroy.destroyFirstPass();
      rowCtrlToDestroy.destroySecondPass();
      this.removeFromCache(rowCtrlToDestroy);
    }
  }
  getRow(rowNode) {
    if (rowNode == null || rowNode.id == null) {
      return null;
    }
    const res = this.entriesMap[rowNode.id];
    if (!res) {
      return null;
    }
    this.removeFromCache(res);
    res.setCached(false);
    const rowNodeMismatch = res.getRowNode() != rowNode;
    return rowNodeMismatch ? null : res;
  }
  removeFromCache(rowCtrl) {
    const rowNodeId = rowCtrl.getRowNode().id;
    delete this.entriesMap[rowNodeId];
    removeFromArray(this.entriesList, rowCtrl);
  }
  getEntries() {
    return this.entriesList;
  }
};
var __decorate$14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ValueFormatterService = class ValueFormatterService2 extends BeanStub {
  formatValue(column, node, value, suppliedFormatter, useFormatterFromColumn = true) {
    let result = null;
    let formatter;
    const colDef = column.getColDef();
    if (suppliedFormatter) {
      formatter = suppliedFormatter;
    } else if (useFormatterFromColumn) {
      formatter = colDef.valueFormatter;
    }
    if (formatter) {
      const params = {
        value,
        node,
        data: node ? node.data : null,
        colDef,
        column,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      };
      if (typeof formatter === "function") {
        result = formatter(params);
      } else {
        result = this.expressionService.evaluate(formatter, params);
      }
    } else if (colDef.refData) {
      return colDef.refData[value] || "";
    }
    if (result == null && Array.isArray(value)) {
      result = value.join(", ");
    }
    return result;
  }
};
__decorate$14([
  Autowired("expressionService")
], ValueFormatterService.prototype, "expressionService", void 0);
ValueFormatterService = __decorate$14([
  Bean("valueFormatterService")
], ValueFormatterService);
var __decorate$13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PinnedRowModel = class PinnedRowModel2 extends BeanStub {
  init() {
    this.setPinnedTopRowData(this.gridOptionsService.get("pinnedTopRowData"));
    this.setPinnedBottomRowData(this.gridOptionsService.get("pinnedBottomRowData"));
  }
  isEmpty(floating) {
    const rows = floating === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
    return missingOrEmpty(rows);
  }
  isRowsToRender(floating) {
    return !this.isEmpty(floating);
  }
  getRowAtPixel(pixel, floating) {
    const rows = floating === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
    if (missingOrEmpty(rows)) {
      return 0;
    }
    for (let i = 0; i < rows.length; i++) {
      const rowNode = rows[i];
      const rowTopPixel = rowNode.rowTop + rowNode.rowHeight - 1;
      if (rowTopPixel >= pixel) {
        return i;
      }
    }
    return rows.length - 1;
  }
  setPinnedTopRowData(rowData) {
    this.pinnedTopRows = this.createNodesFromData(rowData, true);
    const event = {
      type: Events.EVENT_PINNED_ROW_DATA_CHANGED
    };
    this.eventService.dispatchEvent(event);
  }
  setPinnedBottomRowData(rowData) {
    this.pinnedBottomRows = this.createNodesFromData(rowData, false);
    const event = {
      type: Events.EVENT_PINNED_ROW_DATA_CHANGED
    };
    this.eventService.dispatchEvent(event);
  }
  createNodesFromData(allData, isTop) {
    const rowNodes = [];
    if (allData) {
      let nextRowTop = 0;
      allData.forEach((dataItem, index) => {
        const rowNode = new RowNode(this.beans);
        rowNode.data = dataItem;
        const idPrefix = isTop ? RowNode.ID_PREFIX_TOP_PINNED : RowNode.ID_PREFIX_BOTTOM_PINNED;
        rowNode.id = idPrefix + index;
        rowNode.rowPinned = isTop ? "top" : "bottom";
        rowNode.setRowTop(nextRowTop);
        rowNode.setRowHeight(this.gridOptionsService.getRowHeightForNode(rowNode).height);
        rowNode.setRowIndex(index);
        nextRowTop += rowNode.rowHeight;
        rowNodes.push(rowNode);
      });
    }
    return rowNodes;
  }
  getPinnedTopRowData() {
    return this.pinnedTopRows;
  }
  getPinnedBottomRowData() {
    return this.pinnedBottomRows;
  }
  getPinnedTopTotalHeight() {
    return this.getTotalHeight(this.pinnedTopRows);
  }
  getPinnedTopRowCount() {
    return this.pinnedTopRows ? this.pinnedTopRows.length : 0;
  }
  getPinnedBottomRowCount() {
    return this.pinnedBottomRows ? this.pinnedBottomRows.length : 0;
  }
  getPinnedTopRow(index) {
    return this.pinnedTopRows[index];
  }
  getPinnedBottomRow(index) {
    return this.pinnedBottomRows[index];
  }
  forEachPinnedTopRow(callback) {
    if (missingOrEmpty(this.pinnedTopRows)) {
      return;
    }
    this.pinnedTopRows.forEach(callback);
  }
  forEachPinnedBottomRow(callback) {
    if (missingOrEmpty(this.pinnedBottomRows)) {
      return;
    }
    this.pinnedBottomRows.forEach(callback);
  }
  getPinnedBottomTotalHeight() {
    return this.getTotalHeight(this.pinnedBottomRows);
  }
  getTotalHeight(rowNodes) {
    if (!rowNodes || rowNodes.length === 0) {
      return 0;
    }
    const lastNode = last(rowNodes);
    return lastNode.rowTop + lastNode.rowHeight;
  }
};
__decorate$13([
  Autowired("beans")
], PinnedRowModel.prototype, "beans", void 0);
__decorate$13([
  PostConstruct
], PinnedRowModel.prototype, "init", null);
PinnedRowModel = __decorate$13([
  Bean("pinnedRowModel")
], PinnedRowModel);
var ServerSideTransactionResultStatus;
(function(ServerSideTransactionResultStatus2) {
  ServerSideTransactionResultStatus2["Applied"] = "Applied";
  ServerSideTransactionResultStatus2["StoreNotFound"] = "StoreNotFound";
  ServerSideTransactionResultStatus2["StoreLoading"] = "StoreLoading";
  ServerSideTransactionResultStatus2["StoreWaitingToLoad"] = "StoreWaitingToLoad";
  ServerSideTransactionResultStatus2["StoreLoadingFailed"] = "StoreLoadingFailed";
  ServerSideTransactionResultStatus2["StoreWrongType"] = "StoreWrongType";
  ServerSideTransactionResultStatus2["Cancelled"] = "Cancelled";
})(ServerSideTransactionResultStatus || (ServerSideTransactionResultStatus = {}));
var ChangedPath = class {
  constructor(keepingColumns, rootNode) {
    this.active = true;
    this.nodeIdsToColumns = {};
    this.mapToItems = {};
    this.keepingColumns = keepingColumns;
    this.pathRoot = {
      rowNode: rootNode,
      children: null
    };
    this.mapToItems[rootNode.id] = this.pathRoot;
  }
  setInactive() {
    this.active = false;
  }
  isActive() {
    return this.active;
  }
  depthFirstSearchChangedPath(pathItem, callback) {
    if (pathItem.children) {
      for (let i = 0; i < pathItem.children.length; i++) {
        this.depthFirstSearchChangedPath(pathItem.children[i], callback);
      }
    }
    callback(pathItem.rowNode);
  }
  depthFirstSearchEverything(rowNode, callback, traverseEverything) {
    if (rowNode.childrenAfterGroup) {
      for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {
        const childNode = rowNode.childrenAfterGroup[i];
        if (childNode.childrenAfterGroup) {
          this.depthFirstSearchEverything(rowNode.childrenAfterGroup[i], callback, traverseEverything);
        } else if (traverseEverything) {
          callback(childNode);
        }
      }
    }
    callback(rowNode);
  }
  forEachChangedNodeDepthFirst(callback, traverseLeafNodes = false, includeUnchangedNodes = false) {
    if (this.active && !includeUnchangedNodes) {
      this.depthFirstSearchChangedPath(this.pathRoot, callback);
    } else {
      this.depthFirstSearchEverything(this.pathRoot.rowNode, callback, traverseLeafNodes);
    }
  }
  executeFromRootNode(callback) {
    callback(this.pathRoot.rowNode);
  }
  createPathItems(rowNode) {
    let pointer = rowNode;
    let newEntryCount = 0;
    while (!this.mapToItems[pointer.id]) {
      const newEntry = {
        rowNode: pointer,
        children: null
      };
      this.mapToItems[pointer.id] = newEntry;
      newEntryCount++;
      pointer = pointer.parent;
    }
    return newEntryCount;
  }
  populateColumnsMap(rowNode, columns) {
    if (!this.keepingColumns || !columns) {
      return;
    }
    let pointer = rowNode;
    while (pointer) {
      if (!this.nodeIdsToColumns[pointer.id]) {
        this.nodeIdsToColumns[pointer.id] = {};
      }
      columns.forEach((col) => this.nodeIdsToColumns[pointer.id][col.getId()] = true);
      pointer = pointer.parent;
    }
  }
  linkPathItems(rowNode, newEntryCount) {
    let pointer = rowNode;
    for (let i = 0; i < newEntryCount; i++) {
      const thisItem = this.mapToItems[pointer.id];
      const parentItem = this.mapToItems[pointer.parent.id];
      if (!parentItem.children) {
        parentItem.children = [];
      }
      parentItem.children.push(thisItem);
      pointer = pointer.parent;
    }
  }
  addParentNode(rowNode, columns) {
    if (!rowNode || rowNode.isRowPinned()) {
      return;
    }
    const newEntryCount = this.createPathItems(rowNode);
    this.linkPathItems(rowNode, newEntryCount);
    this.populateColumnsMap(rowNode, columns);
  }
  canSkip(rowNode) {
    return this.active && !this.mapToItems[rowNode.id];
  }
  getValueColumnsForNode(rowNode, valueColumns) {
    if (!this.keepingColumns) {
      return valueColumns;
    }
    const colsForThisNode = this.nodeIdsToColumns[rowNode.id];
    const result = valueColumns.filter((col) => colsForThisNode[col.getId()]);
    return result;
  }
  getNotValueColumnsForNode(rowNode, valueColumns) {
    if (!this.keepingColumns) {
      return null;
    }
    const colsForThisNode = this.nodeIdsToColumns[rowNode.id];
    const result = valueColumns.filter((col) => !colsForThisNode[col.getId()]);
    return result;
  }
};
var RowNodeBlock = class extends BeanStub {
  constructor(id) {
    super();
    this.state = RowNodeBlock.STATE_WAITING_TO_LOAD;
    this.version = 0;
    this.id = id;
  }
  getId() {
    return this.id;
  }
  load() {
    this.state = RowNodeBlock.STATE_LOADING;
    this.loadFromDatasource();
  }
  getVersion() {
    return this.version;
  }
  setStateWaitingToLoad() {
    this.version++;
    this.state = RowNodeBlock.STATE_WAITING_TO_LOAD;
  }
  getState() {
    return this.state;
  }
  pageLoadFailed(version) {
    const requestMostRecentAndLive = this.isRequestMostRecentAndLive(version);
    if (requestMostRecentAndLive) {
      this.state = RowNodeBlock.STATE_FAILED;
      this.processServerFail();
    }
    this.dispatchLoadCompleted(false);
  }
  success(version, params) {
    this.successCommon(version, params);
  }
  pageLoaded(version, rows, lastRow) {
    this.successCommon(version, { rowData: rows, rowCount: lastRow });
  }
  isRequestMostRecentAndLive(version) {
    const thisIsMostRecentRequest = version === this.version;
    const weAreNotDestroyed = this.isAlive();
    return thisIsMostRecentRequest && weAreNotDestroyed;
  }
  successCommon(version, params) {
    this.dispatchLoadCompleted();
    const requestMostRecentAndLive = this.isRequestMostRecentAndLive(version);
    if (requestMostRecentAndLive) {
      this.state = RowNodeBlock.STATE_LOADED;
      this.processServerResult(params);
    }
  }
  dispatchLoadCompleted(success = true) {
    const event = {
      type: RowNodeBlock.EVENT_LOAD_COMPLETE,
      success,
      block: this
    };
    this.dispatchEvent(event);
  }
};
RowNodeBlock.EVENT_LOAD_COMPLETE = "loadComplete";
RowNodeBlock.STATE_WAITING_TO_LOAD = "needsLoading";
RowNodeBlock.STATE_LOADING = "loading";
RowNodeBlock.STATE_LOADED = "loaded";
RowNodeBlock.STATE_FAILED = "failed";
var __decorate$12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$7 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RowNodeBlockLoader_1;
var RowNodeBlockLoader = RowNodeBlockLoader_1 = class RowNodeBlockLoader2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.activeBlockLoadsCount = 0;
    this.blocks = [];
    this.active = true;
  }
  postConstruct() {
    this.maxConcurrentRequests = this.getMaxConcurrentDatasourceRequests();
    const blockLoadDebounceMillis = this.gridOptionsService.getNum("blockLoadDebounceMillis");
    if (blockLoadDebounceMillis && blockLoadDebounceMillis > 0) {
      this.checkBlockToLoadDebounce = _.debounce(this.performCheckBlocksToLoad.bind(this), blockLoadDebounceMillis);
    }
  }
  setBeans(loggerFactory) {
    this.logger = loggerFactory.create("RowNodeBlockLoader");
  }
  getMaxConcurrentDatasourceRequests() {
    const res = this.gridOptionsService.getNum("maxConcurrentDatasourceRequests");
    if (res == null) {
      return 2;
    }
    if (res <= 0) {
      return;
    }
    return res;
  }
  addBlock(block) {
    this.blocks.push(block);
    block.addEventListener(RowNodeBlock.EVENT_LOAD_COMPLETE, this.loadComplete.bind(this));
    this.checkBlockToLoad();
  }
  removeBlock(block) {
    _.removeFromArray(this.blocks, block);
  }
  destroy() {
    super.destroy();
    this.active = false;
  }
  loadComplete() {
    this.activeBlockLoadsCount--;
    this.checkBlockToLoad();
    this.dispatchEvent({ type: RowNodeBlockLoader_1.BLOCK_LOADED_EVENT });
    if (this.activeBlockLoadsCount == 0) {
      this.dispatchEvent({ type: RowNodeBlockLoader_1.BLOCK_LOADER_FINISHED_EVENT });
    }
  }
  checkBlockToLoad() {
    if (this.checkBlockToLoadDebounce) {
      this.checkBlockToLoadDebounce();
    } else {
      this.performCheckBlocksToLoad();
    }
  }
  performCheckBlocksToLoad() {
    if (!this.active) {
      return;
    }
    this.printCacheStatus();
    if (this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
      this.logger.log(`checkBlockToLoad: max loads exceeded`);
      return;
    }
    const loadAvailability = this.getAvailableLoadingCount();
    const blocksToLoad = this.blocks.filter((block) => block.getState() === RowNodeBlock.STATE_WAITING_TO_LOAD).slice(0, loadAvailability);
    this.registerLoads(blocksToLoad.length);
    blocksToLoad.forEach((block) => block.load());
    this.printCacheStatus();
  }
  getBlockState() {
    if (this.gridOptionsService.isRowModelType("serverSide")) {
      const ssrm = this.rowModel;
      return ssrm.getBlockStates();
    }
    const result = {};
    this.blocks.forEach((block) => {
      const { id, state } = block.getBlockStateJson();
      result[id] = state;
    });
    return result;
  }
  printCacheStatus() {
    if (this.logger.isLogging()) {
      this.logger.log(`printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount}, blocks = ${JSON.stringify(this.getBlockState())}`);
    }
  }
  isLoading() {
    return this.activeBlockLoadsCount > 0;
  }
  registerLoads(count) {
    this.activeBlockLoadsCount += count;
  }
  getAvailableLoadingCount() {
    return this.maxConcurrentRequests !== void 0 ? this.maxConcurrentRequests - this.activeBlockLoadsCount : void 0;
  }
};
RowNodeBlockLoader.BLOCK_LOADED_EVENT = "blockLoaded";
RowNodeBlockLoader.BLOCK_LOADER_FINISHED_EVENT = "blockLoaderFinished";
__decorate$12([
  Autowired("rowModel")
], RowNodeBlockLoader.prototype, "rowModel", void 0);
__decorate$12([
  PostConstruct
], RowNodeBlockLoader.prototype, "postConstruct", null);
__decorate$12([
  __param$7(0, Qualifier("loggerFactory"))
], RowNodeBlockLoader.prototype, "setBeans", null);
RowNodeBlockLoader = RowNodeBlockLoader_1 = __decorate$12([
  Bean("rowNodeBlockLoader")
], RowNodeBlockLoader);
var __decorate$11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PaginationProxy = class PaginationProxy2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.currentPage = 0;
    this.topDisplayedRowIndex = 0;
    this.bottomDisplayedRowIndex = 0;
    this.pixelOffset = 0;
    this.masterRowCount = 0;
  }
  postConstruct() {
    this.active = this.gridOptionsService.is("pagination");
    this.paginateChildRows = this.isPaginateChildRows();
    this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, this.onModelUpdated.bind(this));
    this.addManagedPropertyListener("pagination", this.onPaginationPageSizeChanged.bind(this));
    this.addManagedPropertyListener("paginationPageSize", this.onPaginationPageSizeChanged.bind(this));
    this.onModelUpdated();
  }
  ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) {
    const res = this.rowModel.ensureRowHeightsValid(startPixel, endPixel, this.getPageFirstRow(), this.getPageLastRow());
    if (res) {
      this.calculatePages();
    }
    return res;
  }
  isPaginateChildRows() {
    const shouldPaginate = this.gridOptionsService.is("groupRemoveSingleChildren") || this.gridOptionsService.is("groupRemoveLowestSingleChildren");
    if (shouldPaginate) {
      return true;
    }
    return this.gridOptionsService.is("paginateChildRows");
  }
  onModelUpdated(modelUpdatedEvent) {
    this.calculatePages();
    const paginationChangedEvent = {
      type: Events.EVENT_PAGINATION_CHANGED,
      animate: modelUpdatedEvent ? modelUpdatedEvent.animate : false,
      newData: modelUpdatedEvent ? modelUpdatedEvent.newData : false,
      newPage: modelUpdatedEvent ? modelUpdatedEvent.newPage : false,
      keepRenderedRows: modelUpdatedEvent ? modelUpdatedEvent.keepRenderedRows : false
    };
    this.eventService.dispatchEvent(paginationChangedEvent);
  }
  onPaginationPageSizeChanged() {
    this.active = this.gridOptionsService.is("pagination");
    this.calculatePages();
    const paginationChangedEvent = {
      type: Events.EVENT_PAGINATION_CHANGED,
      animate: false,
      newData: false,
      newPage: false,
      keepRenderedRows: true
    };
    this.eventService.dispatchEvent(paginationChangedEvent);
  }
  goToPage(page) {
    if (!this.active || this.currentPage === page || typeof this.currentPage !== "number") {
      return;
    }
    this.currentPage = page;
    const event = {
      type: Events.EVENT_MODEL_UPDATED,
      animate: false,
      keepRenderedRows: false,
      newData: false,
      newPage: true
    };
    this.onModelUpdated(event);
  }
  getPixelOffset() {
    return this.pixelOffset;
  }
  getRow(index) {
    return this.rowModel.getRow(index);
  }
  getRowNode(id) {
    return this.rowModel.getRowNode(id);
  }
  getRowIndexAtPixel(pixel) {
    return this.rowModel.getRowIndexAtPixel(pixel);
  }
  getCurrentPageHeight() {
    if (missing(this.topRowBounds) || missing(this.bottomRowBounds)) {
      return 0;
    }
    return Math.max(this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight - this.topRowBounds.rowTop, 0);
  }
  getCurrentPagePixelRange() {
    const pageFirstPixel = this.topRowBounds ? this.topRowBounds.rowTop : 0;
    const pageLastPixel = this.bottomRowBounds ? this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight : 0;
    return { pageFirstPixel, pageLastPixel };
  }
  isRowPresent(rowNode) {
    if (!this.rowModel.isRowPresent(rowNode)) {
      return false;
    }
    const nodeIsInPage = rowNode.rowIndex >= this.topDisplayedRowIndex && rowNode.rowIndex <= this.bottomDisplayedRowIndex;
    return nodeIsInPage;
  }
  isEmpty() {
    return this.rowModel.isEmpty();
  }
  isRowsToRender() {
    return this.rowModel.isRowsToRender();
  }
  forEachNode(callback) {
    return this.rowModel.forEachNode(callback);
  }
  forEachNodeOnPage(callback) {
    const firstRow = this.getPageFirstRow();
    const lastRow = this.getPageLastRow();
    for (let i = firstRow; i <= lastRow; i++) {
      const node = this.getRow(i);
      if (node) {
        callback(node);
      }
    }
  }
  getType() {
    return this.rowModel.getType();
  }
  getRowBounds(index) {
    const res = this.rowModel.getRowBounds(index);
    res.rowIndex = index;
    return res;
  }
  getPageFirstRow() {
    return this.topRowBounds ? this.topRowBounds.rowIndex : -1;
  }
  getPageLastRow() {
    return this.bottomRowBounds ? this.bottomRowBounds.rowIndex : -1;
  }
  getRowCount() {
    return this.rowModel.getRowCount();
  }
  getPageForIndex(index) {
    return Math.floor(index / this.pageSize);
  }
  goToPageWithIndex(index) {
    if (!this.active) {
      return;
    }
    const pageNumber = this.getPageForIndex(index);
    this.goToPage(pageNumber);
  }
  isRowInPage(row) {
    if (!this.active) {
      return true;
    }
    const rowPage = this.getPageForIndex(row.rowIndex);
    return rowPage === this.currentPage;
  }
  isLastPageFound() {
    return this.rowModel.isLastRowIndexKnown();
  }
  getCurrentPage() {
    return this.currentPage;
  }
  goToNextPage() {
    this.goToPage(this.currentPage + 1);
  }
  goToPreviousPage() {
    this.goToPage(this.currentPage - 1);
  }
  goToFirstPage() {
    this.goToPage(0);
  }
  goToLastPage() {
    const rowCount = this.rowModel.getRowCount();
    const lastPage = Math.floor(rowCount / this.pageSize);
    this.goToPage(lastPage);
  }
  getPageSize() {
    return this.pageSize;
  }
  getTotalPages() {
    return this.totalPages;
  }
  setPageSize() {
    this.pageSize = this.gridOptionsService.getNum("paginationPageSize");
    if (this.pageSize == null || this.pageSize < 1) {
      this.pageSize = 100;
    }
  }
  calculatePages() {
    if (this.active) {
      this.setPageSize();
      if (this.paginateChildRows) {
        this.calculatePagesAllRows();
      } else {
        this.calculatePagesMasterRowsOnly();
      }
    } else {
      this.calculatedPagesNotActive();
    }
    this.topRowBounds = this.rowModel.getRowBounds(this.topDisplayedRowIndex);
    if (this.topRowBounds) {
      this.topRowBounds.rowIndex = this.topDisplayedRowIndex;
    }
    this.bottomRowBounds = this.rowModel.getRowBounds(this.bottomDisplayedRowIndex);
    if (this.bottomRowBounds) {
      this.bottomRowBounds.rowIndex = this.bottomDisplayedRowIndex;
    }
    this.setPixelOffset(exists(this.topRowBounds) ? this.topRowBounds.rowTop : 0);
  }
  setPixelOffset(value) {
    if (this.pixelOffset === value) {
      return;
    }
    this.pixelOffset = value;
    this.eventService.dispatchEvent({ type: Events.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED });
  }
  setZeroRows() {
    this.masterRowCount = 0;
    this.topDisplayedRowIndex = 0;
    this.bottomDisplayedRowIndex = -1;
    this.currentPage = 0;
    this.totalPages = 0;
  }
  adjustCurrentPageIfInvalid() {
    if (this.currentPage >= this.totalPages) {
      this.currentPage = this.totalPages - 1;
    }
    if (!isFinite(this.currentPage) || isNaN(this.currentPage) || this.currentPage < 0) {
      this.currentPage = 0;
    }
  }
  calculatePagesMasterRowsOnly() {
    this.masterRowCount = this.rowModel.getTopLevelRowCount();
    if (this.masterRowCount <= 0) {
      this.setZeroRows();
      return;
    }
    const masterLastRowIndex = this.masterRowCount - 1;
    this.totalPages = Math.floor(masterLastRowIndex / this.pageSize) + 1;
    this.adjustCurrentPageIfInvalid();
    const masterPageStartIndex = this.pageSize * this.currentPage;
    let masterPageEndIndex = this.pageSize * (this.currentPage + 1) - 1;
    if (masterPageEndIndex > masterLastRowIndex) {
      masterPageEndIndex = masterLastRowIndex;
    }
    this.topDisplayedRowIndex = this.rowModel.getTopLevelRowDisplayedIndex(masterPageStartIndex);
    if (masterPageEndIndex === masterLastRowIndex) {
      this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
    } else {
      const firstIndexNotToShow = this.rowModel.getTopLevelRowDisplayedIndex(masterPageEndIndex + 1);
      this.bottomDisplayedRowIndex = firstIndexNotToShow - 1;
    }
  }
  getMasterRowCount() {
    return this.masterRowCount;
  }
  calculatePagesAllRows() {
    this.masterRowCount = this.rowModel.getRowCount();
    if (this.masterRowCount === 0) {
      this.setZeroRows();
      return;
    }
    const maxRowIndex = this.masterRowCount - 1;
    this.totalPages = Math.floor(maxRowIndex / this.pageSize) + 1;
    this.adjustCurrentPageIfInvalid();
    this.topDisplayedRowIndex = this.pageSize * this.currentPage;
    this.bottomDisplayedRowIndex = this.pageSize * (this.currentPage + 1) - 1;
    if (this.bottomDisplayedRowIndex > maxRowIndex) {
      this.bottomDisplayedRowIndex = maxRowIndex;
    }
  }
  calculatedPagesNotActive() {
    this.pageSize = this.rowModel.getRowCount();
    this.totalPages = 1;
    this.currentPage = 0;
    this.topDisplayedRowIndex = 0;
    this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
  }
};
__decorate$11([
  Autowired("rowModel")
], PaginationProxy.prototype, "rowModel", void 0);
__decorate$11([
  PostConstruct
], PaginationProxy.prototype, "postConstruct", null);
PaginationProxy = __decorate$11([
  Bean("paginationProxy")
], PaginationProxy);
var __decorate$10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var StylingService = class StylingService2 extends BeanStub {
  processAllCellClasses(colDef, params, onApplicableClass, onNotApplicableClass) {
    this.processClassRules(colDef.cellClassRules, params, onApplicableClass, onNotApplicableClass);
    this.processStaticCellClasses(colDef, params, onApplicableClass);
  }
  processClassRules(classRules, params, onApplicableClass, onNotApplicableClass) {
    if (classRules == null) {
      return;
    }
    const classNames = Object.keys(classRules);
    const classesToApply = {};
    const classesToRemove = {};
    for (let i = 0; i < classNames.length; i++) {
      const className = classNames[i];
      const rule = classRules[className];
      let resultOfRule;
      if (typeof rule === "string") {
        resultOfRule = this.expressionService.evaluate(rule, params);
      } else if (typeof rule === "function") {
        resultOfRule = rule(params);
      }
      className.split(" ").forEach((singleClass) => {
        if (singleClass == null || singleClass.trim() == "") {
          return;
        }
        resultOfRule ? classesToApply[singleClass] = true : classesToRemove[singleClass] = true;
      });
    }
    if (onNotApplicableClass) {
      Object.keys(classesToRemove).forEach(onNotApplicableClass);
    }
    Object.keys(classesToApply).forEach(onApplicableClass);
  }
  getStaticCellClasses(colDef, params) {
    const { cellClass } = colDef;
    if (!cellClass) {
      return [];
    }
    let classOrClasses;
    if (typeof cellClass === "function") {
      const cellClassFunc = cellClass;
      classOrClasses = cellClassFunc(params);
    } else {
      classOrClasses = cellClass;
    }
    if (typeof classOrClasses === "string") {
      classOrClasses = [classOrClasses];
    }
    return classOrClasses || [];
  }
  processStaticCellClasses(colDef, params, onApplicableClass) {
    const classOrClasses = this.getStaticCellClasses(colDef, params);
    classOrClasses.forEach((cssClassItem) => {
      onApplicableClass(cssClassItem);
    });
  }
};
__decorate$10([
  Autowired("expressionService")
], StylingService.prototype, "expressionService", void 0);
StylingService = __decorate$10([
  Bean("stylingService")
], StylingService);
var AgToggleButton = class extends AgCheckbox {
  constructor(config) {
    super(config, "ag-toggle-button");
  }
  setValue(value, silent) {
    super.setValue(value, silent);
    this.addOrRemoveCssClass("ag-selected", this.getValue());
    return this;
  }
};
var AgInputTextArea = class extends AgAbstractInputField {
  constructor(config) {
    super(config, "ag-text-area", null, "textarea");
  }
  setValue(value, silent) {
    const ret = super.setValue(value, silent);
    this.eInput.value = value;
    return ret;
  }
  setCols(cols) {
    this.eInput.cols = cols;
    return this;
  }
  setRows(rows) {
    this.eInput.rows = rows;
    return this;
  }
};
var AgInputDateField = class extends AgInputTextField {
  constructor(config) {
    super(config, "ag-date-field", "date");
  }
  postConstruct() {
    super.postConstruct();
    this.addManagedListener(this.eInput, "wheel", this.onWheel.bind(this));
    const usingSafari = isBrowserSafari();
    this.addManagedListener(this.eInput, "mousedown", () => {
      if (this.isDisabled() || usingSafari) {
        return;
      }
      this.eInput.focus();
    });
    this.eInput.step = "any";
  }
  onWheel(e) {
    if (document.activeElement === this.eInput) {
      e.preventDefault();
    }
  }
  setMin(minDate) {
    var _a;
    const min = minDate instanceof Date ? (_a = serialiseDate(minDate !== null && minDate !== void 0 ? minDate : null, false)) !== null && _a !== void 0 ? _a : void 0 : minDate;
    if (this.min === min) {
      return this;
    }
    this.min = min;
    addOrRemoveAttribute(this.eInput, "min", min);
    return this;
  }
  setMax(maxDate) {
    var _a;
    const max = maxDate instanceof Date ? (_a = serialiseDate(maxDate !== null && maxDate !== void 0 ? maxDate : null, false)) !== null && _a !== void 0 ? _a : void 0 : maxDate;
    if (this.max === max) {
      return this;
    }
    this.max = max;
    addOrRemoveAttribute(this.eInput, "max", max);
    return this;
  }
  setStep(step) {
    if (this.step === step) {
      return this;
    }
    this.step = step;
    addOrRemoveAttribute(this.eInput, "step", step);
    return this;
  }
  getDate() {
    var _a;
    if (!this.eInput.validity.valid) {
      return void 0;
    }
    return (_a = parseDateTimeFromString(this.getValue())) !== null && _a !== void 0 ? _a : void 0;
  }
  setDate(date, silent) {
    this.setValue(serialiseDate(date !== null && date !== void 0 ? date : null, false), silent);
  }
};
var AgInputRange = class extends AgAbstractInputField {
  constructor(config) {
    super(config, "ag-range-field", "range");
  }
  postConstruct() {
    super.postConstruct();
    const { min, max, step } = this.config;
    if (min != null) {
      this.setMinValue(min);
    }
    if (max != null) {
      this.setMaxValue(max);
    }
    this.setStep(step || 1);
  }
  addInputListeners() {
    this.addManagedListener(this.eInput, "input", (e) => {
      const value = e.target.value;
      this.setValue(value);
    });
  }
  setMinValue(value) {
    this.min = value;
    this.eInput.setAttribute("min", value.toString());
    return this;
  }
  setMaxValue(value) {
    this.max = value;
    this.eInput.setAttribute("max", value.toString());
    return this;
  }
  setStep(value) {
    this.eInput.setAttribute("step", value.toString());
    return this;
  }
  setValue(value, silent) {
    if (this.min != null) {
      value = Math.max(parseFloat(value), this.min).toString();
    }
    if (this.max != null) {
      value = Math.min(parseFloat(value), this.max).toString();
    }
    const ret = super.setValue(value, silent);
    this.eInput.value = value;
    return ret;
  }
};
var __decorate$$ = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AgSlider = class extends AgAbstractLabel {
  constructor(config) {
    super(config, AgSlider.TEMPLATE);
    this.labelAlignment = "top";
  }
  init() {
    this.eSlider.addCssClass("ag-slider-field");
  }
  onValueChange(callbackFn) {
    const eventChanged = AgAbstractField.EVENT_CHANGED;
    this.addManagedListener(this.eText, eventChanged, () => {
      const textValue = parseFloat(this.eText.getValue());
      this.eSlider.setValue(textValue.toString(), true);
      callbackFn(textValue || 0);
    });
    this.addManagedListener(this.eSlider, eventChanged, () => {
      const sliderValue = this.eSlider.getValue();
      this.eText.setValue(sliderValue, true);
      callbackFn(parseFloat(sliderValue));
    });
    return this;
  }
  setSliderWidth(width) {
    this.eSlider.setWidth(width);
    return this;
  }
  setTextFieldWidth(width) {
    this.eText.setWidth(width);
    return this;
  }
  setMinValue(minValue) {
    this.eSlider.setMinValue(minValue);
    this.eText.setMin(minValue);
    return this;
  }
  setMaxValue(maxValue) {
    this.eSlider.setMaxValue(maxValue);
    this.eText.setMax(maxValue);
    return this;
  }
  getValue() {
    return this.eText.getValue();
  }
  setValue(value) {
    if (this.getValue() === value) {
      return this;
    }
    this.eText.setValue(value, true);
    this.eSlider.setValue(value, true);
    this.dispatchEvent({ type: AgAbstractField.EVENT_CHANGED });
    return this;
  }
  setStep(step) {
    this.eSlider.setStep(step);
    this.eText.setStep(step);
    return this;
  }
};
AgSlider.TEMPLATE = `<div class="ag-slider">
            <label ref="eLabel"></label>
            <div class="ag-wrapper ag-slider-wrapper">
                <ag-input-range ref="eSlider"></ag-input-range>
                <ag-input-number-field ref="eText"></ag-input-number-field>
            </div>
        </div>`;
__decorate$$([
  RefSelector("eLabel")
], AgSlider.prototype, "eLabel", void 0);
__decorate$$([
  RefSelector("eSlider")
], AgSlider.prototype, "eSlider", void 0);
__decorate$$([
  RefSelector("eText")
], AgSlider.prototype, "eText", void 0);
__decorate$$([
  PostConstruct
], AgSlider.prototype, "init", null);
var __decorate$_ = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AgGroupComponent = class extends Component {
  constructor(params = {}) {
    super(AgGroupComponent.getTemplate(params));
    this.suppressEnabledCheckbox = true;
    this.suppressOpenCloseIcons = false;
    const { title, enabled, items, suppressEnabledCheckbox, suppressOpenCloseIcons } = params;
    this.title = title;
    this.cssIdentifier = params.cssIdentifier || "default";
    this.enabled = enabled != null ? enabled : true;
    this.items = items || [];
    this.alignItems = params.alignItems || "center";
    if (suppressEnabledCheckbox != null) {
      this.suppressEnabledCheckbox = suppressEnabledCheckbox;
    }
    if (suppressOpenCloseIcons != null) {
      this.suppressOpenCloseIcons = suppressOpenCloseIcons;
    }
  }
  static getTemplate(params) {
    const cssIdentifier = params.cssIdentifier || "default";
    const direction = params.direction || "vertical";
    return `<div class="ag-group ag-${cssIdentifier}-group" role="presentation">
            <div class="ag-group-title-bar ag-${cssIdentifier}-group-title-bar ag-unselectable" ref="eTitleBar" role="button">
                <span class="ag-group-title-bar-icon ag-${cssIdentifier}-group-title-bar-icon" ref="eGroupOpenedIcon" role="presentation"></span>
                <span class="ag-group-title-bar-icon ag-${cssIdentifier}-group-title-bar-icon" ref="eGroupClosedIcon" role="presentation"></span>
                <span ref="eTitle" class="ag-group-title ag-${cssIdentifier}-group-title"></span>
            </div>
            <div ref="eToolbar" class="ag-group-toolbar ag-${cssIdentifier}-group-toolbar">
                <ag-checkbox ref="cbGroupEnabled"></ag-checkbox>
            </div>
            <div ref="eContainer" class="ag-group-container ag-group-container-${direction} ag-${cssIdentifier}-group-container"></div>
        </div>`;
  }
  postConstruct() {
    if (this.items.length) {
      const initialItems = this.items;
      this.items = [];
      this.addItems(initialItems);
    }
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    this.cbGroupEnabled.setLabel(localeTextFunc("enabled", "Enabled"));
    if (this.title) {
      this.setTitle(this.title);
    }
    if (this.enabled) {
      this.setEnabled(this.enabled);
    }
    this.setAlignItems(this.alignItems);
    this.hideEnabledCheckbox(this.suppressEnabledCheckbox);
    this.hideOpenCloseIcons(this.suppressOpenCloseIcons);
    this.setupExpandContract();
    this.refreshAriaStatus();
    this.refreshChildDisplay();
  }
  setupExpandContract() {
    this.eGroupClosedIcon.appendChild(createIcon("columnSelectClosed", this.gridOptionsService, null));
    this.eGroupOpenedIcon.appendChild(createIcon("columnSelectOpen", this.gridOptionsService, null));
    this.addManagedListener(this.eTitleBar, "click", () => this.toggleGroupExpand());
    this.addManagedListener(this.eTitleBar, "keydown", (e) => {
      switch (e.key) {
        case KeyCode.ENTER:
        case KeyCode.SPACE:
          e.preventDefault();
          this.toggleGroupExpand();
          break;
        case KeyCode.RIGHT:
        case KeyCode.LEFT:
          e.preventDefault();
          this.toggleGroupExpand(e.key === KeyCode.RIGHT);
          break;
      }
    });
  }
  refreshAriaStatus() {
    if (!this.suppressOpenCloseIcons) {
      setAriaExpanded(this.eTitleBar, this.expanded);
    }
  }
  refreshChildDisplay() {
    const showIcon = !this.suppressOpenCloseIcons;
    setDisplayed(this.eToolbar, this.expanded && !this.suppressEnabledCheckbox);
    setDisplayed(this.eGroupOpenedIcon, showIcon && this.expanded);
    setDisplayed(this.eGroupClosedIcon, showIcon && !this.expanded);
  }
  isExpanded() {
    return this.expanded;
  }
  setAlignItems(alignment) {
    if (this.alignItems !== alignment) {
      this.removeCssClass(`ag-group-item-alignment-${this.alignItems}`);
    }
    this.alignItems = alignment;
    const newCls = `ag-group-item-alignment-${this.alignItems}`;
    this.addCssClass(newCls);
    return this;
  }
  toggleGroupExpand(expanded) {
    if (this.suppressOpenCloseIcons) {
      this.expanded = true;
      this.refreshChildDisplay();
      setDisplayed(this.eContainer, true);
      return this;
    }
    expanded = expanded != null ? expanded : !this.expanded;
    if (this.expanded === expanded) {
      return this;
    }
    this.expanded = expanded;
    this.refreshAriaStatus();
    this.refreshChildDisplay();
    setDisplayed(this.eContainer, expanded);
    this.dispatchEvent({ type: this.expanded ? AgGroupComponent.EVENT_EXPANDED : AgGroupComponent.EVENT_COLLAPSED });
    return this;
  }
  addItems(items) {
    items.forEach((item) => this.addItem(item));
  }
  addItem(item) {
    const container = this.eContainer;
    const el = item instanceof Component ? item.getGui() : item;
    el.classList.add("ag-group-item", `ag-${this.cssIdentifier}-group-item`);
    container.appendChild(el);
    this.items.push(el);
  }
  hideItem(hide, index) {
    const itemToHide = this.items[index];
    setDisplayed(itemToHide, !hide);
  }
  setTitle(title) {
    this.eTitle.innerText = title;
    return this;
  }
  addCssClassToTitleBar(cssClass) {
    this.eTitleBar.classList.add(cssClass);
  }
  setEnabled(enabled, skipToggle) {
    this.enabled = enabled;
    this.refreshDisabledStyles();
    this.toggleGroupExpand(enabled);
    if (!skipToggle) {
      this.cbGroupEnabled.setValue(enabled);
    }
    return this;
  }
  isEnabled() {
    return this.enabled;
  }
  onEnableChange(callbackFn) {
    this.cbGroupEnabled.onValueChange((newSelection) => {
      this.setEnabled(newSelection, true);
      callbackFn(newSelection);
    });
    return this;
  }
  hideEnabledCheckbox(hide) {
    this.suppressEnabledCheckbox = hide;
    this.refreshChildDisplay();
    this.refreshDisabledStyles();
    return this;
  }
  hideOpenCloseIcons(hide) {
    this.suppressOpenCloseIcons = hide;
    if (hide) {
      this.toggleGroupExpand(true);
    }
    return this;
  }
  refreshDisabledStyles() {
    this.addOrRemoveCssClass("ag-disabled", !this.enabled);
    if (this.suppressEnabledCheckbox && !this.enabled) {
      this.eTitleBar.classList.add("ag-disabled-group-title-bar");
      this.eTitleBar.removeAttribute("tabindex");
    } else {
      this.eTitleBar.classList.remove("ag-disabled-group-title-bar");
      this.eTitleBar.setAttribute("tabindex", "0");
    }
    this.eContainer.classList.toggle("ag-disabled-group-container", !this.enabled);
  }
};
AgGroupComponent.EVENT_EXPANDED = "expanded";
AgGroupComponent.EVENT_COLLAPSED = "collapsed";
__decorate$_([
  RefSelector("eTitleBar")
], AgGroupComponent.prototype, "eTitleBar", void 0);
__decorate$_([
  RefSelector("eGroupOpenedIcon")
], AgGroupComponent.prototype, "eGroupOpenedIcon", void 0);
__decorate$_([
  RefSelector("eGroupClosedIcon")
], AgGroupComponent.prototype, "eGroupClosedIcon", void 0);
__decorate$_([
  RefSelector("eToolbar")
], AgGroupComponent.prototype, "eToolbar", void 0);
__decorate$_([
  RefSelector("cbGroupEnabled")
], AgGroupComponent.prototype, "cbGroupEnabled", void 0);
__decorate$_([
  RefSelector("eTitle")
], AgGroupComponent.prototype, "eTitle", void 0);
__decorate$_([
  RefSelector("eContainer")
], AgGroupComponent.prototype, "eContainer", void 0);
__decorate$_([
  PostConstruct
], AgGroupComponent.prototype, "postConstruct", null);
var __decorate$Z = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TabGuardClassNames;
(function(TabGuardClassNames2) {
  TabGuardClassNames2["TAB_GUARD"] = "ag-tab-guard";
  TabGuardClassNames2["TAB_GUARD_TOP"] = "ag-tab-guard-top";
  TabGuardClassNames2["TAB_GUARD_BOTTOM"] = "ag-tab-guard-bottom";
})(TabGuardClassNames || (TabGuardClassNames = {}));
var TabGuardCtrl = class extends BeanStub {
  constructor(params) {
    super();
    this.skipTabGuardFocus = false;
    const { comp, eTopGuard, eBottomGuard, focusInnerElement, onFocusIn, onFocusOut, shouldStopEventPropagation, onTabKeyDown, handleKeyDown, eFocusableElement } = params;
    this.comp = comp;
    this.eTopGuard = eTopGuard;
    this.eBottomGuard = eBottomGuard;
    this.providedFocusInnerElement = focusInnerElement;
    this.eFocusableElement = eFocusableElement;
    this.providedFocusIn = onFocusIn;
    this.providedFocusOut = onFocusOut;
    this.providedShouldStopEventPropagation = shouldStopEventPropagation;
    this.providedOnTabKeyDown = onTabKeyDown;
    this.providedHandleKeyDown = handleKeyDown;
  }
  postConstruct() {
    this.createManagedBean(new ManagedFocusFeature(this.eFocusableElement, {
      shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e),
      onFocusIn: (e) => this.onFocusIn(e),
      onFocusOut: (e) => this.onFocusOut(e)
    }));
    this.activateTabGuards();
    [this.eTopGuard, this.eBottomGuard].forEach((guard) => this.addManagedListener(guard, "focus", this.onFocus.bind(this)));
  }
  handleKeyDown(e) {
    if (this.providedHandleKeyDown) {
      this.providedHandleKeyDown(e);
    }
  }
  tabGuardsAreActive() {
    return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
  }
  shouldStopEventPropagation() {
    if (this.providedShouldStopEventPropagation) {
      return this.providedShouldStopEventPropagation();
    }
    return false;
  }
  activateTabGuards() {
    this.comp.setTabIndex(this.getGridTabIndex());
  }
  deactivateTabGuards() {
    this.comp.setTabIndex();
  }
  onFocus(e) {
    if (this.skipTabGuardFocus) {
      this.skipTabGuardFocus = false;
      return;
    }
    const fromBottom = e.target === this.eBottomGuard;
    if (this.providedFocusInnerElement) {
      this.providedFocusInnerElement(fromBottom);
    } else {
      this.focusInnerElement(fromBottom);
    }
  }
  onFocusIn(e) {
    if (this.providedFocusIn && this.providedFocusIn(e)) {
      return;
    }
    this.deactivateTabGuards();
  }
  onFocusOut(e) {
    if (this.providedFocusOut && this.providedFocusOut(e)) {
      return;
    }
    if (!this.eFocusableElement.contains(e.relatedTarget)) {
      this.activateTabGuards();
    }
  }
  onTabKeyDown(e) {
    if (this.providedOnTabKeyDown) {
      this.providedOnTabKeyDown(e);
      return;
    }
    if (e.defaultPrevented) {
      return;
    }
    const tabGuardsAreActive = this.tabGuardsAreActive();
    if (tabGuardsAreActive) {
      this.deactivateTabGuards();
    }
    const nextRoot = this.getNextFocusableElement(e.shiftKey);
    if (tabGuardsAreActive) {
      setTimeout(() => this.activateTabGuards(), 0);
    }
    if (!nextRoot) {
      return;
    }
    nextRoot.focus();
    e.preventDefault();
  }
  getGridTabIndex() {
    return (this.gridOptionsService.getNum("tabIndex") || 0).toString();
  }
  focusInnerElement(fromBottom = false) {
    const focusable = this.focusService.findFocusableElements(this.eFocusableElement);
    if (this.tabGuardsAreActive()) {
      focusable.splice(0, 1);
      focusable.splice(focusable.length - 1, 1);
    }
    if (!focusable.length) {
      return;
    }
    focusable[fromBottom ? focusable.length - 1 : 0].focus({ preventScroll: true });
  }
  getNextFocusableElement(backwards) {
    return this.focusService.findNextFocusableElement(this.eFocusableElement, false, backwards);
  }
  forceFocusOutOfContainer(up = false) {
    const tabGuardToFocus = up ? this.eTopGuard : this.eBottomGuard;
    this.activateTabGuards();
    this.skipTabGuardFocus = true;
    tabGuardToFocus.focus();
  }
};
__decorate$Z([
  Autowired("focusService")
], TabGuardCtrl.prototype, "focusService", void 0);
__decorate$Z([
  PostConstruct
], TabGuardCtrl.prototype, "postConstruct", null);
var TabGuardComp = class extends Component {
  initialiseTabGuard(params) {
    this.eTopGuard = this.createTabGuard("top");
    this.eBottomGuard = this.createTabGuard("bottom");
    this.eFocusableElement = this.getFocusableElement();
    const tabGuards = [this.eTopGuard, this.eBottomGuard];
    const compProxy = {
      setTabIndex: (tabIndex) => {
        tabGuards.forEach((tabGuard) => tabIndex != null ? tabGuard.setAttribute("tabIndex", tabIndex) : tabGuard.removeAttribute("tabIndex"));
      }
    };
    this.addTabGuards(this.eTopGuard, this.eBottomGuard);
    this.tabGuardCtrl = this.createManagedBean(new TabGuardCtrl({
      comp: compProxy,
      eTopGuard: this.eTopGuard,
      eBottomGuard: this.eBottomGuard,
      eFocusableElement: this.eFocusableElement,
      onFocusIn: params.onFocusIn,
      onFocusOut: params.onFocusOut,
      focusInnerElement: params.focusInnerElement,
      handleKeyDown: params.handleKeyDown,
      onTabKeyDown: params.onTabKeyDown,
      shouldStopEventPropagation: params.shouldStopEventPropagation
    }));
  }
  createTabGuard(side) {
    const tabGuard = document.createElement("div");
    const cls = side === "top" ? TabGuardClassNames.TAB_GUARD_TOP : TabGuardClassNames.TAB_GUARD_BOTTOM;
    tabGuard.classList.add(TabGuardClassNames.TAB_GUARD, cls);
    setAriaRole(tabGuard, "presentation");
    return tabGuard;
  }
  addTabGuards(topTabGuard, bottomTabGuard) {
    this.eFocusableElement.insertAdjacentElement("afterbegin", topTabGuard);
    this.eFocusableElement.insertAdjacentElement("beforeend", bottomTabGuard);
  }
  removeAllChildrenExceptTabGuards() {
    const tabGuards = [this.eTopGuard, this.eBottomGuard];
    clearElement(this.getFocusableElement());
    this.addTabGuards(...tabGuards);
  }
  forceFocusOutOfContainer(up = false) {
    this.tabGuardCtrl.forceFocusOutOfContainer(up);
  }
  appendChild(newChild, container) {
    if (!isNodeOrElement(newChild)) {
      newChild = newChild.getGui();
    }
    const { eBottomGuard: bottomTabGuard } = this;
    if (bottomTabGuard) {
      bottomTabGuard.insertAdjacentElement("beforebegin", newChild);
    } else {
      super.appendChild(newChild, container);
    }
  }
};
var __decorate$Y = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AgMenuList = class extends TabGuardComp {
  constructor(level = 1) {
    super(`<div class="ag-menu-list" role="tree"></div>`);
    this.level = level;
    this.menuItems = [];
  }
  postConstruct() {
    this.initialiseTabGuard({
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e)
    });
  }
  onTabKeyDown(e) {
    const parent = this.getParentComponent();
    const parentGui = parent && parent.getGui();
    const isManaged = parentGui && parentGui.classList.contains("ag-focus-managed");
    if (!isManaged) {
      e.preventDefault();
    }
    if (e.shiftKey) {
      this.closeIfIsChild(e);
    }
  }
  handleKeyDown(e) {
    switch (e.key) {
      case KeyCode.UP:
      case KeyCode.RIGHT:
      case KeyCode.DOWN:
      case KeyCode.LEFT:
        e.preventDefault();
        this.handleNavKey(e.key);
        break;
      case KeyCode.ESCAPE:
        const topMenu = this.findTopMenu();
        if (topMenu) {
          this.focusService.focusInto(topMenu.getGui());
        }
        break;
    }
  }
  clearActiveItem() {
    if (this.activeMenuItem) {
      this.activeMenuItem.deactivate();
      this.activeMenuItem = null;
    }
  }
  addMenuItems(menuItems) {
    if (menuItems == null) {
      return;
    }
    menuItems.forEach((menuItemOrString) => {
      if (menuItemOrString === "separator") {
        this.addSeparator();
      } else if (typeof menuItemOrString === "string") {
        console.warn(`AG Grid: unrecognised menu item ${menuItemOrString}`);
      } else {
        this.addItem(menuItemOrString);
      }
    });
  }
  addItem(menuItemDef) {
    const menuItem = this.createManagedBean(new AgMenuItemComponent(Object.assign(Object.assign({}, menuItemDef), { isAnotherSubMenuOpen: () => this.menuItems.some((m) => m.isSubMenuOpen()) })));
    menuItem.setParentComponent(this);
    setAriaLevel(menuItem.getGui(), this.level);
    this.menuItems.push(menuItem);
    this.appendChild(menuItem.getGui());
    this.addManagedListener(menuItem, AgMenuItemComponent.EVENT_MENU_ITEM_SELECTED, (event) => {
      this.dispatchEvent(event);
    });
    this.addManagedListener(menuItem, AgMenuItemComponent.EVENT_MENU_ITEM_ACTIVATED, (event) => {
      if (this.activeMenuItem && this.activeMenuItem !== event.menuItem) {
        this.activeMenuItem.deactivate();
      }
      this.activeMenuItem = event.menuItem;
    });
  }
  activateFirstItem() {
    const item = this.menuItems.filter((currentItem) => !currentItem.isDisabled())[0];
    if (!item) {
      return;
    }
    item.activate();
  }
  addSeparator() {
    const separatorHtml = `
            <div class="ag-menu-separator" aria-hidden="true">
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
            </div>`;
    this.appendChild(loadTemplate(separatorHtml));
  }
  findTopMenu() {
    let parent = this.getParentComponent();
    if (!parent && this instanceof AgMenuList) {
      return this;
    }
    while (true) {
      const nextParent = parent && parent.getParentComponent && parent.getParentComponent();
      if (!nextParent || !(nextParent instanceof AgMenuList || nextParent instanceof AgMenuItemComponent)) {
        break;
      }
      parent = nextParent;
    }
    return parent instanceof AgMenuList ? parent : void 0;
  }
  handleNavKey(key) {
    switch (key) {
      case KeyCode.UP:
      case KeyCode.DOWN:
        const nextItem = this.findNextItem(key === KeyCode.UP);
        if (nextItem && nextItem !== this.activeMenuItem) {
          nextItem.activate();
        }
        return;
    }
    const left = this.gridOptionsService.is("enableRtl") ? KeyCode.RIGHT : KeyCode.LEFT;
    if (key === left) {
      this.closeIfIsChild();
    } else {
      this.openChild();
    }
  }
  closeIfIsChild(e) {
    const parentItem = this.getParentComponent();
    if (parentItem && parentItem instanceof AgMenuItemComponent) {
      if (e) {
        e.preventDefault();
      }
      parentItem.closeSubMenu();
      parentItem.getGui().focus();
    }
  }
  openChild() {
    if (this.activeMenuItem) {
      this.activeMenuItem.openSubMenu(true);
    }
  }
  findNextItem(up) {
    const items = this.menuItems.filter((item) => !item.isDisabled());
    if (!items.length) {
      return;
    }
    if (!this.activeMenuItem) {
      return up ? last(items) : items[0];
    }
    if (up) {
      items.reverse();
    }
    let nextItem;
    let foundCurrent = false;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (!foundCurrent) {
        if (item === this.activeMenuItem) {
          foundCurrent = true;
        }
        continue;
      }
      nextItem = item;
      break;
    }
    return nextItem || this.activeMenuItem;
  }
  destroy() {
    this.clearActiveItem();
    super.destroy();
  }
};
__decorate$Y([
  Autowired("focusService")
], AgMenuList.prototype, "focusService", void 0);
__decorate$Y([
  PostConstruct
], AgMenuList.prototype, "postConstruct", null);
var __decorate$X = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AgMenuPanel = class extends TabGuardComp {
  constructor(wrappedComponent) {
    super();
    this.wrappedComponent = wrappedComponent;
    this.setTemplateFromElement(wrappedComponent.getGui());
  }
  postConstruct() {
    this.initialiseTabGuard({
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e)
    });
  }
  handleKeyDown(e) {
    if (e.key === KeyCode.ESCAPE) {
      this.closePanel();
    }
  }
  onTabKeyDown(e) {
    if (e.defaultPrevented) {
      return;
    }
    this.closePanel();
    e.preventDefault();
  }
  closePanel() {
    const menuItem = this.parentComponent;
    menuItem.closeSubMenu();
    setTimeout(() => menuItem.getGui().focus(), 0);
  }
};
__decorate$X([
  PostConstruct
], AgMenuPanel.prototype, "postConstruct", null);
var __decorate$W = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AgMenuItemComponent = class extends Component {
  constructor(params) {
    super();
    this.params = params;
    this.isActive = false;
    this.subMenuIsOpen = false;
    this.setTemplate(`<div class="${this.getClassName()}" tabindex="-1" role="treeitem"></div>`);
  }
  init() {
    this.addIcon();
    this.addName();
    this.addShortcut();
    this.addSubMenu();
    this.addTooltip();
    const eGui = this.getGui();
    if (this.params.disabled) {
      this.addCssClass(this.getClassName("disabled"));
      setAriaDisabled(eGui, true);
    } else {
      this.addGuiEventListener("click", (e) => this.onItemSelected(e));
      this.addGuiEventListener("keydown", (e) => {
        if (e.key === KeyCode.ENTER || e.key === KeyCode.SPACE) {
          e.preventDefault();
          this.onItemSelected(e);
        }
      });
      this.addGuiEventListener("mousedown", (e) => {
        e.stopPropagation();
        e.preventDefault();
      });
      this.addGuiEventListener("mouseenter", () => this.onMouseEnter());
      this.addGuiEventListener("mouseleave", () => this.onMouseLeave());
    }
    if (this.params.cssClasses) {
      this.params.cssClasses.forEach((it) => this.addCssClass(it));
    }
  }
  isDisabled() {
    return !!this.params.disabled;
  }
  openSubMenu(activateFirstItem = false) {
    this.closeSubMenu();
    if (!this.params.subMenu) {
      return;
    }
    const ePopup = loadTemplate(`<div class="ag-menu" role="presentation"></div>`);
    let destroySubMenu;
    if (this.params.subMenu instanceof Array) {
      const currentLevel = getAriaLevel(this.getGui());
      const nextLevel = isNaN(currentLevel) ? 1 : currentLevel + 1;
      const childMenu = this.createBean(new AgMenuList(nextLevel));
      childMenu.setParentComponent(this);
      childMenu.addMenuItems(this.params.subMenu);
      ePopup.appendChild(childMenu.getGui());
      this.addManagedListener(childMenu, AgMenuItemComponent.EVENT_MENU_ITEM_SELECTED, (e) => this.dispatchEvent(e));
      childMenu.addGuiEventListener("mouseenter", () => this.cancelDeactivate());
      destroySubMenu = () => this.destroyBean(childMenu);
      if (activateFirstItem) {
        setTimeout(() => childMenu.activateFirstItem(), 0);
      }
    } else {
      const { subMenu } = this.params;
      const menuPanel = this.createBean(new AgMenuPanel(subMenu));
      menuPanel.setParentComponent(this);
      const subMenuGui = menuPanel.getGui();
      const mouseEvent = "mouseenter";
      const mouseEnterListener = () => this.cancelDeactivate();
      subMenuGui.addEventListener(mouseEvent, mouseEnterListener);
      destroySubMenu = () => subMenuGui.removeEventListener(mouseEvent, mouseEnterListener);
      ePopup.appendChild(subMenuGui);
      if (subMenu.afterGuiAttached) {
        setTimeout(() => subMenu.afterGuiAttached(), 0);
      }
    }
    const eGui = this.getGui();
    const positionCallback = this.popupService.positionPopupForMenu.bind(this.popupService, { eventSource: eGui, ePopup });
    const translate = this.localeService.getLocaleTextFunc();
    const addPopupRes = this.popupService.addPopup({
      modal: true,
      eChild: ePopup,
      positionCallback,
      anchorToElement: eGui,
      ariaLabel: translate("ariaLabelSubMenu", "SubMenu")
    });
    this.subMenuIsOpen = true;
    setAriaExpanded(eGui, true);
    this.hideSubMenu = () => {
      if (addPopupRes) {
        addPopupRes.hideFunc();
      }
      this.subMenuIsOpen = false;
      setAriaExpanded(eGui, false);
      destroySubMenu();
    };
  }
  closeSubMenu() {
    if (!this.hideSubMenu) {
      return;
    }
    this.hideSubMenu();
    this.hideSubMenu = null;
    setAriaExpanded(this.getGui(), false);
  }
  isSubMenuOpen() {
    return this.subMenuIsOpen;
  }
  activate(openSubMenu) {
    this.cancelActivate();
    if (this.params.disabled) {
      return;
    }
    this.isActive = true;
    this.addCssClass(this.getClassName("active"));
    this.getGui().focus();
    if (openSubMenu && this.params.subMenu) {
      window.setTimeout(() => {
        if (this.isAlive() && this.isActive) {
          this.openSubMenu();
        }
      }, 300);
    }
    this.onItemActivated();
  }
  deactivate() {
    this.cancelDeactivate();
    this.removeCssClass(this.getClassName("active"));
    this.isActive = false;
    if (this.subMenuIsOpen) {
      this.hideSubMenu();
    }
  }
  addIcon() {
    if (!this.params.checked && !this.params.icon && this.params.isCompact) {
      return;
    }
    const icon = loadTemplate(`<span ref="eIcon" class="${this.getClassName("part")} ${this.getClassName("icon")}" role="presentation"></span>`);
    if (this.params.checked) {
      icon.appendChild(createIconNoSpan("check", this.gridOptionsService));
    } else if (this.params.icon) {
      if (isNodeOrElement(this.params.icon)) {
        icon.appendChild(this.params.icon);
      } else if (typeof this.params.icon === "string") {
        icon.innerHTML = this.params.icon;
      } else {
        console.warn("AG Grid: menu item icon must be DOM node or string");
      }
    }
    this.getGui().appendChild(icon);
  }
  addName() {
    if (!this.params.name && this.params.isCompact) {
      return;
    }
    const name = loadTemplate(`<span ref="eName" class="${this.getClassName("part")} ${this.getClassName("text")}">${this.params.name || ""}</span>`);
    this.getGui().appendChild(name);
  }
  addTooltip() {
    if (!this.params.tooltip) {
      return;
    }
    this.tooltip = this.params.tooltip;
    if (this.gridOptionsService.is("enableBrowserTooltips")) {
      this.getGui().setAttribute("title", this.tooltip);
    } else {
      this.createManagedBean(new CustomTooltipFeature(this));
    }
  }
  getTooltipParams() {
    return {
      location: "menu",
      value: this.tooltip
    };
  }
  addShortcut() {
    if (!this.params.shortcut && this.params.isCompact) {
      return;
    }
    const shortcut = loadTemplate(`<span ref="eShortcut" class="${this.getClassName("part")} ${this.getClassName("shortcut")}">${this.params.shortcut || ""}</span>`);
    this.getGui().appendChild(shortcut);
  }
  addSubMenu() {
    if (!this.params.subMenu && this.params.isCompact) {
      return;
    }
    const pointer = loadTemplate(`<span ref="ePopupPointer" class="${this.getClassName("part")} ${this.getClassName("popup-pointer")}"></span>`);
    const eGui = this.getGui();
    if (this.params.subMenu) {
      const iconName = this.gridOptionsService.is("enableRtl") ? "smallLeft" : "smallRight";
      setAriaExpanded(eGui, false);
      pointer.appendChild(createIconNoSpan(iconName, this.gridOptionsService));
    }
    eGui.appendChild(pointer);
  }
  onItemSelected(event) {
    if (this.params.action) {
      this.params.action();
    } else {
      this.openSubMenu(event && event.type === "keydown");
    }
    if (this.params.subMenu && !this.params.action) {
      return;
    }
    const e = {
      type: AgMenuItemComponent.EVENT_MENU_ITEM_SELECTED,
      action: this.params.action,
      checked: this.params.checked,
      cssClasses: this.params.cssClasses,
      disabled: this.params.disabled,
      icon: this.params.icon,
      name: this.params.name,
      shortcut: this.params.shortcut,
      subMenu: this.params.subMenu,
      tooltip: this.params.tooltip,
      event
    };
    this.dispatchEvent(e);
  }
  onItemActivated() {
    const event = {
      type: AgMenuItemComponent.EVENT_MENU_ITEM_ACTIVATED,
      menuItem: this
    };
    this.dispatchEvent(event);
  }
  cancelActivate() {
    if (this.activateTimeoutId) {
      window.clearTimeout(this.activateTimeoutId);
      this.activateTimeoutId = 0;
    }
  }
  cancelDeactivate() {
    if (this.deactivateTimeoutId) {
      window.clearTimeout(this.deactivateTimeoutId);
      this.deactivateTimeoutId = 0;
    }
  }
  onMouseEnter() {
    this.cancelDeactivate();
    if (this.params.isAnotherSubMenuOpen()) {
      this.activateTimeoutId = window.setTimeout(() => this.activate(true), AgMenuItemComponent.ACTIVATION_DELAY);
    } else {
      this.activate(true);
    }
  }
  onMouseLeave() {
    this.cancelActivate();
    if (this.isSubMenuOpen()) {
      this.deactivateTimeoutId = window.setTimeout(() => this.deactivate(), AgMenuItemComponent.ACTIVATION_DELAY);
    } else {
      this.deactivate();
    }
  }
  getClassName(suffix) {
    const prefix = this.params.isCompact ? "ag-compact-menu-option" : "ag-menu-option";
    return suffix ? `${prefix}-${suffix}` : prefix;
  }
};
AgMenuItemComponent.EVENT_MENU_ITEM_SELECTED = "menuItemSelected";
AgMenuItemComponent.EVENT_MENU_ITEM_ACTIVATED = "menuItemActivated";
AgMenuItemComponent.ACTIVATION_DELAY = 80;
__decorate$W([
  Autowired("popupService")
], AgMenuItemComponent.prototype, "popupService", void 0);
__decorate$W([
  PostConstruct
], AgMenuItemComponent.prototype, "init", null);
var __decorate$V = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AgPanel = class extends Component {
  constructor(config) {
    super(AgPanel.getTemplate(config));
    this.closable = true;
    this.config = config;
  }
  static getTemplate(config) {
    const cssIdentifier = config && config.cssIdentifier || "default";
    return `<div class="ag-panel ag-${cssIdentifier}-panel" tabindex="-1">
            <div ref="eTitleBar" class="ag-panel-title-bar ag-${cssIdentifier}-panel-title-bar ag-unselectable">
                <span ref="eTitle" class="ag-panel-title-bar-title ag-${cssIdentifier}-panel-title-bar-title"></span>
                <div ref="eTitleBarButtons" class="ag-panel-title-bar-buttons ag-${cssIdentifier}-panel-title-bar-buttons"></div>
            </div>
            <div ref="eContentWrapper" class="ag-panel-content-wrapper ag-${cssIdentifier}-panel-content-wrapper"></div>
        </div>`;
  }
  postConstruct() {
    const { component, closable, hideTitleBar, title, minWidth = 250, width, minHeight = 250, height, centered, popup, x, y } = this.config;
    this.positionableFeature = new PositionableFeature(this.getGui(), {
      minWidth,
      width,
      minHeight,
      height,
      centered,
      x,
      y,
      popup,
      calculateTopBuffer: () => this.positionableFeature.getHeight() - this.getBodyHeight()
    });
    this.createManagedBean(this.positionableFeature);
    const eGui = this.getGui();
    if (component) {
      this.setBodyComponent(component);
    }
    if (!hideTitleBar) {
      if (title) {
        this.setTitle(title);
      }
      this.setClosable(closable != null ? closable : this.closable);
    } else {
      setDisplayed(this.eTitleBar, false);
    }
    this.addManagedListener(this.eTitleBar, "mousedown", (e) => {
      const eDocument = this.gridOptionsService.getDocument();
      if (eGui.contains(e.relatedTarget) || eGui.contains(eDocument.activeElement) || this.eTitleBarButtons.contains(e.target)) {
        e.preventDefault();
        return;
      }
      const focusEl = this.eContentWrapper.querySelector("button, [href], input, select, textarea, [tabindex]");
      if (focusEl) {
        focusEl.focus();
      }
    });
    if (popup && this.positionableFeature.isPositioned()) {
      return;
    }
    if (this.renderComponent) {
      this.renderComponent();
    }
    this.positionableFeature.initialisePosition();
    this.eContentWrapper.style.height = "0";
  }
  renderComponent() {
    const eGui = this.getGui();
    eGui.focus();
    this.close = () => {
      eGui.parentElement.removeChild(eGui);
      this.destroy();
    };
  }
  getHeight() {
    return this.positionableFeature.getHeight();
  }
  setHeight(height) {
    this.positionableFeature.setHeight(height);
  }
  getWidth() {
    return this.positionableFeature.getWidth();
  }
  setWidth(width) {
    this.positionableFeature.setWidth(width);
  }
  setClosable(closable) {
    if (closable !== this.closable) {
      this.closable = closable;
    }
    if (closable) {
      const closeButtonComp = this.closeButtonComp = new Component(AgPanel.CLOSE_BTN_TEMPLATE);
      this.getContext().createBean(closeButtonComp);
      const eGui = closeButtonComp.getGui();
      const child = createIconNoSpan("close", this.gridOptionsService);
      child.classList.add("ag-panel-title-bar-button-icon");
      eGui.appendChild(child);
      this.addTitleBarButton(closeButtonComp);
      closeButtonComp.addManagedListener(eGui, "click", this.onBtClose.bind(this));
    } else if (this.closeButtonComp) {
      const eGui = this.closeButtonComp.getGui();
      eGui.parentElement.removeChild(eGui);
      this.closeButtonComp = this.destroyBean(this.closeButtonComp);
    }
  }
  setBodyComponent(bodyComponent) {
    bodyComponent.setParentComponent(this);
    this.eContentWrapper.appendChild(bodyComponent.getGui());
  }
  addTitleBarButton(button, position) {
    const eTitleBarButtons = this.eTitleBarButtons;
    const buttons = eTitleBarButtons.children;
    const len = buttons.length;
    if (position == null) {
      position = len;
    }
    position = Math.max(0, Math.min(position, len));
    button.addCssClass("ag-panel-title-bar-button");
    const eGui = button.getGui();
    if (position === 0) {
      eTitleBarButtons.insertAdjacentElement("afterbegin", eGui);
    } else if (position === len) {
      eTitleBarButtons.insertAdjacentElement("beforeend", eGui);
    } else {
      buttons[position - 1].insertAdjacentElement("afterend", eGui);
    }
    button.setParentComponent(this);
  }
  getBodyHeight() {
    return getInnerHeight(this.eContentWrapper);
  }
  getBodyWidth() {
    return getInnerWidth(this.eContentWrapper);
  }
  setTitle(title) {
    this.eTitle.innerText = title;
  }
  onBtClose() {
    this.close();
  }
  destroy() {
    if (this.closeButtonComp) {
      this.closeButtonComp = this.destroyBean(this.closeButtonComp);
    }
    const eGui = this.getGui();
    if (eGui && eGui.offsetParent) {
      this.close();
    }
    super.destroy();
  }
};
AgPanel.CLOSE_BTN_TEMPLATE = `<div class="ag-button"></div>`;
__decorate$V([
  RefSelector("eContentWrapper")
], AgPanel.prototype, "eContentWrapper", void 0);
__decorate$V([
  RefSelector("eTitleBar")
], AgPanel.prototype, "eTitleBar", void 0);
__decorate$V([
  RefSelector("eTitleBarButtons")
], AgPanel.prototype, "eTitleBarButtons", void 0);
__decorate$V([
  RefSelector("eTitle")
], AgPanel.prototype, "eTitle", void 0);
__decorate$V([
  PostConstruct
], AgPanel.prototype, "postConstruct", null);
var __decorate$U = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AgDialog = class extends AgPanel {
  constructor(config) {
    super(Object.assign(Object.assign({}, config), { popup: true }));
    this.isMaximizable = false;
    this.isMaximized = false;
    this.maximizeListeners = [];
    this.resizeListenerDestroy = null;
    this.lastPosition = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  postConstruct() {
    const eGui = this.getGui();
    const { movable, resizable, maximizable } = this.config;
    this.addCssClass("ag-dialog");
    super.postConstruct();
    this.addManagedListener(eGui, "focusin", (e) => {
      if (eGui.contains(e.relatedTarget)) {
        return;
      }
      this.popupService.bringPopupToFront(eGui);
    });
    if (movable) {
      this.setMovable(movable);
    }
    if (maximizable) {
      this.setMaximizable(maximizable);
    }
    if (resizable) {
      this.setResizable(resizable);
    }
  }
  renderComponent() {
    const eGui = this.getGui();
    const { alwaysOnTop, modal, title } = this.config;
    const translate = this.localeService.getLocaleTextFunc();
    const addPopupRes = this.popupService.addPopup({
      modal,
      eChild: eGui,
      closeOnEsc: true,
      closedCallback: this.destroy.bind(this),
      alwaysOnTop,
      ariaLabel: title || translate("ariaLabelDialog", "Dialog")
    });
    if (addPopupRes) {
      this.close = addPopupRes.hideFunc;
    }
  }
  toggleMaximize() {
    const position = this.positionableFeature.getPosition();
    if (this.isMaximized) {
      const { x, y, width, height } = this.lastPosition;
      this.setWidth(width);
      this.setHeight(height);
      this.positionableFeature.offsetElement(x, y);
    } else {
      this.lastPosition.width = this.getWidth();
      this.lastPosition.height = this.getHeight();
      this.lastPosition.x = position.x;
      this.lastPosition.y = position.y;
      this.positionableFeature.offsetElement(0, 0);
      this.setHeight("100%");
      this.setWidth("100%");
    }
    this.isMaximized = !this.isMaximized;
    this.refreshMaximizeIcon();
  }
  refreshMaximizeIcon() {
    setDisplayed(this.maximizeIcon, !this.isMaximized);
    setDisplayed(this.minimizeIcon, this.isMaximized);
  }
  clearMaximizebleListeners() {
    if (this.maximizeListeners.length) {
      this.maximizeListeners.forEach((destroyListener) => destroyListener());
      this.maximizeListeners.length = 0;
    }
    if (this.resizeListenerDestroy) {
      this.resizeListenerDestroy();
      this.resizeListenerDestroy = null;
    }
  }
  destroy() {
    this.maximizeButtonComp = this.destroyBean(this.maximizeButtonComp);
    this.clearMaximizebleListeners();
    super.destroy();
  }
  setResizable(resizable) {
    this.positionableFeature.setResizable(resizable);
  }
  setMovable(movable) {
    this.positionableFeature.setMovable(movable, this.eTitleBar);
  }
  setMaximizable(maximizable) {
    if (!maximizable) {
      this.clearMaximizebleListeners();
      if (this.maximizeButtonComp) {
        this.destroyBean(this.maximizeButtonComp);
        this.maximizeButtonComp = this.maximizeIcon = this.minimizeIcon = void 0;
      }
      return;
    }
    const eTitleBar = this.eTitleBar;
    if (!eTitleBar || maximizable === this.isMaximizable) {
      return;
    }
    const maximizeButtonComp = this.buildMaximizeAndMinimizeElements();
    this.refreshMaximizeIcon();
    maximizeButtonComp.addManagedListener(maximizeButtonComp.getGui(), "click", this.toggleMaximize.bind(this));
    this.addTitleBarButton(maximizeButtonComp, 0);
    this.maximizeListeners.push(this.addManagedListener(eTitleBar, "dblclick", this.toggleMaximize.bind(this)));
    this.resizeListenerDestroy = this.addManagedListener(this, "resize", () => {
      this.isMaximized = false;
      this.refreshMaximizeIcon();
    });
  }
  buildMaximizeAndMinimizeElements() {
    const maximizeButtonComp = this.maximizeButtonComp = this.createBean(new Component(`<div class="ag-dialog-button"></span>`));
    const eGui = maximizeButtonComp.getGui();
    this.maximizeIcon = createIconNoSpan("maximize", this.gridOptionsService);
    eGui.appendChild(this.maximizeIcon);
    this.maximizeIcon.classList.add("ag-panel-title-bar-button-icon");
    this.minimizeIcon = createIconNoSpan("minimize", this.gridOptionsService);
    eGui.appendChild(this.minimizeIcon);
    this.minimizeIcon.classList.add("ag-panel-title-bar-button-icon");
    return maximizeButtonComp;
  }
};
__decorate$U([
  Autowired("popupService")
], AgDialog.prototype, "popupService", void 0);
var __decorate$T = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FocusService_1;
var FocusService = FocusService_1 = class FocusService2 extends BeanStub {
  static addKeyboardModeEvents(doc, controller) {
    const docControllers = FocusService_1.instancesMonitored.get(doc);
    if (docControllers && docControllers.length > 0) {
      if (docControllers.indexOf(controller) === -1) {
        docControllers.push(controller);
      }
    } else {
      FocusService_1.instancesMonitored.set(doc, [controller]);
      doc.addEventListener("keydown", FocusService_1.toggleKeyboardMode);
      doc.addEventListener("mousedown", FocusService_1.toggleKeyboardMode);
    }
  }
  static removeKeyboardModeEvents(doc, controller) {
    const docControllers = FocusService_1.instancesMonitored.get(doc);
    let newControllers = [];
    if (docControllers && docControllers.length) {
      newControllers = [...docControllers].filter((currentGridCore) => currentGridCore !== controller);
      FocusService_1.instancesMonitored.set(doc, newControllers);
    }
    if (newControllers.length === 0) {
      doc.removeEventListener("keydown", FocusService_1.toggleKeyboardMode);
      doc.removeEventListener("mousedown", FocusService_1.toggleKeyboardMode);
    }
  }
  static toggleKeyboardMode(event) {
    const isKeyboardActive = FocusService_1.keyboardModeActive;
    const isKeyboardEvent = event.type === "keydown";
    if (isKeyboardEvent) {
      if (event.ctrlKey || event.metaKey || event.altKey) {
        return;
      }
    }
    if (isKeyboardActive && isKeyboardEvent || !isKeyboardActive && !isKeyboardEvent) {
      return;
    }
    FocusService_1.keyboardModeActive = isKeyboardEvent;
    const doc = event.target.ownerDocument;
    if (!doc) {
      return;
    }
    const controllersForDoc = FocusService_1.instancesMonitored.get(doc);
    if (controllersForDoc) {
      controllersForDoc.forEach((controller) => {
        controller.dispatchEvent({ type: isKeyboardEvent ? Events.EVENT_KEYBOARD_FOCUS : Events.EVENT_MOUSE_FOCUS });
      });
    }
  }
  init() {
    const clearFocusedCellListener = this.clearFocusedCell.bind(this);
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, clearFocusedCellListener);
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverythingChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_GROUP_OPENED, clearFocusedCellListener);
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, clearFocusedCellListener);
    this.ctrlsService.whenReady((p) => {
      this.gridCtrl = p.gridCtrl;
      const doc = this.gridOptionsService.getDocument();
      FocusService_1.addKeyboardModeEvents(doc, this.gridCtrl);
      this.addDestroyFunc(() => this.unregisterGridCompController(this.gridCtrl));
    });
  }
  unregisterGridCompController(gridCompController) {
    const doc = this.gridOptionsService.getDocument();
    FocusService_1.removeKeyboardModeEvents(doc, gridCompController);
  }
  onColumnEverythingChanged() {
    if (!this.focusedCellPosition) {
      return;
    }
    const col = this.focusedCellPosition.column;
    const colFromColumnModel = this.columnModel.getGridColumn(col.getId());
    if (col !== colFromColumnModel) {
      this.clearFocusedCell();
    }
  }
  isKeyboardMode() {
    return FocusService_1.keyboardModeActive;
  }
  getFocusCellToUseAfterRefresh() {
    const eDocument = this.gridOptionsService.getDocument();
    if (this.gridOptionsService.is("suppressFocusAfterRefresh") || !this.focusedCellPosition) {
      return null;
    }
    if (this.isDomDataMissingInHierarchy(eDocument.activeElement, RowCtrl.DOM_DATA_KEY_ROW_CTRL)) {
      return null;
    }
    return this.focusedCellPosition;
  }
  getFocusHeaderToUseAfterRefresh() {
    const eDocument = this.gridOptionsService.getDocument();
    if (this.gridOptionsService.is("suppressFocusAfterRefresh") || !this.focusedHeaderPosition) {
      return null;
    }
    if (this.isDomDataMissingInHierarchy(eDocument.activeElement, AbstractHeaderCellCtrl.DOM_DATA_KEY_HEADER_CTRL)) {
      return null;
    }
    return this.focusedHeaderPosition;
  }
  isDomDataMissingInHierarchy(eBrowserCell, key) {
    let ePointer = eBrowserCell;
    while (ePointer) {
      const data = this.gridOptionsService.getDomData(ePointer, key);
      if (data) {
        return false;
      }
      ePointer = ePointer.parentNode;
    }
    return true;
  }
  getFocusedCell() {
    return this.focusedCellPosition;
  }
  getFocusEventParams() {
    const { rowIndex, rowPinned, column } = this.focusedCellPosition;
    const params = {
      rowIndex,
      rowPinned,
      column,
      isFullWidthCell: false
    };
    const rowCtrl = this.rowRenderer.getRowByPosition({ rowIndex, rowPinned });
    if (rowCtrl) {
      params.isFullWidthCell = rowCtrl.isFullWidth();
    }
    return params;
  }
  clearFocusedCell() {
    if (this.focusedCellPosition == null) {
      return;
    }
    const event = Object.assign({ type: Events.EVENT_CELL_FOCUS_CLEARED }, this.getFocusEventParams());
    this.focusedCellPosition = null;
    this.eventService.dispatchEvent(event);
  }
  setFocusedCell(params) {
    const { column, rowIndex, rowPinned, forceBrowserFocus = false, preventScrollOnBrowserFocus = false } = params;
    const gridColumn = this.columnModel.getGridColumn(column);
    if (!gridColumn) {
      this.focusedCellPosition = null;
      return;
    }
    this.focusedCellPosition = gridColumn ? {
      rowIndex,
      rowPinned: makeNull(rowPinned),
      column: gridColumn
    } : null;
    const event = Object.assign(Object.assign({ type: Events.EVENT_CELL_FOCUSED }, this.getFocusEventParams()), {
      forceBrowserFocus,
      preventScrollOnBrowserFocus,
      floating: null
    });
    this.eventService.dispatchEvent(event);
  }
  isCellFocused(cellPosition) {
    if (this.focusedCellPosition == null) {
      return false;
    }
    return this.focusedCellPosition.column === cellPosition.column && this.isRowFocused(cellPosition.rowIndex, cellPosition.rowPinned);
  }
  isRowNodeFocused(rowNode) {
    return this.isRowFocused(rowNode.rowIndex, rowNode.rowPinned);
  }
  isHeaderWrapperFocused(headerCtrl) {
    if (this.focusedHeaderPosition == null) {
      return false;
    }
    const column = headerCtrl.getColumnGroupChild();
    const headerRowIndex = headerCtrl.getRowIndex();
    const pinned = headerCtrl.getPinned();
    const { column: focusedColumn, headerRowIndex: focusedHeaderRowIndex } = this.focusedHeaderPosition;
    return column === focusedColumn && headerRowIndex === focusedHeaderRowIndex && pinned == focusedColumn.getPinned();
  }
  clearFocusedHeader() {
    this.focusedHeaderPosition = null;
  }
  getFocusedHeader() {
    return this.focusedHeaderPosition;
  }
  setFocusedHeader(headerRowIndex, column) {
    this.focusedHeaderPosition = { headerRowIndex, column };
  }
  focusHeaderPosition(params) {
    const { direction, fromTab, allowUserOverride, event } = params;
    let { headerPosition } = params;
    if (allowUserOverride) {
      const currentPosition = this.getFocusedHeader();
      const headerRowCount = this.headerNavigationService.getHeaderRowCount();
      if (fromTab) {
        const userFunc = this.gridOptionsService.getCallback("tabToNextHeader");
        if (userFunc) {
          const params2 = {
            backwards: direction === "Before",
            previousHeaderPosition: currentPosition,
            nextHeaderPosition: headerPosition,
            headerRowCount
          };
          headerPosition = userFunc(params2);
        }
      } else {
        const userFunc = this.gridOptionsService.getCallback("navigateToNextHeader");
        if (userFunc && event) {
          const params2 = {
            key: event.key,
            previousHeaderPosition: currentPosition,
            nextHeaderPosition: headerPosition,
            headerRowCount,
            event
          };
          headerPosition = userFunc(params2);
        }
      }
    }
    if (!headerPosition) {
      return false;
    }
    if (headerPosition.headerRowIndex === -1) {
      return this.focusGridView(headerPosition.column);
    }
    this.headerNavigationService.scrollToColumn(headerPosition.column, direction);
    const headerRowContainerCtrl = this.ctrlsService.getHeaderRowContainerCtrl(headerPosition.column.getPinned());
    const focusSuccess = headerRowContainerCtrl.focusHeader(headerPosition.headerRowIndex, headerPosition.column, event);
    return focusSuccess;
  }
  focusFirstHeader() {
    let firstColumn = this.columnModel.getAllDisplayedColumns()[0];
    if (!firstColumn) {
      return false;
    }
    if (firstColumn.getParent()) {
      firstColumn = this.columnModel.getColumnGroupAtLevel(firstColumn, 0);
    }
    return this.focusHeaderPosition({
      headerPosition: { headerRowIndex: 0, column: firstColumn }
    });
  }
  focusLastHeader(event) {
    const headerRowIndex = this.headerNavigationService.getHeaderRowCount() - 1;
    const column = last(this.columnModel.getAllDisplayedColumns());
    return this.focusHeaderPosition({
      headerPosition: { headerRowIndex, column },
      event
    });
  }
  isAnyCellFocused() {
    return !!this.focusedCellPosition;
  }
  isRowFocused(rowIndex, floating) {
    if (this.focusedCellPosition == null) {
      return false;
    }
    return this.focusedCellPosition.rowIndex === rowIndex && this.focusedCellPosition.rowPinned === makeNull(floating);
  }
  findFocusableElements(rootNode, exclude, onlyUnmanaged = false) {
    const focusableString = FOCUSABLE_SELECTOR;
    let excludeString = FOCUSABLE_EXCLUDE;
    if (exclude) {
      excludeString += ", " + exclude;
    }
    if (onlyUnmanaged) {
      excludeString += ', [tabindex="-1"]';
    }
    const nodes = Array.prototype.slice.apply(rootNode.querySelectorAll(focusableString));
    const excludeNodes = Array.prototype.slice.apply(rootNode.querySelectorAll(excludeString));
    if (!excludeNodes.length) {
      return nodes;
    }
    const diff = (a, b) => a.filter((element) => b.indexOf(element) === -1);
    return diff(nodes, excludeNodes);
  }
  focusInto(rootNode, up = false, onlyUnmanaged = false) {
    const focusableElements = this.findFocusableElements(rootNode, null, onlyUnmanaged);
    const toFocus = up ? last(focusableElements) : focusableElements[0];
    if (toFocus) {
      toFocus.focus({ preventScroll: true });
      return true;
    }
    return false;
  }
  findFocusableElementBeforeTabGuard(rootNode, referenceElement) {
    if (!referenceElement) {
      return null;
    }
    const focusableElements = this.findFocusableElements(rootNode);
    const referenceIndex = focusableElements.indexOf(referenceElement);
    if (referenceIndex === -1) {
      return null;
    }
    let lastTabGuardIndex = -1;
    for (let i = referenceIndex - 1; i >= 0; i--) {
      if (focusableElements[i].classList.contains(TabGuardClassNames.TAB_GUARD_TOP)) {
        lastTabGuardIndex = i;
        break;
      }
    }
    if (lastTabGuardIndex <= 0) {
      return null;
    }
    return focusableElements[lastTabGuardIndex - 1];
  }
  findNextFocusableElement(rootNode = this.eGridDiv, onlyManaged, backwards) {
    const focusable = this.findFocusableElements(rootNode, onlyManaged ? ':not([tabindex="-1"])' : null);
    const eDocument = this.gridOptionsService.getDocument();
    const activeEl = eDocument.activeElement;
    let currentIndex;
    if (onlyManaged) {
      currentIndex = focusable.findIndex((el) => el.contains(activeEl));
    } else {
      currentIndex = focusable.indexOf(activeEl);
    }
    const nextIndex = currentIndex + (backwards ? -1 : 1);
    if (nextIndex < 0 || nextIndex >= focusable.length) {
      return null;
    }
    return focusable[nextIndex];
  }
  isTargetUnderManagedComponent(rootNode, target) {
    if (!target) {
      return false;
    }
    const managedContainers = rootNode.querySelectorAll(`.${ManagedFocusFeature.FOCUS_MANAGED_CLASS}`);
    if (!managedContainers.length) {
      return false;
    }
    for (let i = 0; i < managedContainers.length; i++) {
      if (managedContainers[i].contains(target)) {
        return true;
      }
    }
    return false;
  }
  findTabbableParent(node, limit = 5) {
    let counter = 0;
    while (node && getTabIndex(node) === null && ++counter <= limit) {
      node = node.parentElement;
    }
    if (getTabIndex(node) === null) {
      return null;
    }
    return node;
  }
  focusGridView(column, backwards) {
    if (this.gridOptionsService.is("suppressCellFocus")) {
      if (backwards) {
        return this.focusLastHeader();
      }
      return this.focusNextGridCoreContainer(false);
    }
    const nextRow = backwards ? this.rowPositionUtils.getLastRow() : this.rowPositionUtils.getFirstRow();
    if (!nextRow) {
      return false;
    }
    const { rowIndex, rowPinned } = nextRow;
    const focusedHeader = this.getFocusedHeader();
    if (!column && focusedHeader) {
      column = focusedHeader.column;
    }
    if (rowIndex == null || !column) {
      return false;
    }
    this.navigationService.ensureCellVisible({ rowIndex, column, rowPinned });
    this.setFocusedCell({
      rowIndex,
      column,
      rowPinned: makeNull(rowPinned),
      forceBrowserFocus: true
    });
    if (this.rangeService) {
      const cellPosition = { rowIndex, rowPinned, column };
      this.rangeService.setRangeToCell(cellPosition);
    }
    return true;
  }
  focusNextGridCoreContainer(backwards, forceOut = false) {
    if (!forceOut && this.gridCtrl.focusNextInnerContainer(backwards)) {
      return true;
    }
    if (forceOut || !backwards && !this.gridCtrl.isDetailGrid()) {
      this.gridCtrl.forceFocusOutOfContainer(backwards);
    }
    return false;
  }
};
FocusService.AG_KEYBOARD_FOCUS = "ag-keyboard-focus";
FocusService.keyboardModeActive = false;
FocusService.instancesMonitored = /* @__PURE__ */ new Map();
__decorate$T([
  Autowired("eGridDiv")
], FocusService.prototype, "eGridDiv", void 0);
__decorate$T([
  Autowired("columnModel")
], FocusService.prototype, "columnModel", void 0);
__decorate$T([
  Autowired("headerNavigationService")
], FocusService.prototype, "headerNavigationService", void 0);
__decorate$T([
  Autowired("rowRenderer")
], FocusService.prototype, "rowRenderer", void 0);
__decorate$T([
  Autowired("rowPositionUtils")
], FocusService.prototype, "rowPositionUtils", void 0);
__decorate$T([
  Optional("rangeService")
], FocusService.prototype, "rangeService", void 0);
__decorate$T([
  Autowired("navigationService")
], FocusService.prototype, "navigationService", void 0);
__decorate$T([
  Autowired("ctrlsService")
], FocusService.prototype, "ctrlsService", void 0);
__decorate$T([
  PostConstruct
], FocusService.prototype, "init", null);
FocusService = FocusService_1 = __decorate$T([
  Bean("focusService")
], FocusService);
var __decorate$S = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PopupService_1;
var DIRECTION;
(function(DIRECTION2) {
  DIRECTION2[DIRECTION2["vertical"] = 0] = "vertical";
  DIRECTION2[DIRECTION2["horizontal"] = 1] = "horizontal";
})(DIRECTION || (DIRECTION = {}));
var instanceIdSeq = 0;
var PopupService = PopupService_1 = class PopupService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.popupList = [];
  }
  postConstruct() {
    this.ctrlsService.whenReady((p) => {
      this.gridCtrl = p.gridCtrl;
      this.addManagedListener(this.gridCtrl, Events.EVENT_KEYBOARD_FOCUS, () => {
        this.popupList.forEach((popup) => popup.element.classList.add(FocusService.AG_KEYBOARD_FOCUS));
      });
      this.addManagedListener(this.gridCtrl, Events.EVENT_MOUSE_FOCUS, () => {
        this.popupList.forEach((popup) => popup.element.classList.remove(FocusService.AG_KEYBOARD_FOCUS));
      });
    });
  }
  getPopupParent() {
    const ePopupParent = this.gridOptionsService.get("popupParent");
    if (ePopupParent) {
      return ePopupParent;
    }
    return this.gridCtrl.getGui();
  }
  positionPopupForMenu(params) {
    const sourceRect = params.eventSource.getBoundingClientRect();
    const parentRect = this.getParentRect();
    const y = this.keepXYWithinBounds(params.ePopup, sourceRect.top - parentRect.top, DIRECTION.vertical);
    const minWidth = params.ePopup.clientWidth > 0 ? params.ePopup.clientWidth : 200;
    params.ePopup.style.minWidth = `${minWidth}px`;
    const widthOfParent = parentRect.right - parentRect.left;
    const maxX = widthOfParent - minWidth;
    let x;
    if (this.gridOptionsService.is("enableRtl")) {
      x = xLeftPosition();
      if (x < 0) {
        x = xRightPosition();
      }
      if (x > maxX) {
        x = 0;
      }
    } else {
      x = xRightPosition();
      if (x > maxX) {
        x = xLeftPosition();
      }
      if (x < 0) {
        x = 0;
      }
    }
    params.ePopup.style.left = `${x}px`;
    params.ePopup.style.top = `${y}px`;
    function xRightPosition() {
      return sourceRect.right - parentRect.left - 2;
    }
    function xLeftPosition() {
      return sourceRect.left - parentRect.left - minWidth;
    }
  }
  positionPopupUnderMouseEvent(params) {
    const { ePopup, nudgeX, nudgeY, skipObserver } = params;
    this.positionPopup({
      ePopup,
      nudgeX,
      nudgeY,
      keepWithinBounds: true,
      skipObserver,
      updatePosition: () => this.calculatePointerAlign(params.mouseEvent),
      postProcessCallback: () => this.callPostProcessPopup(params.type, params.ePopup, null, params.mouseEvent, params.column, params.rowNode)
    });
  }
  calculatePointerAlign(e) {
    const parentRect = this.getParentRect();
    return {
      x: e.clientX - parentRect.left,
      y: e.clientY - parentRect.top
    };
  }
  positionPopupByComponent(params) {
    const sourceRect = params.eventSource.getBoundingClientRect();
    const alignSide = params.alignSide || "left";
    const position = params.position || "over";
    const parentRect = this.getParentRect();
    const updatePosition = () => {
      let x = sourceRect.left - parentRect.left;
      if (alignSide === "right") {
        x -= params.ePopup.offsetWidth - sourceRect.width;
      }
      const y = position === "over" ? sourceRect.top - parentRect.top : sourceRect.top - parentRect.top + sourceRect.height;
      return { x, y };
    };
    this.positionPopup({
      ePopup: params.ePopup,
      nudgeX: params.nudgeX,
      nudgeY: params.nudgeY,
      keepWithinBounds: params.keepWithinBounds,
      updatePosition,
      postProcessCallback: () => this.callPostProcessPopup(params.type, params.ePopup, params.eventSource, null, params.column, params.rowNode)
    });
  }
  callPostProcessPopup(type, ePopup, eventSource, mouseEvent, column, rowNode) {
    const callback = this.gridOptionsService.getCallback("postProcessPopup");
    if (callback) {
      const params = {
        column,
        rowNode,
        ePopup,
        type,
        eventSource,
        mouseEvent
      };
      callback(params);
    }
  }
  positionPopup(params) {
    const { ePopup, keepWithinBounds, nudgeX, nudgeY, skipObserver, updatePosition } = params;
    const lastSize = { width: 0, height: 0 };
    const updatePopupPosition = (fromResizeObserver = false) => {
      let { x, y } = updatePosition();
      if (fromResizeObserver && ePopup.clientWidth === lastSize.width && ePopup.clientHeight === lastSize.height) {
        return;
      }
      lastSize.width = ePopup.clientWidth;
      lastSize.height = ePopup.clientHeight;
      if (nudgeX) {
        x += nudgeX;
      }
      if (nudgeY) {
        y += nudgeY;
      }
      if (keepWithinBounds) {
        x = this.keepXYWithinBounds(ePopup, x, DIRECTION.horizontal);
        y = this.keepXYWithinBounds(ePopup, y, DIRECTION.vertical);
      }
      ePopup.style.left = `${x}px`;
      ePopup.style.top = `${y}px`;
      if (params.postProcessCallback) {
        params.postProcessCallback();
      }
    };
    updatePopupPosition();
    if (!skipObserver) {
      const resizeObserverDestroyFunc = this.resizeObserverService.observeResize(ePopup, () => updatePopupPosition(true));
      setTimeout(() => resizeObserverDestroyFunc(), PopupService_1.WAIT_FOR_POPUP_CONTENT_RESIZE);
    }
  }
  getActivePopups() {
    return this.popupList.map((popup) => popup.element);
  }
  getPopupList() {
    return this.popupList;
  }
  getParentRect() {
    const eDocument = this.gridOptionsService.getDocument();
    let popupParent = this.getPopupParent();
    if (popupParent === eDocument.body) {
      popupParent = eDocument.documentElement;
    } else if (getComputedStyle(popupParent).position === "static") {
      popupParent = popupParent.offsetParent;
    }
    const style = getComputedStyle(popupParent);
    const bounds = popupParent.getBoundingClientRect();
    return {
      top: bounds.top + parseFloat(style.borderTopWidth) || 0,
      left: bounds.left + parseFloat(style.borderLeftWidth) || 0,
      right: bounds.right + parseFloat(style.borderRightWidth) || 0,
      bottom: bounds.bottom + parseFloat(style.borderBottomWidth) || 0
    };
  }
  keepXYWithinBounds(ePopup, position, direction) {
    const isVertical = direction === DIRECTION.vertical;
    const sizeProperty = isVertical ? "clientHeight" : "clientWidth";
    const anchorProperty = isVertical ? "top" : "left";
    const offsetProperty = isVertical ? "offsetHeight" : "offsetWidth";
    const scrollPositionProperty = isVertical ? "scrollTop" : "scrollLeft";
    const eDocument = this.gridOptionsService.getDocument();
    const docElement = eDocument.documentElement;
    const popupParent = this.getPopupParent();
    const parentRect = popupParent.getBoundingClientRect();
    const documentRect = eDocument.documentElement.getBoundingClientRect();
    const isBody = popupParent === eDocument.body;
    const offsetSize = ePopup[offsetProperty];
    const getSize = isVertical ? getAbsoluteHeight : getAbsoluteWidth;
    let sizeOfParent = isBody ? getSize(docElement) + docElement[scrollPositionProperty] : popupParent[sizeProperty];
    if (isBody) {
      sizeOfParent -= Math.abs(documentRect[anchorProperty] - parentRect[anchorProperty]);
    }
    const max = sizeOfParent - offsetSize;
    return Math.min(Math.max(position, 0), Math.abs(max));
  }
  addPopup(params) {
    const eDocument = this.gridOptionsService.getDocument();
    const { eChild, ariaLabel, alwaysOnTop, positionCallback, anchorToElement } = params;
    if (!eDocument) {
      console.warn("AG Grid: could not find the document, document is empty");
      return { hideFunc: () => {
      } };
    }
    const pos = this.popupList.findIndex((popup) => popup.element === eChild);
    if (pos !== -1) {
      const popup = this.popupList[pos];
      return { hideFunc: popup.hideFunc };
    }
    this.initialisePopupPosition(eChild);
    const wrapperEl = this.createPopupWrapper(eChild, ariaLabel, !!alwaysOnTop);
    const removeListeners = this.addEventListenersToPopup(Object.assign(Object.assign({}, params), { wrapperEl }));
    if (positionCallback) {
      positionCallback();
    }
    this.addPopupToPopupList(eChild, wrapperEl, removeListeners, anchorToElement);
    return {
      hideFunc: removeListeners
    };
  }
  initialisePopupPosition(element) {
    const ePopupParent = this.getPopupParent();
    const ePopupParentRect = ePopupParent.getBoundingClientRect();
    if (!exists(element.style.top)) {
      element.style.top = `${ePopupParentRect.top * -1}px`;
    }
    if (!exists(element.style.left)) {
      element.style.left = `${ePopupParentRect.left * -1}px`;
    }
  }
  createPopupWrapper(element, ariaLabel, alwaysOnTop) {
    const ePopupParent = this.getPopupParent();
    const eWrapper = document.createElement("div");
    const { allThemes } = this.environment.getTheme();
    if (allThemes.length) {
      eWrapper.classList.add(...allThemes);
    }
    eWrapper.classList.add("ag-popup");
    element.classList.add(this.gridOptionsService.is("enableRtl") ? "ag-rtl" : "ag-ltr", "ag-popup-child");
    if (!element.hasAttribute("role")) {
      setAriaRole(element, "dialog");
    }
    setAriaLabel(element, ariaLabel);
    if (this.focusService.isKeyboardMode()) {
      element.classList.add(FocusService.AG_KEYBOARD_FOCUS);
    }
    eWrapper.appendChild(element);
    ePopupParent.appendChild(eWrapper);
    if (alwaysOnTop) {
      this.setAlwaysOnTop(element, true);
    } else {
      this.bringPopupToFront(element);
    }
    return eWrapper;
  }
  addEventListenersToPopup(params) {
    const eDocument = this.gridOptionsService.getDocument();
    const ePopupParent = this.getPopupParent();
    const { wrapperEl, eChild: popupEl, click: pointerEvent, closedCallback, afterGuiAttached, closeOnEsc, modal } = params;
    let popupHidden = false;
    const hidePopupOnKeyboardEvent = (event) => {
      if (!wrapperEl.contains(eDocument.activeElement)) {
        return;
      }
      const key = event.key;
      if (key === KeyCode.ESCAPE) {
        removeListeners({ keyboardEvent: event });
      }
    };
    const hidePopupOnMouseEvent = (event) => removeListeners({ mouseEvent: event });
    const hidePopupOnTouchEvent = (event) => removeListeners({ touchEvent: event });
    const removeListeners = (popupParams = {}) => {
      const { mouseEvent, touchEvent, keyboardEvent } = popupParams;
      if (this.isEventFromCurrentPopup({ mouseEvent, touchEvent }, popupEl) || this.isEventSameChainAsOriginalEvent({ originalMouseEvent: pointerEvent, mouseEvent, touchEvent }) || popupHidden) {
        return;
      }
      popupHidden = true;
      ePopupParent.removeChild(wrapperEl);
      eDocument.removeEventListener("keydown", hidePopupOnKeyboardEvent);
      eDocument.removeEventListener("mousedown", hidePopupOnMouseEvent);
      eDocument.removeEventListener("touchstart", hidePopupOnTouchEvent);
      eDocument.removeEventListener("contextmenu", hidePopupOnMouseEvent);
      this.eventService.removeEventListener(Events.EVENT_DRAG_STARTED, hidePopupOnMouseEvent);
      if (closedCallback) {
        closedCallback(mouseEvent || touchEvent || keyboardEvent);
      }
      this.removePopupFromPopupList(popupEl);
    };
    if (afterGuiAttached) {
      afterGuiAttached({ hidePopup: removeListeners });
    }
    window.setTimeout(() => {
      if (closeOnEsc) {
        eDocument.addEventListener("keydown", hidePopupOnKeyboardEvent);
      }
      if (modal) {
        eDocument.addEventListener("mousedown", hidePopupOnMouseEvent);
        this.eventService.addEventListener(Events.EVENT_DRAG_STARTED, hidePopupOnMouseEvent);
        eDocument.addEventListener("touchstart", hidePopupOnTouchEvent);
        eDocument.addEventListener("contextmenu", hidePopupOnMouseEvent);
      }
    }, 0);
    return removeListeners;
  }
  addPopupToPopupList(element, wrapperEl, removeListeners, anchorToElement) {
    this.popupList.push({
      element,
      wrapper: wrapperEl,
      hideFunc: removeListeners,
      instanceId: instanceIdSeq++,
      isAnchored: !!anchorToElement
    });
    if (anchorToElement) {
      this.setPopupPositionRelatedToElement(element, anchorToElement);
    }
  }
  setPopupPositionRelatedToElement(popupEl, relativeElement) {
    const popup = this.popupList.find((p) => p.element === popupEl);
    if (!popup) {
      return;
    }
    if (popup.stopAnchoringPromise) {
      popup.stopAnchoringPromise.then((destroyFunc) => destroyFunc && destroyFunc());
    }
    popup.stopAnchoringPromise = void 0;
    if (!relativeElement) {
      return;
    }
    const destroyPositionTracker = this.keepPopupPositionedRelativeTo({
      element: relativeElement,
      ePopup: popupEl,
      hidePopup: popup.hideFunc
    });
    popup.stopAnchoringPromise = destroyPositionTracker;
    return destroyPositionTracker;
  }
  removePopupFromPopupList(element) {
    this.setPopupPositionRelatedToElement(element, null);
    this.popupList = this.popupList.filter((p) => p.element !== element);
  }
  keepPopupPositionedRelativeTo(params) {
    const eParent = this.getPopupParent();
    const parentRect = eParent.getBoundingClientRect();
    const { element, ePopup } = params;
    const sourceRect = element.getBoundingClientRect();
    const initialDiffTop = parentRect.top - sourceRect.top;
    const initialDiffLeft = parentRect.left - sourceRect.left;
    let lastDiffTop = initialDiffTop;
    let lastDiffLeft = initialDiffLeft;
    const topPx = ePopup.style.top;
    const top = parseInt(topPx.substring(0, topPx.length - 1), 10);
    const leftPx = ePopup.style.left;
    const left = parseInt(leftPx.substring(0, leftPx.length - 1), 10);
    return new AgPromise((resolve) => {
      this.getFrameworkOverrides().setInterval(() => {
        const pRect = eParent.getBoundingClientRect();
        const sRect = element.getBoundingClientRect();
        const elementNotInDom = sRect.top == 0 && sRect.left == 0 && sRect.height == 0 && sRect.width == 0;
        if (elementNotInDom) {
          params.hidePopup();
          return;
        }
        const currentDiffTop = pRect.top - sRect.top;
        if (currentDiffTop != lastDiffTop) {
          const newTop = this.keepXYWithinBounds(ePopup, top + initialDiffTop - currentDiffTop, DIRECTION.vertical);
          ePopup.style.top = `${newTop}px`;
        }
        lastDiffTop = currentDiffTop;
        const currentDiffLeft = pRect.left - sRect.left;
        if (currentDiffLeft != lastDiffLeft) {
          const newLeft = this.keepXYWithinBounds(ePopup, left + initialDiffLeft - currentDiffLeft, DIRECTION.horizontal);
          ePopup.style.left = `${newLeft}px`;
        }
        lastDiffLeft = currentDiffLeft;
      }, 200).then((intervalId) => {
        const result = () => {
          if (intervalId != null) {
            window.clearInterval(intervalId);
          }
        };
        resolve(result);
      });
    });
  }
  hasAnchoredPopup() {
    return this.popupList.some((popup) => popup.isAnchored);
  }
  isEventFromCurrentPopup(params, target) {
    const { mouseEvent, touchEvent } = params;
    const event = mouseEvent ? mouseEvent : touchEvent;
    if (!event) {
      return false;
    }
    const indexOfThisChild = this.popupList.findIndex((popup) => popup.element === target);
    if (indexOfThisChild === -1) {
      return false;
    }
    for (let i = indexOfThisChild; i < this.popupList.length; i++) {
      const popup = this.popupList[i];
      if (isElementInEventPath(popup.element, event)) {
        return true;
      }
    }
    return this.isElementWithinCustomPopup(event.target);
  }
  isElementWithinCustomPopup(el) {
    const eDocument = this.gridOptionsService.getDocument();
    while (el && el !== eDocument.body) {
      if (el.classList.contains("ag-custom-component-popup") || el.parentElement === null) {
        return true;
      }
      el = el.parentElement;
    }
    return false;
  }
  isEventSameChainAsOriginalEvent(params) {
    const { originalMouseEvent, mouseEvent, touchEvent } = params;
    let mouseEventOrTouch = null;
    if (mouseEvent) {
      mouseEventOrTouch = mouseEvent;
    } else if (touchEvent) {
      mouseEventOrTouch = touchEvent.touches[0];
    }
    if (mouseEventOrTouch && originalMouseEvent) {
      const screenX = mouseEvent ? mouseEvent.screenX : 0;
      const screenY = mouseEvent ? mouseEvent.screenY : 0;
      const xMatch = Math.abs(originalMouseEvent.screenX - screenX) < 5;
      const yMatch = Math.abs(originalMouseEvent.screenY - screenY) < 5;
      if (xMatch && yMatch) {
        return true;
      }
    }
    return false;
  }
  getWrapper(ePopup) {
    while (!ePopup.classList.contains("ag-popup") && ePopup.parentElement) {
      ePopup = ePopup.parentElement;
    }
    return ePopup.classList.contains("ag-popup") ? ePopup : null;
  }
  setAlwaysOnTop(ePopup, alwaysOnTop) {
    const eWrapper = this.getWrapper(ePopup);
    if (!eWrapper) {
      return;
    }
    eWrapper.classList.toggle("ag-always-on-top", !!alwaysOnTop);
    if (alwaysOnTop) {
      this.bringPopupToFront(eWrapper);
    }
  }
  bringPopupToFront(ePopup) {
    const parent = this.getPopupParent();
    const popupList = Array.prototype.slice.call(parent.querySelectorAll(".ag-popup"));
    const popupLen = popupList.length;
    const alwaysOnTopList = Array.prototype.slice.call(parent.querySelectorAll(".ag-popup.ag-always-on-top"));
    const onTopLength = alwaysOnTopList.length;
    const eWrapper = this.getWrapper(ePopup);
    if (!eWrapper || popupLen <= 1 || !parent.contains(ePopup)) {
      return;
    }
    const pos = popupList.indexOf(eWrapper);
    const innerEls = eWrapper.querySelectorAll("div");
    const innerElsScrollMap = [];
    innerEls.forEach((el) => {
      if (el.scrollTop !== 0) {
        innerElsScrollMap.push([el, el.scrollTop]);
      }
    });
    if (onTopLength) {
      const isPopupAlwaysOnTop = eWrapper.classList.contains("ag-always-on-top");
      if (isPopupAlwaysOnTop) {
        if (pos !== popupLen - 1) {
          last(alwaysOnTopList).insertAdjacentElement("afterend", eWrapper);
        }
      } else if (pos !== popupLen - onTopLength - 1) {
        alwaysOnTopList[0].insertAdjacentElement("beforebegin", eWrapper);
      }
    } else if (pos !== popupLen - 1) {
      last(popupList).insertAdjacentElement("afterend", eWrapper);
    }
    while (innerElsScrollMap.length) {
      const currentEl = innerElsScrollMap.pop();
      currentEl[0].scrollTop = currentEl[1];
    }
    const params = {
      type: "popupToFront",
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      eWrapper
    };
    this.eventService.dispatchEvent(params);
  }
};
PopupService.WAIT_FOR_POPUP_CONTENT_RESIZE = 200;
__decorate$S([
  Autowired("focusService")
], PopupService.prototype, "focusService", void 0);
__decorate$S([
  Autowired("ctrlsService")
], PopupService.prototype, "ctrlsService", void 0);
__decorate$S([
  Autowired("resizeObserverService")
], PopupService.prototype, "resizeObserverService", void 0);
__decorate$S([
  PostConstruct
], PopupService.prototype, "postConstruct", null);
PopupService = PopupService_1 = __decorate$S([
  Bean("popupService")
], PopupService);
var __decorate$R = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var VirtualList = class extends TabGuardComp {
  constructor(cssIdentifier = "default", ariaRole = "listbox", listName) {
    super(VirtualList.getTemplate(cssIdentifier));
    this.cssIdentifier = cssIdentifier;
    this.ariaRole = ariaRole;
    this.listName = listName;
    this.renderedRows = /* @__PURE__ */ new Map();
    this.rowHeight = 20;
  }
  postConstruct() {
    this.addScrollListener();
    this.rowHeight = this.getItemHeight();
    this.addResizeObserver();
    this.initialiseTabGuard({
      onFocusIn: (e) => this.onFocusIn(e),
      onFocusOut: (e) => this.onFocusOut(e),
      focusInnerElement: (fromBottom) => this.focusInnerElement(fromBottom),
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e)
    });
    this.setAriaProperties();
    this.addManagedListener(this.eventService, Events.EVENT_GRID_STYLES_CHANGED, this.onGridStylesChanged.bind(this));
  }
  onGridStylesChanged() {
    this.rowHeight = this.getItemHeight();
    this.refresh();
  }
  setAriaProperties() {
    const translate = this.localeService.getLocaleTextFunc();
    const listName = translate("ariaDefaultListName", this.listName || "List");
    const ariaEl = this.eContainer;
    setAriaRole(ariaEl, this.ariaRole);
    setAriaLabel(ariaEl, listName);
  }
  addResizeObserver() {
    const listener = () => this.drawVirtualRows();
    const destroyObserver = this.resizeObserverService.observeResize(this.getGui(), listener);
    this.addDestroyFunc(destroyObserver);
  }
  focusInnerElement(fromBottom) {
    this.focusRow(fromBottom ? this.model.getRowCount() - 1 : 0);
  }
  onFocusIn(e) {
    const target = e.target;
    if (target.classList.contains("ag-virtual-list-item")) {
      this.lastFocusedRowIndex = getAriaPosInSet(target) - 1;
    }
    return false;
  }
  onFocusOut(e) {
    if (!this.getFocusableElement().contains(e.relatedTarget)) {
      this.lastFocusedRowIndex = null;
    }
    return false;
  }
  handleKeyDown(e) {
    switch (e.key) {
      case KeyCode.UP:
      case KeyCode.DOWN:
        if (this.navigate(e.key === KeyCode.UP)) {
          e.preventDefault();
        }
        break;
    }
  }
  onTabKeyDown(e) {
    if (this.navigate(e.shiftKey)) {
      e.preventDefault();
    } else {
      stopPropagationForAgGrid(e);
      this.forceFocusOutOfContainer(e.shiftKey);
    }
  }
  navigate(up) {
    if (this.lastFocusedRowIndex == null) {
      return false;
    }
    const nextRow = this.lastFocusedRowIndex + (up ? -1 : 1);
    if (nextRow < 0 || nextRow >= this.model.getRowCount()) {
      return false;
    }
    this.focusRow(nextRow);
    return true;
  }
  getLastFocusedRow() {
    return this.lastFocusedRowIndex;
  }
  focusRow(rowNumber) {
    this.ensureIndexVisible(rowNumber);
    window.setTimeout(() => {
      if (!this.isAlive()) {
        return;
      }
      const renderedRow = this.renderedRows.get(rowNumber);
      if (renderedRow) {
        renderedRow.eDiv.focus();
      }
    }, 10);
  }
  getComponentAt(rowIndex) {
    const comp = this.renderedRows.get(rowIndex);
    return comp && comp.rowComponent;
  }
  forEachRenderedRow(func) {
    this.renderedRows.forEach((value, key) => func(value.rowComponent, key));
  }
  static getTemplate(cssIdentifier) {
    return `
            <div class="ag-virtual-list-viewport ag-${cssIdentifier}-virtual-list-viewport" role="presentation">
                <div class="ag-virtual-list-container ag-${cssIdentifier}-virtual-list-container" ref="eContainer"></div>
            </div>`;
  }
  getItemHeight() {
    return this.environment.getListItemHeight();
  }
  ensureIndexVisible(index) {
    const lastRow = this.model.getRowCount();
    if (typeof index !== "number" || index < 0 || index >= lastRow) {
      console.warn("AG Grid: invalid row index for ensureIndexVisible: " + index);
      return;
    }
    const rowTopPixel = index * this.rowHeight;
    const rowBottomPixel = rowTopPixel + this.rowHeight;
    const eGui = this.getGui();
    const viewportTopPixel = eGui.scrollTop;
    const viewportHeight = eGui.offsetHeight;
    const viewportBottomPixel = viewportTopPixel + viewportHeight;
    const viewportScrolledPastRow = viewportTopPixel > rowTopPixel;
    const viewportScrolledBeforeRow = viewportBottomPixel < rowBottomPixel;
    if (viewportScrolledPastRow) {
      eGui.scrollTop = rowTopPixel;
    } else if (viewportScrolledBeforeRow) {
      const newScrollPosition = rowBottomPixel - viewportHeight;
      eGui.scrollTop = newScrollPosition;
    }
  }
  setComponentCreator(componentCreator) {
    this.componentCreator = componentCreator;
  }
  setComponentUpdater(componentUpdater) {
    this.componentUpdater = componentUpdater;
  }
  getRowHeight() {
    return this.rowHeight;
  }
  getScrollTop() {
    return this.getGui().scrollTop;
  }
  setRowHeight(rowHeight) {
    this.rowHeight = rowHeight;
    this.refresh();
  }
  refresh(softRefresh) {
    if (this.model == null || !this.isAlive()) {
      return;
    }
    const rowCount = this.model.getRowCount();
    this.eContainer.style.height = `${rowCount * this.rowHeight}px`;
    waitUntil(() => this.eContainer.clientHeight >= rowCount * this.rowHeight, () => {
      if (!this.isAlive()) {
        return;
      }
      if (this.canSoftRefresh(softRefresh)) {
        this.drawVirtualRows(true);
      } else {
        this.clearVirtualRows();
        this.drawVirtualRows();
      }
    });
  }
  canSoftRefresh(softRefresh) {
    return !!(softRefresh && this.renderedRows.size && typeof this.model.areRowsEqual === "function" && this.componentUpdater);
  }
  clearVirtualRows() {
    this.renderedRows.forEach((_2, rowIndex) => this.removeRow(rowIndex));
  }
  drawVirtualRows(softRefresh) {
    if (!this.isAlive()) {
      return;
    }
    const gui = this.getGui();
    const topPixel = gui.scrollTop;
    const bottomPixel = topPixel + gui.offsetHeight;
    const firstRow = Math.floor(topPixel / this.rowHeight);
    const lastRow = Math.floor(bottomPixel / this.rowHeight);
    this.ensureRowsRendered(firstRow, lastRow, softRefresh);
  }
  ensureRowsRendered(start, finish, softRefresh) {
    this.renderedRows.forEach((_2, rowIndex) => {
      if ((rowIndex < start || rowIndex > finish) && rowIndex !== this.lastFocusedRowIndex) {
        this.removeRow(rowIndex);
      }
    });
    if (softRefresh) {
      this.refreshRows();
    }
    for (let rowIndex = start; rowIndex <= finish; rowIndex++) {
      if (this.renderedRows.has(rowIndex)) {
        continue;
      }
      if (rowIndex < this.model.getRowCount()) {
        this.insertRow(rowIndex);
      }
    }
  }
  insertRow(rowIndex) {
    const value = this.model.getRow(rowIndex);
    const eDiv = document.createElement("div");
    eDiv.classList.add("ag-virtual-list-item", `ag-${this.cssIdentifier}-virtual-list-item`);
    setAriaRole(eDiv, this.ariaRole === "tree" ? "treeitem" : "option");
    setAriaSetSize(eDiv, this.model.getRowCount());
    setAriaPosInSet(eDiv, rowIndex + 1);
    eDiv.setAttribute("tabindex", "-1");
    if (typeof this.model.isRowSelected === "function") {
      const isSelected = this.model.isRowSelected(rowIndex);
      setAriaSelected(eDiv, !!isSelected);
      setAriaChecked(eDiv, isSelected);
    }
    eDiv.style.height = `${this.rowHeight}px`;
    eDiv.style.top = `${this.rowHeight * rowIndex}px`;
    const rowComponent = this.componentCreator(value, eDiv);
    rowComponent.addGuiEventListener("focusin", () => this.lastFocusedRowIndex = rowIndex);
    eDiv.appendChild(rowComponent.getGui());
    if (this.renderedRows.has(rowIndex - 1)) {
      this.renderedRows.get(rowIndex - 1).eDiv.insertAdjacentElement("afterend", eDiv);
    } else if (this.renderedRows.has(rowIndex + 1)) {
      this.renderedRows.get(rowIndex + 1).eDiv.insertAdjacentElement("beforebegin", eDiv);
    } else {
      this.eContainer.appendChild(eDiv);
    }
    this.renderedRows.set(rowIndex, { rowComponent, eDiv, value });
  }
  removeRow(rowIndex) {
    const component = this.renderedRows.get(rowIndex);
    this.eContainer.removeChild(component.eDiv);
    this.destroyBean(component.rowComponent);
    this.renderedRows.delete(rowIndex);
  }
  refreshRows() {
    const rowCount = this.model.getRowCount();
    this.renderedRows.forEach((row, rowIndex) => {
      var _a, _b;
      if (rowIndex >= rowCount) {
        this.removeRow(rowIndex);
      } else {
        const newValue = this.model.getRow(rowIndex);
        if ((_b = (_a = this.model).areRowsEqual) === null || _b === void 0 ? void 0 : _b.call(_a, row.value, newValue)) {
          this.componentUpdater(newValue, row.rowComponent);
        } else {
          this.removeRow(rowIndex);
        }
      }
    });
  }
  addScrollListener() {
    this.addGuiEventListener("scroll", () => this.drawVirtualRows(), { passive: true });
  }
  setModel(model) {
    this.model = model;
  }
  destroy() {
    if (!this.isAlive()) {
      return;
    }
    this.clearVirtualRows();
    super.destroy();
  }
};
__decorate$R([
  Autowired("resizeObserverService")
], VirtualList.prototype, "resizeObserverService", void 0);
__decorate$R([
  RefSelector("eContainer")
], VirtualList.prototype, "eContainer", void 0);
__decorate$R([
  PostConstruct
], VirtualList.prototype, "postConstruct", null);
var OUTSIDE_ANGULAR_EVENTS = ["mouseover", "mouseout", "mouseenter", "mouseleave"];
var PASSIVE_EVENTS = ["touchstart", "touchend", "touchmove", "touchcancel"];
var VanillaFrameworkOverrides = class {
  constructor() {
    this.isOutsideAngular = (eventType) => includes(OUTSIDE_ANGULAR_EVENTS, eventType);
  }
  setTimeout(action, timeout) {
    window.setTimeout(action, timeout);
  }
  setInterval(action, timeout) {
    return new AgPromise((resolve) => {
      resolve(window.setInterval(action, timeout));
    });
  }
  addEventListener(element, type, listener, useCapture) {
    const isPassive = includes(PASSIVE_EVENTS, type);
    element.addEventListener(type, listener, { capture: !!useCapture, passive: isPassive });
  }
  dispatchEvent(eventType, listener, global2 = false) {
    listener();
  }
  frameworkComponent(name) {
    return null;
  }
  isFrameworkComponent(comp) {
    return false;
  }
};
var __decorate$Q = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CellNavigationService = class CellNavigationService2 extends BeanStub {
  getNextCellToFocus(key, focusedCell, ctrlPressed = false) {
    if (ctrlPressed) {
      return this.getNextCellToFocusWithCtrlPressed(key, focusedCell);
    }
    return this.getNextCellToFocusWithoutCtrlPressed(key, focusedCell);
  }
  getNextCellToFocusWithCtrlPressed(key, focusedCell) {
    const upKey = key === KeyCode.UP;
    const downKey = key === KeyCode.DOWN;
    const leftKey = key === KeyCode.LEFT;
    let column;
    let rowIndex;
    if (upKey || downKey) {
      rowIndex = upKey ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();
      column = focusedCell.column;
    } else {
      const allColumns = this.columnModel.getAllDisplayedColumns();
      const isRtl = this.gridOptionsService.is("enableRtl");
      rowIndex = focusedCell.rowIndex;
      column = leftKey !== isRtl ? allColumns[0] : last(allColumns);
    }
    return {
      rowIndex,
      rowPinned: null,
      column
    };
  }
  getNextCellToFocusWithoutCtrlPressed(key, focusedCell) {
    let pointer = focusedCell;
    let finished = false;
    while (!finished) {
      switch (key) {
        case KeyCode.UP:
          pointer = this.getCellAbove(pointer);
          break;
        case KeyCode.DOWN:
          pointer = this.getCellBelow(pointer);
          break;
        case KeyCode.RIGHT:
          if (this.gridOptionsService.is("enableRtl")) {
            pointer = this.getCellToLeft(pointer);
          } else {
            pointer = this.getCellToRight(pointer);
          }
          break;
        case KeyCode.LEFT:
          if (this.gridOptionsService.is("enableRtl")) {
            pointer = this.getCellToRight(pointer);
          } else {
            pointer = this.getCellToLeft(pointer);
          }
          break;
        default:
          pointer = null;
          console.warn("AG Grid: unknown key for navigation " + key);
          break;
      }
      if (pointer) {
        finished = this.isCellGoodToFocusOn(pointer);
      } else {
        finished = true;
      }
    }
    return pointer;
  }
  isCellGoodToFocusOn(gridCell) {
    const column = gridCell.column;
    let rowNode;
    switch (gridCell.rowPinned) {
      case "top":
        rowNode = this.pinnedRowModel.getPinnedTopRow(gridCell.rowIndex);
        break;
      case "bottom":
        rowNode = this.pinnedRowModel.getPinnedBottomRow(gridCell.rowIndex);
        break;
      default:
        rowNode = this.rowModel.getRow(gridCell.rowIndex);
        break;
    }
    if (!rowNode) {
      return false;
    }
    const suppressNavigable = column.isSuppressNavigable(rowNode);
    return !suppressNavigable;
  }
  getCellToLeft(lastCell) {
    if (!lastCell) {
      return null;
    }
    const colToLeft = this.columnModel.getDisplayedColBefore(lastCell.column);
    if (!colToLeft) {
      return null;
    }
    return {
      rowIndex: lastCell.rowIndex,
      column: colToLeft,
      rowPinned: lastCell.rowPinned
    };
  }
  getCellToRight(lastCell) {
    if (!lastCell) {
      return null;
    }
    const colToRight = this.columnModel.getDisplayedColAfter(lastCell.column);
    if (!colToRight) {
      return null;
    }
    return {
      rowIndex: lastCell.rowIndex,
      column: colToRight,
      rowPinned: lastCell.rowPinned
    };
  }
  getRowBelow(rowPosition) {
    const index = rowPosition.rowIndex;
    const pinned = rowPosition.rowPinned;
    if (this.isLastRowInContainer(rowPosition)) {
      switch (pinned) {
        case "bottom":
          return null;
        case "top":
          if (this.rowModel.isRowsToRender()) {
            return { rowIndex: this.paginationProxy.getPageFirstRow(), rowPinned: null };
          }
          if (this.pinnedRowModel.isRowsToRender("bottom")) {
            return { rowIndex: 0, rowPinned: "bottom" };
          }
          return null;
        default:
          if (this.pinnedRowModel.isRowsToRender("bottom")) {
            return { rowIndex: 0, rowPinned: "bottom" };
          }
          return null;
      }
    }
    const rowNode = this.rowModel.getRow(rowPosition.rowIndex);
    const nextStickyPosition = this.getNextStickyPosition(rowNode);
    if (nextStickyPosition) {
      return nextStickyPosition;
    }
    return { rowIndex: index + 1, rowPinned: pinned };
  }
  getNextStickyPosition(rowNode, up) {
    if (!this.gridOptionsService.isGroupRowsSticky() || !rowNode || !rowNode.sticky) {
      return;
    }
    const stickyRowCtrls = [...this.rowRenderer.getStickyTopRowCtrls()].sort((a, b) => a.getRowNode().rowIndex - b.getRowNode().rowIndex);
    const diff = up ? -1 : 1;
    const idx = stickyRowCtrls.findIndex((ctrl) => ctrl.getRowNode().rowIndex === rowNode.rowIndex);
    const nextCtrl = stickyRowCtrls[idx + diff];
    if (nextCtrl) {
      return { rowIndex: nextCtrl.getRowNode().rowIndex, rowPinned: null };
    }
  }
  getCellBelow(lastCell) {
    if (!lastCell) {
      return null;
    }
    const rowBelow = this.getRowBelow(lastCell);
    if (rowBelow) {
      return {
        rowIndex: rowBelow.rowIndex,
        column: lastCell.column,
        rowPinned: rowBelow.rowPinned
      };
    }
    return null;
  }
  isLastRowInContainer(rowPosition) {
    const pinned = rowPosition.rowPinned;
    const index = rowPosition.rowIndex;
    if (pinned === "top") {
      const lastTopIndex = this.pinnedRowModel.getPinnedTopRowData().length - 1;
      return lastTopIndex <= index;
    }
    if (pinned === "bottom") {
      const lastBottomIndex = this.pinnedRowModel.getPinnedBottomRowData().length - 1;
      return lastBottomIndex <= index;
    }
    const lastBodyIndex = this.paginationProxy.getPageLastRow();
    return lastBodyIndex <= index;
  }
  getRowAbove(rowPosition) {
    const index = rowPosition.rowIndex;
    const pinned = rowPosition.rowPinned;
    const isFirstRow = pinned ? index === 0 : index === this.paginationProxy.getPageFirstRow();
    if (isFirstRow) {
      if (pinned === "top") {
        return null;
      }
      if (!pinned) {
        if (this.pinnedRowModel.isRowsToRender("top")) {
          return this.getLastFloatingTopRow();
        }
        return null;
      }
      if (this.rowModel.isRowsToRender()) {
        return this.getLastBodyCell();
      }
      if (this.pinnedRowModel.isRowsToRender("top")) {
        return this.getLastFloatingTopRow();
      }
      return null;
    }
    const rowNode = this.rowModel.getRow(rowPosition.rowIndex);
    const nextStickyPosition = this.getNextStickyPosition(rowNode, true);
    if (nextStickyPosition) {
      return nextStickyPosition;
    }
    return { rowIndex: index - 1, rowPinned: pinned };
  }
  getCellAbove(lastCell) {
    if (!lastCell) {
      return null;
    }
    const rowAbove = this.getRowAbove({ rowIndex: lastCell.rowIndex, rowPinned: lastCell.rowPinned });
    if (rowAbove) {
      return {
        rowIndex: rowAbove.rowIndex,
        column: lastCell.column,
        rowPinned: rowAbove.rowPinned
      };
    }
    return null;
  }
  getLastBodyCell() {
    const lastBodyRow = this.paginationProxy.getPageLastRow();
    return { rowIndex: lastBodyRow, rowPinned: null };
  }
  getLastFloatingTopRow() {
    const lastFloatingRow = this.pinnedRowModel.getPinnedTopRowData().length - 1;
    return { rowIndex: lastFloatingRow, rowPinned: "top" };
  }
  getNextTabbedCell(gridCell, backwards) {
    if (backwards) {
      return this.getNextTabbedCellBackwards(gridCell);
    }
    return this.getNextTabbedCellForwards(gridCell);
  }
  getNextTabbedCellForwards(gridCell) {
    const displayedColumns = this.columnModel.getAllDisplayedColumns();
    let newRowIndex = gridCell.rowIndex;
    let newFloating = gridCell.rowPinned;
    let newColumn = this.columnModel.getDisplayedColAfter(gridCell.column);
    if (!newColumn) {
      newColumn = displayedColumns[0];
      const rowBelow = this.getRowBelow(gridCell);
      if (missing(rowBelow)) {
        return null;
      }
      if (!rowBelow.rowPinned && !this.paginationProxy.isRowInPage(rowBelow)) {
        return null;
      }
      newRowIndex = rowBelow ? rowBelow.rowIndex : null;
      newFloating = rowBelow ? rowBelow.rowPinned : null;
    }
    return { rowIndex: newRowIndex, column: newColumn, rowPinned: newFloating };
  }
  getNextTabbedCellBackwards(gridCell) {
    const displayedColumns = this.columnModel.getAllDisplayedColumns();
    let newRowIndex = gridCell.rowIndex;
    let newFloating = gridCell.rowPinned;
    let newColumn = this.columnModel.getDisplayedColBefore(gridCell.column);
    if (!newColumn) {
      newColumn = last(displayedColumns);
      const rowAbove = this.getRowAbove({ rowIndex: gridCell.rowIndex, rowPinned: gridCell.rowPinned });
      if (missing(rowAbove)) {
        return null;
      }
      if (!rowAbove.rowPinned && !this.paginationProxy.isRowInPage(rowAbove)) {
        return null;
      }
      newRowIndex = rowAbove ? rowAbove.rowIndex : null;
      newFloating = rowAbove ? rowAbove.rowPinned : null;
    }
    return { rowIndex: newRowIndex, column: newColumn, rowPinned: newFloating };
  }
};
__decorate$Q([
  Autowired("columnModel")
], CellNavigationService.prototype, "columnModel", void 0);
__decorate$Q([
  Autowired("rowModel")
], CellNavigationService.prototype, "rowModel", void 0);
__decorate$Q([
  Autowired("rowRenderer")
], CellNavigationService.prototype, "rowRenderer", void 0);
__decorate$Q([
  Autowired("pinnedRowModel")
], CellNavigationService.prototype, "pinnedRowModel", void 0);
__decorate$Q([
  Autowired("paginationProxy")
], CellNavigationService.prototype, "paginationProxy", void 0);
CellNavigationService = __decorate$Q([
  Bean("cellNavigationService")
], CellNavigationService);
var __decorate$P = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$6 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var AlignedGridsService = class AlignedGridsService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.consuming = false;
  }
  setBeans(loggerFactory) {
    this.logger = loggerFactory.create("AlignedGridsService");
  }
  init() {
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, this.fireColumnEvent.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, this.fireColumnEvent.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PINNED, this.fireColumnEvent.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_GROUP_OPENED, this.fireColumnEvent.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_RESIZED, this.fireColumnEvent.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL, this.fireScrollEvent.bind(this));
  }
  fireEvent(callback) {
    if (this.consuming) {
      return;
    }
    const otherGrids = this.gridOptionsService.get("alignedGrids");
    if (otherGrids) {
      otherGrids.forEach((otherGridOptions) => {
        if (otherGridOptions.api) {
          const alignedGridService = otherGridOptions.api.__getAlignedGridService();
          callback(alignedGridService);
        }
      });
    }
  }
  onEvent(callback) {
    this.consuming = true;
    callback();
    this.consuming = false;
  }
  fireColumnEvent(event) {
    this.fireEvent((alignedGridsService) => {
      alignedGridsService.onColumnEvent(event);
    });
  }
  fireScrollEvent(event) {
    if (event.direction !== "horizontal") {
      return;
    }
    this.fireEvent((alignedGridsService) => {
      alignedGridsService.onScrollEvent(event);
    });
  }
  onScrollEvent(event) {
    this.onEvent(() => {
      const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
      gridBodyCon.getScrollFeature().setHorizontalScrollPosition(event.left);
    });
  }
  getMasterColumns(event) {
    const result = [];
    if (event.columns) {
      event.columns.forEach((column) => {
        result.push(column);
      });
    } else if (event.column) {
      result.push(event.column);
    }
    return result;
  }
  getColumnIds(event) {
    const result = [];
    if (event.columns) {
      event.columns.forEach((column) => {
        result.push(column.getColId());
      });
    } else if (event.column) {
      result.push(event.column.getColId());
    }
    return result;
  }
  onColumnEvent(event) {
    this.onEvent(() => {
      switch (event.type) {
        case Events.EVENT_COLUMN_MOVED:
        case Events.EVENT_COLUMN_VISIBLE:
        case Events.EVENT_COLUMN_PINNED:
        case Events.EVENT_COLUMN_RESIZED:
          const colEvent = event;
          this.processColumnEvent(colEvent);
          break;
        case Events.EVENT_COLUMN_GROUP_OPENED:
          const groupOpenedEvent = event;
          this.processGroupOpenedEvent(groupOpenedEvent);
          break;
        case Events.EVENT_COLUMN_PIVOT_CHANGED:
          console.warn("AG Grid: pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.");
          break;
      }
    });
  }
  processGroupOpenedEvent(groupOpenedEvent) {
    const masterColumnGroup = groupOpenedEvent.columnGroup;
    let otherColumnGroup = null;
    if (masterColumnGroup) {
      const groupId = masterColumnGroup.getGroupId();
      otherColumnGroup = this.columnModel.getProvidedColumnGroup(groupId);
    }
    if (masterColumnGroup && !otherColumnGroup) {
      return;
    }
    this.logger.log("onColumnEvent-> processing " + groupOpenedEvent + " expanded = " + masterColumnGroup.isExpanded());
    this.columnModel.setColumnGroupOpened(otherColumnGroup, masterColumnGroup.isExpanded(), "alignedGridChanged");
  }
  processColumnEvent(colEvent) {
    var _a;
    const masterColumn = colEvent.column;
    let otherColumn = null;
    if (masterColumn) {
      otherColumn = this.columnModel.getPrimaryColumn(masterColumn.getColId());
    }
    if (masterColumn && !otherColumn) {
      return;
    }
    const masterColumns = this.getMasterColumns(colEvent);
    switch (colEvent.type) {
      case Events.EVENT_COLUMN_MOVED:
        {
          const movedEvent = colEvent;
          const srcColState = colEvent.columnApi.getColumnState();
          const destColState = srcColState.map((s) => ({ colId: s.colId }));
          this.columnModel.applyColumnState({ state: destColState, applyOrder: true }, "alignedGridChanged");
          this.logger.log(`onColumnEvent-> processing ${colEvent.type} toIndex = ${movedEvent.toIndex}`);
        }
        break;
      case Events.EVENT_COLUMN_VISIBLE:
        {
          const visibleEvent = colEvent;
          const srcColState = colEvent.columnApi.getColumnState();
          const destColState = srcColState.map((s) => ({ colId: s.colId, hide: s.hide }));
          this.columnModel.applyColumnState({ state: destColState }, "alignedGridChanged");
          this.logger.log(`onColumnEvent-> processing ${colEvent.type} visible = ${visibleEvent.visible}`);
        }
        break;
      case Events.EVENT_COLUMN_PINNED:
        {
          const pinnedEvent = colEvent;
          const srcColState = colEvent.columnApi.getColumnState();
          const destColState = srcColState.map((s) => ({ colId: s.colId, pinned: s.pinned }));
          this.columnModel.applyColumnState({ state: destColState }, "alignedGridChanged");
          this.logger.log(`onColumnEvent-> processing ${colEvent.type} pinned = ${pinnedEvent.pinned}`);
        }
        break;
      case Events.EVENT_COLUMN_RESIZED:
        const resizedEvent = colEvent;
        const columnWidths = {};
        masterColumns.forEach((column) => {
          this.logger.log(`onColumnEvent-> processing ${colEvent.type} actualWidth = ${column.getActualWidth()}`);
          columnWidths[column.getId()] = { key: column.getColId(), newWidth: column.getActualWidth() };
        });
        (_a = resizedEvent.flexColumns) === null || _a === void 0 ? void 0 : _a.forEach((col) => {
          if (columnWidths[col.getId()]) {
            delete columnWidths[col.getId()];
          }
        });
        this.columnModel.setColumnWidths(Object.values(columnWidths), false, resizedEvent.finished, "alignedGridChanged");
        break;
    }
    const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
    const isVerticalScrollShowing2 = gridBodyCon.isVerticalScrollShowing();
    const alignedGrids = this.gridOptionsService.get("alignedGrids");
    if (alignedGrids) {
      alignedGrids.forEach((grid) => {
        if (grid.api) {
          grid.api.setAlwaysShowVerticalScroll(isVerticalScrollShowing2);
        }
      });
    }
  }
};
__decorate$P([
  Autowired("columnModel")
], AlignedGridsService.prototype, "columnModel", void 0);
__decorate$P([
  Autowired("ctrlsService")
], AlignedGridsService.prototype, "ctrlsService", void 0);
__decorate$P([
  __param$6(0, Qualifier("loggerFactory"))
], AlignedGridsService.prototype, "setBeans", null);
__decorate$P([
  PostConstruct
], AlignedGridsService.prototype, "init", null);
AlignedGridsService = __decorate$P([
  Bean("alignedGridsService")
], AlignedGridsService);
var __decorate$O = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SelectionService = class SelectionService2 extends BeanStub {
  setBeans(loggerFactory) {
    this.logger = loggerFactory.create("selectionService");
    this.reset();
  }
  init() {
    this.groupSelectsChildren = this.gridOptionsService.is("groupSelectsChildren");
    this.addManagedPropertyListener("groupSelectsChildren", (propChange) => this.groupSelectsChildren = propChange.currentValue);
    this.rowSelection = this.gridOptionsService.get("rowSelection");
    this.addManagedPropertyListener("rowSelection", (propChange) => this.rowSelection = propChange.currentValue);
    this.addManagedListener(this.eventService, Events.EVENT_ROW_SELECTED, this.onRowSelected.bind(this));
  }
  isMultiselect() {
    return this.rowSelection === "multiple";
  }
  setNodesSelected(params) {
    var _a;
    if (params.nodes.length === 0)
      return 0;
    const { newValue, clearSelection, suppressFinishActions, rangeSelect, event, source = "api" } = params;
    if (params.nodes.length > 1 && !this.isMultiselect()) {
      console.warn(`AG Grid: cannot multi select while rowSelection='single'`);
      return 0;
    }
    const groupSelectsFiltered = this.groupSelectsChildren && params.groupSelectsFiltered === true;
    const nodes = params.nodes.map((node) => node.footer ? node.sibling : node);
    if (rangeSelect) {
      if (params.nodes.length > 1) {
        console.warn("AG Grid: cannot range select while selecting multiple rows");
        return 0;
      }
      const lastSelectedNode = this.getLastSelectedNode();
      if (lastSelectedNode) {
        const node = nodes[0];
        const newRowClicked = lastSelectedNode !== node;
        if (newRowClicked && this.isMultiselect()) {
          const nodesChanged = this.selectRange(node, lastSelectedNode, params.newValue, source);
          this.setLastSelectedNode(node);
          return nodesChanged;
        }
      }
    }
    let updatedCount = 0;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      const skipThisNode = groupSelectsFiltered && node.group;
      if (!skipThisNode) {
        const thisNodeWasSelected = node.selectThisNode(newValue, params.event, source);
        if (thisNodeWasSelected) {
          updatedCount++;
        }
      }
      if (this.groupSelectsChildren && ((_a = node.childrenAfterGroup) === null || _a === void 0 ? void 0 : _a.length)) {
        updatedCount += this.selectChildren(node, newValue, groupSelectsFiltered, source);
      }
    }
    if (!suppressFinishActions) {
      const clearOtherNodes = newValue && (clearSelection || !this.isMultiselect());
      if (clearOtherNodes) {
        updatedCount += this.clearOtherNodes(nodes[0], source);
      }
      if (updatedCount > 0) {
        this.updateGroupsFromChildrenSelections(source);
        const event2 = {
          type: Events.EVENT_SELECTION_CHANGED,
          source
        };
        this.eventService.dispatchEvent(event2);
      }
      if (newValue) {
        this.setLastSelectedNode(nodes[nodes.length - 1]);
      }
    }
    return updatedCount;
  }
  selectRange(fromNode, toNode, value = true, source) {
    const nodesToSelect = this.rowModel.getNodesInRangeForSelection(fromNode, toNode);
    let updatedCount = 0;
    nodesToSelect.forEach((rowNode) => {
      if (rowNode.group && this.groupSelectsChildren || value === false && fromNode === rowNode) {
        return;
      }
      const nodeWasSelected = rowNode.selectThisNode(value, void 0, source);
      if (nodeWasSelected) {
        updatedCount++;
      }
    });
    this.updateGroupsFromChildrenSelections(source);
    const event = {
      type: Events.EVENT_SELECTION_CHANGED,
      source
    };
    this.eventService.dispatchEvent(event);
    return updatedCount;
  }
  selectChildren(node, newValue, groupSelectsFiltered, source) {
    const children = groupSelectsFiltered ? node.childrenAfterAggFilter : node.childrenAfterGroup;
    if (_.missing(children)) {
      return 0;
    }
    return this.setNodesSelected({
      newValue,
      clearSelection: false,
      suppressFinishActions: true,
      groupSelectsFiltered,
      source,
      nodes: children
    });
  }
  setLastSelectedNode(rowNode) {
    this.lastSelectedNode = rowNode;
  }
  getLastSelectedNode() {
    return this.lastSelectedNode;
  }
  getSelectedNodes() {
    const selectedNodes = [];
    iterateObject(this.selectedNodes, (key, rowNode) => {
      if (rowNode) {
        selectedNodes.push(rowNode);
      }
    });
    return selectedNodes;
  }
  getSelectedRows() {
    const selectedRows = [];
    iterateObject(this.selectedNodes, (key, rowNode) => {
      if (rowNode && rowNode.data) {
        selectedRows.push(rowNode.data);
      }
    });
    return selectedRows;
  }
  getSelectionCount() {
    return Object.values(this.selectedNodes).length;
  }
  filterFromSelection(predicate) {
    const newSelectedNodes = {};
    Object.entries(this.selectedNodes).forEach(([key, node]) => {
      const passesPredicate = node && predicate(node);
      if (passesPredicate) {
        newSelectedNodes[key] = node;
      }
    });
    this.selectedNodes = newSelectedNodes;
  }
  updateGroupsFromChildrenSelections(source, changedPath) {
    if (!this.groupSelectsChildren) {
      return false;
    }
    if (this.rowModel.getType() !== "clientSide") {
      return false;
    }
    const clientSideRowModel = this.rowModel;
    const rootNode = clientSideRowModel.getRootNode();
    if (!changedPath) {
      changedPath = new ChangedPath(true, rootNode);
      changedPath.setInactive();
    }
    let selectionChanged = false;
    changedPath.forEachChangedNodeDepthFirst((rowNode) => {
      if (rowNode !== rootNode) {
        const selected = rowNode.calculateSelectedFromChildren();
        selectionChanged = rowNode.selectThisNode(selected === null ? false : selected, void 0, source) || selectionChanged;
      }
    });
    return selectionChanged;
  }
  clearOtherNodes(rowNodeToKeepSelected, source) {
    const groupsToRefresh = {};
    let updatedCount = 0;
    iterateObject(this.selectedNodes, (key, otherRowNode) => {
      if (otherRowNode && otherRowNode.id !== rowNodeToKeepSelected.id) {
        const rowNode = this.selectedNodes[otherRowNode.id];
        updatedCount += rowNode.setSelectedParams({
          newValue: false,
          clearSelection: false,
          suppressFinishActions: true,
          source
        });
        if (this.groupSelectsChildren && otherRowNode.parent) {
          groupsToRefresh[otherRowNode.parent.id] = otherRowNode.parent;
        }
      }
    });
    iterateObject(groupsToRefresh, (key, group) => {
      const selected = group.calculateSelectedFromChildren();
      group.selectThisNode(selected === null ? false : selected, void 0, source);
    });
    return updatedCount;
  }
  onRowSelected(event) {
    const rowNode = event.node;
    if (this.groupSelectsChildren && rowNode.group) {
      return;
    }
    if (rowNode.isSelected()) {
      this.selectedNodes[rowNode.id] = rowNode;
    } else {
      delete this.selectedNodes[rowNode.id];
    }
  }
  syncInRowNode(rowNode, oldNode) {
    this.syncInOldRowNode(rowNode, oldNode);
    this.syncInNewRowNode(rowNode);
  }
  syncInOldRowNode(rowNode, oldNode) {
    const oldNodeHasDifferentId = exists(oldNode) && rowNode.id !== oldNode.id;
    if (oldNodeHasDifferentId && oldNode) {
      const id = oldNode.id;
      const oldNodeSelected = this.selectedNodes[id] == rowNode;
      if (oldNodeSelected) {
        this.selectedNodes[oldNode.id] = oldNode;
      }
    }
  }
  syncInNewRowNode(rowNode) {
    if (exists(this.selectedNodes[rowNode.id])) {
      rowNode.setSelectedInitialValue(true);
      this.selectedNodes[rowNode.id] = rowNode;
    } else {
      rowNode.setSelectedInitialValue(false);
    }
  }
  reset() {
    this.logger.log("reset");
    this.selectedNodes = {};
    this.lastSelectedNode = null;
  }
  getBestCostNodeSelection() {
    if (this.rowModel.getType() !== "clientSide") {
      return;
    }
    const clientSideRowModel = this.rowModel;
    const topLevelNodes = clientSideRowModel.getTopLevelNodes();
    if (topLevelNodes === null) {
      return;
    }
    const result = [];
    function traverse(nodes) {
      for (let i = 0, l = nodes.length; i < l; i++) {
        const node = nodes[i];
        if (node.isSelected()) {
          result.push(node);
        } else {
          const maybeGroup = node;
          if (maybeGroup.group && maybeGroup.children) {
            traverse(maybeGroup.children);
          }
        }
      }
    }
    traverse(topLevelNodes);
    return result;
  }
  isEmpty() {
    let count = 0;
    iterateObject(this.selectedNodes, (nodeId, rowNode) => {
      if (rowNode) {
        count++;
      }
    });
    return count === 0;
  }
  deselectAllRowNodes(params) {
    const callback = (rowNode) => rowNode.selectThisNode(false, void 0, source);
    const rowModelClientSide = this.rowModel.getType() === "clientSide";
    const { source, justFiltered, justCurrentPage } = params;
    if (justCurrentPage || justFiltered) {
      if (!rowModelClientSide) {
        console.error("AG Grid: selecting just filtered only works when gridOptions.rowModelType='clientSide'");
        return;
      }
      this.getNodesToSelect(justFiltered, justCurrentPage).forEach(callback);
    } else {
      iterateObject(this.selectedNodes, (id, rowNode) => {
        if (rowNode) {
          callback(rowNode);
        }
      });
      this.reset();
    }
    if (rowModelClientSide && this.groupSelectsChildren) {
      this.updateGroupsFromChildrenSelections(source);
    }
    const event = {
      type: Events.EVENT_SELECTION_CHANGED,
      source
    };
    this.eventService.dispatchEvent(event);
  }
  getSelectAllState(justFiltered, justCurrentPage) {
    let selectedCount = 0;
    let notSelectedCount = 0;
    const callback = (node) => {
      if (this.groupSelectsChildren && node.group) {
        return;
      }
      if (node.isSelected()) {
        selectedCount++;
      } else if (!node.selectable)
        ;
      else {
        notSelectedCount++;
      }
    };
    this.getNodesToSelect(justFiltered, justCurrentPage).forEach(callback);
    if (selectedCount === 0 && notSelectedCount === 0) {
      return false;
    }
    if (selectedCount > 0 && notSelectedCount > 0) {
      return null;
    }
    return selectedCount > 0;
  }
  getNodesToSelect(justFiltered = false, justCurrentPage = false) {
    if (this.rowModel.getType() !== "clientSide") {
      throw new Error(`selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`);
    }
    const nodes = [];
    if (justCurrentPage) {
      this.paginationProxy.forEachNodeOnPage((node) => {
        if (!node.group) {
          nodes.push(node);
          return;
        }
        if (!node.expanded) {
          const recursivelyAddChildren = (child) => {
            var _a;
            nodes.push(child);
            if ((_a = child.childrenAfterFilter) === null || _a === void 0 ? void 0 : _a.length) {
              child.childrenAfterFilter.forEach(recursivelyAddChildren);
            }
          };
          recursivelyAddChildren(node);
          return;
        }
        if (!this.groupSelectsChildren) {
          nodes.push(node);
        }
      });
      return nodes;
    }
    const clientSideRowModel = this.rowModel;
    if (justFiltered) {
      clientSideRowModel.forEachNodeAfterFilter((node) => {
        nodes.push(node);
      });
      return nodes;
    }
    clientSideRowModel.forEachNode((node) => {
      nodes.push(node);
    });
    return nodes;
  }
  selectAllRowNodes(params) {
    if (this.rowModel.getType() !== "clientSide") {
      throw new Error(`selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`);
    }
    const { source, justFiltered, justCurrentPage } = params;
    const callback = (rowNode) => rowNode.selectThisNode(true, void 0, source);
    this.getNodesToSelect(justFiltered, justCurrentPage).forEach(callback);
    if (this.rowModel.getType() === "clientSide" && this.groupSelectsChildren) {
      this.updateGroupsFromChildrenSelections(source);
    }
    const event = {
      type: Events.EVENT_SELECTION_CHANGED,
      source
    };
    this.eventService.dispatchEvent(event);
  }
  getServerSideSelectionState() {
    return null;
  }
  setServerSideSelectionState(state) {
  }
};
__decorate$O([
  Autowired("rowModel")
], SelectionService.prototype, "rowModel", void 0);
__decorate$O([
  Autowired("paginationProxy")
], SelectionService.prototype, "paginationProxy", void 0);
__decorate$O([
  __param$5(0, Qualifier("loggerFactory"))
], SelectionService.prototype, "setBeans", null);
__decorate$O([
  PostConstruct
], SelectionService.prototype, "init", null);
SelectionService = __decorate$O([
  Bean("selectionService")
], SelectionService);
var __decorate$N = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ColumnApi = class ColumnApi2 {
  sizeColumnsToFit(gridWidth) {
    if (typeof gridWidth === "undefined") {
      console.error("AG Grid: missing parameter to columnApi.sizeColumnsToFit(gridWidth)");
    }
    this.columnModel.sizeColumnsToFit(gridWidth, "api");
  }
  setColumnGroupOpened(group, newValue) {
    this.columnModel.setColumnGroupOpened(group, newValue, "api");
  }
  getColumnGroup(name, instanceId) {
    return this.columnModel.getColumnGroup(name, instanceId);
  }
  getProvidedColumnGroup(name) {
    return this.columnModel.getProvidedColumnGroup(name);
  }
  getDisplayNameForColumn(column, location) {
    return this.columnModel.getDisplayNameForColumn(column, location) || "";
  }
  getDisplayNameForColumnGroup(columnGroup, location) {
    return this.columnModel.getDisplayNameForColumnGroup(columnGroup, location) || "";
  }
  getColumn(key) {
    return this.columnModel.getPrimaryColumn(key);
  }
  getColumns() {
    return this.columnModel.getAllPrimaryColumns();
  }
  applyColumnState(params) {
    return this.columnModel.applyColumnState(params, "api");
  }
  getColumnState() {
    return this.columnModel.getColumnState();
  }
  resetColumnState() {
    this.columnModel.resetColumnState("api");
  }
  getColumnGroupState() {
    return this.columnModel.getColumnGroupState();
  }
  setColumnGroupState(stateItems) {
    this.columnModel.setColumnGroupState(stateItems, "api");
  }
  resetColumnGroupState() {
    this.columnModel.resetColumnGroupState("api");
  }
  isPinning() {
    return this.columnModel.isPinningLeft() || this.columnModel.isPinningRight();
  }
  isPinningLeft() {
    return this.columnModel.isPinningLeft();
  }
  isPinningRight() {
    return this.columnModel.isPinningRight();
  }
  getDisplayedColAfter(col) {
    return this.columnModel.getDisplayedColAfter(col);
  }
  getDisplayedColBefore(col) {
    return this.columnModel.getDisplayedColBefore(col);
  }
  setColumnVisible(key, visible) {
    this.columnModel.setColumnVisible(key, visible, "api");
  }
  setColumnsVisible(keys2, visible) {
    this.columnModel.setColumnsVisible(keys2, visible, "api");
  }
  setColumnPinned(key, pinned) {
    this.columnModel.setColumnPinned(key, pinned, "api");
  }
  setColumnsPinned(keys2, pinned) {
    this.columnModel.setColumnsPinned(keys2, pinned, "api");
  }
  getAllGridColumns() {
    return this.columnModel.getAllGridColumns();
  }
  getDisplayedLeftColumns() {
    return this.columnModel.getDisplayedLeftColumns();
  }
  getDisplayedCenterColumns() {
    return this.columnModel.getDisplayedCenterColumns();
  }
  getDisplayedRightColumns() {
    return this.columnModel.getDisplayedRightColumns();
  }
  getAllDisplayedColumns() {
    return this.columnModel.getAllDisplayedColumns();
  }
  getAllDisplayedVirtualColumns() {
    return this.columnModel.getViewportColumns();
  }
  moveColumn(key, toIndex) {
    this.columnModel.moveColumn(key, toIndex, "api");
  }
  moveColumnByIndex(fromIndex, toIndex) {
    this.columnModel.moveColumnByIndex(fromIndex, toIndex, "api");
  }
  moveColumns(columnsToMoveKeys, toIndex) {
    this.columnModel.moveColumns(columnsToMoveKeys, toIndex, "api");
  }
  moveRowGroupColumn(fromIndex, toIndex) {
    this.columnModel.moveRowGroupColumn(fromIndex, toIndex);
  }
  setColumnAggFunc(key, aggFunc) {
    this.columnModel.setColumnAggFunc(key, aggFunc);
  }
  setColumnWidth(key, newWidth, finished = true, source) {
    this.columnModel.setColumnWidths([{ key, newWidth }], false, finished, source);
  }
  setColumnWidths(columnWidths, finished = true, source) {
    this.columnModel.setColumnWidths(columnWidths, false, finished, source);
  }
  setPivotMode(pivotMode) {
    this.columnModel.setPivotMode(pivotMode);
  }
  isPivotMode() {
    return this.columnModel.isPivotMode();
  }
  getPivotResultColumn(pivotKeys, valueColKey) {
    return this.columnModel.getSecondaryPivotColumn(pivotKeys, valueColKey);
  }
  setValueColumns(colKeys) {
    this.columnModel.setValueColumns(colKeys, "api");
  }
  getValueColumns() {
    return this.columnModel.getValueColumns();
  }
  removeValueColumn(colKey) {
    this.columnModel.removeValueColumn(colKey, "api");
  }
  removeValueColumns(colKeys) {
    this.columnModel.removeValueColumns(colKeys, "api");
  }
  addValueColumn(colKey) {
    this.columnModel.addValueColumn(colKey, "api");
  }
  addValueColumns(colKeys) {
    this.columnModel.addValueColumns(colKeys, "api");
  }
  setRowGroupColumns(colKeys) {
    this.columnModel.setRowGroupColumns(colKeys, "api");
  }
  removeRowGroupColumn(colKey) {
    this.columnModel.removeRowGroupColumn(colKey, "api");
  }
  removeRowGroupColumns(colKeys) {
    this.columnModel.removeRowGroupColumns(colKeys, "api");
  }
  addRowGroupColumn(colKey) {
    this.columnModel.addRowGroupColumn(colKey, "api");
  }
  addRowGroupColumns(colKeys) {
    this.columnModel.addRowGroupColumns(colKeys, "api");
  }
  getRowGroupColumns() {
    return this.columnModel.getRowGroupColumns();
  }
  setPivotColumns(colKeys) {
    this.columnModel.setPivotColumns(colKeys, "api");
  }
  removePivotColumn(colKey) {
    this.columnModel.removePivotColumn(colKey, "api");
  }
  removePivotColumns(colKeys) {
    this.columnModel.removePivotColumns(colKeys, "api");
  }
  addPivotColumn(colKey) {
    this.columnModel.addPivotColumn(colKey, "api");
  }
  addPivotColumns(colKeys) {
    this.columnModel.addPivotColumns(colKeys, "api");
  }
  getPivotColumns() {
    return this.columnModel.getPivotColumns();
  }
  getLeftDisplayedColumnGroups() {
    return this.columnModel.getDisplayedTreeLeft();
  }
  getCenterDisplayedColumnGroups() {
    return this.columnModel.getDisplayedTreeCentre();
  }
  getRightDisplayedColumnGroups() {
    return this.columnModel.getDisplayedTreeRight();
  }
  getAllDisplayedColumnGroups() {
    return this.columnModel.getAllDisplayedTrees();
  }
  autoSizeColumn(key, skipHeader) {
    return this.columnModel.autoSizeColumn(key, skipHeader, "api");
  }
  autoSizeColumns(keys2, skipHeader) {
    this.columnModel.autoSizeColumns({ columns: keys2, skipHeader });
  }
  autoSizeAllColumns(skipHeader) {
    this.columnModel.autoSizeAllColumns(skipHeader, "api");
  }
  setPivotResultColumns(colDefs) {
    this.columnModel.setSecondaryColumns(colDefs, "api");
  }
  getPivotResultColumns() {
    return this.columnModel.getSecondaryColumns();
  }
  cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid() {
    setTimeout(_.removeAllReferences.bind(window, this, "Column API"), 100);
  }
  getAllColumns() {
    logDeprecation("28.0", "getAllColumns", "getColumns");
    return this.getColumns();
  }
  getPrimaryColumns() {
    logDeprecation("28.0", "getPrimaryColumns", "getColumns");
    return this.getColumns();
  }
  getSecondaryColumns() {
    logDeprecation("28.0", "getSecondaryColumns", "getPivotResultColumns");
    return this.getPivotResultColumns();
  }
  setSecondaryColumns(colDefs) {
    logDeprecation("28.0", "setSecondaryColumns", "setPivotResultColumns");
    this.setPivotResultColumns(colDefs);
  }
  getSecondaryPivotColumn(pivotKeys, valueColKey) {
    logDeprecation("28.0", "getSecondaryPivotColumn", "getPivotResultColumn");
    return this.getPivotResultColumn(pivotKeys, valueColKey);
  }
};
__decorate$N([
  Autowired("columnModel")
], ColumnApi.prototype, "columnModel", void 0);
__decorate$N([
  PreDestroy
], ColumnApi.prototype, "cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid", null);
ColumnApi = __decorate$N([
  Bean("columnApi")
], ColumnApi);
var __decorate$M = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ValueService = class ValueService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.initialised = false;
    this.isSsrm = false;
  }
  init() {
    this.isSsrm = this.gridOptionsService.isRowModelType("serverSide");
    this.cellExpressions = this.gridOptionsService.is("enableCellExpressions");
    this.isTreeData = this.gridOptionsService.is("treeData");
    this.initialised = true;
    this.eventService.addEventListener(Events.EVENT_CELL_VALUE_CHANGED, (event) => this.callColumnCellValueChangedHandler(event), this.gridOptionsService.useAsyncEvents());
    this.addManagedPropertyListener("treeData", (propChange) => this.isTreeData = propChange.currentValue);
  }
  getValue(column, rowNode, forFilter = false, ignoreAggData = false) {
    if (!this.initialised) {
      this.init();
    }
    if (!rowNode) {
      return;
    }
    const colDef = column.getColDef();
    const field = colDef.field;
    const colId = column.getColId();
    const data = rowNode.data;
    let result;
    const groupDataExists = rowNode.groupData && rowNode.groupData[colId] !== void 0;
    const aggDataExists = !ignoreAggData && rowNode.aggData && rowNode.aggData[colId] !== void 0;
    const ignoreSsrmAggData = this.isSsrm && ignoreAggData && !!column.getColDef().aggFunc;
    const ssrmFooterGroupCol = this.isSsrm && rowNode.footer && rowNode.field && (column.getColDef().showRowGroup === true || column.getColDef().showRowGroup === rowNode.field);
    if (forFilter && colDef.filterValueGetter) {
      result = this.executeFilterValueGetter(colDef.filterValueGetter, data, column, rowNode);
    } else if (this.isTreeData && aggDataExists) {
      result = rowNode.aggData[colId];
    } else if (this.isTreeData && colDef.valueGetter) {
      result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
    } else if (this.isTreeData && (field && data)) {
      result = getValueUsingField(data, field, column.isFieldContainsDots());
    } else if (groupDataExists) {
      result = rowNode.groupData[colId];
    } else if (aggDataExists) {
      result = rowNode.aggData[colId];
    } else if (colDef.valueGetter) {
      result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
    } else if (ssrmFooterGroupCol) {
      result = getValueUsingField(data, rowNode.field, column.isFieldContainsDots());
    } else if (field && data && !ignoreSsrmAggData) {
      result = getValueUsingField(data, field, column.isFieldContainsDots());
    }
    if (this.cellExpressions && typeof result === "string" && result.indexOf("=") === 0) {
      const cellValueGetter = result.substring(1);
      result = this.executeValueGetter(cellValueGetter, data, column, rowNode);
    }
    if (result == null) {
      const openedGroup = this.getOpenedGroup(rowNode, column);
      if (openedGroup != null) {
        return openedGroup;
      }
    }
    return result;
  }
  getOpenedGroup(rowNode, column) {
    if (!this.gridOptionsService.is("showOpenedGroup")) {
      return;
    }
    const colDef = column.getColDef();
    if (!colDef.showRowGroup) {
      return;
    }
    const showRowGroup = column.getColDef().showRowGroup;
    let pointer = rowNode.parent;
    while (pointer != null) {
      if (pointer.rowGroupColumn && (showRowGroup === true || showRowGroup === pointer.rowGroupColumn.getColId())) {
        return pointer.key;
      }
      pointer = pointer.parent;
    }
    return void 0;
  }
  setValue(rowNode, colKey, newValue, eventSource) {
    const column = this.columnModel.getPrimaryColumn(colKey);
    if (!rowNode || !column) {
      return false;
    }
    if (missing(rowNode.data)) {
      rowNode.data = {};
    }
    const { field, valueSetter } = column.getColDef();
    if (missing(field) && missing(valueSetter)) {
      console.warn(`AG Grid: you need either field or valueSetter set on colDef for editing to work`);
      return false;
    }
    if (!this.dataTypeService.checkType(column, newValue)) {
      console.warn(`AG Grid: Data type of the new value does not match the cell data type of the column`);
      return false;
    }
    const params = {
      node: rowNode,
      data: rowNode.data,
      oldValue: this.getValue(column, rowNode),
      newValue,
      colDef: column.getColDef(),
      column,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    };
    params.newValue = newValue;
    let valueWasDifferent;
    if (exists(valueSetter)) {
      if (typeof valueSetter === "function") {
        valueWasDifferent = valueSetter(params);
      } else {
        valueWasDifferent = this.expressionService.evaluate(valueSetter, params);
      }
    } else {
      valueWasDifferent = this.setValueUsingField(rowNode.data, field, newValue, column.isFieldContainsDots());
    }
    if (valueWasDifferent === void 0) {
      valueWasDifferent = true;
    }
    if (!valueWasDifferent) {
      return false;
    }
    rowNode.resetQuickFilterAggregateText();
    this.valueCache.onDataChanged();
    params.newValue = this.getValue(column, rowNode);
    const event = {
      type: Events.EVENT_CELL_VALUE_CHANGED,
      event: null,
      rowIndex: rowNode.rowIndex,
      rowPinned: rowNode.rowPinned,
      column: params.column,
      api: params.api,
      columnApi: params.columnApi,
      colDef: params.colDef,
      context: params.context,
      data: rowNode.data,
      node: rowNode,
      oldValue: params.oldValue,
      newValue: params.newValue,
      value: params.newValue,
      source: eventSource
    };
    this.eventService.dispatchEvent(event);
    return true;
  }
  callColumnCellValueChangedHandler(event) {
    const onCellValueChanged = event.colDef.onCellValueChanged;
    if (typeof onCellValueChanged === "function") {
      onCellValueChanged({
        node: event.node,
        data: event.data,
        oldValue: event.oldValue,
        newValue: event.newValue,
        colDef: event.colDef,
        column: event.column,
        api: event.api,
        columnApi: event.columnApi,
        context: event.context
      });
    }
  }
  setValueUsingField(data, field, newValue, isFieldContainsDots) {
    if (!field) {
      return false;
    }
    let valuesAreSame = false;
    if (!isFieldContainsDots) {
      valuesAreSame = data[field] == newValue;
      if (!valuesAreSame) {
        data[field] = newValue;
      }
    } else {
      const fieldPieces = field.split(".");
      let currentObject = data;
      while (fieldPieces.length > 0 && currentObject) {
        const fieldPiece = fieldPieces.shift();
        if (fieldPieces.length === 0) {
          valuesAreSame = currentObject[fieldPiece] == newValue;
          if (!valuesAreSame) {
            currentObject[fieldPiece] = newValue;
          }
        } else {
          currentObject = currentObject[fieldPiece];
        }
      }
    }
    return !valuesAreSame;
  }
  executeFilterValueGetter(valueGetter, data, column, rowNode) {
    const params = {
      data,
      node: rowNode,
      column,
      colDef: column.getColDef(),
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context,
      getValue: this.getValueCallback.bind(this, rowNode)
    };
    if (typeof valueGetter === "function") {
      return valueGetter(params);
    }
    return this.expressionService.evaluate(valueGetter, params);
  }
  executeValueGetter(valueGetter, data, column, rowNode) {
    const colId = column.getColId();
    const valueFromCache = this.valueCache.getValue(rowNode, colId);
    if (valueFromCache !== void 0) {
      return valueFromCache;
    }
    const params = {
      data,
      node: rowNode,
      column,
      colDef: column.getColDef(),
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context,
      getValue: this.getValueCallback.bind(this, rowNode)
    };
    let result;
    if (typeof valueGetter === "function") {
      result = valueGetter(params);
    } else {
      result = this.expressionService.evaluate(valueGetter, params);
    }
    this.valueCache.setValue(rowNode, colId, result);
    return result;
  }
  getValueCallback(node, field) {
    const otherColumn = this.columnModel.getPrimaryColumn(field);
    if (otherColumn) {
      return this.getValue(otherColumn, node);
    }
    return null;
  }
  getKeyForNode(col, rowNode) {
    const value = this.getValue(col, rowNode);
    const keyCreator = col.getColDef().keyCreator;
    let result = value;
    if (keyCreator) {
      const keyParams = {
        value,
        colDef: col.getColDef(),
        column: col,
        node: rowNode,
        data: rowNode.data,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      };
      result = keyCreator(keyParams);
    }
    if (typeof result === "string" || result == null) {
      return result;
    }
    result = String(result);
    if (result === "[object Object]") {
      doOnce(() => {
        console.warn("AG Grid: a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (se AG Grid docs) or b) to toString() on the object to return a key");
      }, "getKeyForNode - warn about [object,object]");
    }
    return result;
  }
};
__decorate$M([
  Autowired("expressionService")
], ValueService.prototype, "expressionService", void 0);
__decorate$M([
  Autowired("columnModel")
], ValueService.prototype, "columnModel", void 0);
__decorate$M([
  Autowired("valueCache")
], ValueService.prototype, "valueCache", void 0);
__decorate$M([
  Autowired("dataTypeService")
], ValueService.prototype, "dataTypeService", void 0);
__decorate$M([
  PostConstruct
], ValueService.prototype, "init", null);
ValueService = __decorate$M([
  Bean("valueService")
], ValueService);
var __decorate$L = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ExpressionService = class ExpressionService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.expressionToFunctionCache = {};
  }
  setBeans(loggerFactory) {
    this.logger = loggerFactory.create("ExpressionService");
  }
  evaluate(expression, params) {
    if (typeof expression === "string") {
      return this.evaluateExpression(expression, params);
    } else {
      console.error("AG Grid: value should be either a string or a function", expression);
    }
  }
  evaluateExpression(expression, params) {
    try {
      const javaScriptFunction = this.createExpressionFunction(expression);
      const result = javaScriptFunction(params.value, params.context, params.oldValue, params.newValue, params.value, params.node, params.data, params.colDef, params.rowIndex, params.api, params.columnApi, params.getValue, params.column, params.columnGroup);
      return result;
    } catch (e) {
      console.log("Processing of the expression failed");
      console.log("Expression = " + expression);
      console.log("Params =", params);
      console.log("Exception = " + e);
      return null;
    }
  }
  createExpressionFunction(expression) {
    if (this.expressionToFunctionCache[expression]) {
      return this.expressionToFunctionCache[expression];
    }
    const functionBody = this.createFunctionBody(expression);
    const theFunction = new Function("x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, columnApi, getValue, column, columnGroup", functionBody);
    this.expressionToFunctionCache[expression] = theFunction;
    return theFunction;
  }
  createFunctionBody(expression) {
    if (expression.indexOf("return") >= 0) {
      return expression;
    } else {
      return "return " + expression + ";";
    }
  }
};
__decorate$L([
  __param$4(0, Qualifier("loggerFactory"))
], ExpressionService.prototype, "setBeans", null);
ExpressionService = __decorate$L([
  Bean("expressionService")
], ExpressionService);
var __decorate$K = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TemplateService = class TemplateService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.templateCache = {};
    this.waitingCallbacks = {};
  }
  getTemplate(url, callback) {
    const templateFromCache = this.templateCache[url];
    if (templateFromCache) {
      return templateFromCache;
    }
    let callbackList = this.waitingCallbacks[url];
    const that = this;
    if (!callbackList) {
      callbackList = [];
      this.waitingCallbacks[url] = callbackList;
      const client = new XMLHttpRequest();
      client.onload = function() {
        that.handleHttpResult(this, url);
      };
      client.open("GET", url);
      client.send();
    }
    if (callback) {
      callbackList.push(callback);
    }
    return null;
  }
  handleHttpResult(httpResult, url) {
    if (httpResult.status !== 200 || httpResult.response === null) {
      console.warn(`AG Grid: Unable to get template error ${httpResult.status} - ${url}`);
      return;
    }
    this.templateCache[url] = httpResult.response || httpResult.responseText;
    const callbacks = this.waitingCallbacks[url];
    for (let i = 0; i < callbacks.length; i++) {
      const callback = callbacks[i];
      callback();
    }
  }
};
TemplateService = __decorate$K([
  Bean("templateService")
], TemplateService);
var __decorate$J = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var LoggerFactory = class LoggerFactory2 extends BeanStub {
  setBeans(gridOptionsService) {
    this.logging = gridOptionsService.is("debug");
  }
  create(name) {
    return new Logger(name, this.isLogging.bind(this));
  }
  isLogging() {
    return this.logging;
  }
};
__decorate$J([
  __param$3(0, Qualifier("gridOptionsService"))
], LoggerFactory.prototype, "setBeans", null);
LoggerFactory = __decorate$J([
  Bean("loggerFactory")
], LoggerFactory);
var Logger = class {
  constructor(name, isLoggingFunc) {
    this.name = name;
    this.isLoggingFunc = isLoggingFunc;
  }
  isLogging() {
    return this.isLoggingFunc();
  }
  log(message) {
    if (this.isLoggingFunc()) {
      console.log("AG Grid." + this.name + ": " + message);
    }
  }
};
var __decorate$I = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GridCtrl = class extends BeanStub {
  setComp(view, eGridDiv, eGui) {
    this.view = view;
    this.eGridHostDiv = eGridDiv;
    this.eGui = eGui;
    this.eGui.setAttribute("grid-id", this.context.getGridId());
    this.dragAndDropService.addDropTarget({
      getContainer: () => this.eGui,
      isInterestedIn: (type) => type === DragSourceType.HeaderCell || type === DragSourceType.ToolPanel,
      getIconName: () => DragAndDropService.ICON_NOT_ALLOWED
    });
    this.mouseEventService.stampTopLevelGridCompWithGridInstance(eGridDiv);
    this.createManagedBean(new LayoutFeature(this.view));
    this.addRtlSupport();
    this.addManagedListener(this, Events.EVENT_KEYBOARD_FOCUS, () => {
      this.view.addOrRemoveKeyboardFocusClass(true);
    });
    this.addManagedListener(this, Events.EVENT_MOUSE_FOCUS, () => {
      this.view.addOrRemoveKeyboardFocusClass(false);
    });
    const unsubscribeFromResize = this.resizeObserverService.observeResize(this.eGridHostDiv, this.onGridSizeChanged.bind(this));
    this.addDestroyFunc(() => unsubscribeFromResize());
    this.ctrlsService.registerGridCtrl(this);
  }
  isDetailGrid() {
    var _a;
    const el = this.focusService.findTabbableParent(this.getGui());
    return ((_a = el === null || el === void 0 ? void 0 : el.getAttribute("row-id")) === null || _a === void 0 ? void 0 : _a.startsWith("detail")) || false;
  }
  showDropZones() {
    return ModuleRegistry.isRegistered(ModuleNames.RowGroupingModule, this.context.getGridId());
  }
  showSideBar() {
    return ModuleRegistry.isRegistered(ModuleNames.SideBarModule, this.context.getGridId());
  }
  showStatusBar() {
    return ModuleRegistry.isRegistered(ModuleNames.StatusBarModule, this.context.getGridId());
  }
  showWatermark() {
    return ModuleRegistry.isRegistered(ModuleNames.EnterpriseCoreModule, this.context.getGridId());
  }
  onGridSizeChanged() {
    const event = {
      type: Events.EVENT_GRID_SIZE_CHANGED,
      clientWidth: this.eGridHostDiv.clientWidth,
      clientHeight: this.eGridHostDiv.clientHeight
    };
    this.eventService.dispatchEvent(event);
  }
  addRtlSupport() {
    const cssClass = this.gridOptionsService.is("enableRtl") ? "ag-rtl" : "ag-ltr";
    this.view.setRtlClass(cssClass);
  }
  destroyGridUi() {
    this.view.destroyGridUi();
  }
  getGui() {
    return this.eGui;
  }
  setResizeCursor(on) {
    this.view.setCursor(on ? "ew-resize" : null);
  }
  disableUserSelect(on) {
    this.view.setUserSelect(on ? "none" : null);
  }
  focusNextInnerContainer(backwards) {
    const eDocument = this.gridOptionsService.getDocument();
    const focusableContainers = this.view.getFocusableContainers();
    const idxWithFocus = focusableContainers.findIndex((container) => container.contains(eDocument.activeElement));
    const nextIdx = idxWithFocus + (backwards ? -1 : 1);
    if (nextIdx <= 0 || nextIdx >= focusableContainers.length) {
      return false;
    }
    return this.focusService.focusInto(focusableContainers[nextIdx]);
  }
  focusInnerElement(fromBottom) {
    const focusableContainers = this.view.getFocusableContainers();
    const allColumns = this.columnModel.getAllDisplayedColumns();
    if (fromBottom) {
      if (focusableContainers.length > 1) {
        return this.focusService.focusInto(last(focusableContainers), true);
      }
      const lastColumn = last(allColumns);
      if (this.focusService.focusGridView(lastColumn, true)) {
        return true;
      }
    }
    if (this.gridOptionsService.getNum("headerHeight") === 0) {
      return this.focusService.focusGridView(allColumns[0]);
    }
    return this.focusService.focusFirstHeader();
  }
  forceFocusOutOfContainer(up = false) {
    this.view.forceFocusOutOfContainer(up);
  }
};
__decorate$I([
  Autowired("focusService")
], GridCtrl.prototype, "focusService", void 0);
__decorate$I([
  Autowired("resizeObserverService")
], GridCtrl.prototype, "resizeObserverService", void 0);
__decorate$I([
  Autowired("columnModel")
], GridCtrl.prototype, "columnModel", void 0);
__decorate$I([
  Autowired("ctrlsService")
], GridCtrl.prototype, "ctrlsService", void 0);
__decorate$I([
  Autowired("mouseEventService")
], GridCtrl.prototype, "mouseEventService", void 0);
__decorate$I([
  Autowired("dragAndDropService")
], GridCtrl.prototype, "dragAndDropService", void 0);
var __decorate$H = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GridComp = class extends TabGuardComp {
  constructor(eGridDiv) {
    super();
    this.eGridDiv = eGridDiv;
  }
  postConstruct() {
    this.logger = this.loggerFactory.create("GridComp");
    const compProxy = {
      destroyGridUi: () => this.destroyBean(this),
      setRtlClass: (cssClass) => this.addCssClass(cssClass),
      addOrRemoveKeyboardFocusClass: (addOrRemove) => this.addOrRemoveCssClass(FocusService.AG_KEYBOARD_FOCUS, addOrRemove),
      forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
      updateLayoutClasses: this.updateLayoutClasses.bind(this),
      getFocusableContainers: this.getFocusableContainers.bind(this),
      setUserSelect: (value) => {
        this.getGui().style.userSelect = value != null ? value : "";
        this.getGui().style.webkitUserSelect = value != null ? value : "";
      },
      setCursor: (value) => {
        this.getGui().style.cursor = value != null ? value : "";
      }
    };
    this.ctrl = this.createManagedBean(new GridCtrl());
    const template = this.createTemplate();
    this.setTemplate(template);
    this.ctrl.setComp(compProxy, this.eGridDiv, this.getGui());
    this.insertGridIntoDom();
    this.initialiseTabGuard({
      onTabKeyDown: () => void 0,
      focusInnerElement: (fromBottom) => this.ctrl.focusInnerElement(fromBottom)
    });
  }
  insertGridIntoDom() {
    const eGui = this.getGui();
    this.eGridDiv.appendChild(eGui);
    this.addDestroyFunc(() => {
      this.eGridDiv.removeChild(eGui);
      this.logger.log("Grid removed from DOM");
    });
  }
  updateLayoutClasses(cssClass, params) {
    const eRootWrapperBodyClassList = this.eRootWrapperBody.classList;
    eRootWrapperBodyClassList.toggle(LayoutCssClasses.AUTO_HEIGHT, params.autoHeight);
    eRootWrapperBodyClassList.toggle(LayoutCssClasses.NORMAL, params.normal);
    eRootWrapperBodyClassList.toggle(LayoutCssClasses.PRINT, params.print);
    this.addOrRemoveCssClass(LayoutCssClasses.AUTO_HEIGHT, params.autoHeight);
    this.addOrRemoveCssClass(LayoutCssClasses.NORMAL, params.normal);
    this.addOrRemoveCssClass(LayoutCssClasses.PRINT, params.print);
  }
  createTemplate() {
    const dropZones = this.ctrl.showDropZones() ? "<ag-grid-header-drop-zones></ag-grid-header-drop-zones>" : "";
    const sideBar = this.ctrl.showSideBar() ? '<ag-side-bar ref="sideBar"></ag-side-bar>' : "";
    const statusBar = this.ctrl.showStatusBar() ? '<ag-status-bar ref="statusBar"></ag-status-bar>' : "";
    const watermark = this.ctrl.showWatermark() ? "<ag-watermark></ag-watermark>" : "";
    const template = `<div class="ag-root-wrapper" role="presentation">
                ${dropZones}
                <div class="ag-root-wrapper-body" ref="rootWrapperBody" role="presentation">
                    <ag-grid-body ref="gridBody"></ag-grid-body>
                    ${sideBar}
                </div>
                ${statusBar}
                <ag-pagination></ag-pagination>
                ${watermark}
            </div>`;
    return template;
  }
  getFocusableElement() {
    return this.eRootWrapperBody;
  }
  getFocusableContainers() {
    const focusableContainers = [
      this.gridBodyComp.getGui()
    ];
    if (this.sideBarComp) {
      focusableContainers.push(this.sideBarComp.getGui());
    }
    return focusableContainers.filter((el) => isVisible(el));
  }
};
__decorate$H([
  Autowired("loggerFactory")
], GridComp.prototype, "loggerFactory", void 0);
__decorate$H([
  RefSelector("gridBody")
], GridComp.prototype, "gridBodyComp", void 0);
__decorate$H([
  RefSelector("sideBar")
], GridComp.prototype, "sideBarComp", void 0);
__decorate$H([
  RefSelector("rootWrapperBody")
], GridComp.prototype, "eRootWrapperBody", void 0);
__decorate$H([
  PostConstruct
], GridComp.prototype, "postConstruct", null);
var __decorate$G = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SortController_1;
var SortController = SortController_1 = class SortController2 extends BeanStub {
  progressSort(column, multiSort, source) {
    const nextDirection = this.getNextSortDirection(column);
    this.setSortForColumn(column, nextDirection, multiSort, source);
  }
  setSortForColumn(column, sort, multiSort, source) {
    if (sort !== "asc" && sort !== "desc") {
      sort = null;
    }
    const isColumnsSortingCoupledToGroup = this.gridOptionsService.isColumnsSortingCoupledToGroup();
    let columnsToUpdate = [column];
    if (isColumnsSortingCoupledToGroup) {
      if (column.getColDef().showRowGroup) {
        const rowGroupColumns = this.columnModel.getSourceColumnsForGroupColumn(column);
        const sortableRowGroupColumns = rowGroupColumns === null || rowGroupColumns === void 0 ? void 0 : rowGroupColumns.filter((col) => col.getColDef().sortable);
        if (sortableRowGroupColumns) {
          columnsToUpdate = [column, ...sortableRowGroupColumns];
        }
      }
    }
    columnsToUpdate.forEach((col) => col.setSort(sort, source));
    const doingMultiSort = (multiSort || this.gridOptionsService.is("alwaysMultiSort")) && !this.gridOptionsService.is("suppressMultiSort");
    if (!doingMultiSort) {
      this.clearSortBarTheseColumns(columnsToUpdate, source);
    }
    this.updateSortIndex(column);
    this.dispatchSortChangedEvents(source);
  }
  updateSortIndex(lastColToChange) {
    const isCoupled = this.gridOptionsService.isColumnsSortingCoupledToGroup();
    const groupParent = this.columnModel.getGroupDisplayColumnForGroup(lastColToChange.getId());
    const lastSortIndexCol = isCoupled ? groupParent || lastColToChange : lastColToChange;
    const allSortedCols = this.getColumnsWithSortingOrdered();
    this.columnModel.getPrimaryAndSecondaryAndAutoColumns().forEach((col) => col.setSortIndex(null));
    const allSortedColsWithoutChanges = allSortedCols.filter((col) => col !== lastSortIndexCol);
    const sortedColsWithIndices = !!lastSortIndexCol.getSort() ? [...allSortedColsWithoutChanges, lastSortIndexCol] : allSortedColsWithoutChanges;
    sortedColsWithIndices.forEach((col, idx) => col.setSortIndex(idx));
  }
  onSortChanged(source) {
    this.dispatchSortChangedEvents(source);
  }
  isSortActive() {
    const allCols = this.columnModel.getPrimaryAndSecondaryAndAutoColumns();
    const sortedCols = allCols.filter((column) => !!column.getSort());
    return sortedCols && sortedCols.length > 0;
  }
  dispatchSortChangedEvents(source) {
    const event = {
      type: Events.EVENT_SORT_CHANGED,
      source
    };
    this.eventService.dispatchEvent(event);
  }
  clearSortBarTheseColumns(columnsToSkip, source) {
    this.columnModel.getPrimaryAndSecondaryAndAutoColumns().forEach((columnToClear) => {
      if (!columnsToSkip.includes(columnToClear)) {
        columnToClear.setSort(void 0, source);
      }
    });
  }
  getNextSortDirection(column) {
    let sortingOrder;
    if (column.getColDef().sortingOrder) {
      sortingOrder = column.getColDef().sortingOrder;
    } else if (this.gridOptionsService.get("sortingOrder")) {
      sortingOrder = this.gridOptionsService.get("sortingOrder");
    } else {
      sortingOrder = SortController_1.DEFAULT_SORTING_ORDER;
    }
    if (!Array.isArray(sortingOrder) || sortingOrder.length <= 0) {
      console.warn(`AG Grid: sortingOrder must be an array with at least one element, currently it's ${sortingOrder}`);
      return null;
    }
    const currentIndex = sortingOrder.indexOf(column.getSort());
    const notInArray = currentIndex < 0;
    const lastItemInArray = currentIndex == sortingOrder.length - 1;
    let result;
    if (notInArray || lastItemInArray) {
      result = sortingOrder[0];
    } else {
      result = sortingOrder[currentIndex + 1];
    }
    if (SortController_1.DEFAULT_SORTING_ORDER.indexOf(result) < 0) {
      console.warn("AG Grid: invalid sort type " + result);
      return null;
    }
    return result;
  }
  getIndexedSortMap() {
    let allSortedCols = this.columnModel.getPrimaryAndSecondaryAndAutoColumns().filter((col) => !!col.getSort());
    if (this.columnModel.isPivotMode()) {
      const isSortingLinked = this.gridOptionsService.isColumnsSortingCoupledToGroup();
      allSortedCols = allSortedCols.filter((col) => {
        const isAggregated = !!col.getAggFunc();
        const isSecondary = !col.isPrimary();
        const isGroup = isSortingLinked ? this.columnModel.getGroupDisplayColumnForGroup(col.getId()) : col.getColDef().showRowGroup;
        return isAggregated || isSecondary || isGroup;
      });
    }
    const sortedRowGroupCols = this.columnModel.getRowGroupColumns().filter((col) => !!col.getSort());
    const isSortLinked = this.gridOptionsService.isColumnsSortingCoupledToGroup() && !!sortedRowGroupCols.length;
    if (isSortLinked) {
      allSortedCols = [
        ...new Set(
          allSortedCols.map((col) => {
            var _a;
            return (_a = this.columnModel.getGroupDisplayColumnForGroup(col.getId())) !== null && _a !== void 0 ? _a : col;
          })
        )
      ];
    }
    const allColsIndexes = {};
    allSortedCols.forEach((col, index) => allColsIndexes[col.getId()] = index);
    allSortedCols.sort((a, b) => {
      const iA = a.getSortIndex();
      const iB = b.getSortIndex();
      if (iA != null && iB != null) {
        return iA - iB;
      } else if (iA == null && iB == null) {
        const posA = allColsIndexes[a.getId()];
        const posB = allColsIndexes[b.getId()];
        return posA > posB ? 1 : -1;
      } else if (iB == null) {
        return -1;
      } else {
        return 1;
      }
    });
    const indexMap = /* @__PURE__ */ new Map();
    allSortedCols.forEach((col, idx) => indexMap.set(col, idx));
    if (isSortLinked) {
      sortedRowGroupCols.forEach((col) => {
        const groupDisplayCol = this.columnModel.getGroupDisplayColumnForGroup(col.getId());
        indexMap.set(col, indexMap.get(groupDisplayCol));
      });
    }
    return indexMap;
  }
  getColumnsWithSortingOrdered() {
    return [...this.getIndexedSortMap().entries()].sort(([col1, idx1], [col2, idx2]) => idx1 - idx2).map(([col]) => col);
  }
  getSortModel() {
    return this.getColumnsWithSortingOrdered().map((column) => ({
      sort: column.getSort(),
      colId: column.getId()
    }));
  }
  getSortOptions() {
    return this.getColumnsWithSortingOrdered().map((column) => ({
      sort: column.getSort(),
      column
    }));
  }
  canColumnDisplayMixedSort(column) {
    const isColumnSortCouplingActive = this.gridOptionsService.isColumnsSortingCoupledToGroup();
    const isGroupDisplayColumn = !!column.getColDef().showRowGroup;
    return isColumnSortCouplingActive && isGroupDisplayColumn;
  }
  getDisplaySortForColumn(column) {
    const linkedColumns = this.columnModel.getSourceColumnsForGroupColumn(column);
    if (!this.canColumnDisplayMixedSort(column) || !(linkedColumns === null || linkedColumns === void 0 ? void 0 : linkedColumns.length)) {
      return column.getSort();
    }
    const columnHasUniqueData = !!column.getColDef().field;
    const sortableColumns = columnHasUniqueData ? [column, ...linkedColumns] : linkedColumns;
    const firstSort = sortableColumns[0].getSort();
    const allMatch = sortableColumns.every((col) => col.getSort() == firstSort);
    if (!allMatch) {
      return "mixed";
    }
    return firstSort;
  }
  getDisplaySortIndexForColumn(column) {
    return this.getIndexedSortMap().get(column);
  }
};
SortController.DEFAULT_SORTING_ORDER = ["asc", "desc", null];
__decorate$G([
  Autowired("columnModel")
], SortController.prototype, "columnModel", void 0);
SortController = SortController_1 = __decorate$G([
  Bean("sortController")
], SortController);
var __decorate$F = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ColumnHoverService = class ColumnHoverService2 extends BeanStub {
  setMouseOver(columns) {
    this.selectedColumns = columns;
    const event = {
      type: Events.EVENT_COLUMN_HOVER_CHANGED
    };
    this.eventService.dispatchEvent(event);
  }
  clearMouseOver() {
    this.selectedColumns = null;
    const event = {
      type: Events.EVENT_COLUMN_HOVER_CHANGED
    };
    this.eventService.dispatchEvent(event);
  }
  isHovered(column) {
    return !!this.selectedColumns && this.selectedColumns.indexOf(column) >= 0;
  }
};
ColumnHoverService = __decorate$F([
  Bean("columnHoverService")
], ColumnHoverService);
var __decorate$E = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ColumnAnimationService = class ColumnAnimationService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.executeNextFuncs = [];
    this.executeLaterFuncs = [];
    this.active = false;
    this.animationThreadCount = 0;
  }
  postConstruct() {
    this.ctrlsService.whenReady((p) => this.gridBodyCtrl = p.gridBodyCtrl);
  }
  isActive() {
    return this.active;
  }
  start() {
    if (this.active) {
      return;
    }
    if (this.gridOptionsService.is("suppressColumnMoveAnimation")) {
      return;
    }
    if (this.gridOptionsService.is("enableRtl")) {
      return;
    }
    this.ensureAnimationCssClassPresent();
    this.active = true;
  }
  finish() {
    if (!this.active) {
      return;
    }
    this.flush();
    this.active = false;
  }
  executeNextVMTurn(func) {
    if (this.active) {
      this.executeNextFuncs.push(func);
    } else {
      func();
    }
  }
  executeLaterVMTurn(func) {
    if (this.active) {
      this.executeLaterFuncs.push(func);
    } else {
      func();
    }
  }
  ensureAnimationCssClassPresent() {
    this.animationThreadCount++;
    const animationThreadCountCopy = this.animationThreadCount;
    this.gridBodyCtrl.setColumnMovingCss(true);
    this.executeLaterFuncs.push(() => {
      if (this.animationThreadCount === animationThreadCountCopy) {
        this.gridBodyCtrl.setColumnMovingCss(false);
      }
    });
  }
  flush() {
    const nowFuncs = this.executeNextFuncs;
    this.executeNextFuncs = [];
    const waitFuncs = this.executeLaterFuncs;
    this.executeLaterFuncs = [];
    if (nowFuncs.length === 0 && waitFuncs.length === 0) {
      return;
    }
    window.setTimeout(() => nowFuncs.forEach((func) => func()), 0);
    window.setTimeout(() => waitFuncs.forEach((func) => func()), 300);
  }
};
__decorate$E([
  Autowired("ctrlsService")
], ColumnAnimationService.prototype, "ctrlsService", void 0);
__decorate$E([
  PostConstruct
], ColumnAnimationService.prototype, "postConstruct", null);
ColumnAnimationService = __decorate$E([
  Bean("columnAnimationService")
], ColumnAnimationService);
var __decorate$D = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PaginationAutoPageSizeService = class PaginationAutoPageSizeService2 extends BeanStub {
  postConstruct() {
    this.ctrlsService.whenReady((p) => {
      this.centerRowContainerCon = p.centerRowContainerCtrl;
      this.addManagedListener(this.eventService, Events.EVENT_BODY_HEIGHT_CHANGED, this.checkPageSize.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_SCROLL_VISIBILITY_CHANGED, this.checkPageSize.bind(this));
      this.checkPageSize();
    });
  }
  notActive() {
    return !this.gridOptionsService.is("paginationAutoPageSize") || this.centerRowContainerCon == null;
  }
  checkPageSize() {
    if (this.notActive()) {
      return;
    }
    const bodyHeight = this.centerRowContainerCon.getViewportSizeFeature().getBodyHeight();
    if (bodyHeight > 0) {
      const update = () => {
        const rowHeight = this.gridOptionsService.getRowHeightAsNumber();
        const newPageSize = Math.floor(bodyHeight / rowHeight);
        this.gridOptionsService.set("paginationPageSize", newPageSize);
      };
      if (!this.isBodyRendered) {
        update();
        this.isBodyRendered = true;
      } else {
        debounce(() => update(), 50)();
      }
    } else {
      this.isBodyRendered = false;
    }
  }
};
__decorate$D([
  Autowired("ctrlsService")
], PaginationAutoPageSizeService.prototype, "ctrlsService", void 0);
__decorate$D([
  PostConstruct
], PaginationAutoPageSizeService.prototype, "postConstruct", null);
PaginationAutoPageSizeService = __decorate$D([
  Bean("paginationAutoPageSizeService")
], PaginationAutoPageSizeService);
var __decorate$C = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ValueCache = class ValueCache2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.cacheVersion = 0;
  }
  init() {
    this.active = this.gridOptionsService.is("valueCache");
    this.neverExpires = this.gridOptionsService.is("valueCacheNeverExpires");
  }
  onDataChanged() {
    if (this.neverExpires) {
      return;
    }
    this.expire();
  }
  expire() {
    this.cacheVersion++;
  }
  setValue(rowNode, colId, value) {
    if (this.active) {
      if (rowNode.__cacheVersion !== this.cacheVersion) {
        rowNode.__cacheVersion = this.cacheVersion;
        rowNode.__cacheData = {};
      }
      rowNode.__cacheData[colId] = value;
    }
  }
  getValue(rowNode, colId) {
    if (!this.active || rowNode.__cacheVersion !== this.cacheVersion) {
      return void 0;
    }
    return rowNode.__cacheData[colId];
  }
};
__decorate$C([
  PostConstruct
], ValueCache.prototype, "init", null);
ValueCache = __decorate$C([
  Bean("valueCache")
], ValueCache);
var __decorate$B = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SOURCE_PASTE = "paste";
var ChangeDetectionService = class ChangeDetectionService2 extends BeanStub {
  init() {
    if (this.rowModel.getType() === "clientSide") {
      this.clientSideRowModel = this.rowModel;
    }
    this.addManagedListener(this.eventService, Events.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged.bind(this));
  }
  onCellValueChanged(event) {
    if (event.source === SOURCE_PASTE) {
      return;
    }
    this.doChangeDetection(event.node, event.column);
  }
  doChangeDetection(rowNode, column) {
    if (this.gridOptionsService.is("suppressChangeDetection")) {
      return;
    }
    if (this.clientSideRowModel && !rowNode.isRowPinned()) {
      const onlyChangedColumns = this.gridOptionsService.is("aggregateOnlyChangedColumns");
      const changedPath = new ChangedPath(onlyChangedColumns, this.clientSideRowModel.getRootNode());
      changedPath.addParentNode(rowNode.parent, [column]);
      this.clientSideRowModel.doAggregate(changedPath);
    }
    this.rowRenderer.refreshCells();
  }
};
__decorate$B([
  Autowired("rowModel")
], ChangeDetectionService.prototype, "rowModel", void 0);
__decorate$B([
  Autowired("rowRenderer")
], ChangeDetectionService.prototype, "rowRenderer", void 0);
__decorate$B([
  PostConstruct
], ChangeDetectionService.prototype, "init", null);
ChangeDetectionService = __decorate$B([
  Bean("changeDetectionService")
], ChangeDetectionService);
var __decorate$A = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AgComponentUtils = class AgComponentUtils2 extends BeanStub {
  adaptFunction(propertyName, jsCompFunc) {
    const metadata = this.componentMetadataProvider.retrieve(propertyName);
    if (metadata && metadata.functionAdapter) {
      return metadata.functionAdapter(jsCompFunc);
    }
    return null;
  }
  adaptCellRendererFunction(callback) {
    class Adapter {
      refresh(params) {
        return false;
      }
      getGui() {
        return this.eGui;
      }
      init(params) {
        const callbackResult = callback(params);
        const type = typeof callbackResult;
        if (type === "string" || type === "number" || type === "boolean") {
          this.eGui = loadTemplate("<span>" + callbackResult + "</span>");
          return;
        }
        if (callbackResult == null) {
          this.eGui = loadTemplate("<span></span>");
          return;
        }
        this.eGui = callbackResult;
      }
    }
    return Adapter;
  }
  doesImplementIComponent(candidate) {
    if (!candidate) {
      return false;
    }
    return candidate.prototype && "getGui" in candidate.prototype;
  }
};
__decorate$A([
  Autowired("componentMetadataProvider")
], AgComponentUtils.prototype, "componentMetadataProvider", void 0);
AgComponentUtils = __decorate$A([
  Bean("agComponentUtils")
], AgComponentUtils);
var __decorate$z = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ComponentMetadataProvider = class ComponentMetadataProvider2 extends BeanStub {
  postConstruct() {
    this.componentMetaData = {
      dateComponent: {
        mandatoryMethodList: ["getDate", "setDate"],
        optionalMethodList: ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel"]
      },
      detailCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      headerComponent: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      headerGroupComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      loadingCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      loadingOverlayComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      noRowsOverlayComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      floatingFilterComponent: {
        mandatoryMethodList: ["onParentModelChanged"],
        optionalMethodList: ["afterGuiAttached"]
      },
      floatingFilterWrapperComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      cellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      cellEditor: {
        mandatoryMethodList: ["getValue"],
        optionalMethodList: ["isPopup", "isCancelBeforeStart", "isCancelAfterEnd", "getPopupPosition", "focusIn", "focusOut", "afterGuiAttached"]
      },
      innerRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      fullWidthCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      groupRowRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      filter: {
        mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
        optionalMethodList: ["afterGuiAttached", "afterGuiDetached", "onNewRowsLoaded", "getModelAsString", "onFloatingFilterChanged", "onAnyFilterChanged"]
      },
      filterComponent: {
        mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
        optionalMethodList: ["afterGuiAttached", "afterGuiDetached", "onNewRowsLoaded", "getModelAsString", "onFloatingFilterChanged", "onAnyFilterChanged"]
      },
      statusPanel: {
        mandatoryMethodList: [],
        optionalMethodList: ["afterGuiAttached"]
      },
      toolPanel: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "afterGuiAttached"]
      },
      tooltipComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      }
    };
  }
  retrieve(name) {
    return this.componentMetaData[name];
  }
};
__decorate$z([
  Autowired("agComponentUtils")
], ComponentMetadataProvider.prototype, "agComponentUtils", void 0);
__decorate$z([
  PostConstruct
], ComponentMetadataProvider.prototype, "postConstruct", null);
ComponentMetadataProvider = __decorate$z([
  Bean("componentMetadataProvider")
], ComponentMetadataProvider);
var __decorate$y = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DEFAULT_ROW_HEIGHT = 25;
var MIN_COL_WIDTH = 10;
var MAT_GRID_SIZE = 8;
var BASE_GRID_SIZE = 4;
var BALHAM_GRID_SIZE = 4;
var ALPINE_GRID_SIZE = 6;
var HARD_CODED_SIZES = {
  "ag-theme-custom": {
    headerHeight: 25,
    headerCellMinWidth: 24,
    listItemHeight: BASE_GRID_SIZE * 5,
    rowHeight: 25,
    chartMenuPanelWidth: 220
  },
  "ag-theme-material": {
    headerHeight: MAT_GRID_SIZE * 7,
    headerCellMinWidth: 48,
    listItemHeight: MAT_GRID_SIZE * 4,
    rowHeight: MAT_GRID_SIZE * 6,
    chartMenuPanelWidth: 240
  },
  "ag-theme-balham": {
    headerHeight: BALHAM_GRID_SIZE * 8,
    headerCellMinWidth: 24,
    listItemHeight: BALHAM_GRID_SIZE * 6,
    rowHeight: BALHAM_GRID_SIZE * 7,
    chartMenuPanelWidth: 220
  },
  "ag-theme-alpine": {
    headerHeight: ALPINE_GRID_SIZE * 8,
    headerCellMinWidth: 36,
    listItemHeight: ALPINE_GRID_SIZE * 4,
    rowHeight: ALPINE_GRID_SIZE * 7,
    chartMenuPanelWidth: 240
  }
};
var SASS_PROPERTY_BUILDER = {
  headerHeight: ["ag-header-row"],
  headerCellMinWidth: ["ag-header-cell"],
  listItemHeight: ["ag-virtual-list-item"],
  rowHeight: ["ag-row"],
  chartMenuPanelWidth: ["ag-chart-docked-container"]
};
var Environment = class Environment2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.calculatedSizes = {};
  }
  postConstruct() {
    var _a;
    const el = (_a = this.getTheme().el) !== null && _a !== void 0 ? _a : this.eGridDiv;
    this.mutationObserver = new MutationObserver(() => {
      this.calculatedSizes = {};
      this.fireGridStylesChangedEvent();
    });
    this.mutationObserver.observe(el || this.eGridDiv, {
      attributes: true,
      attributeFilter: ["class"]
    });
  }
  fireGridStylesChangedEvent() {
    const event = {
      type: Events.EVENT_GRID_STYLES_CHANGED
    };
    this.eventService.dispatchEvent(event);
  }
  getSassVariable(key) {
    const { themeFamily, el } = this.getTheme();
    if (!themeFamily || themeFamily.indexOf("ag-theme") !== 0) {
      return;
    }
    if (!this.calculatedSizes) {
      this.calculatedSizes = {};
    }
    if (!this.calculatedSizes[themeFamily]) {
      this.calculatedSizes[themeFamily] = {};
    }
    const size = this.calculatedSizes[themeFamily][key];
    if (size != null) {
      return size;
    }
    this.calculatedSizes[themeFamily][key] = this.calculateValueForSassProperty(key, themeFamily, el);
    return this.calculatedSizes[themeFamily][key];
  }
  calculateValueForSassProperty(property, theme, themeElement) {
    const useTheme = "ag-theme-" + (theme.match("material") ? "material" : theme.match("balham") ? "balham" : theme.match("alpine") ? "alpine" : "custom");
    const defaultValue = HARD_CODED_SIZES[useTheme][property];
    const eDocument = this.gridOptionsService.getDocument();
    if (!themeElement) {
      themeElement = this.eGridDiv;
    }
    if (!SASS_PROPERTY_BUILDER[property]) {
      return defaultValue;
    }
    const classList = SASS_PROPERTY_BUILDER[property];
    const div = eDocument.createElement("div");
    const classesFromThemeElement = Array.from(themeElement.classList);
    div.classList.add(theme, ...classesFromThemeElement);
    div.style.position = "absolute";
    const el = classList.reduce((prevEl, currentClass) => {
      const currentDiv = eDocument.createElement("div");
      currentDiv.style.position = "static";
      currentDiv.classList.add(currentClass);
      prevEl.appendChild(currentDiv);
      return currentDiv;
    }, div);
    let calculatedValue = 0;
    if (eDocument.body) {
      eDocument.body.appendChild(div);
      const sizeName = property.toLowerCase().indexOf("height") !== -1 ? "height" : "width";
      calculatedValue = parseInt(window.getComputedStyle(el)[sizeName], 10);
      eDocument.body.removeChild(div);
    }
    return calculatedValue || defaultValue;
  }
  isThemeDark() {
    const { theme } = this.getTheme();
    return !!theme && theme.indexOf("dark") >= 0;
  }
  chartMenuPanelWidth() {
    return this.getSassVariable("chartMenuPanelWidth");
  }
  getTheme() {
    const reg = /\bag-(material|(?:theme-([\w\-]*)))\b/g;
    let el = this.eGridDiv;
    let themeMatch = null;
    let allThemes = [];
    while (el) {
      themeMatch = reg.exec(el.className);
      if (!themeMatch) {
        el = el.parentElement || void 0;
      } else {
        const matched = el.className.match(reg);
        if (matched) {
          allThemes = matched;
        }
        break;
      }
    }
    if (!themeMatch) {
      return { allThemes };
    }
    const theme = themeMatch[0];
    return { theme, el, themeFamily: theme.replace(/-dark$/, ""), allThemes };
  }
  getFromTheme(defaultValue, sassVariableName) {
    var _a;
    return (_a = this.getSassVariable(sassVariableName)) !== null && _a !== void 0 ? _a : defaultValue;
  }
  getDefaultRowHeight() {
    return this.getFromTheme(DEFAULT_ROW_HEIGHT, "rowHeight");
  }
  getListItemHeight() {
    return this.getFromTheme(20, "listItemHeight");
  }
  setRowHeightVariable(height) {
    const oldRowHeight = this.eGridDiv.style.getPropertyValue("--ag-line-height").trim();
    const newRowHeight = `${height}px`;
    if (oldRowHeight != newRowHeight) {
      this.eGridDiv.style.setProperty("--ag-line-height", newRowHeight);
    }
  }
  getMinColWidth() {
    const measuredMin = this.getFromTheme(null, "headerCellMinWidth");
    return exists(measuredMin) ? Math.max(measuredMin, MIN_COL_WIDTH) : MIN_COL_WIDTH;
  }
  destroy() {
    this.calculatedSizes = null;
    if (this.mutationObserver) {
      this.mutationObserver.disconnect();
    }
    super.destroy();
  }
};
__decorate$y([
  Autowired("eGridDiv")
], Environment.prototype, "eGridDiv", void 0);
__decorate$y([
  PostConstruct
], Environment.prototype, "postConstruct", null);
Environment = __decorate$y([
  Bean("environment")
], Environment);
var __decorate$x = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RowContainerHeightService = class RowContainerHeightService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.scrollY = 0;
    this.uiBodyHeight = 0;
  }
  agWire(loggerFactory) {
    this.logger = loggerFactory.create("RowContainerHeightService");
  }
  postConstruct() {
    this.addManagedListener(this.eventService, Events.EVENT_BODY_HEIGHT_CHANGED, this.updateOffset.bind(this));
    this.maxDivHeight = getMaxDivHeight();
    this.logger.log("maxDivHeight = " + this.maxDivHeight);
  }
  isStretching() {
    return this.stretching;
  }
  getDivStretchOffset() {
    return this.divStretchOffset;
  }
  updateOffset() {
    if (!this.stretching) {
      return;
    }
    const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
    const newScrollY = gridBodyCon.getScrollFeature().getVScrollPosition().top;
    const newBodyHeight = this.getUiBodyHeight();
    const atLeastOneChanged = newScrollY !== this.scrollY || newBodyHeight !== this.uiBodyHeight;
    if (atLeastOneChanged) {
      this.scrollY = newScrollY;
      this.uiBodyHeight = newBodyHeight;
      this.calculateOffset();
    }
  }
  calculateOffset() {
    this.setUiContainerHeight(this.maxDivHeight);
    this.pixelsToShave = this.modelHeight - this.uiContainerHeight;
    this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
    const scrollPercent = this.scrollY / this.maxScrollY;
    const divStretchOffset = scrollPercent * this.pixelsToShave;
    this.logger.log(`Div Stretch Offset = ${divStretchOffset} (${this.pixelsToShave} * ${scrollPercent})`);
    this.setDivStretchOffset(divStretchOffset);
  }
  setUiContainerHeight(height) {
    if (height !== this.uiContainerHeight) {
      this.uiContainerHeight = height;
      this.eventService.dispatchEvent({ type: Events.EVENT_ROW_CONTAINER_HEIGHT_CHANGED });
    }
  }
  clearOffset() {
    this.setUiContainerHeight(this.modelHeight);
    this.pixelsToShave = 0;
    this.setDivStretchOffset(0);
  }
  setDivStretchOffset(newOffset) {
    const newOffsetFloor = typeof newOffset === "number" ? Math.floor(newOffset) : null;
    if (this.divStretchOffset === newOffsetFloor) {
      return;
    }
    this.divStretchOffset = newOffsetFloor;
    this.eventService.dispatchEvent({ type: Events.EVENT_HEIGHT_SCALE_CHANGED });
  }
  setModelHeight(modelHeight) {
    this.modelHeight = modelHeight;
    this.stretching = modelHeight != null && this.maxDivHeight > 0 && modelHeight > this.maxDivHeight;
    if (this.stretching) {
      this.calculateOffset();
    } else {
      this.clearOffset();
    }
  }
  getUiContainerHeight() {
    return this.uiContainerHeight;
  }
  getRealPixelPosition(modelPixel) {
    return modelPixel - this.divStretchOffset;
  }
  getUiBodyHeight() {
    const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
    const pos = gridBodyCon.getScrollFeature().getVScrollPosition();
    return pos.bottom - pos.top;
  }
  getScrollPositionForPixel(rowTop) {
    if (this.pixelsToShave <= 0) {
      return rowTop;
    }
    const modelMaxScroll = this.modelHeight - this.getUiBodyHeight();
    const scrollPercent = rowTop / modelMaxScroll;
    const scrollPixel = this.maxScrollY * scrollPercent;
    return scrollPixel;
  }
};
__decorate$x([
  Autowired("ctrlsService")
], RowContainerHeightService.prototype, "ctrlsService", void 0);
__decorate$x([
  __param$2(0, Qualifier("loggerFactory"))
], RowContainerHeightService.prototype, "agWire", null);
__decorate$x([
  PostConstruct
], RowContainerHeightService.prototype, "postConstruct", null);
RowContainerHeightService = __decorate$x([
  Bean("rowContainerHeightService")
], RowContainerHeightService);
var __decorate$w = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SelectableService = class SelectableService2 extends BeanStub {
  init() {
    this.groupSelectsChildren = this.gridOptionsService.is("groupSelectsChildren");
    this.isRowSelectableFunc = this.gridOptionsService.get("isRowSelectable");
  }
  updateSelectableAfterGrouping(rowNode) {
    if (this.isRowSelectableFunc) {
      const nextChildrenFunc = (node) => node.childrenAfterGroup;
      this.recurseDown(rowNode.childrenAfterGroup, nextChildrenFunc);
    }
  }
  recurseDown(children, nextChildrenFunc) {
    if (!children) {
      return;
    }
    children.forEach((child) => {
      if (!child.group) {
        return;
      }
      if (child.hasChildren()) {
        this.recurseDown(nextChildrenFunc(child), nextChildrenFunc);
      }
      let rowSelectable;
      if (this.groupSelectsChildren) {
        const firstSelectable = (nextChildrenFunc(child) || []).find((rowNode) => rowNode.selectable === true);
        rowSelectable = exists(firstSelectable);
      } else {
        rowSelectable = this.isRowSelectableFunc ? this.isRowSelectableFunc(child) : false;
      }
      child.setRowSelectable(rowSelectable);
    });
  }
};
__decorate$w([
  PostConstruct
], SelectableService.prototype, "init", null);
SelectableService = __decorate$w([
  Bean("selectableService")
], SelectableService);
var __decorate$v = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PaginationComp = class extends Component {
  constructor() {
    super();
    this.previousAndFirstButtonsDisabled = false;
    this.nextButtonDisabled = false;
    this.lastButtonDisabled = false;
    this.areListenersSetup = false;
  }
  postConstruct() {
    const isRtl = this.gridOptionsService.is("enableRtl");
    this.setTemplate(this.getTemplate());
    this.btFirst.insertAdjacentElement("afterbegin", createIconNoSpan(isRtl ? "last" : "first", this.gridOptionsService));
    this.btPrevious.insertAdjacentElement("afterbegin", createIconNoSpan(isRtl ? "next" : "previous", this.gridOptionsService));
    this.btNext.insertAdjacentElement("afterbegin", createIconNoSpan(isRtl ? "previous" : "next", this.gridOptionsService));
    this.btLast.insertAdjacentElement("afterbegin", createIconNoSpan(isRtl ? "first" : "last", this.gridOptionsService));
    this.addManagedPropertyListener("pagination", this.onPaginationChanged.bind(this));
    this.addManagedPropertyListener("suppressPaginationPanel", this.onPaginationChanged.bind(this));
    this.onPaginationChanged();
  }
  onPaginationChanged() {
    const isPaging = this.gridOptionsService.is("pagination");
    const paginationPanelEnabled = isPaging && !this.gridOptionsService.is("suppressPaginationPanel");
    this.setDisplayed(paginationPanelEnabled);
    if (!paginationPanelEnabled) {
      return;
    }
    this.setupListeners();
    this.enableOrDisableButtons();
    this.updateRowLabels();
    this.setCurrentPageLabel();
    this.setTotalLabels();
  }
  setupListeners() {
    if (!this.areListenersSetup) {
      this.addManagedListener(this.eventService, Events.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this));
      [
        { el: this.btFirst, fn: this.onBtFirst.bind(this) },
        { el: this.btPrevious, fn: this.onBtPrevious.bind(this) },
        { el: this.btNext, fn: this.onBtNext.bind(this) },
        { el: this.btLast, fn: this.onBtLast.bind(this) }
      ].forEach((item) => {
        const { el, fn } = item;
        this.addManagedListener(el, "click", fn);
        this.addManagedListener(el, "keydown", (e) => {
          if (e.key === KeyCode.ENTER || e.key === KeyCode.SPACE) {
            e.preventDefault();
            fn();
          }
        });
      });
      this.areListenersSetup = true;
    }
  }
  onBtFirst() {
    if (!this.previousAndFirstButtonsDisabled) {
      this.paginationProxy.goToFirstPage();
    }
  }
  setCurrentPageLabel() {
    const pagesExist = this.paginationProxy.getTotalPages() > 0;
    const currentPage = this.paginationProxy.getCurrentPage();
    const toDisplay = pagesExist ? currentPage + 1 : 0;
    this.lbCurrent.innerHTML = this.formatNumber(toDisplay);
  }
  formatNumber(value) {
    const userFunc = this.gridOptionsService.getCallback("paginationNumberFormatter");
    if (userFunc) {
      const params = { value };
      return userFunc(params);
    }
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    const thousandSeparator = localeTextFunc("thousandSeparator", ",");
    const decimalSeparator = localeTextFunc("decimalSeparator", ".");
    return formatNumberCommas(value, thousandSeparator, decimalSeparator);
  }
  getTemplate() {
    const localeTextFunc = this.localeService.getLocaleTextFunc();
    const strPage = localeTextFunc("page", "Page");
    const strTo = localeTextFunc("to", "to");
    const strOf = localeTextFunc("of", "of");
    const strFirst = localeTextFunc("firstPage", "First Page");
    const strPrevious = localeTextFunc("previousPage", "Previous Page");
    const strNext = localeTextFunc("nextPage", "Next Page");
    const strLast = localeTextFunc("lastPage", "Last Page");
    const compId = this.getCompId();
    return `<div class="ag-paging-panel ag-unselectable" id="ag-${compId}">
                <span class="ag-paging-row-summary-panel" role="status">
                    <span id="ag-${compId}-first-row" ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${compId}-to">${strTo}</span>
                    <span id="ag-${compId}-last-row" ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${compId}-of">${strOf}</span>
                    <span id="ag-${compId}-row-count" ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>
                </span>
                <span class="ag-paging-page-summary-panel" role="presentation">
                    <div ref="btFirst" class="ag-paging-button" role="button" aria-label="${strFirst}"></div>
                    <div ref="btPrevious" class="ag-paging-button" role="button" aria-label="${strPrevious}"></div>
                    <span class="ag-paging-description" role="status">
                        <span id="ag-${compId}-start-page">${strPage}</span>
                        <span id="ag-${compId}-start-page-number" ref="lbCurrent" class="ag-paging-number"></span>
                        <span id="ag-${compId}-of-page">${strOf}</span>
                        <span id="ag-${compId}-of-page-number" ref="lbTotal" class="ag-paging-number"></span>
                    </span>
                    <div ref="btNext" class="ag-paging-button" role="button" aria-label="${strNext}"></div>
                    <div ref="btLast" class="ag-paging-button" role="button" aria-label="${strLast}"></div>
                </span>
            </div>`;
  }
  onBtNext() {
    if (!this.nextButtonDisabled) {
      this.paginationProxy.goToNextPage();
    }
  }
  onBtPrevious() {
    if (!this.previousAndFirstButtonsDisabled) {
      this.paginationProxy.goToPreviousPage();
    }
  }
  onBtLast() {
    if (!this.lastButtonDisabled) {
      this.paginationProxy.goToLastPage();
    }
  }
  enableOrDisableButtons() {
    const currentPage = this.paginationProxy.getCurrentPage();
    const maxRowFound = this.paginationProxy.isLastPageFound();
    const totalPages = this.paginationProxy.getTotalPages();
    this.previousAndFirstButtonsDisabled = currentPage === 0;
    this.toggleButtonDisabled(this.btFirst, this.previousAndFirstButtonsDisabled);
    this.toggleButtonDisabled(this.btPrevious, this.previousAndFirstButtonsDisabled);
    const zeroPagesToDisplay = this.isZeroPagesToDisplay();
    const onLastPage = maxRowFound && currentPage === totalPages - 1;
    this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;
    this.lastButtonDisabled = !maxRowFound || zeroPagesToDisplay || currentPage === totalPages - 1;
    this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled);
    this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled);
  }
  toggleButtonDisabled(button, disabled) {
    setAriaDisabled(button, disabled);
    button.classList.toggle("ag-disabled", disabled);
    if (disabled) {
      button.removeAttribute("tabindex");
    } else {
      button.setAttribute("tabindex", "0");
    }
  }
  updateRowLabels() {
    const currentPage = this.paginationProxy.getCurrentPage();
    const pageSize = this.paginationProxy.getPageSize();
    const maxRowFound = this.paginationProxy.isLastPageFound();
    const rowCount = this.paginationProxy.isLastPageFound() ? this.paginationProxy.getMasterRowCount() : null;
    let startRow;
    let endRow;
    if (this.isZeroPagesToDisplay()) {
      startRow = endRow = 0;
    } else {
      startRow = pageSize * currentPage + 1;
      endRow = startRow + pageSize - 1;
      if (maxRowFound && endRow > rowCount) {
        endRow = rowCount;
      }
    }
    this.lbFirstRowOnPage.innerHTML = this.formatNumber(startRow);
    if (this.rowNodeBlockLoader.isLoading()) {
      const translate = this.localeService.getLocaleTextFunc();
      this.lbLastRowOnPage.innerHTML = translate("pageLastRowUnknown", "?");
    } else {
      this.lbLastRowOnPage.innerHTML = this.formatNumber(endRow);
    }
  }
  isZeroPagesToDisplay() {
    const maxRowFound = this.paginationProxy.isLastPageFound();
    const totalPages = this.paginationProxy.getTotalPages();
    return maxRowFound && totalPages === 0;
  }
  setTotalLabels() {
    const lastPageFound = this.paginationProxy.isLastPageFound();
    const totalPages = this.paginationProxy.getTotalPages();
    const rowCount = lastPageFound ? this.paginationProxy.getMasterRowCount() : null;
    if (rowCount === 1) {
      const firstRow = this.paginationProxy.getRow(0);
      const hiddenGroupRow = firstRow && firstRow.group && !(firstRow.groupData || firstRow.aggData);
      if (hiddenGroupRow) {
        this.setTotalLabelsToZero();
        return;
      }
    }
    if (lastPageFound) {
      this.lbTotal.innerHTML = this.formatNumber(totalPages);
      this.lbRecordCount.innerHTML = this.formatNumber(rowCount);
    } else {
      const moreText = this.localeService.getLocaleTextFunc()("more", "more");
      this.lbTotal.innerHTML = moreText;
      this.lbRecordCount.innerHTML = moreText;
    }
  }
  setTotalLabelsToZero() {
    this.lbFirstRowOnPage.innerHTML = this.formatNumber(0);
    this.lbCurrent.innerHTML = this.formatNumber(0);
    this.lbLastRowOnPage.innerHTML = this.formatNumber(0);
    this.lbTotal.innerHTML = this.formatNumber(0);
    this.lbRecordCount.innerHTML = this.formatNumber(0);
  }
};
__decorate$v([
  Autowired("paginationProxy")
], PaginationComp.prototype, "paginationProxy", void 0);
__decorate$v([
  Autowired("rowNodeBlockLoader")
], PaginationComp.prototype, "rowNodeBlockLoader", void 0);
__decorate$v([
  RefSelector("btFirst")
], PaginationComp.prototype, "btFirst", void 0);
__decorate$v([
  RefSelector("btPrevious")
], PaginationComp.prototype, "btPrevious", void 0);
__decorate$v([
  RefSelector("btNext")
], PaginationComp.prototype, "btNext", void 0);
__decorate$v([
  RefSelector("btLast")
], PaginationComp.prototype, "btLast", void 0);
__decorate$v([
  RefSelector("lbRecordCount")
], PaginationComp.prototype, "lbRecordCount", void 0);
__decorate$v([
  RefSelector("lbFirstRowOnPage")
], PaginationComp.prototype, "lbFirstRowOnPage", void 0);
__decorate$v([
  RefSelector("lbLastRowOnPage")
], PaginationComp.prototype, "lbLastRowOnPage", void 0);
__decorate$v([
  RefSelector("lbCurrent")
], PaginationComp.prototype, "lbCurrent", void 0);
__decorate$v([
  RefSelector("lbTotal")
], PaginationComp.prototype, "lbTotal", void 0);
__decorate$v([
  PostConstruct
], PaginationComp.prototype, "postConstruct", null);
var __decorate$u = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LoadingType;
(function(LoadingType2) {
  LoadingType2[LoadingType2["Loading"] = 0] = "Loading";
  LoadingType2[LoadingType2["NoRows"] = 1] = "NoRows";
})(LoadingType || (LoadingType = {}));
var OverlayWrapperComponent = class extends Component {
  constructor() {
    super(OverlayWrapperComponent.TEMPLATE);
    this.inProgress = false;
    this.destroyRequested = false;
    this.manuallyDisplayed = false;
  }
  updateLayoutClasses(cssClass, params) {
    const overlayWrapperClassList = this.eOverlayWrapper.classList;
    overlayWrapperClassList.toggle(LayoutCssClasses.AUTO_HEIGHT, params.autoHeight);
    overlayWrapperClassList.toggle(LayoutCssClasses.NORMAL, params.normal);
    overlayWrapperClassList.toggle(LayoutCssClasses.PRINT, params.print);
  }
  postConstruct() {
    this.createManagedBean(new LayoutFeature(this));
    this.setDisplayed(false, { skipAriaHidden: true });
    this.addManagedListener(this.eventService, Events.EVENT_ROW_DATA_UPDATED, this.onRowDataUpdated.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this));
    if (this.gridOptionsService.isRowModelType("clientSide") && !this.gridOptionsService.get("rowData")) {
      this.showLoadingOverlay();
    }
    this.gridApi.registerOverlayWrapperComp(this);
  }
  setWrapperTypeClass(loadingType) {
    const overlayWrapperClassList = this.eOverlayWrapper.classList;
    overlayWrapperClassList.toggle("ag-overlay-loading-wrapper", loadingType === LoadingType.Loading);
    overlayWrapperClassList.toggle("ag-overlay-no-rows-wrapper", loadingType === LoadingType.NoRows);
  }
  showLoadingOverlay() {
    if (this.gridOptionsService.is("suppressLoadingOverlay")) {
      return;
    }
    const params = {};
    const compDetails = this.userComponentFactory.getLoadingOverlayCompDetails(params);
    const promise = compDetails.newAgStackInstance();
    this.showOverlay(promise, LoadingType.Loading);
  }
  showNoRowsOverlay() {
    if (this.gridOptionsService.is("suppressNoRowsOverlay")) {
      return;
    }
    const params = {};
    const compDetails = this.userComponentFactory.getNoRowsOverlayCompDetails(params);
    const promise = compDetails.newAgStackInstance();
    this.showOverlay(promise, LoadingType.NoRows);
  }
  showOverlay(workItem, type) {
    if (this.inProgress) {
      return;
    }
    this.setWrapperTypeClass(type);
    this.destroyActiveOverlay();
    this.inProgress = true;
    if (workItem) {
      workItem.then((comp) => {
        this.inProgress = false;
        this.eOverlayWrapper.appendChild(comp.getGui());
        this.activeOverlay = comp;
        if (this.destroyRequested) {
          this.destroyRequested = false;
          this.destroyActiveOverlay();
        }
      });
    }
    this.manuallyDisplayed = this.columnModel.isReady() && !this.paginationProxy.isEmpty();
    this.setDisplayed(true, { skipAriaHidden: true });
  }
  destroyActiveOverlay() {
    if (this.inProgress) {
      this.destroyRequested = true;
      return;
    }
    if (!this.activeOverlay) {
      return;
    }
    this.activeOverlay = this.getContext().destroyBean(this.activeOverlay);
    clearElement(this.eOverlayWrapper);
  }
  hideOverlay() {
    this.manuallyDisplayed = false;
    this.destroyActiveOverlay();
    this.setDisplayed(false, { skipAriaHidden: true });
  }
  destroy() {
    this.destroyActiveOverlay();
    super.destroy();
  }
  showOrHideOverlay() {
    const isEmpty = this.paginationProxy.isEmpty();
    const isSuppressNoRowsOverlay = this.gridOptionsService.is("suppressNoRowsOverlay");
    if (isEmpty && !isSuppressNoRowsOverlay) {
      this.showNoRowsOverlay();
    } else {
      this.hideOverlay();
    }
  }
  onRowDataUpdated() {
    this.showOrHideOverlay();
  }
  onNewColumnsLoaded() {
    if (this.columnModel.isReady() && !this.paginationProxy.isEmpty() && !this.manuallyDisplayed) {
      this.hideOverlay();
    }
  }
};
OverlayWrapperComponent.TEMPLATE = `
        <div class="ag-overlay" aria-hidden="true">
            <div class="ag-overlay-panel">
                <div class="ag-overlay-wrapper" ref="eOverlayWrapper"></div>
            </div>
        </div>`;
__decorate$u([
  Autowired("userComponentFactory")
], OverlayWrapperComponent.prototype, "userComponentFactory", void 0);
__decorate$u([
  Autowired("paginationProxy")
], OverlayWrapperComponent.prototype, "paginationProxy", void 0);
__decorate$u([
  Autowired("gridApi")
], OverlayWrapperComponent.prototype, "gridApi", void 0);
__decorate$u([
  Autowired("columnModel")
], OverlayWrapperComponent.prototype, "columnModel", void 0);
__decorate$u([
  RefSelector("eOverlayWrapper")
], OverlayWrapperComponent.prototype, "eOverlayWrapper", void 0);
__decorate$u([
  PostConstruct
], OverlayWrapperComponent.prototype, "postConstruct", null);
var __decorate$t = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RowPositionUtils = class RowPositionUtils2 extends BeanStub {
  getFirstRow() {
    let rowIndex = 0;
    let rowPinned;
    if (this.pinnedRowModel.getPinnedTopRowCount()) {
      rowPinned = "top";
    } else if (this.rowModel.getRowCount()) {
      rowPinned = null;
      rowIndex = this.paginationProxy.getPageFirstRow();
    } else if (this.pinnedRowModel.getPinnedBottomRowCount()) {
      rowPinned = "bottom";
    }
    return rowPinned === void 0 ? null : { rowIndex, rowPinned };
  }
  getLastRow() {
    let rowIndex;
    let rowPinned = null;
    const pinnedBottomCount = this.pinnedRowModel.getPinnedBottomRowCount();
    const pinnedTopCount = this.pinnedRowModel.getPinnedTopRowCount();
    if (pinnedBottomCount) {
      rowPinned = "bottom";
      rowIndex = pinnedBottomCount - 1;
    } else if (this.rowModel.getRowCount()) {
      rowPinned = null;
      rowIndex = this.paginationProxy.getPageLastRow();
    } else if (pinnedTopCount) {
      rowPinned = "top";
      rowIndex = pinnedTopCount - 1;
    }
    return rowIndex === void 0 ? null : { rowIndex, rowPinned };
  }
  getRowNode(gridRow) {
    switch (gridRow.rowPinned) {
      case "top":
        return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];
      case "bottom":
        return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];
      default:
        return this.rowModel.getRow(gridRow.rowIndex);
    }
  }
  sameRow(rowA, rowB) {
    if (!rowA && !rowB) {
      return true;
    }
    if (rowA && !rowB || !rowA && rowB) {
      return false;
    }
    return rowA.rowIndex === rowB.rowIndex && rowA.rowPinned == rowB.rowPinned;
  }
  before(rowA, rowB) {
    switch (rowA.rowPinned) {
      case "top":
        if (rowB.rowPinned !== "top") {
          return true;
        }
        break;
      case "bottom":
        if (rowB.rowPinned !== "bottom") {
          return false;
        }
        break;
      default:
        if (exists(rowB.rowPinned)) {
          return rowB.rowPinned !== "top";
        }
        break;
    }
    return rowA.rowIndex < rowB.rowIndex;
  }
  rowMax(rows) {
    let max;
    rows.forEach((row) => {
      if (max === void 0 || this.before(max, row)) {
        max = row;
      }
    });
    return max;
  }
  rowMin(rows) {
    let min;
    rows.forEach((row) => {
      if (min === void 0 || this.before(row, min)) {
        min = row;
      }
    });
    return min;
  }
};
__decorate$t([
  Autowired("rowModel")
], RowPositionUtils.prototype, "rowModel", void 0);
__decorate$t([
  Autowired("pinnedRowModel")
], RowPositionUtils.prototype, "pinnedRowModel", void 0);
__decorate$t([
  Autowired("paginationProxy")
], RowPositionUtils.prototype, "paginationProxy", void 0);
RowPositionUtils = __decorate$t([
  Bean("rowPositionUtils")
], RowPositionUtils);
var __decorate$s = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CellPositionUtils = class CellPositionUtils2 extends BeanStub {
  createId(cellPosition) {
    const { rowIndex, rowPinned, column } = cellPosition;
    return this.createIdFromValues({ rowIndex, column, rowPinned });
  }
  createIdFromValues(cellPosition) {
    const { rowIndex, rowPinned, column } = cellPosition;
    return `${rowIndex}.${rowPinned == null ? "null" : rowPinned}.${column.getId()}`;
  }
  equals(cellA, cellB) {
    const colsMatch = cellA.column === cellB.column;
    const floatingMatch = cellA.rowPinned === cellB.rowPinned;
    const indexMatch = cellA.rowIndex === cellB.rowIndex;
    return colsMatch && floatingMatch && indexMatch;
  }
};
CellPositionUtils = __decorate$s([
  Bean("cellPositionUtils")
], CellPositionUtils);
var UndoRedoAction = class {
  constructor(cellValueChanges) {
    this.cellValueChanges = cellValueChanges;
  }
};
var RangeUndoRedoAction = class extends UndoRedoAction {
  constructor(cellValueChanges, initialRange, finalRange, ranges) {
    super(cellValueChanges);
    this.initialRange = initialRange;
    this.finalRange = finalRange;
    this.ranges = ranges;
  }
};
var UndoRedoStack = class {
  constructor(maxStackSize) {
    this.actionStack = [];
    this.maxStackSize = maxStackSize ? maxStackSize : UndoRedoStack.DEFAULT_STACK_SIZE;
    this.actionStack = new Array(this.maxStackSize);
  }
  pop() {
    return this.actionStack.pop();
  }
  push(item) {
    const shouldAddActions = item.cellValueChanges && item.cellValueChanges.length > 0;
    if (!shouldAddActions) {
      return;
    }
    if (this.actionStack.length === this.maxStackSize) {
      this.actionStack.shift();
    }
    this.actionStack.push(item);
  }
  clear() {
    this.actionStack = [];
  }
  getCurrentStackSize() {
    return this.actionStack.length;
  }
};
UndoRedoStack.DEFAULT_STACK_SIZE = 10;
var __decorate$r = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var UndoRedoService = class UndoRedoService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.cellValueChanges = [];
    this.activeCellEdit = null;
    this.activeRowEdit = null;
    this.isPasting = false;
    this.isRangeInAction = false;
    this.onCellValueChanged = (event) => {
      const eventCell = { column: event.column, rowIndex: event.rowIndex, rowPinned: event.rowPinned };
      const isCellEditing = this.activeCellEdit !== null && this.cellPositionUtils.equals(this.activeCellEdit, eventCell);
      const isRowEditing = this.activeRowEdit !== null && this.rowPositionUtils.sameRow(this.activeRowEdit, eventCell);
      const shouldCaptureAction = isCellEditing || isRowEditing || this.isPasting || this.isRangeInAction;
      if (!shouldCaptureAction) {
        return;
      }
      const { rowPinned, rowIndex, column, oldValue, value } = event;
      const cellValueChange = {
        rowPinned,
        rowIndex,
        columnId: column.getColId(),
        newValue: value,
        oldValue
      };
      this.cellValueChanges.push(cellValueChange);
    };
    this.clearStacks = () => {
      this.undoStack.clear();
      this.redoStack.clear();
    };
  }
  init() {
    if (!this.gridOptionsService.is("undoRedoCellEditing")) {
      return;
    }
    const undoRedoLimit = this.gridOptionsService.getNum("undoRedoCellEditingLimit");
    if (undoRedoLimit <= 0) {
      return;
    }
    this.undoStack = new UndoRedoStack(undoRedoLimit);
    this.redoStack = new UndoRedoStack(undoRedoLimit);
    this.addRowEditingListeners();
    this.addCellEditingListeners();
    this.addPasteListeners();
    this.addFillListeners();
    this.addCellKeyListeners();
    this.addManagedListener(this.eventService, Events.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged);
    this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, (e) => {
      if (!e.keepUndoRedoStack) {
        this.clearStacks();
      }
    });
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.clearStacks);
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.clearStacks);
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_GROUP_OPENED, this.clearStacks);
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.clearStacks);
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, this.clearStacks);
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PINNED, this.clearStacks);
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, this.clearStacks);
    this.addManagedListener(this.eventService, Events.EVENT_ROW_DRAG_END, this.clearStacks);
    this.ctrlsService.whenReady(() => {
      this.gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
    });
  }
  getCurrentUndoStackSize() {
    return this.undoStack ? this.undoStack.getCurrentStackSize() : 0;
  }
  getCurrentRedoStackSize() {
    return this.redoStack ? this.redoStack.getCurrentStackSize() : 0;
  }
  undo(source) {
    const startEvent = {
      type: Events.EVENT_UNDO_STARTED,
      source
    };
    this.eventService.dispatchEvent(startEvent);
    const operationPerformed = this.undoRedo(this.undoStack, this.redoStack, "initialRange", "oldValue", "undo");
    const endEvent = {
      type: Events.EVENT_UNDO_ENDED,
      source,
      operationPerformed
    };
    this.eventService.dispatchEvent(endEvent);
  }
  redo(source) {
    const startEvent = {
      type: Events.EVENT_REDO_STARTED,
      source
    };
    this.eventService.dispatchEvent(startEvent);
    const operationPerformed = this.undoRedo(this.redoStack, this.undoStack, "finalRange", "newValue", "redo");
    const endEvent = {
      type: Events.EVENT_REDO_ENDED,
      source,
      operationPerformed
    };
    this.eventService.dispatchEvent(endEvent);
  }
  undoRedo(undoRedoStack, opposingUndoRedoStack, rangeProperty, cellValueChangeProperty, source) {
    if (!undoRedoStack) {
      return false;
    }
    const undoRedoAction = undoRedoStack.pop();
    if (!undoRedoAction || !undoRedoAction.cellValueChanges) {
      return false;
    }
    this.processAction(undoRedoAction, (cellValueChange) => cellValueChange[cellValueChangeProperty], source);
    if (undoRedoAction instanceof RangeUndoRedoAction) {
      this.processRange(undoRedoAction.ranges || [undoRedoAction[rangeProperty]]);
    } else {
      this.processCell(undoRedoAction.cellValueChanges);
    }
    opposingUndoRedoStack.push(undoRedoAction);
    return true;
  }
  processAction(action, valueExtractor, source) {
    action.cellValueChanges.forEach((cellValueChange) => {
      const { rowIndex, rowPinned, columnId } = cellValueChange;
      const rowPosition = { rowIndex, rowPinned };
      const currentRow = this.getRowNode(rowPosition);
      if (!currentRow.displayed) {
        return;
      }
      currentRow.setDataValue(columnId, valueExtractor(cellValueChange), source);
    });
  }
  processRange(ranges) {
    let lastFocusedCell;
    this.rangeService.removeAllCellRanges(true);
    ranges.forEach((range, idx) => {
      if (!range) {
        return;
      }
      const startRow = range.startRow;
      const endRow = range.endRow;
      if (idx === ranges.length - 1) {
        lastFocusedCell = {
          rowPinned: startRow.rowPinned,
          rowIndex: startRow.rowIndex,
          columnId: range.startColumn.getColId()
        };
        this.setLastFocusedCell(lastFocusedCell);
      }
      const cellRangeParams = {
        rowStartIndex: startRow.rowIndex,
        rowStartPinned: startRow.rowPinned,
        rowEndIndex: endRow.rowIndex,
        rowEndPinned: endRow.rowPinned,
        columnStart: range.startColumn,
        columns: range.columns
      };
      this.rangeService.addCellRange(cellRangeParams);
    });
  }
  processCell(cellValueChanges) {
    const cellValueChange = cellValueChanges[0];
    const { rowIndex, rowPinned } = cellValueChange;
    const rowPosition = { rowIndex, rowPinned };
    const row = this.getRowNode(rowPosition);
    const lastFocusedCell = {
      rowPinned: cellValueChange.rowPinned,
      rowIndex: row.rowIndex,
      columnId: cellValueChange.columnId
    };
    this.setLastFocusedCell(lastFocusedCell, !!this.rangeService);
  }
  setLastFocusedCell(lastFocusedCell, setRangeToCell) {
    const { rowIndex, columnId, rowPinned } = lastFocusedCell;
    const scrollFeature = this.gridBodyCtrl.getScrollFeature();
    const column = this.columnModel.getGridColumn(columnId);
    if (!column) {
      return;
    }
    scrollFeature.ensureIndexVisible(rowIndex);
    scrollFeature.ensureColumnVisible(column);
    const cellPosition = { rowIndex, column, rowPinned };
    this.focusService.setFocusedCell(Object.assign(Object.assign({}, cellPosition), { forceBrowserFocus: true }));
    if (setRangeToCell) {
      this.rangeService.setRangeToCell(cellPosition);
    }
  }
  addRowEditingListeners() {
    this.addManagedListener(this.eventService, Events.EVENT_ROW_EDITING_STARTED, (e) => {
      this.activeRowEdit = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
    });
    this.addManagedListener(this.eventService, Events.EVENT_ROW_EDITING_STOPPED, () => {
      const action = new UndoRedoAction(this.cellValueChanges);
      this.pushActionsToUndoStack(action);
      this.activeRowEdit = null;
    });
  }
  addCellEditingListeners() {
    this.addManagedListener(this.eventService, Events.EVENT_CELL_EDITING_STARTED, (e) => {
      this.activeCellEdit = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned };
    });
    this.addManagedListener(this.eventService, Events.EVENT_CELL_EDITING_STOPPED, (e) => {
      this.activeCellEdit = null;
      const shouldPushAction = e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction;
      if (shouldPushAction) {
        const action = new UndoRedoAction(this.cellValueChanges);
        this.pushActionsToUndoStack(action);
      }
    });
  }
  addPasteListeners() {
    this.addManagedListener(this.eventService, Events.EVENT_PASTE_START, () => {
      this.isPasting = true;
    });
    this.addManagedListener(this.eventService, Events.EVENT_PASTE_END, () => {
      const action = new UndoRedoAction(this.cellValueChanges);
      this.pushActionsToUndoStack(action);
      this.isPasting = false;
    });
  }
  addFillListeners() {
    this.addManagedListener(this.eventService, Events.EVENT_FILL_START, () => {
      this.isRangeInAction = true;
    });
    this.addManagedListener(this.eventService, Events.EVENT_FILL_END, (event) => {
      const action = new RangeUndoRedoAction(this.cellValueChanges, event.initialRange, event.finalRange);
      this.pushActionsToUndoStack(action);
      this.isRangeInAction = false;
    });
  }
  addCellKeyListeners() {
    this.addManagedListener(this.eventService, Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_START, () => {
      this.isRangeInAction = true;
    });
    this.addManagedListener(this.eventService, Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_END, () => {
      let action;
      if (this.rangeService && this.gridOptionsService.isEnableRangeSelection()) {
        action = new RangeUndoRedoAction(this.cellValueChanges, void 0, void 0, [...this.rangeService.getCellRanges()]);
      } else {
        action = new UndoRedoAction(this.cellValueChanges);
      }
      this.pushActionsToUndoStack(action);
      this.isRangeInAction = false;
    });
  }
  pushActionsToUndoStack(action) {
    this.undoStack.push(action);
    this.cellValueChanges = [];
    this.redoStack.clear();
  }
  getRowNode(gridRow) {
    switch (gridRow.rowPinned) {
      case "top":
        return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];
      case "bottom":
        return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];
      default:
        return this.rowModel.getRow(gridRow.rowIndex);
    }
  }
};
__decorate$r([
  Autowired("focusService")
], UndoRedoService.prototype, "focusService", void 0);
__decorate$r([
  Autowired("ctrlsService")
], UndoRedoService.prototype, "ctrlsService", void 0);
__decorate$r([
  Autowired("rowModel")
], UndoRedoService.prototype, "rowModel", void 0);
__decorate$r([
  Autowired("pinnedRowModel")
], UndoRedoService.prototype, "pinnedRowModel", void 0);
__decorate$r([
  Autowired("cellPositionUtils")
], UndoRedoService.prototype, "cellPositionUtils", void 0);
__decorate$r([
  Autowired("rowPositionUtils")
], UndoRedoService.prototype, "rowPositionUtils", void 0);
__decorate$r([
  Autowired("columnModel")
], UndoRedoService.prototype, "columnModel", void 0);
__decorate$r([
  Optional("rangeService")
], UndoRedoService.prototype, "rangeService", void 0);
__decorate$r([
  PostConstruct
], UndoRedoService.prototype, "init", null);
UndoRedoService = __decorate$r([
  Bean("undoRedoService")
], UndoRedoService);
var __decorate$q = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HeaderPositionUtils = class HeaderPositionUtils2 extends BeanStub {
  findHeader(focusedHeader, direction) {
    let nextColumn;
    let getGroupMethod;
    let getColMethod;
    if (focusedHeader.column instanceof ColumnGroup) {
      getGroupMethod = `getDisplayedGroup${direction}`;
      nextColumn = this.columnModel[getGroupMethod](focusedHeader.column);
    } else {
      getColMethod = `getDisplayedCol${direction}`;
      nextColumn = this.columnModel[getColMethod](focusedHeader.column);
    }
    if (!nextColumn) {
      return;
    }
    let { headerRowIndex } = focusedHeader;
    const currentRowType = this.getHeaderRowType(headerRowIndex);
    if (currentRowType === HeaderRowType.COLUMN_GROUP) {
      const columnGroup = nextColumn;
      if (columnGroup.isPadding() && this.isAnyChildSpanningHeaderHeight(columnGroup)) {
        const { nextFocusColumn, nextRow } = this.getColumnVisibleChild(columnGroup, headerRowIndex, direction);
        if (nextFocusColumn) {
          nextColumn = nextFocusColumn;
          headerRowIndex = nextRow;
        }
      }
    }
    return {
      column: nextColumn,
      headerRowIndex
    };
  }
  isAnyChildSpanningHeaderHeight(columnGroup) {
    if (!columnGroup) {
      return false;
    }
    return columnGroup.getLeafColumns().some((col) => col.isSpanHeaderHeight());
  }
  getColumnVisibleParent(currentColumn, currentIndex) {
    const currentRowType = this.getHeaderRowType(currentIndex);
    const isFloatingFilter = currentRowType === HeaderRowType.FLOATING_FILTER;
    const isColumn = currentRowType === HeaderRowType.COLUMN;
    let nextFocusColumn = isFloatingFilter ? currentColumn : currentColumn.getParent();
    let nextRow = currentIndex - 1;
    if (isColumn && this.isAnyChildSpanningHeaderHeight(currentColumn.getParent())) {
      while (nextFocusColumn && nextFocusColumn.isPadding()) {
        nextFocusColumn = nextFocusColumn.getParent();
        nextRow--;
      }
      if (nextRow < 0) {
        nextFocusColumn = currentColumn;
        nextRow = currentIndex;
      }
    }
    return { nextFocusColumn, nextRow };
  }
  getColumnVisibleChild(column, currentIndex, direction = "After") {
    const currentRowType = this.getHeaderRowType(currentIndex);
    let nextFocusColumn = column;
    let nextRow = currentIndex + 1;
    if (currentRowType === HeaderRowType.COLUMN_GROUP) {
      const leafColumns = column.getLeafColumns();
      const leafChild = direction === "After" ? leafColumns[0] : last(leafColumns);
      if (this.isAnyChildSpanningHeaderHeight(leafChild.getParent())) {
        nextFocusColumn = leafChild;
        let currentColumn = leafChild.getParent();
        while (currentColumn && currentColumn !== column) {
          currentColumn = currentColumn.getParent();
          nextRow++;
        }
      } else {
        nextFocusColumn = column.getDisplayedChildren()[0];
      }
    }
    return { nextFocusColumn, nextRow };
  }
  getHeaderRowType(rowIndex) {
    const centerHeaderContainer = this.ctrlsService.getHeaderRowContainerCtrl();
    if (centerHeaderContainer) {
      return centerHeaderContainer.getRowType(rowIndex);
    }
  }
  findColAtEdgeForHeaderRow(level, position) {
    const displayedColumns = this.columnModel.getAllDisplayedColumns();
    const column = displayedColumns[position === "start" ? 0 : displayedColumns.length - 1];
    if (!column) {
      return;
    }
    const childContainer = this.ctrlsService.getHeaderRowContainerCtrl(column.getPinned());
    const type = childContainer.getRowType(level);
    if (type == HeaderRowType.COLUMN_GROUP) {
      const columnGroup = this.columnModel.getColumnGroupAtLevel(column, level);
      return {
        headerRowIndex: level,
        column: columnGroup
      };
    }
    return {
      headerRowIndex: type == null ? -1 : level,
      column
    };
  }
};
__decorate$q([
  Autowired("columnModel")
], HeaderPositionUtils.prototype, "columnModel", void 0);
__decorate$q([
  Autowired("ctrlsService")
], HeaderPositionUtils.prototype, "ctrlsService", void 0);
HeaderPositionUtils = __decorate$q([
  Bean("headerPositionUtils")
], HeaderPositionUtils);
var __decorate$p = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ColumnDefFactory = class ColumnDefFactory2 {
  buildColumnDefs(cols, rowGroupColumns, pivotColumns) {
    const res = [];
    const colGroupDefs = {};
    cols.forEach((col) => {
      const colDef = this.createDefFromColumn(col, rowGroupColumns, pivotColumns);
      let addToResult = true;
      let childDef = colDef;
      let pointer = col.getOriginalParent();
      let lastPointer = null;
      while (pointer) {
        let parentDef = null;
        if (pointer.isPadding()) {
          pointer = pointer.getOriginalParent();
          continue;
        }
        const existingParentDef = colGroupDefs[pointer.getGroupId()];
        if (existingParentDef) {
          existingParentDef.children.push(childDef);
          addToResult = false;
          break;
        }
        parentDef = this.createDefFromGroup(pointer);
        if (parentDef) {
          parentDef.children = [childDef];
          colGroupDefs[parentDef.groupId] = parentDef;
          childDef = parentDef;
          pointer = pointer.getOriginalParent();
        }
        if (lastPointer === pointer) {
          addToResult = false;
          break;
        }
        lastPointer = pointer;
      }
      if (addToResult) {
        res.push(childDef);
      }
    });
    return res;
  }
  createDefFromGroup(group) {
    const defCloned = deepCloneDefinition(group.getColGroupDef(), ["children"]);
    if (defCloned) {
      defCloned.groupId = group.getGroupId();
    }
    return defCloned;
  }
  createDefFromColumn(col, rowGroupColumns, pivotColumns) {
    const colDefCloned = deepCloneDefinition(col.getColDef());
    colDefCloned.colId = col.getColId();
    colDefCloned.width = col.getActualWidth();
    colDefCloned.rowGroup = col.isRowGroupActive();
    colDefCloned.rowGroupIndex = col.isRowGroupActive() ? rowGroupColumns.indexOf(col) : null;
    colDefCloned.pivot = col.isPivotActive();
    colDefCloned.pivotIndex = col.isPivotActive() ? pivotColumns.indexOf(col) : null;
    colDefCloned.aggFunc = col.isValueActive() ? col.getAggFunc() : null;
    colDefCloned.hide = col.isVisible() ? void 0 : true;
    colDefCloned.pinned = col.isPinned() ? col.getPinned() : null;
    colDefCloned.sort = col.getSort() ? col.getSort() : null;
    colDefCloned.sortIndex = col.getSortIndex() != null ? col.getSortIndex() : null;
    return colDefCloned;
  }
};
ColumnDefFactory = __decorate$p([
  Bean("columnDefFactory")
], ColumnDefFactory);
var __decorate$o = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RowCssClassCalculator = class RowCssClassCalculator2 {
  getInitialRowClasses(params) {
    const classes = [];
    if (exists(params.extraCssClass)) {
      classes.push(params.extraCssClass);
    }
    classes.push("ag-row");
    classes.push(params.rowFocused ? "ag-row-focus" : "ag-row-no-focus");
    if (params.fadeRowIn) {
      classes.push("ag-opacity-zero");
    }
    classes.push(params.rowIsEven ? "ag-row-even" : "ag-row-odd");
    if (params.rowNode.isRowPinned()) {
      classes.push("ag-row-pinned");
    }
    if (params.rowNode.isSelected()) {
      classes.push("ag-row-selected");
    }
    if (params.rowNode.footer) {
      classes.push("ag-row-footer");
    }
    classes.push("ag-row-level-" + params.rowLevel);
    if (params.rowNode.stub) {
      classes.push("ag-row-loading");
    }
    if (params.fullWidthRow) {
      classes.push("ag-full-width-row");
    }
    if (params.expandable) {
      classes.push("ag-row-group");
      classes.push(params.rowNode.expanded ? "ag-row-group-expanded" : "ag-row-group-contracted");
    }
    if (params.rowNode.dragging) {
      classes.push("ag-row-dragging");
    }
    pushAll(classes, this.processClassesFromGridOptions(params.rowNode));
    pushAll(classes, this.preProcessRowClassRules(params.rowNode));
    classes.push(params.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute");
    if (params.firstRowOnPage) {
      classes.push("ag-row-first");
    }
    if (params.lastRowOnPage) {
      classes.push("ag-row-last");
    }
    if (params.fullWidthRow) {
      if (params.pinned === "left") {
        classes.push("ag-cell-last-left-pinned");
      }
      if (params.pinned === "right") {
        classes.push("ag-cell-first-right-pinned");
      }
    }
    return classes;
  }
  processClassesFromGridOptions(rowNode) {
    const res = [];
    const process = (rowCls) => {
      if (typeof rowCls === "string") {
        res.push(rowCls);
      } else if (Array.isArray(rowCls)) {
        rowCls.forEach((e) => res.push(e));
      }
    };
    const rowClass = this.gridOptionsService.get("rowClass");
    if (rowClass) {
      if (typeof rowClass === "function") {
        console.warn("AG Grid: rowClass should not be a function, please use getRowClass instead");
        return [];
      }
      process(rowClass);
    }
    const rowClassFunc = this.gridOptionsService.getCallback("getRowClass");
    if (rowClassFunc) {
      const params = {
        data: rowNode.data,
        node: rowNode,
        rowIndex: rowNode.rowIndex
      };
      const rowClassFuncResult = rowClassFunc(params);
      process(rowClassFuncResult);
    }
    return res;
  }
  preProcessRowClassRules(rowNode) {
    const res = [];
    this.processRowClassRules(rowNode, (className) => {
      res.push(className);
    }, (className) => {
    });
    return res;
  }
  processRowClassRules(rowNode, onApplicableClass, onNotApplicableClass) {
    const rowClassParams = {
      data: rowNode.data,
      node: rowNode,
      rowIndex: rowNode.rowIndex,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    };
    this.stylingService.processClassRules(this.gridOptionsService.get("rowClassRules"), rowClassParams, onApplicableClass, onNotApplicableClass);
  }
  calculateRowLevel(rowNode) {
    if (rowNode.group) {
      return rowNode.level;
    }
    return rowNode.parent ? rowNode.parent.level + 1 : 0;
  }
};
__decorate$o([
  Autowired("stylingService")
], RowCssClassCalculator.prototype, "stylingService", void 0);
__decorate$o([
  Autowired("gridOptionsService")
], RowCssClassCalculator.prototype, "gridOptionsService", void 0);
RowCssClassCalculator = __decorate$o([
  Bean("rowCssClassCalculator")
], RowCssClassCalculator);
var __decorate$n = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RowNodeSorter = class RowNodeSorter2 extends BeanStub {
  init() {
    this.isAccentedSort = this.gridOptionsService.is("accentedSort");
    this.primaryColumnsSortGroups = this.gridOptionsService.isColumnsSortingCoupledToGroup();
    this.addManagedPropertyListener("accentedSort", (propChange) => this.isAccentedSort = propChange.currentValue);
    this.addManagedPropertyListener("autoGroupColumnDef", () => this.primaryColumnsSortGroups = this.gridOptionsService.isColumnsSortingCoupledToGroup());
  }
  doFullSort(rowNodes, sortOptions) {
    const mapper = (rowNode, pos) => ({ currentPos: pos, rowNode });
    const sortedRowNodes = rowNodes.map(mapper);
    sortedRowNodes.sort(this.compareRowNodes.bind(this, sortOptions));
    return sortedRowNodes.map((item) => item.rowNode);
  }
  compareRowNodes(sortOptions, sortedNodeA, sortedNodeB) {
    const nodeA = sortedNodeA.rowNode;
    const nodeB = sortedNodeB.rowNode;
    for (let i = 0, len = sortOptions.length; i < len; i++) {
      const sortOption = sortOptions[i];
      const isDescending = sortOption.sort === "desc";
      const valueA = this.getValue(nodeA, sortOption.column);
      const valueB = this.getValue(nodeB, sortOption.column);
      let comparatorResult;
      const providedComparator = this.getComparator(sortOption, nodeA);
      if (providedComparator) {
        comparatorResult = providedComparator(valueA, valueB, nodeA, nodeB, isDescending);
      } else {
        comparatorResult = _.defaultComparator(valueA, valueB, this.isAccentedSort);
      }
      const validResult = !isNaN(comparatorResult);
      if (validResult && comparatorResult !== 0) {
        return sortOption.sort === "asc" ? comparatorResult : comparatorResult * -1;
      }
    }
    return sortedNodeA.currentPos - sortedNodeB.currentPos;
  }
  getComparator(sortOption, rowNode) {
    const column = sortOption.column;
    const comparatorOnCol = column.getColDef().comparator;
    if (comparatorOnCol != null) {
      return comparatorOnCol;
    }
    if (!column.getColDef().showRowGroup) {
      return;
    }
    const groupLeafField = !rowNode.group && column.getColDef().field;
    if (!groupLeafField) {
      return;
    }
    const primaryColumn = this.columnModel.getPrimaryColumn(groupLeafField);
    if (!primaryColumn) {
      return;
    }
    return primaryColumn.getColDef().comparator;
  }
  getValue(node, column) {
    var _a, _b;
    if (!this.primaryColumnsSortGroups) {
      return this.valueService.getValue(column, node, false, false);
    }
    const isNodeGroupedAtLevel = node.rowGroupColumn === column;
    if (isNodeGroupedAtLevel) {
      const isGroupRows = this.gridOptionsService.isGroupUseEntireRow(this.columnModel.isPivotActive());
      if (isGroupRows) {
        const keyCreator = column.getColDef().keyCreator;
        if (keyCreator) {
          return node.key;
        }
        const leafChild = (_a = node.allLeafChildren) === null || _a === void 0 ? void 0 : _a[0];
        if (leafChild) {
          return this.valueService.getValue(column, leafChild, false, false);
        }
        return void 0;
      }
      const displayCol = this.columnModel.getGroupDisplayColumnForGroup(column.getId());
      if (!displayCol) {
        return void 0;
      }
      return (_b = node.groupData) === null || _b === void 0 ? void 0 : _b[displayCol.getId()];
    }
    if (node.group && column.getColDef().showRowGroup) {
      return void 0;
    }
    return this.valueService.getValue(column, node, false, false);
  }
};
__decorate$n([
  Autowired("valueService")
], RowNodeSorter.prototype, "valueService", void 0);
__decorate$n([
  Autowired("columnModel")
], RowNodeSorter.prototype, "columnModel", void 0);
__decorate$n([
  PostConstruct
], RowNodeSorter.prototype, "init", null);
RowNodeSorter = __decorate$n([
  Bean("rowNodeSorter")
], RowNodeSorter);
var __decorate$m = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CtrlsService_1;
var CtrlsService = CtrlsService_1 = class CtrlsService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.ready = false;
    this.readyCallbacks = [];
  }
  checkReady() {
    this.ready = this.gridCtrl != null && this.gridBodyCtrl != null && this.centerRowContainerCtrl != null && this.leftRowContainerCtrl != null && this.rightRowContainerCtrl != null && this.bottomCenterRowContainerCtrl != null && this.bottomLeftRowContainerCtrl != null && this.bottomRightRowContainerCtrl != null && this.topCenterRowContainerCtrl != null && this.topLeftRowContainerCtrl != null && this.topRightRowContainerCtrl != null && this.stickyTopCenterRowContainerCtrl != null && this.stickyTopLeftRowContainerCtrl != null && this.stickyTopRightRowContainerCtrl != null && this.centerHeaderRowContainerCtrl != null && this.leftHeaderRowContainerCtrl != null && this.rightHeaderRowContainerCtrl != null && this.fakeHScrollComp != null && this.fakeVScrollComp != null && this.gridHeaderCtrl != null;
    if (this.ready) {
      const p = this.createReadyParams();
      this.readyCallbacks.forEach((c) => c(p));
      this.readyCallbacks.length = 0;
    }
  }
  whenReady(callback) {
    if (this.ready) {
      callback(this.createReadyParams());
    } else {
      this.readyCallbacks.push(callback);
    }
  }
  createReadyParams() {
    return {
      centerRowContainerCtrl: this.centerRowContainerCtrl,
      leftRowContainerCtrl: this.leftRowContainerCtrl,
      rightRowContainerCtrl: this.rightRowContainerCtrl,
      bottomCenterRowContainerCtrl: this.bottomCenterRowContainerCtrl,
      bottomLeftRowContainerCtrl: this.bottomLeftRowContainerCtrl,
      bottomRightRowContainerCtrl: this.bottomRightRowContainerCtrl,
      topCenterRowContainerCtrl: this.topCenterRowContainerCtrl,
      topLeftRowContainerCtrl: this.topLeftRowContainerCtrl,
      topRightRowContainerCtrl: this.topRightRowContainerCtrl,
      stickyTopCenterRowContainerCtrl: this.stickyTopCenterRowContainerCtrl,
      stickyTopLeftRowContainerCtrl: this.stickyTopLeftRowContainerCtrl,
      stickyTopRightRowContainerCtrl: this.stickyTopRightRowContainerCtrl,
      centerHeaderRowContainerCtrl: this.centerHeaderRowContainerCtrl,
      leftHeaderRowContainerCtrl: this.leftHeaderRowContainerCtrl,
      rightHeaderRowContainerCtrl: this.rightHeaderRowContainerCtrl,
      fakeHScrollComp: this.fakeHScrollComp,
      fakeVScrollComp: this.fakeVScrollComp,
      gridBodyCtrl: this.gridBodyCtrl,
      gridCtrl: this.gridCtrl,
      gridHeaderCtrl: this.gridHeaderCtrl
    };
  }
  registerFakeHScrollComp(comp) {
    this.fakeHScrollComp = comp;
    this.checkReady();
  }
  registerFakeVScrollComp(comp) {
    this.fakeVScrollComp = comp;
    this.checkReady();
  }
  registerGridHeaderCtrl(gridHeaderCtrl) {
    this.gridHeaderCtrl = gridHeaderCtrl;
    this.checkReady();
  }
  registerCenterRowContainerCtrl(ctrl) {
    this.centerRowContainerCtrl = ctrl;
    this.checkReady();
  }
  registerLeftRowContainerCtrl(ctrl) {
    this.leftRowContainerCtrl = ctrl;
    this.checkReady();
  }
  registerRightRowContainerCtrl(ctrl) {
    this.rightRowContainerCtrl = ctrl;
    this.checkReady();
  }
  registerTopCenterRowContainerCtrl(ctrl) {
    this.topCenterRowContainerCtrl = ctrl;
    this.checkReady();
  }
  registerTopLeftRowContainerCon(ctrl) {
    this.topLeftRowContainerCtrl = ctrl;
    this.checkReady();
  }
  registerTopRightRowContainerCtrl(ctrl) {
    this.topRightRowContainerCtrl = ctrl;
    this.checkReady();
  }
  registerStickyTopCenterRowContainerCtrl(ctrl) {
    this.stickyTopCenterRowContainerCtrl = ctrl;
    this.checkReady();
  }
  registerStickyTopLeftRowContainerCon(ctrl) {
    this.stickyTopLeftRowContainerCtrl = ctrl;
    this.checkReady();
  }
  registerStickyTopRightRowContainerCtrl(ctrl) {
    this.stickyTopRightRowContainerCtrl = ctrl;
    this.checkReady();
  }
  registerBottomCenterRowContainerCtrl(ctrl) {
    this.bottomCenterRowContainerCtrl = ctrl;
    this.checkReady();
  }
  registerBottomLeftRowContainerCtrl(ctrl) {
    this.bottomLeftRowContainerCtrl = ctrl;
    this.checkReady();
  }
  registerBottomRightRowContainerCtrl(ctrl) {
    this.bottomRightRowContainerCtrl = ctrl;
    this.checkReady();
  }
  registerHeaderContainer(ctrl, pinned) {
    switch (pinned) {
      case "left":
        this.leftHeaderRowContainerCtrl = ctrl;
        break;
      case "right":
        this.rightHeaderRowContainerCtrl = ctrl;
        break;
      default:
        this.centerHeaderRowContainerCtrl = ctrl;
        break;
    }
    this.checkReady();
  }
  registerGridBodyCtrl(ctrl) {
    this.gridBodyCtrl = ctrl;
    this.checkReady();
  }
  registerGridCtrl(ctrl) {
    this.gridCtrl = ctrl;
    this.checkReady();
  }
  getFakeHScrollComp() {
    return this.fakeHScrollComp;
  }
  getFakeVScrollComp() {
    return this.fakeVScrollComp;
  }
  getGridHeaderCtrl() {
    return this.gridHeaderCtrl;
  }
  getGridCtrl() {
    return this.gridCtrl;
  }
  getCenterRowContainerCtrl() {
    return this.centerRowContainerCtrl;
  }
  getTopCenterRowContainerCtrl() {
    return this.topCenterRowContainerCtrl;
  }
  getBottomCenterRowContainerCtrl() {
    return this.bottomCenterRowContainerCtrl;
  }
  getStickyTopCenterRowContainerCtrl() {
    return this.stickyTopCenterRowContainerCtrl;
  }
  getGridBodyCtrl() {
    return this.gridBodyCtrl;
  }
  getHeaderRowContainerCtrls() {
    return [this.leftHeaderRowContainerCtrl, this.rightHeaderRowContainerCtrl, this.centerHeaderRowContainerCtrl];
  }
  getHeaderRowContainerCtrl(pinned) {
    switch (pinned) {
      case "left":
        return this.leftHeaderRowContainerCtrl;
      case "right":
        return this.rightHeaderRowContainerCtrl;
      default:
        return this.centerHeaderRowContainerCtrl;
    }
  }
};
CtrlsService.NAME = "ctrlsService";
CtrlsService = CtrlsService_1 = __decorate$m([
  Bean(CtrlsService_1.NAME)
], CtrlsService);
var __decorate$l = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CtrlsFactory = class CtrlsFactory2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.registry = {};
  }
  register(meta) {
    this.registry[meta.controllerName] = meta.controllerClass;
  }
  getInstance(name) {
    const ControllerClass = this.registry[name];
    if (ControllerClass == null) {
      return void 0;
    }
    return new ControllerClass();
  }
};
CtrlsFactory = __decorate$l([
  Bean("ctrlsFactory")
], CtrlsFactory);
var __decorate$k = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AbstractFakeScrollComp = class extends Component {
  constructor(template, direction) {
    super(template);
    this.direction = direction;
    this.hideTimeout = null;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, Events.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this));
    this.onScrollVisibilityChanged();
    this.addOrRemoveCssClass("ag-apple-scrollbar", isMacOsUserAgent() || isIOSUserAgent());
  }
  initialiseInvisibleScrollbar() {
    if (this.invisibleScrollbar !== void 0) {
      return;
    }
    this.invisibleScrollbar = isInvisibleScrollbar();
    if (this.invisibleScrollbar) {
      this.hideAndShowInvisibleScrollAsNeeded();
      this.addActiveListenerToggles();
    }
  }
  addActiveListenerToggles() {
    const activateEvents = ["mouseenter", "mousedown", "touchstart"];
    const deactivateEvents = ["mouseleave", "touchend"];
    const eGui = this.getGui();
    activateEvents.forEach((eventName) => this.addManagedListener(eGui, eventName, () => this.addOrRemoveCssClass("ag-scrollbar-active", true)));
    deactivateEvents.forEach((eventName) => this.addManagedListener(eGui, eventName, () => this.addOrRemoveCssClass("ag-scrollbar-active", false)));
  }
  onScrollVisibilityChanged() {
    if (this.invisibleScrollbar === void 0) {
      this.initialiseInvisibleScrollbar();
    }
    this.animationFrameService.requestAnimationFrame(() => this.setScrollVisible());
  }
  hideAndShowInvisibleScrollAsNeeded() {
    this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL, (params) => {
      if (params.direction === this.direction) {
        if (this.hideTimeout !== null) {
          window.clearTimeout(this.hideTimeout);
          this.hideTimeout = null;
        }
        this.addOrRemoveCssClass("ag-scrollbar-scrolling", true);
      }
    });
    this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL_END, () => {
      this.hideTimeout = window.setTimeout(() => {
        this.addOrRemoveCssClass("ag-scrollbar-scrolling", false);
        this.hideTimeout = null;
      }, 400);
    });
  }
  getViewport() {
    return this.eViewport;
  }
  getContainer() {
    return this.eContainer;
  }
};
__decorate$k([
  RefSelector("eViewport")
], AbstractFakeScrollComp.prototype, "eViewport", void 0);
__decorate$k([
  RefSelector("eContainer")
], AbstractFakeScrollComp.prototype, "eContainer", void 0);
__decorate$k([
  Autowired("scrollVisibleService")
], AbstractFakeScrollComp.prototype, "scrollVisibleService", void 0);
__decorate$k([
  Autowired("ctrlsService")
], AbstractFakeScrollComp.prototype, "ctrlsService", void 0);
__decorate$k([
  Autowired("animationFrameService")
], AbstractFakeScrollComp.prototype, "animationFrameService", void 0);
var __decorate$j = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FakeHScrollComp = class extends AbstractFakeScrollComp {
  constructor() {
    super(FakeHScrollComp.TEMPLATE, "horizontal");
  }
  postConstruct() {
    super.postConstruct();
    const spacerWidthsListener = this.setFakeHScrollSpacerWidths.bind(this);
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, spacerWidthsListener);
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, spacerWidthsListener);
    this.addManagedListener(this.eventService, Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));
    this.addManagedPropertyListener("domLayout", spacerWidthsListener);
    this.ctrlsService.registerFakeHScrollComp(this);
    this.createManagedBean(new CenterWidthFeature((width) => this.eContainer.style.width = `${width}px`));
  }
  initialiseInvisibleScrollbar() {
    if (this.invisibleScrollbar !== void 0) {
      return;
    }
    this.enableRtl = this.gridOptionsService.is("enableRtl");
    super.initialiseInvisibleScrollbar();
    if (this.invisibleScrollbar) {
      this.refreshCompBottom();
    }
  }
  onPinnedRowDataChanged() {
    this.refreshCompBottom();
  }
  refreshCompBottom() {
    if (!this.invisibleScrollbar) {
      return;
    }
    const bottomPinnedHeight = this.pinnedRowModel.getPinnedBottomTotalHeight();
    this.getGui().style.bottom = `${bottomPinnedHeight}px`;
  }
  onScrollVisibilityChanged() {
    super.onScrollVisibilityChanged();
    this.setFakeHScrollSpacerWidths();
  }
  setFakeHScrollSpacerWidths() {
    const vScrollShowing = this.scrollVisibleService.isVerticalScrollShowing();
    let rightSpacing = this.columnModel.getDisplayedColumnsRightWidth();
    const scrollOnRight = !this.enableRtl && vScrollShowing;
    const scrollbarWidth = this.gridOptionsService.getScrollbarWidth();
    if (scrollOnRight) {
      rightSpacing += scrollbarWidth;
    }
    setFixedWidth(this.eRightSpacer, rightSpacing);
    this.eRightSpacer.classList.toggle("ag-scroller-corner", rightSpacing <= scrollbarWidth);
    let leftSpacing = this.columnModel.getDisplayedColumnsLeftWidth();
    const scrollOnLeft = this.enableRtl && vScrollShowing;
    if (scrollOnLeft) {
      leftSpacing += scrollbarWidth;
    }
    setFixedWidth(this.eLeftSpacer, leftSpacing);
    this.eLeftSpacer.classList.toggle("ag-scroller-corner", leftSpacing <= scrollbarWidth);
  }
  setScrollVisible() {
    const hScrollShowing = this.scrollVisibleService.isHorizontalScrollShowing();
    const invisibleScrollbar2 = this.invisibleScrollbar;
    const isSuppressHorizontalScroll = this.gridOptionsService.is("suppressHorizontalScroll");
    const scrollbarWidth = hScrollShowing ? this.gridOptionsService.getScrollbarWidth() || 0 : 0;
    const adjustedScrollbarWidth = scrollbarWidth === 0 && invisibleScrollbar2 ? 16 : scrollbarWidth;
    const scrollContainerSize = !isSuppressHorizontalScroll ? adjustedScrollbarWidth : 0;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", invisibleScrollbar2);
    setFixedHeight(this.getGui(), scrollContainerSize);
    setFixedHeight(this.eViewport, scrollContainerSize);
    setFixedHeight(this.eContainer, scrollContainerSize);
    this.setDisplayed(hScrollShowing, { skipAriaHidden: true });
  }
};
FakeHScrollComp.TEMPLATE = `<div class="ag-body-horizontal-scroll" aria-hidden="true">
            <div class="ag-horizontal-left-spacer" ref="eLeftSpacer"></div>
            <div class="ag-body-horizontal-scroll-viewport" ref="eViewport">
                <div class="ag-body-horizontal-scroll-container" ref="eContainer"></div>
            </div>
            <div class="ag-horizontal-right-spacer" ref="eRightSpacer"></div>
        </div>`;
__decorate$j([
  RefSelector("eLeftSpacer")
], FakeHScrollComp.prototype, "eLeftSpacer", void 0);
__decorate$j([
  RefSelector("eRightSpacer")
], FakeHScrollComp.prototype, "eRightSpacer", void 0);
__decorate$j([
  Autowired("columnModel")
], FakeHScrollComp.prototype, "columnModel", void 0);
__decorate$j([
  Autowired("pinnedRowModel")
], FakeHScrollComp.prototype, "pinnedRowModel", void 0);
__decorate$j([
  PostConstruct
], FakeHScrollComp.prototype, "postConstruct", null);
var __decorate$i = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PinnedWidthService = class PinnedWidthService2 extends BeanStub {
  postConstruct() {
    const listener = this.checkContainerWidths.bind(this);
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, listener);
    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, listener);
    this.addManagedPropertyListener("domLayout", listener);
  }
  checkContainerWidths() {
    const printLayout = this.gridOptionsService.isDomLayout("print");
    const newLeftWidth = printLayout ? 0 : this.columnModel.getDisplayedColumnsLeftWidth();
    const newRightWidth = printLayout ? 0 : this.columnModel.getDisplayedColumnsRightWidth();
    if (newLeftWidth != this.leftWidth) {
      this.leftWidth = newLeftWidth;
      this.eventService.dispatchEvent({ type: Events.EVENT_LEFT_PINNED_WIDTH_CHANGED });
    }
    if (newRightWidth != this.rightWidth) {
      this.rightWidth = newRightWidth;
      this.eventService.dispatchEvent({ type: Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED });
    }
  }
  getPinnedRightWidth() {
    return this.rightWidth;
  }
  getPinnedLeftWidth() {
    return this.leftWidth;
  }
};
__decorate$i([
  Autowired("columnModel")
], PinnedWidthService.prototype, "columnModel", void 0);
__decorate$i([
  PostConstruct
], PinnedWidthService.prototype, "postConstruct", null);
PinnedWidthService = __decorate$i([
  Bean("pinnedWidthService")
], PinnedWidthService);
var __decorate$h = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RowNodeEventThrottle = class RowNodeEventThrottle2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.events = [];
  }
  postConstruct() {
    if (this.rowModel.getType() == "clientSide") {
      this.clientSideRowModel = this.rowModel;
    }
  }
  dispatchExpanded(event) {
    if (this.clientSideRowModel == null) {
      this.eventService.dispatchEvent(event);
      return;
    }
    this.events.push(event);
    const func = () => {
      if (this.clientSideRowModel) {
        this.clientSideRowModel.onRowGroupOpened();
      }
      this.events.forEach((e) => this.eventService.dispatchEvent(e));
      this.events = [];
    };
    if (this.dispatchExpandedDebounced == null) {
      this.dispatchExpandedDebounced = this.animationFrameService.debounce(func);
    }
    this.dispatchExpandedDebounced();
  }
};
__decorate$h([
  Autowired("animationFrameService")
], RowNodeEventThrottle.prototype, "animationFrameService", void 0);
__decorate$h([
  Autowired("rowModel")
], RowNodeEventThrottle.prototype, "rowModel", void 0);
__decorate$h([
  PostConstruct
], RowNodeEventThrottle.prototype, "postConstruct", null);
RowNodeEventThrottle = __decorate$h([
  Bean("rowNodeEventThrottle")
], RowNodeEventThrottle);
var __decorate$g = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$1 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (typeof value == "string") {
    return parseInt(value, 10);
  }
}
function isTrue(value) {
  return value === true || value === "true";
}
var GridOptionsService = class GridOptionsService2 {
  constructor() {
    this.destroyed = false;
    this.domDataKey = "__AG_" + Math.random().toString();
    this.propertyEventService = new EventService();
  }
  get context() {
    return this.gridOptions["context"];
  }
  agWire(gridApi, columnApi) {
    this.gridOptions.api = gridApi;
    this.gridOptions.columnApi = columnApi;
    this.api = gridApi;
    this.columnApi = columnApi;
  }
  init() {
    this.gridOptionLookup = /* @__PURE__ */ new Set([...ComponentUtil.ALL_PROPERTIES, ...ComponentUtil.EVENT_CALLBACKS]);
    const async = !this.is("suppressAsyncEvents");
    this.eventService.addGlobalListener(this.globalEventHandler.bind(this), async);
    this.getScrollbarWidth();
  }
  destroy() {
    this.gridOptions.api = null;
    this.gridOptions.columnApi = null;
    this.destroyed = true;
  }
  is(property) {
    return isTrue(this.gridOptions[property]);
  }
  get(property) {
    return this.gridOptions[property];
  }
  getNum(property) {
    return toNumber(this.gridOptions[property]);
  }
  getCallback(property) {
    return this.mergeGridCommonParams(this.gridOptions[property]);
  }
  exists(property) {
    return exists(this.gridOptions[property]);
  }
  mergeGridCommonParams(callback) {
    if (callback) {
      const wrapped = (callbackParams) => {
        const mergedParams = callbackParams;
        mergedParams.api = this.api;
        mergedParams.columnApi = this.columnApi;
        mergedParams.context = this.context;
        return callback(mergedParams);
      };
      return wrapped;
    }
    return callback;
  }
  set(key, newValue, force = false, eventParams = {}) {
    if (this.gridOptionLookup.has(key)) {
      const previousValue = this.gridOptions[key];
      if (force || previousValue !== newValue) {
        this.gridOptions[key] = newValue;
        const event = Object.assign({ type: key, currentValue: newValue, previousValue }, eventParams);
        this.propertyEventService.dispatchEvent(event);
      }
    }
  }
  addEventListener(key, listener) {
    this.propertyEventService.addEventListener(key, listener);
  }
  removeEventListener(key, listener) {
    this.propertyEventService.removeEventListener(key, listener);
  }
  globalEventHandler(eventName, event) {
    if (this.destroyed) {
      return;
    }
    const callbackMethodName = ComponentUtil.getCallbackForEvent(eventName);
    if (typeof this.gridOptions[callbackMethodName] === "function") {
      this.gridOptions[callbackMethodName](event);
    }
  }
  getGridId() {
    return this.api.getGridId();
  }
  getScrollbarWidth() {
    if (this.scrollbarWidth == null) {
      const useGridOptions = typeof this.gridOptions.scrollbarWidth === "number" && this.gridOptions.scrollbarWidth >= 0;
      const scrollbarWidth = useGridOptions ? this.gridOptions.scrollbarWidth : getScrollbarWidth();
      if (scrollbarWidth != null) {
        this.scrollbarWidth = scrollbarWidth;
        this.eventService.dispatchEvent({
          type: Events.EVENT_SCROLLBAR_WIDTH_CHANGED
        });
      }
    }
    return this.scrollbarWidth;
  }
  isRowModelType(rowModelType) {
    return this.gridOptions.rowModelType === rowModelType || rowModelType === "clientSide" && missing(this.gridOptions.rowModelType);
  }
  isDomLayout(domLayout) {
    var _a;
    const gridLayout = (_a = this.gridOptions.domLayout) !== null && _a !== void 0 ? _a : "normal";
    return gridLayout === domLayout;
  }
  isRowSelection() {
    return this.gridOptions.rowSelection === "single" || this.gridOptions.rowSelection === "multiple";
  }
  useAsyncEvents() {
    return !this.is("suppressAsyncEvents");
  }
  isGetRowHeightFunction() {
    return typeof this.gridOptions.getRowHeight === "function";
  }
  getRowHeightForNode(rowNode, allowEstimate = false, defaultRowHeight) {
    if (defaultRowHeight == null) {
      defaultRowHeight = this.environment.getDefaultRowHeight();
    }
    if (this.isGetRowHeightFunction()) {
      if (allowEstimate) {
        return { height: defaultRowHeight, estimated: true };
      }
      const params = {
        node: rowNode,
        data: rowNode.data
      };
      const height = this.getCallback("getRowHeight")(params);
      if (this.isNumeric(height)) {
        if (height === 0) {
          doOnce(() => console.warn("AG Grid: The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead."), "invalidRowHeight");
        }
        return { height: Math.max(1, height), estimated: false };
      }
    }
    if (rowNode.detail && this.is("masterDetail")) {
      return this.getMasterDetailRowHeight();
    }
    const rowHeight = this.gridOptions.rowHeight && this.isNumeric(this.gridOptions.rowHeight) ? this.gridOptions.rowHeight : defaultRowHeight;
    return { height: rowHeight, estimated: false };
  }
  getMasterDetailRowHeight() {
    if (this.is("detailRowAutoHeight")) {
      return { height: 1, estimated: false };
    }
    if (this.isNumeric(this.gridOptions.detailRowHeight)) {
      return { height: this.gridOptions.detailRowHeight, estimated: false };
    }
    return { height: 300, estimated: false };
  }
  getRowHeightAsNumber() {
    if (!this.gridOptions.rowHeight || missing(this.gridOptions.rowHeight)) {
      return this.environment.getDefaultRowHeight();
    }
    const rowHeight = this.gridOptions.rowHeight;
    if (rowHeight && this.isNumeric(rowHeight)) {
      this.environment.setRowHeightVariable(rowHeight);
      return rowHeight;
    }
    console.warn("AG Grid row height must be a number if not using standard row model");
    return this.environment.getDefaultRowHeight();
  }
  isNumeric(value) {
    return !isNaN(value) && typeof value === "number" && isFinite(value);
  }
  getDomDataKey() {
    return this.domDataKey;
  }
  getDomData(element, key) {
    const domData = element[this.getDomDataKey()];
    return domData ? domData[key] : void 0;
  }
  setDomData(element, key, value) {
    const domDataKey = this.getDomDataKey();
    let domData = element[domDataKey];
    if (missing(domData)) {
      domData = {};
      element[domDataKey] = domData;
    }
    domData[key] = value;
  }
  getDocument() {
    let result = null;
    if (this.gridOptions.getDocument && exists(this.gridOptions.getDocument)) {
      result = this.gridOptions.getDocument();
    } else if (this.eGridDiv) {
      result = this.eGridDiv.ownerDocument;
    }
    if (result && exists(result)) {
      return result;
    }
    return document;
  }
  getWindow() {
    const eDocument = this.getDocument();
    return eDocument.defaultView || window;
  }
  getRootNode() {
    return this.eGridDiv.getRootNode();
  }
  getAsyncTransactionWaitMillis() {
    return exists(this.gridOptions.asyncTransactionWaitMillis) ? this.gridOptions.asyncTransactionWaitMillis : 50;
  }
  isAnimateRows() {
    if (this.is("ensureDomOrder")) {
      return false;
    }
    return this.is("animateRows");
  }
  isGroupRowsSticky() {
    if (this.is("suppressGroupRowsSticky") || this.is("paginateChildRows") || this.is("groupHideOpenParents")) {
      return false;
    }
    return true;
  }
  isTreeData() {
    return this.is("treeData") && ModuleRegistry.assertRegistered(ModuleNames.RowGroupingModule, "Tree Data", this.api.getGridId());
  }
  isMasterDetail() {
    return this.is("masterDetail") && ModuleRegistry.assertRegistered(ModuleNames.MasterDetailModule, "masterDetail", this.api.getGridId());
  }
  isEnableRangeSelection() {
    return this.is("enableRangeSelection") && ModuleRegistry.isRegistered(ModuleNames.RangeSelectionModule, this.api.getGridId());
  }
  isColumnsSortingCoupledToGroup() {
    const autoGroupColumnDef = this.gridOptions.autoGroupColumnDef;
    const isClientSideRowModel = this.isRowModelType("clientSide");
    return isClientSideRowModel && !(autoGroupColumnDef === null || autoGroupColumnDef === void 0 ? void 0 : autoGroupColumnDef.comparator) && !this.isTreeData();
  }
  getGroupAggFiltering() {
    const userValue = this.gridOptions.groupAggFiltering;
    if (typeof userValue === "function") {
      return this.getCallback("groupAggFiltering");
    }
    if (isTrue(userValue)) {
      return () => true;
    }
    return void 0;
  }
  isGroupMultiAutoColumn() {
    if (this.gridOptions.groupDisplayType) {
      return matchesGroupDisplayType("multipleColumns", this.gridOptions.groupDisplayType);
    }
    return this.is("groupHideOpenParents");
  }
  isGroupUseEntireRow(pivotMode) {
    if (pivotMode) {
      return false;
    }
    return this.gridOptions.groupDisplayType ? matchesGroupDisplayType("groupRows", this.gridOptions.groupDisplayType) : false;
  }
};
__decorate$g([
  Autowired("gridOptions")
], GridOptionsService.prototype, "gridOptions", void 0);
__decorate$g([
  Autowired("eventService")
], GridOptionsService.prototype, "eventService", void 0);
__decorate$g([
  Autowired("environment")
], GridOptionsService.prototype, "environment", void 0);
__decorate$g([
  Autowired("eGridDiv")
], GridOptionsService.prototype, "eGridDiv", void 0);
__decorate$g([
  __param$1(0, Qualifier("gridApi")),
  __param$1(1, Qualifier("columnApi"))
], GridOptionsService.prototype, "agWire", null);
__decorate$g([
  PostConstruct
], GridOptionsService.prototype, "init", null);
__decorate$g([
  PreDestroy
], GridOptionsService.prototype, "destroy", null);
GridOptionsService = __decorate$g([
  Bean("gridOptionsService")
], GridOptionsService);
var __decorate$f = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LocaleService = class LocaleService2 extends BeanStub {
  getLocaleTextFunc() {
    const getLocaleText = this.gridOptionsService.getCallback("getLocaleText");
    if (getLocaleText) {
      return (key, defaultValue, variableValues) => {
        const params = {
          key,
          defaultValue,
          variableValues
        };
        return getLocaleText(params);
      };
    }
    const localeText = this.gridOptionsService.get("localeText");
    return (key, defaultValue, variableValues) => {
      let localisedText = localeText && localeText[key];
      if (localisedText && variableValues && variableValues.length) {
        let found = 0;
        while (true) {
          if (found >= variableValues.length) {
            break;
          }
          const idx = localisedText.indexOf("${variable}");
          if (idx === -1) {
            break;
          }
          localisedText = localisedText.replace("${variable}", variableValues[found++]);
        }
      }
      return localisedText !== null && localisedText !== void 0 ? localisedText : defaultValue;
    };
  }
};
LocaleService = __decorate$f([
  Bean("localeService")
], LocaleService);
var __decorate$e = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FakeVScrollComp = class extends AbstractFakeScrollComp {
  constructor() {
    super(FakeVScrollComp.TEMPLATE, "vertical");
  }
  postConstruct() {
    super.postConstruct();
    this.createManagedBean(new SetHeightFeature(this.eContainer));
    this.ctrlsService.registerFakeVScrollComp(this);
    this.addManagedListener(this.eventService, Events.EVENT_ROW_CONTAINER_HEIGHT_CHANGED, this.onRowContainerHeightChanged.bind(this));
  }
  setScrollVisible() {
    const vScrollShowing = this.scrollVisibleService.isVerticalScrollShowing();
    const invisibleScrollbar2 = this.invisibleScrollbar;
    const scrollbarWidth = vScrollShowing ? this.gridOptionsService.getScrollbarWidth() || 0 : 0;
    const adjustedScrollbarWidth = scrollbarWidth === 0 && invisibleScrollbar2 ? 16 : scrollbarWidth;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", invisibleScrollbar2);
    setFixedWidth(this.getGui(), adjustedScrollbarWidth);
    setFixedWidth(this.eViewport, adjustedScrollbarWidth);
    setFixedWidth(this.eContainer, adjustedScrollbarWidth);
    this.setDisplayed(vScrollShowing, { skipAriaHidden: true });
  }
  onRowContainerHeightChanged() {
    const gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
    const gridBodyViewportEl = gridBodyCtrl.getBodyViewportElement();
    if (this.eViewport.scrollTop != gridBodyViewportEl.scrollTop) {
      this.eViewport.scrollTop = gridBodyViewportEl.scrollTop;
    }
  }
};
FakeVScrollComp.TEMPLATE = `<div class="ag-body-vertical-scroll" aria-hidden="true">
            <div class="ag-body-vertical-scroll-viewport" ref="eViewport">
                <div class="ag-body-vertical-scroll-container" ref="eContainer"></div>
            </div>
        </div>`;
__decorate$e([
  PostConstruct
], FakeVScrollComp.prototype, "postConstruct", null);
var __decorate$d = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var MONTH_LOCALE_TEXT = {
  january: "January",
  february: "February",
  march: "March",
  april: "April",
  may: "May",
  june: "June",
  july: "July",
  august: "August",
  september: "September",
  october: "October",
  november: "November",
  december: "December"
};
var MONTH_KEYS = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
var DataTypeService = class DataTypeService2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.dataTypeDefinitions = {};
    this.isWaitingForRowData = false;
  }
  init() {
    this.groupHideOpenParents = this.gridOptionsService.is("groupHideOpenParents");
    this.addManagedPropertyListener("groupHideOpenParents", () => {
      this.groupHideOpenParents = this.gridOptionsService.is("groupHideOpenParents");
    });
    this.processDataTypeDefinitions();
    this.addManagedPropertyListener("dataTypeDefinitions", () => {
      this.processDataTypeDefinitions();
      this.columnModel.recreateColumnDefs("gridOptionsChanged");
    });
  }
  processDataTypeDefinitions() {
    var _a;
    const defaultDataTypes = this.getDefaultDataTypes();
    this.dataTypeDefinitions = {};
    Object.entries(defaultDataTypes).forEach(([cellDataType, dataTypeDefinition]) => {
      this.dataTypeDefinitions[cellDataType] = Object.assign(Object.assign({}, dataTypeDefinition), { groupSafeValueFormatter: this.createGroupSafeValueFormatter(dataTypeDefinition) });
    });
    const dataTypeDefinitions = (_a = this.gridOptionsService.get("dataTypeDefinitions")) !== null && _a !== void 0 ? _a : {};
    this.dataTypeMatchers = {};
    Object.entries(dataTypeDefinitions).forEach(([cellDataType, dataTypeDefinition]) => {
      const mergedDataTypeDefinition = this.processDataTypeDefinition(dataTypeDefinition, dataTypeDefinitions, [cellDataType], defaultDataTypes);
      if (mergedDataTypeDefinition) {
        this.dataTypeDefinitions[cellDataType] = mergedDataTypeDefinition;
        if (dataTypeDefinition.dataTypeMatcher) {
          this.dataTypeMatchers[cellDataType] = dataTypeDefinition.dataTypeMatcher;
        }
      }
    });
    this.checkObjectValueHandlers(defaultDataTypes);
    ["dateString", "text", "number", "boolean", "date"].forEach((cellDataType) => {
      const overriddenDataTypeMatcher = this.dataTypeMatchers[cellDataType];
      if (overriddenDataTypeMatcher) {
        delete this.dataTypeMatchers[cellDataType];
      }
      this.dataTypeMatchers[cellDataType] = overriddenDataTypeMatcher !== null && overriddenDataTypeMatcher !== void 0 ? overriddenDataTypeMatcher : defaultDataTypes[cellDataType].dataTypeMatcher;
    });
  }
  mergeDataTypeDefinitions(parentDataTypeDefinition, childDataTypeDefinition) {
    const mergedDataTypeDefinition = Object.assign(Object.assign({}, parentDataTypeDefinition), childDataTypeDefinition);
    if (parentDataTypeDefinition.columnTypes && childDataTypeDefinition.columnTypes && childDataTypeDefinition.appendColumnTypes) {
      mergedDataTypeDefinition.columnTypes = [
        ...this.convertColumnTypes(parentDataTypeDefinition.columnTypes),
        ...this.convertColumnTypes(childDataTypeDefinition.columnTypes)
      ];
    }
    return mergedDataTypeDefinition;
  }
  processDataTypeDefinition(dataTypeDefinition, dataTypeDefinitions, alreadyProcessedDataTypes, defaultDataTypes) {
    let mergedDataTypeDefinition;
    const extendsCellDataType = dataTypeDefinition.extendsDataType;
    if (dataTypeDefinition.extendsDataType === dataTypeDefinition.baseDataType) {
      const baseDataTypeDefinition = defaultDataTypes[extendsCellDataType];
      if (!this.validateDataTypeDefinition(dataTypeDefinition, baseDataTypeDefinition, extendsCellDataType)) {
        return void 0;
      }
      mergedDataTypeDefinition = this.mergeDataTypeDefinitions(baseDataTypeDefinition, dataTypeDefinition);
    } else {
      if (alreadyProcessedDataTypes.includes(extendsCellDataType)) {
        doOnce(() => console.warn('AG Grid: Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.'), "dataTypeExtendsCircularRef");
        return void 0;
      }
      const extendedDataTypeDefinition = dataTypeDefinitions[extendsCellDataType];
      if (!this.validateDataTypeDefinition(dataTypeDefinition, extendedDataTypeDefinition, extendsCellDataType)) {
        return void 0;
      }
      const mergedExtendedDataTypeDefinition = this.processDataTypeDefinition(extendedDataTypeDefinition, dataTypeDefinitions, [...alreadyProcessedDataTypes, extendsCellDataType], defaultDataTypes);
      if (!mergedExtendedDataTypeDefinition) {
        return void 0;
      }
      mergedDataTypeDefinition = this.mergeDataTypeDefinitions(mergedExtendedDataTypeDefinition, dataTypeDefinition);
    }
    return Object.assign(Object.assign({}, mergedDataTypeDefinition), { groupSafeValueFormatter: this.createGroupSafeValueFormatter(mergedDataTypeDefinition) });
  }
  validateDataTypeDefinition(dataTypeDefinition, parentDataTypeDefinition, parentCellDataType) {
    if (!parentDataTypeDefinition) {
      doOnce(() => console.warn(`AG Grid: The data type definition ${parentCellDataType} does not exist.`), "dataTypeDefMissing" + parentCellDataType);
      return false;
    }
    if (parentDataTypeDefinition.baseDataType !== dataTypeDefinition.baseDataType) {
      doOnce(() => console.warn('AG Grid: The "baseDataType" property of a data type definition must match that of its parent.'), "dataTypeBaseTypesMatch");
      return false;
    }
    return true;
  }
  createGroupSafeValueFormatter(dataTypeDefinition) {
    if (!dataTypeDefinition.valueFormatter) {
      return void 0;
    }
    return (params) => {
      var _a, _b;
      if ((_a = params.node) === null || _a === void 0 ? void 0 : _a.group) {
        const aggFunc = params.column.getAggFunc();
        if (aggFunc) {
          if (aggFunc === "first" || aggFunc === "last") {
            return dataTypeDefinition.valueFormatter(params);
          }
          if (dataTypeDefinition.baseDataType === "number" && aggFunc !== "count") {
            if (typeof params.value === "number") {
              return dataTypeDefinition.valueFormatter(params);
            }
            if (typeof params.value === "object") {
              if (!params.value) {
                return void 0;
              }
              if ("toNumber" in params.value) {
                return dataTypeDefinition.valueFormatter(Object.assign(Object.assign({}, params), { value: params.value.toNumber() }));
              }
              if ("value" in params.value) {
                return dataTypeDefinition.valueFormatter(Object.assign(Object.assign({}, params), { value: params.value.value }));
              }
            }
          }
        }
        return void 0;
      } else if (this.groupHideOpenParents && params.column.isRowGroupActive()) {
        if (typeof params.value !== "string" || ((_b = dataTypeDefinition.dataTypeMatcher) === null || _b === void 0 ? void 0 : _b.call(dataTypeDefinition, params.value))) {
          return dataTypeDefinition.valueFormatter(params);
        }
        return void 0;
      }
      return dataTypeDefinition.valueFormatter(params);
    };
  }
  updateColDefAndGetDataTypeDefinitionColumnType(colDef, userColDef, colId) {
    let { cellDataType } = userColDef;
    const { field } = userColDef;
    if (cellDataType === void 0) {
      cellDataType = colDef.cellDataType;
    }
    if (cellDataType == null || cellDataType === true) {
      cellDataType = this.canInferCellDataType(colDef, userColDef) ? this.inferCellDataType(field) : false;
    }
    if (!cellDataType) {
      colDef.cellDataType = false;
      return void 0;
    }
    const dataTypeDefinition = this.dataTypeDefinitions[cellDataType];
    if (!dataTypeDefinition) {
      doOnce(() => console.warn(`AG Grid: Missing data type definition - "${cellDataType}"`), "dataTypeMissing" + cellDataType);
      return void 0;
    }
    colDef.cellDataType = cellDataType;
    if (dataTypeDefinition.groupSafeValueFormatter) {
      colDef.valueFormatter = dataTypeDefinition.groupSafeValueFormatter;
    }
    if (dataTypeDefinition.valueParser) {
      colDef.valueParser = dataTypeDefinition.valueParser;
    }
    if (!dataTypeDefinition.suppressDefaultProperties) {
      this.setColDefPropertiesForBaseDataType(colDef, dataTypeDefinition, colId);
    }
    return dataTypeDefinition.columnTypes;
  }
  updateColDefAndGetColumnType(colDef, userColDef, colId) {
    var _a, _b;
    const dataTypeDefinitionColumnType = this.updateColDefAndGetDataTypeDefinitionColumnType(colDef, userColDef, colId);
    const columnTypes = (_b = (_a = userColDef.type) !== null && _a !== void 0 ? _a : dataTypeDefinitionColumnType) !== null && _b !== void 0 ? _b : colDef.type;
    return columnTypes ? this.convertColumnTypes(columnTypes) : void 0;
  }
  canInferCellDataType(colDef, userColDef) {
    var _a;
    if (this.rowModel.getType() !== "clientSide") {
      return false;
    }
    const propsToCheckForInference = { cellRenderer: true, valueGetter: true, valueParser: true, refData: true };
    if (this.doColDefPropsPreventInference(userColDef, propsToCheckForInference)) {
      return false;
    }
    const columnTypes = userColDef.type === null ? colDef.type : userColDef.type;
    if (columnTypes) {
      const columnTypeDefs = (_a = this.gridOptionsService.get("columnTypes")) !== null && _a !== void 0 ? _a : {};
      const hasPropsPreventingInference = this.convertColumnTypes(columnTypes).some((columnType) => {
        const columnTypeDef = columnTypeDefs[columnType.trim()];
        return columnTypeDef && this.doColDefPropsPreventInference(columnTypeDef, propsToCheckForInference);
      });
      if (hasPropsPreventingInference) {
        return false;
      }
    }
    return !this.doColDefPropsPreventInference(colDef, propsToCheckForInference);
  }
  doColDefPropsPreventInference(colDef, propsToCheckForInference) {
    return [
      ["cellRenderer", "agSparklineCellRenderer"],
      ["valueGetter", void 0],
      ["valueParser", void 0],
      ["refData", void 0]
    ].some(([prop, comparisonValue]) => this.doesColDefPropPreventInference(colDef, propsToCheckForInference, prop, comparisonValue));
  }
  doesColDefPropPreventInference(colDef, checkProps, prop, comparisonValue) {
    if (!checkProps[prop]) {
      return false;
    }
    const value = colDef[prop];
    if (value === null) {
      checkProps[prop] = false;
      return false;
    } else {
      return comparisonValue === void 0 ? !!value : value === comparisonValue;
    }
  }
  inferCellDataType(field) {
    var _a;
    if (!field) {
      return void 0;
    }
    const rowData = this.gridOptionsService.get("rowData");
    let value;
    const fieldContainsDots = field.indexOf(".") >= 0 && !this.gridOptionsService.is("suppressFieldDotNotation");
    if (rowData === null || rowData === void 0 ? void 0 : rowData.length) {
      value = getValueUsingField(rowData[0], field, fieldContainsDots);
    } else {
      const rowNodes = this.rowModel.getRootNode().allLeafChildren;
      if (rowNodes === null || rowNodes === void 0 ? void 0 : rowNodes.length) {
        value = getValueUsingField(rowNodes[0].data, field, fieldContainsDots);
      } else {
        this.initWaitForRowData();
      }
    }
    if (value == null) {
      return void 0;
    }
    const [cellDataType] = (_a = Object.entries(this.dataTypeMatchers).find(([_cellDataType, dataTypeMatcher]) => dataTypeMatcher(value))) !== null && _a !== void 0 ? _a : ["object"];
    return cellDataType;
  }
  initWaitForRowData() {
    if (this.isWaitingForRowData) {
      return;
    }
    this.isWaitingForRowData = true;
    const destroyFunc = this.addManagedListener(this.eventService, Events.EVENT_ROW_DATA_UPDATED, () => {
      destroyFunc === null || destroyFunc === void 0 ? void 0 : destroyFunc();
      this.isWaitingForRowData = false;
      setTimeout(() => {
        this.columnModel.recreateColumnDefs("rowDataUpdated");
      });
    });
  }
  checkObjectValueHandlers(defaultDataTypes) {
    const resolvedObjectDataTypeDefinition = this.dataTypeDefinitions.object;
    const defaultObjectDataTypeDefinition = defaultDataTypes.object;
    this.hasObjectValueParser = resolvedObjectDataTypeDefinition.valueParser !== defaultObjectDataTypeDefinition.valueParser;
    this.hasObjectValueFormatter = resolvedObjectDataTypeDefinition.valueFormatter !== defaultObjectDataTypeDefinition.valueFormatter;
  }
  convertColumnTypes(type) {
    let typeKeys = [];
    if (type instanceof Array) {
      const invalidArray = type.some((a) => typeof a !== "string");
      if (invalidArray) {
        console.warn("AG Grid: if colDef.type is supplied an array it should be of type 'string[]'");
      } else {
        typeKeys = type;
      }
    } else if (typeof type === "string") {
      typeKeys = type.split(",");
    } else {
      console.warn("AG Grid: colDef.type should be of type 'string' | 'string[]'");
    }
    return typeKeys;
  }
  getDateStringTypeDefinition() {
    return this.dataTypeDefinitions.dateString;
  }
  getDateParserFunction() {
    return this.getDateStringTypeDefinition().dateParser;
  }
  getDateFormatterFunction() {
    return this.getDateStringTypeDefinition().dateFormatter;
  }
  checkType(column, value) {
    var _a;
    const colDef = column.getColDef();
    if (!colDef.cellDataType || value == null) {
      return true;
    }
    const dataTypeMatcher = (_a = this.dataTypeDefinitions[colDef.cellDataType]) === null || _a === void 0 ? void 0 : _a.dataTypeMatcher;
    if (!dataTypeMatcher) {
      return true;
    }
    return dataTypeMatcher(value);
  }
  validateColDef(colDef) {
    if (colDef.cellDataType === "object") {
      if (colDef.valueFormatter === this.dataTypeDefinitions.object.groupSafeValueFormatter && !this.hasObjectValueFormatter) {
        doOnce(() => console.warn('AG Grid: Cell data type is "object" but no value formatter has been provided. Please either provide an object data type definition with a value formatter, or set "colDef.valueFormatter"'), "dataTypeObjectValueFormatter");
      }
      if (colDef.editable && colDef.valueParser === this.dataTypeDefinitions.object.valueParser && !this.hasObjectValueParser) {
        doOnce(() => console.warn('AG Grid: Cell data type is "object" but no value parser has been provided. Please either provide an object data type definition with a value parser, or set "colDef.valueParser"'), "dataTypeObjectValueParser");
      }
    }
  }
  setColDefPropertiesForBaseDataType(colDef, dataTypeDefinition, colId) {
    const formatValue = (column, node, value) => {
      let valueFormatter = column.getColDef().valueFormatter;
      if (valueFormatter === dataTypeDefinition.groupSafeValueFormatter) {
        valueFormatter = dataTypeDefinition.valueFormatter;
      }
      return this.valueFormatterService.formatValue(column, node, value, valueFormatter);
    };
    const usingSetFilter = ModuleRegistry.isRegistered(ModuleNames.SetFilterModule, this.context.getGridId());
    const translate = this.localeService.getLocaleTextFunc();
    colDef.useValueFormatterForExport = true;
    colDef.useValueParserForImport = true;
    switch (dataTypeDefinition.baseDataType) {
      case "number": {
        colDef.cellEditor = "agNumberCellEditor";
        if (usingSetFilter) {
          colDef.filterParams = {
            comparator: (a, b) => {
              const valA = a == null ? 0 : parseInt(a);
              const valB = b == null ? 0 : parseInt(b);
              if (valA === valB)
                return 0;
              return valA > valB ? 1 : -1;
            }
          };
        }
        break;
      }
      case "boolean": {
        colDef.cellEditor = "agCheckboxCellEditor";
        colDef.cellRenderer = "agCheckboxCellRenderer";
        colDef.suppressKeyboardEvent = (params) => !!params.colDef.editable && params.event.key === KeyCode.SPACE;
        if (usingSetFilter) {
          colDef.filterParams = {
            valueFormatter: (params) => {
              if (!exists(params.value)) {
                return translate("blanks", "(Blanks)");
              }
              return translate(String(params.value), params.value ? "True" : "False");
            }
          };
        } else {
          colDef.filterParams = {
            maxNumConditions: 1,
            filterOptions: [
              "empty",
              {
                displayKey: "true",
                displayName: "True",
                predicate: (_filterValues, cellValue) => cellValue,
                numberOfInputs: 0
              },
              {
                displayKey: "false",
                displayName: "False",
                predicate: (_filterValues, cellValue) => cellValue === false,
                numberOfInputs: 0
              }
            ]
          };
        }
        break;
      }
      case "date": {
        colDef.cellEditor = "agDateCellEditor";
        colDef.keyCreator = (params) => formatValue(params.column, params.node, params.value);
        if (usingSetFilter) {
          colDef.filterParams = {
            valueFormatter: (params) => {
              const valueFormatted = formatValue(params.column, params.node, params.value);
              return exists(valueFormatted) ? valueFormatted : translate("blanks", "(Blanks)");
            },
            treeList: true,
            treeListFormatter: (pathKey, level) => {
              if (level === 1 && pathKey != null) {
                const monthKey = MONTH_KEYS[Number(pathKey) - 1];
                return translate(monthKey, MONTH_LOCALE_TEXT[monthKey]);
              }
              return pathKey !== null && pathKey !== void 0 ? pathKey : translate("blanks", "(Blanks)");
            }
          };
        }
        break;
      }
      case "dateString": {
        colDef.cellEditor = "agDateStringCellEditor";
        colDef.keyCreator = (params) => formatValue(params.column, params.node, params.value);
        const convertToDate = this.getDateParserFunction();
        if (usingSetFilter) {
          colDef.filterParams = {
            valueFormatter: (params) => {
              const valueFormatted = formatValue(params.column, params.node, params.value);
              return exists(valueFormatted) ? valueFormatted : translate("blanks", "(Blanks)");
            },
            treeList: true,
            treeListPathGetter: (value) => {
              const date = convertToDate(value !== null && value !== void 0 ? value : void 0);
              return date ? [String(date.getFullYear()), String(date.getMonth() + 1), String(date.getDate())] : null;
            },
            treeListFormatter: (pathKey, level) => {
              if (level === 1 && pathKey != null) {
                const monthKey = MONTH_KEYS[Number(pathKey) - 1];
                return translate(monthKey, MONTH_LOCALE_TEXT[monthKey]);
              }
              return pathKey !== null && pathKey !== void 0 ? pathKey : translate("blanks", "(Blanks)");
            }
          };
        } else {
          colDef.filterParams = {
            comparator: (filterDate, cellValue) => {
              const cellAsDate = convertToDate(cellValue);
              if (cellValue == null || cellAsDate < filterDate) {
                return -1;
              }
              if (cellAsDate > filterDate) {
                return 1;
              }
              return 0;
            }
          };
        }
        break;
      }
      case "object": {
        colDef.cellEditorParams = {
          useFormatter: true
        };
        colDef.comparator = (a, b) => {
          const column = this.columnModel.getPrimaryColumn(colId);
          const colDef2 = column === null || column === void 0 ? void 0 : column.getColDef();
          if (!column || !colDef2) {
            return 0;
          }
          const valA = a == null ? "" : formatValue(column, null, a);
          const valB = b == null ? "" : formatValue(column, null, b);
          if (valA === valB)
            return 0;
          return valA > valB ? 1 : -1;
        };
        colDef.keyCreator = (params) => formatValue(params.column, params.node, params.value);
        if (usingSetFilter) {
          colDef.filterParams = {
            valueFormatter: (params) => {
              const valueFormatted = formatValue(params.column, params.node, params.value);
              return exists(valueFormatted) ? valueFormatted : translate("blanks", "(Blanks)");
            }
          };
        } else {
          colDef.filterValueGetter = (params) => formatValue(params.column, params.node, this.valueService.getValue(params.column, params.node));
        }
        break;
      }
    }
  }
  getDefaultDataTypes() {
    const defaultDateFormatMatcher = (value) => !!value.match("\\d{4}-\\d{2}-\\d{2}");
    const translate = this.localeService.getLocaleTextFunc();
    return {
      number: {
        baseDataType: "number",
        valueParser: (params) => params.newValue === "" ? null : Number(params.newValue),
        valueFormatter: (params) => {
          if (params.value == null) {
            return "";
          }
          if (typeof params.value !== "number" || isNaN(params.value)) {
            return translate("invalidNumber", "Invalid Number");
          }
          return String(params.value);
        },
        dataTypeMatcher: (value) => typeof value === "number"
      },
      text: {
        baseDataType: "text",
        valueParser: (params) => params.newValue === "" ? null : toStringOrNull(params.newValue),
        dataTypeMatcher: (value) => typeof value === "string"
      },
      boolean: {
        baseDataType: "boolean",
        valueParser: (params) => params.newValue === "" ? null : String(params.newValue).toLowerCase() === "true",
        valueFormatter: (params) => params.value == null ? "" : String(params.value),
        dataTypeMatcher: (value) => typeof value === "boolean"
      },
      date: {
        baseDataType: "date",
        valueParser: (params) => parseDateTimeFromString(params.newValue == null ? null : String(params.newValue)),
        valueFormatter: (params) => {
          var _a;
          if (params.value == null) {
            return "";
          }
          if (!(params.value instanceof Date) || isNaN(params.value.getTime())) {
            return translate("invalidDate", "Invalid Date");
          }
          return (_a = serialiseDate(params.value, false)) !== null && _a !== void 0 ? _a : "";
        },
        dataTypeMatcher: (value) => value instanceof Date
      },
      dateString: {
        baseDataType: "dateString",
        dateParser: (value) => {
          var _a;
          return (_a = parseDateTimeFromString(value)) !== null && _a !== void 0 ? _a : void 0;
        },
        dateFormatter: (value) => {
          var _a;
          return (_a = serialiseDate(value !== null && value !== void 0 ? value : null, false)) !== null && _a !== void 0 ? _a : void 0;
        },
        valueParser: (params) => defaultDateFormatMatcher(String(params.newValue)) ? params.newValue : null,
        valueFormatter: (params) => defaultDateFormatMatcher(String(params.value)) ? params.value : "",
        dataTypeMatcher: (value) => typeof value === "string" && defaultDateFormatMatcher(value)
      },
      object: {
        baseDataType: "object",
        valueParser: () => null,
        valueFormatter: (params) => {
          var _a;
          return (_a = toStringOrNull(params.value)) !== null && _a !== void 0 ? _a : "";
        }
      }
    };
  }
};
__decorate$d([
  Autowired("rowModel")
], DataTypeService.prototype, "rowModel", void 0);
__decorate$d([
  Autowired("columnModel")
], DataTypeService.prototype, "columnModel", void 0);
__decorate$d([
  Autowired("valueService")
], DataTypeService.prototype, "valueService", void 0);
__decorate$d([
  Autowired("valueFormatterService")
], DataTypeService.prototype, "valueFormatterService", void 0);
__decorate$d([
  PostConstruct
], DataTypeService.prototype, "init", null);
DataTypeService = __decorate$d([
  Bean("dataTypeService")
], DataTypeService);
var __decorate$c = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ValueParserService = class ValueParserService2 extends BeanStub {
  parseValue(column, rowNode, newValue, oldValue) {
    const colDef = column.getColDef();
    const params = {
      node: rowNode,
      data: rowNode === null || rowNode === void 0 ? void 0 : rowNode.data,
      oldValue,
      newValue,
      colDef,
      column,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    };
    const valueParser = colDef.valueParser;
    if (exists(valueParser)) {
      if (typeof valueParser === "function") {
        return valueParser(params);
      }
      return this.expressionService.evaluate(valueParser, params);
    }
    return newValue;
  }
};
__decorate$c([
  Autowired("expressionService")
], ValueParserService.prototype, "expressionService", void 0);
ValueParserService = __decorate$c([
  Bean("valueParserService")
], ValueParserService);
var Grid = class {
  constructor(eGridDiv, gridOptions, params) {
    if (!gridOptions) {
      console.error("AG Grid: no gridOptions provided to the grid");
      return;
    }
    this.gridOptions = gridOptions;
    new GridCoreCreator().create(eGridDiv, gridOptions, (context) => {
      const gridComp = new GridComp(eGridDiv);
      context.createBean(gridComp);
    }, void 0, params);
  }
  destroy() {
    if (this.gridOptions && this.gridOptions.api) {
      this.gridOptions.api.destroy();
    }
  }
};
var nextGridId = 1;
var GridCoreCreator = class {
  create(eGridDiv, gridOptions, createUi, acceptChanges, params) {
    var _a;
    const debug = !!gridOptions.debug;
    const gridId = (_a = gridOptions.gridId) !== null && _a !== void 0 ? _a : String(nextGridId++);
    const registeredModules = this.getRegisteredModules(params, gridId);
    const beanClasses = this.createBeansList(gridOptions.rowModelType, registeredModules, gridId);
    const providedBeanInstances = this.createProvidedBeans(eGridDiv, gridOptions, params);
    if (!beanClasses) {
      return;
    }
    const contextParams = {
      providedBeanInstances,
      beanClasses,
      debug,
      gridId
    };
    const logger = new Logger("AG Grid", () => gridOptions.debug);
    const contextLogger = new Logger("Context", () => contextParams.debug);
    const context = new Context(contextParams, contextLogger);
    const beans = context.getBean("beans");
    this.registerModuleUserComponents(beans, registeredModules);
    this.registerStackComponents(beans, registeredModules);
    this.registerControllers(beans, registeredModules);
    createUi(context);
    beans.ctrlsService.whenReady(() => {
      this.setColumnsAndData(beans);
      this.dispatchGridReadyEvent(beans);
      const isEnterprise = ModuleRegistry.isRegistered(ModuleNames.EnterpriseCoreModule, gridId);
      logger.log(`initialised successfully, enterprise = ${isEnterprise}`);
    });
    if (acceptChanges) {
      acceptChanges(context);
    }
  }
  registerControllers(beans, registeredModules) {
    registeredModules.forEach((module) => {
      if (module.controllers) {
        module.controllers.forEach((meta) => beans.ctrlsFactory.register(meta));
      }
    });
  }
  registerStackComponents(beans, registeredModules) {
    const agStackComponents = this.createAgStackComponentsList(registeredModules);
    beans.agStackComponentsRegistry.setupComponents(agStackComponents);
  }
  getRegisteredModules(params, gridId) {
    const passedViaConstructor = params ? params.modules : null;
    const registered = ModuleRegistry.getRegisteredModules(gridId);
    const allModules = [];
    const mapNames = {};
    const addModule = (moduleBased, mod, gridId2) => {
      const addIndividualModule = (currentModule) => {
        if (!mapNames[currentModule.moduleName]) {
          mapNames[currentModule.moduleName] = true;
          allModules.push(currentModule);
          ModuleRegistry.register(currentModule, moduleBased, gridId2);
        }
      };
      addIndividualModule(mod);
      if (mod.dependantModules) {
        mod.dependantModules.forEach((m) => addModule(moduleBased, m, gridId2));
      }
    };
    if (passedViaConstructor) {
      passedViaConstructor.forEach((m) => addModule(true, m, gridId));
    }
    if (registered) {
      registered.forEach((m) => addModule(!ModuleRegistry.isPackageBased(), m, void 0));
    }
    return allModules;
  }
  registerModuleUserComponents(beans, registeredModules) {
    const moduleUserComps = this.extractModuleEntity(registeredModules, (module) => module.userComponents ? module.userComponents : []);
    moduleUserComps.forEach((compMeta) => {
      beans.userComponentRegistry.registerDefaultComponent(compMeta.componentName, compMeta.componentClass);
    });
  }
  createProvidedBeans(eGridDiv, gridOptions, params) {
    let frameworkOverrides = params ? params.frameworkOverrides : null;
    if (missing(frameworkOverrides)) {
      frameworkOverrides = new VanillaFrameworkOverrides();
    }
    const seed = {
      gridOptions,
      eGridDiv,
      globalEventListener: params ? params.globalEventListener : null,
      frameworkOverrides
    };
    if (params && params.providedBeanInstances) {
      Object.assign(seed, params.providedBeanInstances);
    }
    return seed;
  }
  createAgStackComponentsList(registeredModules) {
    let components = [
      { componentName: "AgCheckbox", componentClass: AgCheckbox },
      { componentName: "AgRadioButton", componentClass: AgRadioButton },
      { componentName: "AgToggleButton", componentClass: AgToggleButton },
      { componentName: "AgInputTextField", componentClass: AgInputTextField },
      { componentName: "AgInputTextArea", componentClass: AgInputTextArea },
      { componentName: "AgInputNumberField", componentClass: AgInputNumberField },
      { componentName: "AgInputDateField", componentClass: AgInputDateField },
      { componentName: "AgInputRange", componentClass: AgInputRange },
      { componentName: "AgSelect", componentClass: AgSelect },
      { componentName: "AgSlider", componentClass: AgSlider },
      { componentName: "AgGridBody", componentClass: GridBodyComp },
      { componentName: "AgHeaderRoot", componentClass: GridHeaderComp },
      { componentName: "AgSortIndicator", componentClass: SortIndicatorComp },
      { componentName: "AgPagination", componentClass: PaginationComp },
      { componentName: "AgOverlayWrapper", componentClass: OverlayWrapperComponent },
      { componentName: "AgGroupComponent", componentClass: AgGroupComponent },
      { componentName: "AgPanel", componentClass: AgPanel },
      { componentName: "AgDialog", componentClass: AgDialog },
      { componentName: "AgRowContainer", componentClass: RowContainerComp },
      { componentName: "AgFakeHorizontalScroll", componentClass: FakeHScrollComp },
      { componentName: "AgFakeVerticalScroll", componentClass: FakeVScrollComp }
    ];
    const moduleAgStackComps = this.extractModuleEntity(registeredModules, (module) => module.agStackComponents ? module.agStackComponents : []);
    components = components.concat(moduleAgStackComps);
    return components;
  }
  createBeansList(rowModelType = "clientSide", registeredModules, gridId) {
    const rowModelModules = registeredModules.filter((module) => !module.rowModel || module.rowModel === rowModelType);
    const rowModelModuleNames = {
      clientSide: ModuleNames.ClientSideRowModelModule,
      infinite: ModuleNames.InfiniteRowModelModule,
      serverSide: ModuleNames.ServerSideRowModelModule,
      viewport: ModuleNames.ViewportRowModelModule
    };
    if (!rowModelModuleNames[rowModelType]) {
      console.error("AG Grid: could not find row model for rowModelType = " + rowModelType);
      return;
    }
    if (!ModuleRegistry.assertRegistered(rowModelModuleNames[rowModelType], `rowModelType = '${rowModelType}'`, gridId)) {
      return;
    }
    const beans = [
      Beans,
      RowPositionUtils,
      CellPositionUtils,
      HeaderPositionUtils,
      PaginationAutoPageSizeService,
      GridApi,
      UserComponentRegistry,
      AgComponentUtils,
      ComponentMetadataProvider,
      ResizeObserverService,
      UserComponentFactory,
      RowContainerHeightService,
      HorizontalResizeService,
      LocaleService,
      GridOptionsValidator,
      PinnedRowModel,
      DragService,
      DisplayedGroupCreator,
      EventService,
      GridOptionsService,
      PopupService,
      SelectionService,
      FilterManager,
      ColumnModel,
      HeaderNavigationService,
      PaginationProxy,
      RowRenderer,
      ExpressionService,
      ColumnFactory,
      TemplateService,
      AlignedGridsService,
      NavigationService,
      ValueCache,
      ValueService,
      LoggerFactory,
      ColumnUtils,
      AutoWidthCalculator,
      StandardMenuFactory,
      DragAndDropService,
      ColumnApi,
      FocusService,
      MouseEventService,
      Environment,
      CellNavigationService,
      ValueFormatterService,
      StylingService,
      ScrollVisibleService,
      SortController,
      ColumnHoverService,
      ColumnAnimationService,
      SelectableService,
      AutoGroupColService,
      ChangeDetectionService,
      AnimationFrameService,
      UndoRedoService,
      AgStackComponentsRegistry,
      ColumnDefFactory,
      RowCssClassCalculator,
      RowNodeBlockLoader,
      RowNodeSorter,
      CtrlsService,
      PinnedWidthService,
      RowNodeEventThrottle,
      CtrlsFactory,
      DataTypeService,
      ValueParserService
    ];
    const moduleBeans = this.extractModuleEntity(rowModelModules, (module) => module.beans ? module.beans : []);
    beans.push(...moduleBeans);
    const beansNoDuplicates = [];
    beans.forEach((bean) => {
      if (beansNoDuplicates.indexOf(bean) < 0) {
        beansNoDuplicates.push(bean);
      }
    });
    return beansNoDuplicates;
  }
  extractModuleEntity(moduleEntities, extractor) {
    return [].concat(...moduleEntities.map(extractor));
  }
  setColumnsAndData(beans) {
    const columnDefs = beans.gridOptionsService.get("columnDefs");
    beans.columnModel.setColumnDefs(columnDefs || [], "gridInitializing");
    beans.rowModel.start();
  }
  dispatchGridReadyEvent(beans) {
    const readyEvent = {
      type: Events.EVENT_GRID_READY
    };
    beans.eventService.dispatchEvent(readyEvent);
  }
};
var BaseComponentWrapper = class {
  wrap(OriginalConstructor, mandatoryMethodList, optionalMethodList = [], componentType) {
    const wrapper = this.createWrapper(OriginalConstructor, componentType);
    mandatoryMethodList.forEach((methodName) => {
      this.createMethod(wrapper, methodName, true);
    });
    optionalMethodList.forEach((methodName) => {
      this.createMethod(wrapper, methodName, false);
    });
    return wrapper;
  }
  unwrap(comp) {
    return comp;
  }
  createMethod(wrapper, methodName, mandatory) {
    wrapper.addMethod(methodName, this.createMethodProxy(wrapper, methodName, mandatory));
  }
  createMethodProxy(wrapper, methodName, mandatory) {
    return function() {
      if (wrapper.hasMethod(methodName)) {
        return wrapper.callMethod(methodName, arguments);
      }
      if (mandatory) {
        console.warn("AG Grid: Framework component is missing the method " + methodName + "()");
      }
      return null;
    };
  }
};
var BarColumnLabelPlacement;
(function(BarColumnLabelPlacement2) {
  BarColumnLabelPlacement2["InsideBase"] = "insideBase";
  BarColumnLabelPlacement2["InsideEnd"] = "insideEnd";
  BarColumnLabelPlacement2["Center"] = "center";
  BarColumnLabelPlacement2["OutsideEnd"] = "outsideEnd";
})(BarColumnLabelPlacement || (BarColumnLabelPlacement = {}));
var globalObj = typeof global === "undefined" ? {} : global;
globalObj.HTMLElement = typeof HTMLElement === "undefined" ? {} : HTMLElement;
globalObj.HTMLButtonElement = typeof HTMLButtonElement === "undefined" ? {} : HTMLButtonElement;
globalObj.HTMLSelectElement = typeof HTMLSelectElement === "undefined" ? {} : HTMLSelectElement;
globalObj.HTMLInputElement = typeof HTMLInputElement === "undefined" ? {} : HTMLInputElement;
globalObj.Node = typeof Node === "undefined" ? {} : Node;
globalObj.MouseEvent = typeof MouseEvent === "undefined" ? {} : MouseEvent;
var ClientSideNodeManager = class {
  constructor(rootNode, gridOptionsService, eventService, columnModel, selectionService, beans) {
    this.nextId = 0;
    this.allNodesMap = {};
    this.rootNode = rootNode;
    this.gridOptionsService = gridOptionsService;
    this.eventService = eventService;
    this.columnModel = columnModel;
    this.beans = beans;
    this.selectionService = selectionService;
    this.rootNode.group = true;
    this.rootNode.level = -1;
    this.rootNode.id = ClientSideNodeManager.ROOT_NODE_ID;
    this.rootNode.allLeafChildren = [];
    this.rootNode.childrenAfterGroup = [];
    this.rootNode.childrenAfterSort = [];
    this.rootNode.childrenAfterAggFilter = [];
    this.rootNode.childrenAfterFilter = [];
    this.postConstruct();
  }
  postConstruct() {
    this.suppressParentsInRowNodes = this.gridOptionsService.is("suppressParentsInRowNodes");
    this.isRowMasterFunc = this.gridOptionsService.get("isRowMaster");
    this.doingTreeData = this.gridOptionsService.isTreeData();
    this.doingMasterDetail = this.gridOptionsService.isMasterDetail();
  }
  getCopyOfNodesMap() {
    return _.cloneObject(this.allNodesMap);
  }
  getRowNode(id) {
    return this.allNodesMap[id];
  }
  setRowData(rowData) {
    if (typeof rowData === "string") {
      console.warn("AG Grid: rowData must be an array, however you passed in a string. If you are loading JSON, make sure you convert the JSON string to JavaScript objects first");
      return;
    }
    const rootNode = this.rootNode;
    const sibling = this.rootNode.sibling;
    rootNode.childrenAfterFilter = null;
    rootNode.childrenAfterGroup = null;
    rootNode.childrenAfterAggFilter = null;
    rootNode.childrenAfterSort = null;
    rootNode.childrenMapped = null;
    rootNode.updateHasChildren();
    this.nextId = 0;
    this.allNodesMap = {};
    if (rowData) {
      rootNode.allLeafChildren = rowData.map((dataItem) => this.createNode(dataItem, this.rootNode, ClientSideNodeManager.TOP_LEVEL));
    } else {
      rootNode.allLeafChildren = [];
      rootNode.childrenAfterGroup = [];
    }
    if (sibling) {
      sibling.childrenAfterFilter = rootNode.childrenAfterFilter;
      sibling.childrenAfterGroup = rootNode.childrenAfterGroup;
      sibling.childrenAfterAggFilter = rootNode.childrenAfterAggFilter;
      sibling.childrenAfterSort = rootNode.childrenAfterSort;
      sibling.childrenMapped = rootNode.childrenMapped;
      sibling.allLeafChildren = rootNode.allLeafChildren;
    }
  }
  updateRowData(rowDataTran, rowNodeOrder) {
    const rowNodeTransaction = {
      remove: [],
      update: [],
      add: []
    };
    const nodesToUnselect = [];
    this.executeRemove(rowDataTran, rowNodeTransaction, nodesToUnselect);
    this.executeUpdate(rowDataTran, rowNodeTransaction, nodesToUnselect);
    this.executeAdd(rowDataTran, rowNodeTransaction);
    this.updateSelection(nodesToUnselect, "rowDataChanged");
    if (rowNodeOrder) {
      _.sortRowNodesByOrder(this.rootNode.allLeafChildren, rowNodeOrder);
    }
    return rowNodeTransaction;
  }
  updateSelection(nodesToUnselect, source) {
    const selectionChanged = nodesToUnselect.length > 0;
    if (selectionChanged) {
      this.selectionService.setNodesSelected({
        newValue: false,
        nodes: nodesToUnselect,
        suppressFinishActions: true,
        source
      });
    }
    this.selectionService.updateGroupsFromChildrenSelections(source);
    if (selectionChanged) {
      const event = {
        type: Events.EVENT_SELECTION_CHANGED,
        source
      };
      this.eventService.dispatchEvent(event);
    }
  }
  executeAdd(rowDataTran, rowNodeTransaction) {
    var _a;
    const { add, addIndex } = rowDataTran;
    if (_.missingOrEmpty(add)) {
      return;
    }
    const newNodes = add.map((item) => this.createNode(item, this.rootNode, ClientSideNodeManager.TOP_LEVEL));
    if (typeof addIndex === "number" && addIndex >= 0) {
      const { allLeafChildren } = this.rootNode;
      const len = allLeafChildren.length;
      let normalisedAddIndex = addIndex;
      if (this.doingTreeData && addIndex > 0 && len > 0) {
        for (let i = 0; i < len; i++) {
          if (((_a = allLeafChildren[i]) === null || _a === void 0 ? void 0 : _a.rowIndex) == addIndex - 1) {
            normalisedAddIndex = i + 1;
            break;
          }
        }
      }
      const nodesBeforeIndex = allLeafChildren.slice(0, normalisedAddIndex);
      const nodesAfterIndex = allLeafChildren.slice(normalisedAddIndex, allLeafChildren.length);
      this.rootNode.allLeafChildren = [...nodesBeforeIndex, ...newNodes, ...nodesAfterIndex];
    } else {
      this.rootNode.allLeafChildren = [...this.rootNode.allLeafChildren, ...newNodes];
    }
    if (this.rootNode.sibling) {
      this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren;
    }
    rowNodeTransaction.add = newNodes;
  }
  executeRemove(rowDataTran, rowNodeTransaction, nodesToUnselect) {
    const { remove } = rowDataTran;
    if (_.missingOrEmpty(remove)) {
      return;
    }
    const rowIdsRemoved = {};
    remove.forEach((item) => {
      const rowNode = this.lookupRowNode(item);
      if (!rowNode) {
        return;
      }
      if (rowNode.isSelected()) {
        nodesToUnselect.push(rowNode);
      }
      rowNode.clearRowTopAndRowIndex();
      rowIdsRemoved[rowNode.id] = true;
      delete this.allNodesMap[rowNode.id];
      rowNodeTransaction.remove.push(rowNode);
    });
    this.rootNode.allLeafChildren = this.rootNode.allLeafChildren.filter((rowNode) => !rowIdsRemoved[rowNode.id]);
    if (this.rootNode.sibling) {
      this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren;
    }
  }
  executeUpdate(rowDataTran, rowNodeTransaction, nodesToUnselect) {
    const { update } = rowDataTran;
    if (_.missingOrEmpty(update)) {
      return;
    }
    update.forEach((item) => {
      const rowNode = this.lookupRowNode(item);
      if (!rowNode) {
        return;
      }
      rowNode.updateData(item);
      if (!rowNode.selectable && rowNode.isSelected()) {
        nodesToUnselect.push(rowNode);
      }
      this.setMasterForRow(rowNode, item, ClientSideNodeManager.TOP_LEVEL, false);
      rowNodeTransaction.update.push(rowNode);
    });
  }
  lookupRowNode(data) {
    const getRowIdFunc = this.gridOptionsService.getCallback("getRowId");
    let rowNode;
    if (getRowIdFunc) {
      const id = getRowIdFunc({ data, level: 0 });
      rowNode = this.allNodesMap[id];
      if (!rowNode) {
        console.error(`AG Grid: could not find row id=${id}, data item was not found for this id`);
        return null;
      }
    } else {
      rowNode = this.rootNode.allLeafChildren.find((node) => node.data === data);
      if (!rowNode) {
        console.error(`AG Grid: could not find data item as object was not found`, data);
        console.error(`Consider using getRowId to help the Grid find matching row data`);
        return null;
      }
    }
    return rowNode || null;
  }
  createNode(dataItem, parent, level) {
    const node = new RowNode(this.beans);
    node.group = false;
    this.setMasterForRow(node, dataItem, level, true);
    if (parent && !this.suppressParentsInRowNodes) {
      node.parent = parent;
    }
    node.level = level;
    node.setDataAndId(dataItem, this.nextId.toString());
    if (this.allNodesMap[node.id]) {
      console.warn(`AG Grid: duplicate node id '${node.id}' detected from getRowId callback, this could cause issues in your grid.`);
    }
    this.allNodesMap[node.id] = node;
    this.nextId++;
    return node;
  }
  setMasterForRow(rowNode, data, level, setExpanded) {
    if (this.doingTreeData) {
      rowNode.setMaster(false);
      if (setExpanded) {
        rowNode.expanded = false;
      }
    } else {
      if (this.doingMasterDetail) {
        if (this.isRowMasterFunc) {
          rowNode.setMaster(this.isRowMasterFunc(data));
        } else {
          rowNode.setMaster(true);
        }
      } else {
        rowNode.setMaster(false);
      }
      if (setExpanded) {
        const rowGroupColumns = this.columnModel.getRowGroupColumns();
        const numRowGroupColumns = rowGroupColumns ? rowGroupColumns.length : 0;
        const masterRowLevel = level + numRowGroupColumns;
        rowNode.expanded = rowNode.master ? this.isExpanded(masterRowLevel) : false;
      }
    }
  }
  isExpanded(level) {
    const expandByDefault = this.gridOptionsService.getNum("groupDefaultExpanded");
    if (expandByDefault === -1) {
      return true;
    }
    return level < expandByDefault;
  }
};
ClientSideNodeManager.TOP_LEVEL = 0;
ClientSideNodeManager.ROOT_NODE_ID = "ROOT_NODE_ID";
var __decorate$b = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RecursionType;
(function(RecursionType2) {
  RecursionType2[RecursionType2["Normal"] = 0] = "Normal";
  RecursionType2[RecursionType2["AfterFilter"] = 1] = "AfterFilter";
  RecursionType2[RecursionType2["AfterFilterAndSort"] = 2] = "AfterFilterAndSort";
  RecursionType2[RecursionType2["PivotNodes"] = 3] = "PivotNodes";
})(RecursionType || (RecursionType = {}));
var ClientSideRowModel = class ClientSideRowModel2 extends BeanStub {
  constructor() {
    super(...arguments);
    this.onRowHeightChanged_debounced = _.debounce(this.onRowHeightChanged.bind(this), 100);
    this.rowsToDisplay = [];
  }
  init() {
    const refreshEverythingFunc = this.refreshModel.bind(this, { step: ClientSideRowModelSteps.EVERYTHING });
    const animate = !this.gridOptionsService.is("suppressAnimationFrame");
    const refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {
      step: ClientSideRowModelSteps.EVERYTHING,
      afterColumnsChanged: true,
      keepRenderedRows: true,
      animate
    });
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refreshEverythingAfterColsChangedFunc);
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, refreshEverythingFunc);
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, { step: ClientSideRowModelSteps.PIVOT }));
    this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, refreshEverythingFunc);
    this.addManagedListener(this.eventService, Events.EVENT_GRID_STYLES_CHANGED, this.onGridStylesChanges.bind(this));
    const refreshMapListener = this.refreshModel.bind(this, {
      step: ClientSideRowModelSteps.MAP,
      keepRenderedRows: true,
      animate
    });
    this.addManagedPropertyListener("groupRemoveSingleChildren", refreshMapListener);
    this.addManagedPropertyListener("groupRemoveLowestSingleChildren", refreshMapListener);
    this.rootNode = new RowNode(this.beans);
    this.nodeManager = new ClientSideNodeManager(this.rootNode, this.gridOptionsService, this.eventService, this.columnModel, this.selectionService, this.beans);
  }
  start() {
    const rowData = this.gridOptionsService.get("rowData");
    if (rowData) {
      this.setRowData(rowData);
    }
  }
  ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) {
    let atLeastOneChange;
    let res = false;
    do {
      atLeastOneChange = false;
      const rowAtStartPixel = this.getRowIndexAtPixel(startPixel);
      const rowAtEndPixel = this.getRowIndexAtPixel(endPixel);
      const firstRow = Math.max(rowAtStartPixel, startLimitIndex);
      const lastRow = Math.min(rowAtEndPixel, endLimitIndex);
      for (let rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {
        const rowNode = this.getRow(rowIndex);
        if (rowNode.rowHeightEstimated) {
          const rowHeight = this.gridOptionsService.getRowHeightForNode(rowNode);
          rowNode.setRowHeight(rowHeight.height);
          atLeastOneChange = true;
          res = true;
        }
      }
      if (atLeastOneChange) {
        this.setRowTopAndRowIndex();
      }
    } while (atLeastOneChange);
    return res;
  }
  setRowTopAndRowIndex() {
    const defaultRowHeight = this.environment.getDefaultRowHeight();
    let nextRowTop = 0;
    const displayedRowsMapped = /* @__PURE__ */ new Set();
    const allowEstimate = this.gridOptionsService.isDomLayout("normal");
    for (let i = 0; i < this.rowsToDisplay.length; i++) {
      const rowNode = this.rowsToDisplay[i];
      if (rowNode.id != null) {
        displayedRowsMapped.add(rowNode.id);
      }
      if (rowNode.rowHeight == null) {
        const rowHeight = this.gridOptionsService.getRowHeightForNode(rowNode, allowEstimate, defaultRowHeight);
        rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);
      }
      rowNode.setRowTop(nextRowTop);
      rowNode.setRowIndex(i);
      nextRowTop += rowNode.rowHeight;
    }
    return displayedRowsMapped;
  }
  clearRowTopAndRowIndex(changedPath, displayedRowsMapped) {
    const changedPathActive = changedPath.isActive();
    const clearIfNotDisplayed = (rowNode) => {
      if (rowNode && rowNode.id != null && !displayedRowsMapped.has(rowNode.id)) {
        rowNode.clearRowTopAndRowIndex();
      }
    };
    const recurse = (rowNode) => {
      clearIfNotDisplayed(rowNode);
      clearIfNotDisplayed(rowNode.detailNode);
      clearIfNotDisplayed(rowNode.sibling);
      if (rowNode.hasChildren()) {
        if (rowNode.childrenAfterGroup) {
          const isRootNode = rowNode.level == -1;
          const skipChildren = changedPathActive && !isRootNode && !rowNode.expanded;
          if (!skipChildren) {
            rowNode.childrenAfterGroup.forEach(recurse);
          }
        }
      }
    };
    recurse(this.rootNode);
  }
  ensureRowsAtPixel(rowNodes, pixel, increment = 0) {
    const indexAtPixelNow = this.getRowIndexAtPixel(pixel);
    const rowNodeAtPixelNow = this.getRow(indexAtPixelNow);
    const animate = !this.gridOptionsService.is("suppressAnimationFrame");
    if (rowNodeAtPixelNow === rowNodes[0]) {
      return false;
    }
    rowNodes.forEach((rowNode) => {
      _.removeFromArray(this.rootNode.allLeafChildren, rowNode);
    });
    rowNodes.forEach((rowNode, idx) => {
      _.insertIntoArray(this.rootNode.allLeafChildren, rowNode, Math.max(indexAtPixelNow + increment, 0) + idx);
    });
    this.refreshModel({
      step: ClientSideRowModelSteps.EVERYTHING,
      keepRenderedRows: true,
      keepEditingRows: true,
      animate
    });
    return true;
  }
  highlightRowAtPixel(rowNode, pixel) {
    const indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;
    const rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;
    if (!rowNodeAtPixelNow || !rowNode || rowNodeAtPixelNow === rowNode || pixel == null) {
      if (this.lastHighlightedRow) {
        this.lastHighlightedRow.setHighlighted(null);
        this.lastHighlightedRow = null;
      }
      return;
    }
    const highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);
    if (this.lastHighlightedRow && this.lastHighlightedRow !== rowNodeAtPixelNow) {
      this.lastHighlightedRow.setHighlighted(null);
      this.lastHighlightedRow = null;
    }
    rowNodeAtPixelNow.setHighlighted(highlight);
    this.lastHighlightedRow = rowNodeAtPixelNow;
  }
  getHighlightPosition(pixel, rowNode) {
    if (!rowNode) {
      const index = this.getRowIndexAtPixel(pixel);
      rowNode = this.getRow(index || 0);
      if (!rowNode) {
        return RowHighlightPosition.Below;
      }
    }
    const { rowTop, rowHeight } = rowNode;
    return pixel - rowTop < rowHeight / 2 ? RowHighlightPosition.Above : RowHighlightPosition.Below;
  }
  getLastHighlightedRowNode() {
    return this.lastHighlightedRow;
  }
  isLastRowIndexKnown() {
    return true;
  }
  getRowCount() {
    if (this.rowsToDisplay) {
      return this.rowsToDisplay.length;
    }
    return 0;
  }
  getTopLevelRowCount() {
    const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;
    if (showingRootNode) {
      return 1;
    }
    const filteredChildren = this.rootNode.childrenAfterAggFilter;
    return filteredChildren ? filteredChildren.length : 0;
  }
  getTopLevelRowDisplayedIndex(topLevelIndex) {
    const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;
    if (showingRootNode) {
      return topLevelIndex;
    }
    let rowNode = this.rootNode.childrenAfterSort[topLevelIndex];
    if (this.gridOptionsService.is("groupHideOpenParents")) {
      while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {
        rowNode = rowNode.childrenAfterSort[0];
      }
    }
    return rowNode.rowIndex;
  }
  getRowBounds(index) {
    if (_.missing(this.rowsToDisplay)) {
      return null;
    }
    const rowNode = this.rowsToDisplay[index];
    if (rowNode) {
      return {
        rowTop: rowNode.rowTop,
        rowHeight: rowNode.rowHeight
      };
    }
    return null;
  }
  onRowGroupOpened() {
    const animate = this.gridOptionsService.isAnimateRows();
    this.refreshModel({ step: ClientSideRowModelSteps.MAP, keepRenderedRows: true, animate });
  }
  onFilterChanged(event) {
    if (event.afterDataChange) {
      return;
    }
    const animate = this.gridOptionsService.isAnimateRows();
    const primaryOrQuickFilterChanged = event.columns.length === 0 || event.columns.some((col) => col.isPrimary());
    const step = primaryOrQuickFilterChanged ? ClientSideRowModelSteps.FILTER : ClientSideRowModelSteps.FILTER_AGGREGATES;
    this.refreshModel({ step, keepRenderedRows: true, animate });
  }
  onSortChanged() {
    const animate = this.gridOptionsService.isAnimateRows();
    this.refreshModel({ step: ClientSideRowModelSteps.SORT, keepRenderedRows: true, animate, keepEditingRows: true });
  }
  getType() {
    return "clientSide";
  }
  onValueChanged() {
    if (this.columnModel.isPivotActive()) {
      this.refreshModel({ step: ClientSideRowModelSteps.PIVOT });
    } else {
      this.refreshModel({ step: ClientSideRowModelSteps.AGGREGATE });
    }
  }
  createChangePath(rowNodeTransactions) {
    const noTransactions = _.missingOrEmpty(rowNodeTransactions);
    const changedPath = new ChangedPath(false, this.rootNode);
    if (noTransactions || this.gridOptionsService.isTreeData()) {
      changedPath.setInactive();
    }
    return changedPath;
  }
  isSuppressModelUpdateAfterUpdateTransaction(params) {
    if (!this.gridOptionsService.is("suppressModelUpdateAfterUpdateTransaction")) {
      return false;
    }
    if (params.rowNodeTransactions == null) {
      return false;
    }
    const transWithAddsOrDeletes = params.rowNodeTransactions.filter((tx) => tx.add != null && tx.add.length > 0 || tx.remove != null && tx.remove.length > 0);
    const transactionsContainUpdatesOnly = transWithAddsOrDeletes == null || transWithAddsOrDeletes.length == 0;
    return transactionsContainUpdatesOnly;
  }
  buildRefreshModelParams(step) {
    let paramsStep = ClientSideRowModelSteps.EVERYTHING;
    const stepsMapped = {
      everything: ClientSideRowModelSteps.EVERYTHING,
      group: ClientSideRowModelSteps.EVERYTHING,
      filter: ClientSideRowModelSteps.FILTER,
      map: ClientSideRowModelSteps.MAP,
      aggregate: ClientSideRowModelSteps.AGGREGATE,
      sort: ClientSideRowModelSteps.SORT,
      pivot: ClientSideRowModelSteps.PIVOT
    };
    if (_.exists(step)) {
      paramsStep = stepsMapped[step];
    }
    if (_.missing(paramsStep)) {
      console.error(`AG Grid: invalid step ${step}, available steps are ${Object.keys(stepsMapped).join(", ")}`);
      return void 0;
    }
    const animate = !this.gridOptionsService.is("suppressAnimationFrame");
    const modelParams = {
      step: paramsStep,
      keepRenderedRows: true,
      keepEditingRows: true,
      animate
    };
    return modelParams;
  }
  refreshModel(paramsOrStep) {
    let params = typeof paramsOrStep === "object" && "step" in paramsOrStep ? paramsOrStep : this.buildRefreshModelParams(paramsOrStep);
    if (!params) {
      return;
    }
    if (this.isSuppressModelUpdateAfterUpdateTransaction(params)) {
      return;
    }
    const changedPath = this.createChangePath(params.rowNodeTransactions);
    switch (params.step) {
      case ClientSideRowModelSteps.EVERYTHING:
        this.doRowGrouping(params.groupState, params.rowNodeTransactions, params.rowNodeOrder, changedPath, !!params.afterColumnsChanged);
      case ClientSideRowModelSteps.FILTER:
        this.doFilter(changedPath);
      case ClientSideRowModelSteps.PIVOT:
        this.doPivot(changedPath);
      case ClientSideRowModelSteps.AGGREGATE:
        this.doAggregate(changedPath);
      case ClientSideRowModelSteps.FILTER_AGGREGATES:
        this.doFilterAggregates(changedPath);
      case ClientSideRowModelSteps.SORT:
        this.doSort(params.rowNodeTransactions, changedPath);
      case ClientSideRowModelSteps.MAP:
        this.doRowsToDisplay();
    }
    const displayedNodesMapped = this.setRowTopAndRowIndex();
    this.clearRowTopAndRowIndex(changedPath, displayedNodesMapped);
    const event = {
      type: Events.EVENT_MODEL_UPDATED,
      animate: params.animate,
      keepRenderedRows: params.keepRenderedRows,
      newData: params.newData,
      newPage: false,
      keepUndoRedoStack: params.keepUndoRedoStack
    };
    this.eventService.dispatchEvent(event);
  }
  isEmpty() {
    const rowsMissing = _.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;
    return _.missing(this.rootNode) || rowsMissing || !this.columnModel.isReady();
  }
  isRowsToRender() {
    return _.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;
  }
  getNodesInRangeForSelection(firstInRange, lastInRange) {
    let started = !lastInRange;
    let finished = false;
    const result = [];
    const groupsSelectChildren = this.gridOptionsService.is("groupSelectsChildren");
    this.forEachNodeAfterFilterAndSort((rowNode) => {
      if (finished) {
        return;
      }
      if (started) {
        if (rowNode === lastInRange || rowNode === firstInRange) {
          finished = true;
          if (rowNode.group && groupsSelectChildren) {
            result.push(...rowNode.allLeafChildren);
            return;
          }
        }
      }
      if (!started) {
        if (rowNode !== lastInRange && rowNode !== firstInRange) {
          return;
        }
        started = true;
      }
      const includeThisNode = !rowNode.group || !groupsSelectChildren;
      if (includeThisNode) {
        result.push(rowNode);
        return;
      }
    });
    return result;
  }
  setDatasource(datasource) {
    console.error("AG Grid: should never call setDatasource on clientSideRowController");
  }
  getTopLevelNodes() {
    return this.rootNode ? this.rootNode.childrenAfterGroup : null;
  }
  getRootNode() {
    return this.rootNode;
  }
  getRow(index) {
    return this.rowsToDisplay[index];
  }
  isRowPresent(rowNode) {
    return this.rowsToDisplay.indexOf(rowNode) >= 0;
  }
  getRowIndexAtPixel(pixelToMatch) {
    if (this.isEmpty() || this.rowsToDisplay.length === 0) {
      return -1;
    }
    let bottomPointer = 0;
    let topPointer = this.rowsToDisplay.length - 1;
    if (pixelToMatch <= 0) {
      return 0;
    }
    const lastNode = _.last(this.rowsToDisplay);
    if (lastNode.rowTop <= pixelToMatch) {
      return this.rowsToDisplay.length - 1;
    }
    let oldBottomPointer = -1;
    let oldTopPointer = -1;
    while (true) {
      const midPointer = Math.floor((bottomPointer + topPointer) / 2);
      const currentRowNode = this.rowsToDisplay[midPointer];
      if (this.isRowInPixel(currentRowNode, pixelToMatch)) {
        return midPointer;
      }
      if (currentRowNode.rowTop < pixelToMatch) {
        bottomPointer = midPointer + 1;
      } else if (currentRowNode.rowTop > pixelToMatch) {
        topPointer = midPointer - 1;
      }
      const caughtInInfiniteLoop = oldBottomPointer === bottomPointer && oldTopPointer === topPointer;
      if (caughtInInfiniteLoop) {
        return midPointer;
      }
      oldBottomPointer = bottomPointer;
      oldTopPointer = topPointer;
    }
  }
  isRowInPixel(rowNode, pixelToMatch) {
    const topPixel = rowNode.rowTop;
    const bottomPixel = rowNode.rowTop + rowNode.rowHeight;
    const pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;
    return pixelInRow;
  }
  forEachLeafNode(callback) {
    if (this.rootNode.allLeafChildren) {
      this.rootNode.allLeafChildren.forEach((rowNode, index) => callback(rowNode, index));
    }
  }
  forEachNode(callback, includeFooterNodes = false) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterGroup || []],
      callback,
      recursionType: RecursionType.Normal,
      index: 0,
      includeFooterNodes
    });
  }
  forEachNodeAfterFilter(callback, includeFooterNodes = false) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterAggFilter || []],
      callback,
      recursionType: RecursionType.AfterFilter,
      index: 0,
      includeFooterNodes
    });
  }
  forEachNodeAfterFilterAndSort(callback, includeFooterNodes = false) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterSort || []],
      callback,
      recursionType: RecursionType.AfterFilterAndSort,
      index: 0,
      includeFooterNodes
    });
  }
  forEachPivotNode(callback, includeFooterNodes = false) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [this.rootNode],
      callback,
      recursionType: RecursionType.PivotNodes,
      index: 0,
      includeFooterNodes
    });
  }
  recursivelyWalkNodesAndCallback(params) {
    var _a;
    const { nodes, callback, recursionType, includeFooterNodes } = params;
    let { index } = params;
    const firstNode = nodes[0];
    if (includeFooterNodes && ((_a = firstNode === null || firstNode === void 0 ? void 0 : firstNode.parent) === null || _a === void 0 ? void 0 : _a.sibling)) {
      nodes.push(firstNode.parent.sibling);
    }
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      callback(node, index++);
      if (node.hasChildren() && !node.footer) {
        let nodeChildren = null;
        switch (recursionType) {
          case RecursionType.Normal:
            nodeChildren = node.childrenAfterGroup;
            break;
          case RecursionType.AfterFilter:
            nodeChildren = node.childrenAfterAggFilter;
            break;
          case RecursionType.AfterFilterAndSort:
            nodeChildren = node.childrenAfterSort;
            break;
          case RecursionType.PivotNodes:
            nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;
            break;
        }
        if (nodeChildren) {
          index = this.recursivelyWalkNodesAndCallback({
            nodes: [...nodeChildren],
            callback,
            recursionType,
            index,
            includeFooterNodes
          });
        }
      }
    }
    return index;
  }
  doAggregate(changedPath) {
    if (this.aggregationStage) {
      this.aggregationStage.execute({ rowNode: this.rootNode, changedPath });
    }
  }
  doFilterAggregates(changedPath) {
    if (this.filterAggregatesStage) {
      this.filterAggregatesStage.execute({ rowNode: this.rootNode, changedPath });
    } else {
      this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter;
    }
  }
  expandOrCollapseAll(expand) {
    const usingTreeData = this.gridOptionsService.isTreeData();
    const usingPivotMode = this.columnModel.isPivotActive();
    const recursiveExpandOrCollapse = (rowNodes) => {
      if (!rowNodes) {
        return;
      }
      rowNodes.forEach((rowNode) => {
        const actionRow = () => {
          rowNode.expanded = expand;
          recursiveExpandOrCollapse(rowNode.childrenAfterGroup);
        };
        if (usingTreeData) {
          const hasChildren = _.exists(rowNode.childrenAfterGroup);
          if (hasChildren) {
            actionRow();
          }
          return;
        }
        if (usingPivotMode) {
          const notLeafGroup = !rowNode.leafGroup;
          if (notLeafGroup) {
            actionRow();
          }
          return;
        }
        const isRowGroup = rowNode.group;
        if (isRowGroup) {
          actionRow();
        }
      });
    };
    if (this.rootNode) {
      recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);
    }
    this.refreshModel({ step: ClientSideRowModelSteps.MAP });
    const eventSource = expand ? "expandAll" : "collapseAll";
    const event = {
      type: Events.EVENT_EXPAND_COLLAPSE_ALL,
      source: eventSource
    };
    this.eventService.dispatchEvent(event);
  }
  doSort(rowNodeTransactions, changedPath) {
    this.sortStage.execute({
      rowNode: this.rootNode,
      rowNodeTransactions,
      changedPath
    });
  }
  doRowGrouping(groupState, rowNodeTransactions, rowNodeOrder, changedPath, afterColumnsChanged) {
    if (this.groupStage) {
      if (rowNodeTransactions) {
        this.groupStage.execute({
          rowNode: this.rootNode,
          rowNodeTransactions,
          rowNodeOrder,
          changedPath
        });
      } else {
        this.groupStage.execute({
          rowNode: this.rootNode,
          changedPath,
          afterColumnsChanged
        });
        this.restoreGroupState(groupState);
      }
      if (this.gridOptionsService.is("groupSelectsChildren")) {
        const selectionChanged = this.selectionService.updateGroupsFromChildrenSelections("rowGroupChanged", changedPath);
        if (selectionChanged) {
          const event = {
            type: Events.EVENT_SELECTION_CHANGED,
            source: "rowGroupChanged"
          };
          this.eventService.dispatchEvent(event);
        }
      }
    } else {
      this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;
      if (this.rootNode.sibling) {
        this.rootNode.sibling.childrenAfterGroup = this.rootNode.childrenAfterGroup;
      }
      this.rootNode.updateHasChildren();
    }
  }
  restoreGroupState(groupState) {
    if (!groupState) {
      return;
    }
    _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, (node, key) => {
      if (typeof groupState[key] === "boolean") {
        node.expanded = groupState[key];
      }
    });
  }
  doFilter(changedPath) {
    this.filterStage.execute({ rowNode: this.rootNode, changedPath });
  }
  doPivot(changedPath) {
    if (this.pivotStage) {
      this.pivotStage.execute({ rowNode: this.rootNode, changedPath });
    }
  }
  getGroupState() {
    if (!this.rootNode.childrenAfterGroup || !this.gridOptionsService.is("rememberGroupStateWhenNewData")) {
      return null;
    }
    const result = {};
    _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, (node, key) => result[key] = node.expanded);
    return result;
  }
  getCopyOfNodesMap() {
    return this.nodeManager.getCopyOfNodesMap();
  }
  getRowNode(id) {
    const idIsGroup = typeof id == "string" && id.indexOf(RowNode.ID_PREFIX_ROW_GROUP) == 0;
    if (idIsGroup) {
      let res = void 0;
      this.forEachNode((node) => {
        if (node.id === id) {
          res = node;
        }
      });
      return res;
    }
    return this.nodeManager.getRowNode(id);
  }
  setRowData(rowData) {
    const groupState = this.getGroupState();
    this.nodeManager.setRowData(rowData);
    this.selectionService.reset();
    this.filterManager.onNewRowsLoaded("rowDataUpdated");
    const rowDataUpdatedEvent = {
      type: Events.EVENT_ROW_DATA_UPDATED
    };
    this.eventService.dispatchEvent(rowDataUpdatedEvent);
    this.refreshModel({
      step: ClientSideRowModelSteps.EVERYTHING,
      groupState,
      newData: true
    });
  }
  batchUpdateRowData(rowDataTransaction, callback) {
    if (this.applyAsyncTransactionsTimeout == null) {
      this.rowDataTransactionBatch = [];
      const waitMillis = this.gridOptionsService.getAsyncTransactionWaitMillis();
      this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
        this.executeBatchUpdateRowData();
      }, waitMillis);
    }
    this.rowDataTransactionBatch.push({ rowDataTransaction, callback });
  }
  flushAsyncTransactions() {
    if (this.applyAsyncTransactionsTimeout != null) {
      clearTimeout(this.applyAsyncTransactionsTimeout);
      this.executeBatchUpdateRowData();
    }
  }
  executeBatchUpdateRowData() {
    this.valueCache.onDataChanged();
    const callbackFuncsBound = [];
    const rowNodeTrans = [];
    let forceRowNodeOrder = false;
    if (this.rowDataTransactionBatch) {
      this.rowDataTransactionBatch.forEach((tranItem) => {
        const rowNodeTran = this.nodeManager.updateRowData(tranItem.rowDataTransaction, void 0);
        rowNodeTrans.push(rowNodeTran);
        if (tranItem.callback) {
          callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTran));
        }
        if (typeof tranItem.rowDataTransaction.addIndex === "number") {
          forceRowNodeOrder = true;
        }
      });
    }
    this.commonUpdateRowData(rowNodeTrans, void 0, forceRowNodeOrder);
    if (callbackFuncsBound.length > 0) {
      window.setTimeout(() => {
        callbackFuncsBound.forEach((func) => func());
      }, 0);
    }
    if (rowNodeTrans.length > 0) {
      const event = {
        type: Events.EVENT_ASYNC_TRANSACTIONS_FLUSHED,
        results: rowNodeTrans
      };
      this.eventService.dispatchEvent(event);
    }
    this.rowDataTransactionBatch = null;
    this.applyAsyncTransactionsTimeout = void 0;
  }
  updateRowData(rowDataTran, rowNodeOrder) {
    this.valueCache.onDataChanged();
    const rowNodeTran = this.nodeManager.updateRowData(rowDataTran, rowNodeOrder);
    const forceRowNodeOrder = typeof rowDataTran.addIndex === "number";
    this.commonUpdateRowData([rowNodeTran], rowNodeOrder, forceRowNodeOrder);
    return rowNodeTran;
  }
  createRowNodeOrder() {
    const suppressSortOrder = this.gridOptionsService.is("suppressMaintainUnsortedOrder");
    if (suppressSortOrder) {
      return;
    }
    const orderMap = {};
    if (this.rootNode && this.rootNode.allLeafChildren) {
      for (let index = 0; index < this.rootNode.allLeafChildren.length; index++) {
        const node = this.rootNode.allLeafChildren[index];
        orderMap[node.id] = index;
      }
    }
    return orderMap;
  }
  commonUpdateRowData(rowNodeTrans, rowNodeOrder, forceRowNodeOrder) {
    const animate = !this.gridOptionsService.is("suppressAnimationFrame");
    if (forceRowNodeOrder) {
      rowNodeOrder = this.createRowNodeOrder();
    }
    this.refreshModel({
      step: ClientSideRowModelSteps.EVERYTHING,
      rowNodeTransactions: rowNodeTrans,
      rowNodeOrder,
      keepRenderedRows: true,
      keepEditingRows: true,
      animate
    });
    this.filterManager.onNewRowsLoaded("rowDataUpdated");
    const event = {
      type: Events.EVENT_ROW_DATA_UPDATED
    };
    this.eventService.dispatchEvent(event);
  }
  doRowsToDisplay() {
    this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });
  }
  onRowHeightChanged() {
    this.refreshModel({ step: ClientSideRowModelSteps.MAP, keepRenderedRows: true, keepEditingRows: true, keepUndoRedoStack: true });
  }
  onRowHeightChangedDebounced() {
    this.onRowHeightChanged_debounced();
  }
  resetRowHeights() {
    const atLeastOne = this.resetRowHeightsForAllRowNodes();
    this.rootNode.setRowHeight(this.rootNode.rowHeight, true);
    if (atLeastOne) {
      this.onRowHeightChanged();
    }
  }
  resetRowHeightsForAllRowNodes() {
    let atLeastOne = false;
    this.forEachNode((rowNode) => {
      rowNode.setRowHeight(rowNode.rowHeight, true);
      const detailNode = rowNode.detailNode;
      if (detailNode) {
        detailNode.setRowHeight(detailNode.rowHeight, true);
      }
      atLeastOne = true;
    });
    return atLeastOne;
  }
  onGridStylesChanges() {
    if (this.columnModel.isAutoRowHeightActive()) {
      return;
    }
    this.resetRowHeights();
  }
};
__decorate$b([
  Autowired("columnModel")
], ClientSideRowModel.prototype, "columnModel", void 0);
__decorate$b([
  Autowired("selectionService")
], ClientSideRowModel.prototype, "selectionService", void 0);
__decorate$b([
  Autowired("filterManager")
], ClientSideRowModel.prototype, "filterManager", void 0);
__decorate$b([
  Autowired("valueCache")
], ClientSideRowModel.prototype, "valueCache", void 0);
__decorate$b([
  Autowired("beans")
], ClientSideRowModel.prototype, "beans", void 0);
__decorate$b([
  Autowired("filterStage")
], ClientSideRowModel.prototype, "filterStage", void 0);
__decorate$b([
  Autowired("sortStage")
], ClientSideRowModel.prototype, "sortStage", void 0);
__decorate$b([
  Autowired("flattenStage")
], ClientSideRowModel.prototype, "flattenStage", void 0);
__decorate$b([
  Optional("groupStage")
], ClientSideRowModel.prototype, "groupStage", void 0);
__decorate$b([
  Optional("aggregationStage")
], ClientSideRowModel.prototype, "aggregationStage", void 0);
__decorate$b([
  Optional("pivotStage")
], ClientSideRowModel.prototype, "pivotStage", void 0);
__decorate$b([
  Optional("filterAggregatesStage")
], ClientSideRowModel.prototype, "filterAggregatesStage", void 0);
__decorate$b([
  PostConstruct
], ClientSideRowModel.prototype, "init", null);
ClientSideRowModel = __decorate$b([
  Bean("rowModel")
], ClientSideRowModel);
var __decorate$a = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FilterStage = class FilterStage2 extends BeanStub {
  execute(params) {
    const { changedPath } = params;
    this.filterService.filter(changedPath);
  }
};
__decorate$a([
  Autowired("filterService")
], FilterStage.prototype, "filterService", void 0);
FilterStage = __decorate$a([
  Bean("filterStage")
], FilterStage);
var __decorate$9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SortStage = class SortStage2 extends BeanStub {
  execute(params) {
    const sortOptions = this.sortController.getSortOptions();
    const sortActive = _.exists(sortOptions) && sortOptions.length > 0;
    const deltaSort = sortActive && _.exists(params.rowNodeTransactions) && this.gridOptionsService.is("deltaSort");
    const sortContainsGroupColumns = sortOptions.some((opt) => !!this.columnModel.getGroupDisplayColumnForGroup(opt.column.getId()));
    this.sortService.sort(sortOptions, sortActive, deltaSort, params.rowNodeTransactions, params.changedPath, sortContainsGroupColumns);
  }
};
__decorate$9([
  Autowired("sortService")
], SortStage.prototype, "sortService", void 0);
__decorate$9([
  Autowired("sortController")
], SortStage.prototype, "sortController", void 0);
__decorate$9([
  Autowired("columnModel")
], SortStage.prototype, "columnModel", void 0);
SortStage = __decorate$9([
  Bean("sortStage")
], SortStage);
var __decorate$8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FlattenStage = class FlattenStage2 extends BeanStub {
  execute(params) {
    const rootNode = params.rowNode;
    const result = [];
    const nextRowTop = { value: 0 };
    const skipLeafNodes = this.columnModel.isPivotMode();
    const showRootNode = skipLeafNodes && rootNode.leafGroup;
    const topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort;
    this.recursivelyAddToRowsToDisplay(topList, result, nextRowTop, skipLeafNodes, 0);
    const atLeastOneRowPresent = result.length > 0;
    const includeGroupTotalFooter = !showRootNode && atLeastOneRowPresent && this.gridOptionsService.is("groupIncludeTotalFooter");
    if (includeGroupTotalFooter) {
      rootNode.createFooter();
      this.addRowNodeToRowsToDisplay(rootNode.sibling, result, nextRowTop, 0);
    }
    return result;
  }
  recursivelyAddToRowsToDisplay(rowsToFlatten, result, nextRowTop, skipLeafNodes, uiLevel) {
    if (_.missingOrEmpty(rowsToFlatten)) {
      return;
    }
    const hideOpenParents = this.gridOptionsService.is("groupHideOpenParents");
    const groupRemoveSingleChildren = this.gridOptionsService.is("groupRemoveSingleChildren");
    const groupRemoveLowestSingleChildren = !groupRemoveSingleChildren && this.gridOptionsService.is("groupRemoveLowestSingleChildren");
    for (let i = 0; i < rowsToFlatten.length; i++) {
      const rowNode = rowsToFlatten[i];
      const isParent = rowNode.hasChildren();
      const isSkippedLeafNode = skipLeafNodes && !isParent;
      const isRemovedSingleChildrenGroup = groupRemoveSingleChildren && isParent && rowNode.childrenAfterGroup.length === 1;
      const isRemovedLowestSingleChildrenGroup = groupRemoveLowestSingleChildren && isParent && rowNode.leafGroup && rowNode.childrenAfterGroup.length === 1;
      const neverAllowToExpand = skipLeafNodes && rowNode.leafGroup;
      const isHiddenOpenParent = hideOpenParents && rowNode.expanded && !rowNode.master && !neverAllowToExpand;
      const thisRowShouldBeRendered = !isSkippedLeafNode && !isHiddenOpenParent && !isRemovedSingleChildrenGroup && !isRemovedLowestSingleChildrenGroup;
      if (thisRowShouldBeRendered) {
        this.addRowNodeToRowsToDisplay(rowNode, result, nextRowTop, uiLevel);
      }
      if (skipLeafNodes && rowNode.leafGroup) {
        continue;
      }
      if (isParent) {
        const excludedParent = isRemovedSingleChildrenGroup || isRemovedLowestSingleChildrenGroup;
        if (rowNode.expanded || excludedParent) {
          const uiLevelForChildren = excludedParent ? uiLevel : uiLevel + 1;
          this.recursivelyAddToRowsToDisplay(rowNode.childrenAfterSort, result, nextRowTop, skipLeafNodes, uiLevelForChildren);
          if (this.gridOptionsService.is("groupIncludeFooter")) {
            this.addRowNodeToRowsToDisplay(rowNode.sibling, result, nextRowTop, uiLevelForChildren);
          }
        }
      } else if (rowNode.master && rowNode.expanded) {
        const detailNode = this.createDetailNode(rowNode);
        this.addRowNodeToRowsToDisplay(detailNode, result, nextRowTop, uiLevel);
      }
    }
  }
  addRowNodeToRowsToDisplay(rowNode, result, nextRowTop, uiLevel) {
    const isGroupMultiAutoColumn = this.gridOptionsService.isGroupMultiAutoColumn();
    result.push(rowNode);
    rowNode.setUiLevel(isGroupMultiAutoColumn ? 0 : uiLevel);
  }
  createDetailNode(masterNode) {
    if (_.exists(masterNode.detailNode)) {
      return masterNode.detailNode;
    }
    const detailNode = new RowNode(this.beans);
    detailNode.detail = true;
    detailNode.selectable = false;
    detailNode.parent = masterNode;
    if (_.exists(masterNode.id)) {
      detailNode.id = "detail_" + masterNode.id;
    }
    detailNode.data = masterNode.data;
    detailNode.level = masterNode.level + 1;
    masterNode.detailNode = detailNode;
    return detailNode;
  }
};
__decorate$8([
  Autowired("columnModel")
], FlattenStage.prototype, "columnModel", void 0);
__decorate$8([
  Autowired("beans")
], FlattenStage.prototype, "beans", void 0);
FlattenStage = __decorate$8([
  Bean("flattenStage")
], FlattenStage);
var __decorate$7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SortService = class SortService2 extends BeanStub {
  init() {
    this.postSortFunc = this.gridOptionsService.getCallback("postSortRows");
  }
  sort(sortOptions, sortActive, useDeltaSort, rowNodeTransactions, changedPath, sortContainsGroupColumns) {
    const groupMaintainOrder = this.gridOptionsService.is("groupMaintainOrder");
    const groupColumnsPresent = this.columnModel.getAllGridColumns().some((c) => c.isRowGroupActive());
    let allDirtyNodes = {};
    if (useDeltaSort && rowNodeTransactions) {
      allDirtyNodes = this.calculateDirtyNodes(rowNodeTransactions);
    }
    const isPivotMode = this.columnModel.isPivotMode();
    const callback = (rowNode) => {
      this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterAggFilter, true);
      const skipSortingPivotLeafs = isPivotMode && rowNode.leafGroup;
      let skipSortingGroups = groupMaintainOrder && groupColumnsPresent && !rowNode.leafGroup && !sortContainsGroupColumns;
      if (skipSortingGroups) {
        const childrenToBeSorted = rowNode.childrenAfterAggFilter.slice(0);
        if (rowNode.childrenAfterSort) {
          const indexedOrders = {};
          rowNode.childrenAfterSort.forEach((node, idx) => {
            indexedOrders[node.id] = idx;
          });
          childrenToBeSorted.sort((row1, row2) => {
            var _a, _b;
            return ((_a = indexedOrders[row1.id]) !== null && _a !== void 0 ? _a : 0) - ((_b = indexedOrders[row2.id]) !== null && _b !== void 0 ? _b : 0);
          });
        }
        rowNode.childrenAfterSort = childrenToBeSorted;
      } else if (!sortActive || skipSortingPivotLeafs) {
        rowNode.childrenAfterSort = rowNode.childrenAfterAggFilter.slice(0);
      } else if (useDeltaSort) {
        rowNode.childrenAfterSort = this.doDeltaSort(rowNode, allDirtyNodes, changedPath, sortOptions);
      } else {
        rowNode.childrenAfterSort = this.rowNodeSorter.doFullSort(rowNode.childrenAfterAggFilter, sortOptions);
      }
      if (rowNode.sibling) {
        rowNode.sibling.childrenAfterSort = rowNode.childrenAfterSort;
      }
      this.updateChildIndexes(rowNode);
      if (this.postSortFunc) {
        const params = { nodes: rowNode.childrenAfterSort };
        this.postSortFunc(params);
      }
    };
    if (changedPath) {
      changedPath.forEachChangedNodeDepthFirst(callback);
    }
    this.updateGroupDataForHideOpenParents(changedPath);
  }
  calculateDirtyNodes(rowNodeTransactions) {
    const dirtyNodes = {};
    const addNodesFunc = (rowNodes) => {
      if (rowNodes) {
        rowNodes.forEach((rowNode) => dirtyNodes[rowNode.id] = true);
      }
    };
    if (rowNodeTransactions) {
      rowNodeTransactions.forEach((tran) => {
        addNodesFunc(tran.add);
        addNodesFunc(tran.update);
        addNodesFunc(tran.remove);
      });
    }
    return dirtyNodes;
  }
  doDeltaSort(rowNode, allTouchedNodes, changedPath, sortOptions) {
    const unsortedRows = rowNode.childrenAfterAggFilter;
    const oldSortedRows = rowNode.childrenAfterSort;
    if (!oldSortedRows) {
      return this.rowNodeSorter.doFullSort(unsortedRows, sortOptions);
    }
    const untouchedRowsMap = {};
    const touchedRows = [];
    unsortedRows.forEach((row) => {
      if (allTouchedNodes[row.id] || !changedPath.canSkip(row)) {
        touchedRows.push(row);
      } else {
        untouchedRowsMap[row.id] = true;
      }
    });
    const sortedUntouchedRows = oldSortedRows.filter((child) => untouchedRowsMap[child.id]);
    const mapNodeToSortedNode = (rowNode2, pos) => ({ currentPos: pos, rowNode: rowNode2 });
    const sortedChangedRows = touchedRows.map(mapNodeToSortedNode).sort((a, b) => this.rowNodeSorter.compareRowNodes(sortOptions, a, b));
    return this.mergeSortedArrays(sortOptions, sortedChangedRows, sortedUntouchedRows.map(mapNodeToSortedNode)).map(({ rowNode: rowNode2 }) => rowNode2);
  }
  mergeSortedArrays(sortOptions, arr1, arr2) {
    const res = [];
    let i = 0;
    let j = 0;
    while (i < arr1.length && j < arr2.length) {
      const compareResult = this.rowNodeSorter.compareRowNodes(sortOptions, arr1[i], arr2[j]);
      if (compareResult < 0) {
        res.push(arr1[i++]);
      } else {
        res.push(arr2[j++]);
      }
    }
    while (i < arr1.length) {
      res.push(arr1[i++]);
    }
    while (j < arr2.length) {
      res.push(arr2[j++]);
    }
    return res;
  }
  updateChildIndexes(rowNode) {
    if (_.missing(rowNode.childrenAfterSort)) {
      return;
    }
    const listToSort = rowNode.childrenAfterSort;
    for (let i = 0; i < listToSort.length; i++) {
      const child = listToSort[i];
      const firstChild = i === 0;
      const lastChild = i === rowNode.childrenAfterSort.length - 1;
      child.setFirstChild(firstChild);
      child.setLastChild(lastChild);
      child.setChildIndex(i);
    }
  }
  updateGroupDataForHideOpenParents(changedPath) {
    if (!this.gridOptionsService.is("groupHideOpenParents")) {
      return;
    }
    if (this.gridOptionsService.isTreeData()) {
      const msg = `AG Grid: The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them (as opposed to Row Grouping, which only has Aggregated Values at the group level).`;
      _.doOnce(() => console.warn(msg), "sortService.hideOpenParentsWithTreeData");
      return false;
    }
    const callback = (rowNode) => {
      this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterSort, false);
      rowNode.childrenAfterSort.forEach((child) => {
        if (child.hasChildren()) {
          callback(child);
        }
      });
    };
    if (changedPath) {
      changedPath.executeFromRootNode((rowNode) => callback(rowNode));
    }
  }
  pullDownGroupDataForHideOpenParents(rowNodes, clearOperation) {
    if (!this.gridOptionsService.is("groupHideOpenParents") || _.missing(rowNodes)) {
      return;
    }
    rowNodes.forEach((childRowNode) => {
      const groupDisplayCols = this.columnModel.getGroupDisplayColumns();
      groupDisplayCols.forEach((groupDisplayCol) => {
        const showRowGroup = groupDisplayCol.getColDef().showRowGroup;
        if (typeof showRowGroup !== "string") {
          console.error("AG Grid: groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup");
          return;
        }
        const displayingGroupKey = showRowGroup;
        const rowGroupColumn = this.columnModel.getPrimaryColumn(displayingGroupKey);
        const thisRowNodeMatches = rowGroupColumn === childRowNode.rowGroupColumn;
        if (thisRowNodeMatches) {
          return;
        }
        if (clearOperation) {
          childRowNode.setGroupValue(groupDisplayCol.getId(), void 0);
        } else {
          const parentToStealFrom = childRowNode.getFirstChildOfFirstChild(rowGroupColumn);
          if (parentToStealFrom) {
            childRowNode.setGroupValue(groupDisplayCol.getId(), parentToStealFrom.key);
          }
        }
      });
    });
  }
};
__decorate$7([
  Autowired("columnModel")
], SortService.prototype, "columnModel", void 0);
__decorate$7([
  Autowired("rowNodeSorter")
], SortService.prototype, "rowNodeSorter", void 0);
__decorate$7([
  PostConstruct
], SortService.prototype, "init", null);
SortService = __decorate$7([
  Bean("sortService")
], SortService);
var __decorate$6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FilterService = class FilterService2 extends BeanStub {
  filter(changedPath) {
    const filterActive = this.filterManager.isColumnFilterPresent() || this.filterManager.isQuickFilterPresent() || this.filterManager.isExternalFilterPresent();
    this.filterNodes(filterActive, changedPath);
  }
  filterNodes(filterActive, changedPath) {
    const filterCallback = (rowNode, includeChildNodes) => {
      if (rowNode.hasChildren()) {
        if (filterActive && !includeChildNodes) {
          rowNode.childrenAfterFilter = rowNode.childrenAfterGroup.filter((childNode) => {
            const passBecauseChildren = childNode.childrenAfterFilter && childNode.childrenAfterFilter.length > 0;
            const passBecauseDataPasses = childNode.data && this.filterManager.doesRowPassFilter({ rowNode: childNode });
            return passBecauseChildren || passBecauseDataPasses;
          });
        } else {
          rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
        }
      } else {
        rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
      }
      if (rowNode.sibling) {
        rowNode.sibling.childrenAfterFilter = rowNode.childrenAfterFilter;
      }
    };
    if (this.doingTreeDataFiltering()) {
      const treeDataDepthFirstFilter = (rowNode, alreadyFoundInParent) => {
        if (rowNode.childrenAfterGroup) {
          for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {
            const childNode = rowNode.childrenAfterGroup[i];
            const foundInParent = alreadyFoundInParent || this.filterManager.doesRowPassFilter({ rowNode: childNode });
            if (childNode.childrenAfterGroup) {
              treeDataDepthFirstFilter(rowNode.childrenAfterGroup[i], foundInParent);
            } else {
              filterCallback(childNode, foundInParent);
            }
          }
        }
        filterCallback(rowNode, alreadyFoundInParent);
      };
      const treeDataFilterCallback = (rowNode) => treeDataDepthFirstFilter(rowNode, false);
      changedPath.executeFromRootNode(treeDataFilterCallback);
    } else {
      const defaultFilterCallback = (rowNode) => filterCallback(rowNode, false);
      changedPath.forEachChangedNodeDepthFirst(defaultFilterCallback, true);
    }
  }
  doingTreeDataFiltering() {
    return this.gridOptionsService.isTreeData() && !this.gridOptionsService.is("excludeChildrenWhenTreeDataFiltering");
  }
};
__decorate$6([
  Autowired("filterManager")
], FilterService.prototype, "filterManager", void 0);
FilterService = __decorate$6([
  Bean("filterService")
], FilterService);
var __decorate$5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ImmutableService = class ImmutableService2 extends BeanStub {
  postConstruct() {
    if (this.rowModel.getType() === "clientSide") {
      this.clientSideRowModel = this.rowModel;
    }
  }
  isActive() {
    const getRowIdProvided = this.gridOptionsService.exists("getRowId");
    const resetRowDataOnUpdate = this.gridOptionsService.is("resetRowDataOnUpdate");
    if (resetRowDataOnUpdate) {
      return false;
    }
    return getRowIdProvided;
  }
  setRowData(rowData) {
    const transactionAndMap = this.createTransactionForRowData(rowData);
    if (!transactionAndMap) {
      return;
    }
    const [transaction, orderIdMap] = transactionAndMap;
    this.clientSideRowModel.updateRowData(transaction, orderIdMap);
  }
  createTransactionForRowData(rowData) {
    if (_.missing(this.clientSideRowModel)) {
      console.error("AG Grid: ImmutableService only works with ClientSideRowModel");
      return;
    }
    const getRowIdFunc = this.gridOptionsService.getCallback("getRowId");
    if (getRowIdFunc == null) {
      console.error("AG Grid: ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!");
      return;
    }
    const transaction = {
      remove: [],
      update: [],
      add: []
    };
    const existingNodesMap = this.clientSideRowModel.getCopyOfNodesMap();
    const suppressSortOrder = this.gridOptionsService.is("suppressMaintainUnsortedOrder");
    const orderMap = suppressSortOrder ? void 0 : {};
    if (_.exists(rowData)) {
      rowData.forEach((data, index) => {
        const id = getRowIdFunc({ data, level: 0 });
        const existingNode = existingNodesMap[id];
        if (orderMap) {
          orderMap[id] = index;
        }
        if (existingNode) {
          const dataHasChanged = existingNode.data !== data;
          if (dataHasChanged) {
            transaction.update.push(data);
          }
          existingNodesMap[id] = void 0;
        } else {
          transaction.add.push(data);
        }
      });
    }
    _.iterateObject(existingNodesMap, (id, rowNode) => {
      if (rowNode) {
        transaction.remove.push(rowNode.data);
      }
    });
    return [transaction, orderMap];
  }
};
__decorate$5([
  Autowired("rowModel")
], ImmutableService.prototype, "rowModel", void 0);
__decorate$5([
  Autowired("rowRenderer")
], ImmutableService.prototype, "rowRenderer", void 0);
__decorate$5([
  PostConstruct
], ImmutableService.prototype, "postConstruct", null);
ImmutableService = __decorate$5([
  Bean("immutableService")
], ImmutableService);
var VERSION$2 = "30.0.2";
var ClientSideRowModelModule = {
  version: VERSION$2,
  moduleName: ModuleNames.ClientSideRowModelModule,
  rowModel: "clientSide",
  beans: [ClientSideRowModel, FilterStage, SortStage, FlattenStage, SortService, FilterService, ImmutableService]
};
var __decorate$4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var InfiniteBlock = class extends RowNodeBlock {
  constructor(id, parentCache, params) {
    super(id);
    this.parentCache = parentCache;
    this.params = params;
    this.startRow = id * params.blockSize;
    this.endRow = this.startRow + params.blockSize;
  }
  postConstruct() {
    this.createRowNodes();
  }
  getBlockStateJson() {
    return {
      id: "" + this.getId(),
      state: {
        blockNumber: this.getId(),
        startRow: this.getStartRow(),
        endRow: this.getEndRow(),
        pageStatus: this.getState()
      }
    };
  }
  setDataAndId(rowNode, data, index) {
    if (!rowNode.id && rowNode.alreadyRendered) {
      rowNode.alreadyRendered = false;
    }
    if (_.exists(data)) {
      rowNode.setDataAndId(data, index.toString());
    } else {
      rowNode.setDataAndId(void 0, void 0);
    }
  }
  loadFromDatasource() {
    const params = this.createLoadParams();
    if (_.missing(this.params.datasource.getRows)) {
      console.warn(`AG Grid: datasource is missing getRows method`);
      return;
    }
    window.setTimeout(() => {
      this.params.datasource.getRows(params);
    }, 0);
  }
  processServerFail() {
  }
  createLoadParams() {
    const params = {
      startRow: this.getStartRow(),
      endRow: this.getEndRow(),
      successCallback: this.pageLoaded.bind(this, this.getVersion()),
      failCallback: this.pageLoadFailed.bind(this, this.getVersion()),
      sortModel: this.params.sortModel,
      filterModel: this.params.filterModel,
      context: this.gridOptionsService.context
    };
    return params;
  }
  forEachNode(callback, sequence, rowCount) {
    this.rowNodes.forEach((rowNode, index) => {
      const rowIndex = this.startRow + index;
      if (rowIndex < rowCount) {
        callback(rowNode, sequence.next());
      }
    });
  }
  getLastAccessed() {
    return this.lastAccessed;
  }
  getRow(rowIndex, dontTouchLastAccessed = false) {
    if (!dontTouchLastAccessed) {
      this.lastAccessed = this.params.lastAccessedSequence.next();
    }
    const localIndex = rowIndex - this.startRow;
    return this.rowNodes[localIndex];
  }
  getStartRow() {
    return this.startRow;
  }
  getEndRow() {
    return this.endRow;
  }
  createRowNodes() {
    this.rowNodes = [];
    for (let i = 0; i < this.params.blockSize; i++) {
      const rowIndex = this.startRow + i;
      const rowNode = new RowNode(this.beans);
      rowNode.setRowHeight(this.params.rowHeight);
      rowNode.uiLevel = 0;
      rowNode.setRowIndex(rowIndex);
      rowNode.setRowTop(this.params.rowHeight * rowIndex);
      this.rowNodes.push(rowNode);
    }
  }
  processServerResult(params) {
    this.rowNodes.forEach((rowNode, index) => {
      const data = params.rowData ? params.rowData[index] : void 0;
      this.setDataAndId(rowNode, data, this.startRow + index);
    });
    const finalRowCount = params.rowCount != null && params.rowCount >= 0 ? params.rowCount : void 0;
    this.parentCache.pageLoaded(this, finalRowCount);
  }
  destroyRowNodes() {
    this.rowNodes.forEach((rowNode) => {
      rowNode.clearRowTopAndRowIndex();
    });
  }
};
__decorate$4([
  Autowired("beans")
], InfiniteBlock.prototype, "beans", void 0);
__decorate$4([
  PostConstruct
], InfiniteBlock.prototype, "postConstruct", null);
__decorate$4([
  PreDestroy
], InfiniteBlock.prototype, "destroyRowNodes", null);
var __decorate$3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InfiniteCache = class extends BeanStub {
  constructor(params) {
    super();
    this.lastRowIndexKnown = false;
    this.blocks = {};
    this.blockCount = 0;
    this.rowCount = params.initialRowCount;
    this.params = params;
  }
  setBeans(loggerFactory) {
    this.logger = loggerFactory.create("InfiniteCache");
  }
  getRow(rowIndex, dontCreatePage = false) {
    const blockId = Math.floor(rowIndex / this.params.blockSize);
    let block = this.blocks[blockId];
    if (!block) {
      if (dontCreatePage) {
        return void 0;
      }
      block = this.createBlock(blockId);
    }
    return block.getRow(rowIndex);
  }
  createBlock(blockNumber) {
    const newBlock = this.createBean(new InfiniteBlock(blockNumber, this, this.params));
    this.blocks[newBlock.getId()] = newBlock;
    this.blockCount++;
    this.purgeBlocksIfNeeded(newBlock);
    this.params.rowNodeBlockLoader.addBlock(newBlock);
    return newBlock;
  }
  refreshCache() {
    const nothingToRefresh = this.blockCount == 0;
    if (nothingToRefresh) {
      this.purgeCache();
      return;
    }
    this.getBlocksInOrder().forEach((block) => block.setStateWaitingToLoad());
    this.params.rowNodeBlockLoader.checkBlockToLoad();
  }
  destroyAllBlocks() {
    this.getBlocksInOrder().forEach((block) => this.destroyBlock(block));
  }
  getRowCount() {
    return this.rowCount;
  }
  isLastRowIndexKnown() {
    return this.lastRowIndexKnown;
  }
  pageLoaded(block, lastRow) {
    if (!this.isAlive()) {
      return;
    }
    this.logger.log(`onPageLoaded: page = ${block.getId()}, lastRow = ${lastRow}`);
    this.checkRowCount(block, lastRow);
    this.onCacheUpdated();
  }
  purgeBlocksIfNeeded(blockToExclude) {
    const blocksForPurging = this.getBlocksInOrder().filter((b) => b != blockToExclude);
    const lastAccessedComparator = (a, b) => b.getLastAccessed() - a.getLastAccessed();
    blocksForPurging.sort(lastAccessedComparator);
    const maxBlocksProvided = this.params.maxBlocksInCache > 0;
    const blocksToKeep = maxBlocksProvided ? this.params.maxBlocksInCache - 1 : null;
    const emptyBlocksToKeep = InfiniteCache.MAX_EMPTY_BLOCKS_TO_KEEP - 1;
    blocksForPurging.forEach((block, index) => {
      const purgeBecauseBlockEmpty = block.getState() === InfiniteBlock.STATE_WAITING_TO_LOAD && index >= emptyBlocksToKeep;
      const purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;
      if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {
        if (this.isBlockCurrentlyDisplayed(block)) {
          return;
        }
        if (this.isBlockFocused(block)) {
          return;
        }
        this.removeBlockFromCache(block);
      }
    });
  }
  isBlockFocused(block) {
    const focusedCell = this.focusService.getFocusCellToUseAfterRefresh();
    if (!focusedCell) {
      return false;
    }
    if (focusedCell.rowPinned != null) {
      return false;
    }
    const blockIndexStart = block.getStartRow();
    const blockIndexEnd = block.getEndRow();
    const hasFocus = focusedCell.rowIndex >= blockIndexStart && focusedCell.rowIndex < blockIndexEnd;
    return hasFocus;
  }
  isBlockCurrentlyDisplayed(block) {
    const startIndex = block.getStartRow();
    const endIndex = block.getEndRow() - 1;
    return this.rowRenderer.isRangeInRenderedViewport(startIndex, endIndex);
  }
  removeBlockFromCache(blockToRemove) {
    if (!blockToRemove) {
      return;
    }
    this.destroyBlock(blockToRemove);
  }
  checkRowCount(block, lastRow) {
    if (typeof lastRow === "number" && lastRow >= 0) {
      this.rowCount = lastRow;
      this.lastRowIndexKnown = true;
    } else if (!this.lastRowIndexKnown) {
      const lastRowIndex = (block.getId() + 1) * this.params.blockSize;
      const lastRowIndexPlusOverflow = lastRowIndex + this.params.overflowSize;
      if (this.rowCount < lastRowIndexPlusOverflow) {
        this.rowCount = lastRowIndexPlusOverflow;
      }
    }
  }
  setRowCount(rowCount, lastRowIndexKnown) {
    this.rowCount = rowCount;
    if (_.exists(lastRowIndexKnown)) {
      this.lastRowIndexKnown = lastRowIndexKnown;
    }
    if (!this.lastRowIndexKnown) {
      if (this.rowCount % this.params.blockSize === 0) {
        this.rowCount++;
      }
    }
    this.onCacheUpdated();
  }
  forEachNodeDeep(callback) {
    const sequence = new NumberSequence();
    this.getBlocksInOrder().forEach((block) => block.forEachNode(callback, sequence, this.rowCount));
  }
  getBlocksInOrder() {
    const blockComparator = (a, b) => a.getId() - b.getId();
    const blocks = _.getAllValuesInObject(this.blocks).sort(blockComparator);
    return blocks;
  }
  destroyBlock(block) {
    delete this.blocks[block.getId()];
    this.destroyBean(block);
    this.blockCount--;
    this.params.rowNodeBlockLoader.removeBlock(block);
  }
  onCacheUpdated() {
    if (this.isAlive()) {
      this.destroyAllBlocksPastVirtualRowCount();
      const event = {
        type: Events.EVENT_STORE_UPDATED
      };
      this.eventService.dispatchEvent(event);
    }
  }
  destroyAllBlocksPastVirtualRowCount() {
    const blocksToDestroy = [];
    this.getBlocksInOrder().forEach((block) => {
      const startRow = block.getId() * this.params.blockSize;
      if (startRow >= this.rowCount) {
        blocksToDestroy.push(block);
      }
    });
    if (blocksToDestroy.length > 0) {
      blocksToDestroy.forEach((block) => this.destroyBlock(block));
    }
  }
  purgeCache() {
    this.getBlocksInOrder().forEach((block) => this.removeBlockFromCache(block));
    this.lastRowIndexKnown = false;
    if (this.rowCount === 0) {
      this.rowCount = this.params.initialRowCount;
    }
    this.onCacheUpdated();
  }
  getRowNodesInRange(firstInRange, lastInRange) {
    const result = [];
    let lastBlockId = -1;
    let inActiveRange = false;
    const numberSequence = new NumberSequence();
    if (_.missing(firstInRange)) {
      inActiveRange = true;
    }
    let foundGapInSelection = false;
    this.getBlocksInOrder().forEach((block) => {
      if (foundGapInSelection) {
        return;
      }
      if (inActiveRange && lastBlockId + 1 !== block.getId()) {
        foundGapInSelection = true;
        return;
      }
      lastBlockId = block.getId();
      block.forEachNode((rowNode) => {
        const hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;
        if (inActiveRange || hitFirstOrLast) {
          result.push(rowNode);
        }
        if (hitFirstOrLast) {
          inActiveRange = !inActiveRange;
        }
      }, numberSequence, this.rowCount);
    });
    const invalidRange = foundGapInSelection || inActiveRange;
    return invalidRange ? [] : result;
  }
};
InfiniteCache.MAX_EMPTY_BLOCKS_TO_KEEP = 2;
__decorate$3([
  Autowired("rowRenderer")
], InfiniteCache.prototype, "rowRenderer", void 0);
__decorate$3([
  Autowired("focusService")
], InfiniteCache.prototype, "focusService", void 0);
__decorate$3([
  __param(0, Qualifier("loggerFactory"))
], InfiniteCache.prototype, "setBeans", null);
__decorate$3([
  PreDestroy
], InfiniteCache.prototype, "destroyAllBlocks", null);
var __decorate$2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var InfiniteRowModel = class InfiniteRowModel2 extends BeanStub {
  getRowBounds(index) {
    return {
      rowHeight: this.rowHeight,
      rowTop: this.rowHeight * index
    };
  }
  ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) {
    return false;
  }
  init() {
    if (!this.gridOptionsService.isRowModelType("infinite")) {
      return;
    }
    this.rowHeight = this.gridOptionsService.getRowHeightAsNumber();
    this.addEventListeners();
    this.addDestroyFunc(() => this.destroyCache());
    this.verifyProps();
  }
  verifyProps() {
    if (this.gridOptionsService.exists("initialGroupOrderComparator")) {
      const message = `AG Grid: initialGroupOrderComparator cannot be used with Infinite Row Model. If using Infinite Row Model, then sorting is done on the server side, nothing to do with the client.`;
      _.doOnce(() => console.warn(message), "IRM.InitialGroupOrderComparator");
    }
  }
  start() {
    this.setDatasource(this.gridOptionsService.get("datasource"));
  }
  destroyDatasource() {
    if (this.datasource) {
      this.getContext().destroyBean(this.datasource);
      this.rowRenderer.datasourceChanged();
      this.datasource = null;
    }
  }
  addEventListeners() {
    this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverything.bind(this));
    this.addManagedListener(this.eventService, Events.EVENT_STORE_UPDATED, this.onCacheUpdated.bind(this));
  }
  onFilterChanged() {
    this.reset();
  }
  onSortChanged() {
    this.reset();
  }
  onColumnEverything() {
    let resetRequired;
    if (this.cacheParams) {
      resetRequired = this.isSortModelDifferent();
    } else {
      resetRequired = true;
    }
    if (resetRequired) {
      this.reset();
    }
  }
  isSortModelDifferent() {
    return !_.jsonEquals(this.cacheParams.sortModel, this.sortController.getSortModel());
  }
  getType() {
    return "infinite";
  }
  setDatasource(datasource) {
    this.destroyDatasource();
    this.datasource = datasource;
    if (datasource) {
      this.reset();
    }
  }
  isEmpty() {
    return !this.infiniteCache;
  }
  isRowsToRender() {
    return !!this.infiniteCache;
  }
  getNodesInRangeForSelection(firstInRange, lastInRange) {
    return this.infiniteCache ? this.infiniteCache.getRowNodesInRange(firstInRange, lastInRange) : [];
  }
  reset() {
    if (!this.datasource) {
      return;
    }
    const getRowIdFunc = this.gridOptionsService.getCallback("getRowId");
    const userGeneratingIds = getRowIdFunc != null;
    if (!userGeneratingIds) {
      this.selectionService.reset();
    }
    this.resetCache();
    const event = this.createModelUpdatedEvent();
    this.eventService.dispatchEvent(event);
  }
  createModelUpdatedEvent() {
    return {
      type: Events.EVENT_MODEL_UPDATED,
      newPage: false,
      newData: false,
      keepRenderedRows: true,
      animate: false
    };
  }
  resetCache() {
    this.destroyCache();
    this.cacheParams = {
      datasource: this.datasource,
      filterModel: this.filterManager.getFilterModel(),
      sortModel: this.sortController.getSortModel(),
      rowNodeBlockLoader: this.rowNodeBlockLoader,
      initialRowCount: this.defaultIfInvalid(this.gridOptionsService.getNum("infiniteInitialRowCount"), 1),
      maxBlocksInCache: this.gridOptionsService.getNum("maxBlocksInCache"),
      rowHeight: this.gridOptionsService.getRowHeightAsNumber(),
      overflowSize: this.defaultIfInvalid(this.gridOptionsService.getNum("cacheOverflowSize"), 1),
      blockSize: this.defaultIfInvalid(this.gridOptionsService.getNum("cacheBlockSize"), 100),
      lastAccessedSequence: new NumberSequence()
    };
    this.infiniteCache = this.createBean(new InfiniteCache(this.cacheParams));
  }
  defaultIfInvalid(value, defaultValue) {
    return value > 0 ? value : defaultValue;
  }
  destroyCache() {
    if (this.infiniteCache) {
      this.infiniteCache = this.destroyBean(this.infiniteCache);
    }
  }
  onCacheUpdated() {
    const event = this.createModelUpdatedEvent();
    this.eventService.dispatchEvent(event);
  }
  getRow(rowIndex) {
    if (!this.infiniteCache) {
      return void 0;
    }
    if (rowIndex >= this.infiniteCache.getRowCount()) {
      return void 0;
    }
    return this.infiniteCache.getRow(rowIndex);
  }
  getRowNode(id) {
    let result;
    this.forEachNode((rowNode) => {
      if (rowNode.id === id) {
        result = rowNode;
      }
    });
    return result;
  }
  forEachNode(callback) {
    if (this.infiniteCache) {
      this.infiniteCache.forEachNodeDeep(callback);
    }
  }
  getTopLevelRowCount() {
    return this.getRowCount();
  }
  getTopLevelRowDisplayedIndex(topLevelIndex) {
    return topLevelIndex;
  }
  getRowIndexAtPixel(pixel) {
    if (this.rowHeight !== 0) {
      const rowIndexForPixel = Math.floor(pixel / this.rowHeight);
      const lastRowIndex = this.getRowCount() - 1;
      if (rowIndexForPixel > lastRowIndex) {
        return lastRowIndex;
      }
      return rowIndexForPixel;
    }
    return 0;
  }
  getRowCount() {
    return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;
  }
  isRowPresent(rowNode) {
    const foundRowNode = this.getRowNode(rowNode.id);
    return !!foundRowNode;
  }
  refreshCache() {
    if (this.infiniteCache) {
      this.infiniteCache.refreshCache();
    }
  }
  purgeCache() {
    if (this.infiniteCache) {
      this.infiniteCache.purgeCache();
    }
  }
  isLastRowIndexKnown() {
    if (this.infiniteCache) {
      return this.infiniteCache.isLastRowIndexKnown();
    }
    return false;
  }
  setRowCount(rowCount, lastRowIndexKnown) {
    if (this.infiniteCache) {
      this.infiniteCache.setRowCount(rowCount, lastRowIndexKnown);
    }
  }
};
__decorate$2([
  Autowired("filterManager")
], InfiniteRowModel.prototype, "filterManager", void 0);
__decorate$2([
  Autowired("sortController")
], InfiniteRowModel.prototype, "sortController", void 0);
__decorate$2([
  Autowired("selectionService")
], InfiniteRowModel.prototype, "selectionService", void 0);
__decorate$2([
  Autowired("rowRenderer")
], InfiniteRowModel.prototype, "rowRenderer", void 0);
__decorate$2([
  Autowired("rowNodeBlockLoader")
], InfiniteRowModel.prototype, "rowNodeBlockLoader", void 0);
__decorate$2([
  PostConstruct
], InfiniteRowModel.prototype, "init", null);
__decorate$2([
  PreDestroy
], InfiniteRowModel.prototype, "destroyDatasource", null);
InfiniteRowModel = __decorate$2([
  Bean("rowModel")
], InfiniteRowModel);
var VERSION$1 = "30.0.2";
var InfiniteRowModelModule = {
  version: VERSION$1,
  moduleName: ModuleNames.InfiniteRowModelModule,
  rowModel: "infinite",
  beans: [InfiniteRowModel]
};
var BaseCreator = class {
  setBeans(beans) {
    this.beans = beans;
  }
  getFileName(fileName) {
    const extension = this.getDefaultFileExtension();
    if (fileName == null || !fileName.length) {
      fileName = this.getDefaultFileName();
    }
    return fileName.indexOf(".") === -1 ? `${fileName}.${extension}` : fileName;
  }
  getData(params) {
    const serializingSession = this.createSerializingSession(params);
    const data = this.beans.gridSerializer.serialize(serializingSession, params);
    return data;
  }
};
var BaseGridSerializingSession = class {
  constructor(config) {
    this.groupColumns = [];
    const { columnModel, valueService, gridOptionsService, valueFormatterService, valueParserService, processCellCallback, processHeaderCallback, processGroupHeaderCallback, processRowGroupCallback } = config;
    this.columnModel = columnModel;
    this.valueService = valueService;
    this.gridOptionsService = gridOptionsService;
    this.valueFormatterService = valueFormatterService;
    this.valueParserService = valueParserService;
    this.processCellCallback = processCellCallback;
    this.processHeaderCallback = processHeaderCallback;
    this.processGroupHeaderCallback = processGroupHeaderCallback;
    this.processRowGroupCallback = processRowGroupCallback;
  }
  prepare(columnsToExport) {
    this.groupColumns = columnsToExport.filter((col) => !!col.getColDef().showRowGroup);
  }
  extractHeaderValue(column) {
    const value = this.getHeaderName(this.processHeaderCallback, column);
    return value != null ? value : "";
  }
  extractRowCellValue(column, index, accumulatedRowIndex, type, node) {
    const hideOpenParents = this.gridOptionsService.is("groupHideOpenParents");
    const value = (!hideOpenParents || node.footer) && this.shouldRenderGroupSummaryCell(node, column, index) ? this.createValueForGroupNode(node) : this.valueService.getValue(column, node);
    const processedValue = this.processCell({
      accumulatedRowIndex,
      rowNode: node,
      column,
      value,
      processCellCallback: this.processCellCallback,
      type
    });
    return processedValue;
  }
  shouldRenderGroupSummaryCell(node, column, currentColumnIndex) {
    var _a;
    const isGroupNode = node && node.group;
    if (!isGroupNode) {
      return false;
    }
    const currentColumnGroupIndex = this.groupColumns.indexOf(column);
    if (currentColumnGroupIndex !== -1) {
      if ((_a = node.groupData) === null || _a === void 0 ? void 0 : _a[column.getId()]) {
        return true;
      }
      if (node.footer && node.level === -1) {
        const colDef = column.getColDef();
        const isFullWidth = colDef == null || colDef.showRowGroup === true;
        return isFullWidth || colDef.showRowGroup === this.columnModel.getRowGroupColumns()[0].getId();
      }
    }
    const isGroupUseEntireRow = this.gridOptionsService.isGroupUseEntireRow(this.columnModel.isPivotMode());
    return currentColumnIndex === 0 && isGroupUseEntireRow;
  }
  getHeaderName(callback, column) {
    if (callback) {
      return callback({
        column,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      });
    }
    return this.columnModel.getDisplayNameForColumn(column, "csv", true);
  }
  createValueForGroupNode(node) {
    if (this.processRowGroupCallback) {
      return this.processRowGroupCallback({
        node,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      });
    }
    const isFooter = node.footer;
    const keys2 = [node.key];
    if (!this.gridOptionsService.isGroupMultiAutoColumn()) {
      while (node.parent) {
        node = node.parent;
        keys2.push(node.key);
      }
    }
    const groupValue = keys2.reverse().join(" -> ");
    return isFooter ? `Total ${groupValue}` : groupValue;
  }
  processCell(params) {
    var _a;
    const { accumulatedRowIndex, rowNode, column, value, processCellCallback, type } = params;
    if (processCellCallback) {
      return {
        value: (_a = processCellCallback({
          accumulatedRowIndex,
          column,
          node: rowNode,
          value,
          api: this.gridOptionsService.api,
          columnApi: this.gridOptionsService.columnApi,
          context: this.gridOptionsService.context,
          type,
          parseValue: (valueToParse) => this.valueParserService.parseValue(column, rowNode, valueToParse, this.valueService.getValue(column, rowNode)),
          formatValue: (valueToFormat) => {
            var _a2;
            return (_a2 = this.valueFormatterService.formatValue(column, rowNode, valueToFormat)) !== null && _a2 !== void 0 ? _a2 : valueToFormat;
          }
        })) !== null && _a !== void 0 ? _a : ""
      };
    }
    if (column.getColDef().useValueFormatterForExport) {
      return {
        value: value !== null && value !== void 0 ? value : "",
        valueFormatted: this.valueFormatterService.formatValue(column, rowNode, value)
      };
    }
    return { value: value !== null && value !== void 0 ? value : "" };
  }
};
var Downloader = class {
  static download(fileName, content) {
    const win = document.defaultView || window;
    if (!win) {
      console.warn("AG Grid: There is no `window` associated with the current `document`");
      return;
    }
    const element = document.createElement("a");
    const url = win.URL.createObjectURL(content);
    element.setAttribute("href", url);
    element.setAttribute("download", fileName);
    element.style.display = "none";
    document.body.appendChild(element);
    element.dispatchEvent(new MouseEvent("click", {
      bubbles: false,
      cancelable: true,
      view: win
    }));
    document.body.removeChild(element);
    win.setTimeout(() => {
      win.URL.revokeObjectURL(url);
    }, 0);
  }
};
var LINE_SEPARATOR$1 = "\r\n";
var CsvSerializingSession = class extends BaseGridSerializingSession {
  constructor(config) {
    super(config);
    this.isFirstLine = true;
    this.result = "";
    const { suppressQuotes, columnSeparator } = config;
    this.suppressQuotes = suppressQuotes;
    this.columnSeparator = columnSeparator;
  }
  addCustomContent(content) {
    if (!content) {
      return;
    }
    if (typeof content === "string") {
      if (!/^\s*\n/.test(content)) {
        this.beginNewLine();
      }
      content = content.replace(/\r?\n/g, LINE_SEPARATOR$1);
      this.result += content;
    } else {
      content.forEach((row) => {
        this.beginNewLine();
        row.forEach((cell, index) => {
          if (index !== 0) {
            this.result += this.columnSeparator;
          }
          this.result += this.putInQuotes(cell.data.value || "");
          if (cell.mergeAcross) {
            this.appendEmptyCells(cell.mergeAcross);
          }
        });
      });
    }
  }
  onNewHeaderGroupingRow() {
    this.beginNewLine();
    return {
      onColumn: this.onNewHeaderGroupingRowColumn.bind(this)
    };
  }
  onNewHeaderGroupingRowColumn(columnGroup, header, index, span) {
    if (index != 0) {
      this.result += this.columnSeparator;
    }
    this.result += this.putInQuotes(header);
    this.appendEmptyCells(span);
  }
  appendEmptyCells(count) {
    for (let i = 1; i <= count; i++) {
      this.result += this.columnSeparator + this.putInQuotes("");
    }
  }
  onNewHeaderRow() {
    this.beginNewLine();
    return {
      onColumn: this.onNewHeaderRowColumn.bind(this)
    };
  }
  onNewHeaderRowColumn(column, index) {
    if (index != 0) {
      this.result += this.columnSeparator;
    }
    this.result += this.putInQuotes(this.extractHeaderValue(column));
  }
  onNewBodyRow() {
    this.beginNewLine();
    return {
      onColumn: this.onNewBodyRowColumn.bind(this)
    };
  }
  onNewBodyRowColumn(column, index, node) {
    var _a;
    if (index != 0) {
      this.result += this.columnSeparator;
    }
    const rowCellValue = this.extractRowCellValue(column, index, index, "csv", node);
    this.result += this.putInQuotes((_a = rowCellValue.valueFormatted) !== null && _a !== void 0 ? _a : rowCellValue.value);
  }
  putInQuotes(value) {
    if (this.suppressQuotes) {
      return value;
    }
    if (value === null || value === void 0) {
      return '""';
    }
    let stringValue;
    if (typeof value === "string") {
      stringValue = value;
    } else if (typeof value.toString === "function") {
      stringValue = value.toString();
    } else {
      console.warn("AG Grid: unknown value type during csv conversion");
      stringValue = "";
    }
    const valueEscaped = stringValue.replace(/"/g, '""');
    return '"' + valueEscaped + '"';
  }
  parse() {
    return this.result;
  }
  beginNewLine() {
    if (!this.isFirstLine) {
      this.result += LINE_SEPARATOR$1;
    }
    this.isFirstLine = false;
  }
};
var __decorate$1 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CsvCreator = class CsvCreator2 extends BaseCreator {
  postConstruct() {
    this.setBeans({
      gridSerializer: this.gridSerializer,
      gridOptionsService: this.gridOptionsService
    });
  }
  getMergedParams(params) {
    const baseParams = this.gridOptionsService.get("defaultCsvExportParams");
    return Object.assign({}, baseParams, params);
  }
  export(userParams) {
    if (this.isExportSuppressed()) {
      console.warn(`AG Grid: Export cancelled. Export is not allowed as per your configuration.`);
      return "";
    }
    const mergedParams = this.getMergedParams(userParams);
    const data = this.getData(mergedParams);
    const packagedFile = new Blob(["\uFEFF", data], { type: "text/plain" });
    Downloader.download(this.getFileName(mergedParams.fileName), packagedFile);
    return data;
  }
  exportDataAsCsv(params) {
    return this.export(params);
  }
  getDataAsCsv(params, skipDefaultParams = false) {
    const mergedParams = skipDefaultParams ? Object.assign({}, params) : this.getMergedParams(params);
    return this.getData(mergedParams);
  }
  getDefaultFileName() {
    return "export.csv";
  }
  getDefaultFileExtension() {
    return "csv";
  }
  createSerializingSession(params) {
    const { columnModel, valueService, gridOptionsService, valueFormatterService, valueParserService } = this;
    const { processCellCallback, processHeaderCallback, processGroupHeaderCallback, processRowGroupCallback, suppressQuotes, columnSeparator } = params;
    return new CsvSerializingSession({
      columnModel,
      valueService,
      gridOptionsService,
      valueFormatterService,
      valueParserService,
      processCellCallback: processCellCallback || void 0,
      processHeaderCallback: processHeaderCallback || void 0,
      processGroupHeaderCallback: processGroupHeaderCallback || void 0,
      processRowGroupCallback: processRowGroupCallback || void 0,
      suppressQuotes: suppressQuotes || false,
      columnSeparator: columnSeparator || ","
    });
  }
  isExportSuppressed() {
    return this.gridOptionsService.is("suppressCsvExport");
  }
};
__decorate$1([
  Autowired("columnModel")
], CsvCreator.prototype, "columnModel", void 0);
__decorate$1([
  Autowired("valueService")
], CsvCreator.prototype, "valueService", void 0);
__decorate$1([
  Autowired("gridSerializer")
], CsvCreator.prototype, "gridSerializer", void 0);
__decorate$1([
  Autowired("gridOptionsService")
], CsvCreator.prototype, "gridOptionsService", void 0);
__decorate$1([
  Autowired("valueFormatterService")
], CsvCreator.prototype, "valueFormatterService", void 0);
__decorate$1([
  Autowired("valueParserService")
], CsvCreator.prototype, "valueParserService", void 0);
__decorate$1([
  PostConstruct
], CsvCreator.prototype, "postConstruct", null);
CsvCreator = __decorate$1([
  Bean("csvCreator")
], CsvCreator);
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RowType;
(function(RowType2) {
  RowType2[RowType2["HEADER_GROUPING"] = 0] = "HEADER_GROUPING";
  RowType2[RowType2["HEADER"] = 1] = "HEADER";
  RowType2[RowType2["BODY"] = 2] = "BODY";
})(RowType || (RowType = {}));
var GridSerializer = class GridSerializer2 extends BeanStub {
  serialize(gridSerializingSession, params = {}) {
    const columnsToExport = this.getColumnsToExport(params.allColumns, params.columnKeys);
    const serializeChain = _.compose(
      this.prepareSession(columnsToExport),
      this.prependContent(params),
      this.exportColumnGroups(params, columnsToExport),
      this.exportHeaders(params, columnsToExport),
      this.processPinnedTopRows(params, columnsToExport),
      this.processRows(params, columnsToExport),
      this.processPinnedBottomRows(params, columnsToExport),
      this.appendContent(params)
    );
    return serializeChain(gridSerializingSession).parse();
  }
  processRow(gridSerializingSession, params, columnsToExport, node) {
    const rowSkipper = params.shouldRowBeSkipped || (() => false);
    const context = this.gridOptionsService.context;
    const api = this.gridOptionsService.api;
    const columnApi = this.gridOptionsService.columnApi;
    const skipSingleChildrenGroup = this.gridOptionsService.is("groupRemoveSingleChildren");
    const skipLowestSingleChildrenGroup = this.gridOptionsService.is("groupRemoveLowestSingleChildren");
    const isClipboardExport = params.rowPositions != null;
    const isExplicitExportSelection = isClipboardExport || !!params.onlySelected;
    const hideOpenParents = this.gridOptionsService.is("groupHideOpenParents") && !isExplicitExportSelection;
    const isLeafNode = this.columnModel.isPivotMode() ? node.leafGroup : !node.group;
    const isFooter = !!node.footer;
    const skipRowGroups = params.skipGroups || params.skipRowGroups;
    const shouldSkipLowestGroup = skipLowestSingleChildrenGroup && node.leafGroup;
    const shouldSkipCurrentGroup = node.allChildrenCount === 1 && (skipSingleChildrenGroup || shouldSkipLowestGroup);
    if (skipRowGroups && params.skipGroups) {
      _.doOnce(() => console.warn("AG Grid: Since v25.2 `skipGroups` has been renamed to `skipRowGroups`."), "gridSerializer-skipGroups");
    }
    if (!isLeafNode && !isFooter && (params.skipRowGroups || shouldSkipCurrentGroup || hideOpenParents) || params.onlySelected && !node.isSelected() || params.skipPinnedTop && node.rowPinned === "top" || params.skipPinnedBottom && node.rowPinned === "bottom") {
      return;
    }
    const nodeIsRootNode = node.level === -1;
    if (nodeIsRootNode && !isLeafNode && !isFooter) {
      return;
    }
    const shouldRowBeSkipped = rowSkipper({ node, api, columnApi, context });
    if (shouldRowBeSkipped) {
      return;
    }
    const rowAccumulator = gridSerializingSession.onNewBodyRow(node);
    columnsToExport.forEach((column, index) => {
      rowAccumulator.onColumn(column, index, node);
    });
    if (params.getCustomContentBelowRow) {
      const content = params.getCustomContentBelowRow({ node, api, columnApi, context });
      if (content) {
        gridSerializingSession.addCustomContent(content);
      }
    }
  }
  appendContent(params) {
    return (gridSerializingSession) => {
      const appendContent = params.customFooter || params.appendContent;
      if (appendContent) {
        if (params.customFooter) {
          _.doOnce(() => console.warn("AG Grid: Since version 25.2.0 the `customFooter` param has been deprecated. Use `appendContent` instead."), "gridSerializer-customFooter");
        }
        gridSerializingSession.addCustomContent(appendContent);
      }
      return gridSerializingSession;
    };
  }
  prependContent(params) {
    return (gridSerializingSession) => {
      const prependContent = params.customHeader || params.prependContent;
      if (prependContent) {
        if (params.customHeader) {
          _.doOnce(() => console.warn("AG Grid: Since version 25.2.0 the `customHeader` param has been deprecated. Use `prependContent` instead."), "gridSerializer-customHeader");
        }
        gridSerializingSession.addCustomContent(prependContent);
      }
      return gridSerializingSession;
    };
  }
  prepareSession(columnsToExport) {
    return (gridSerializingSession) => {
      gridSerializingSession.prepare(columnsToExport);
      return gridSerializingSession;
    };
  }
  exportColumnGroups(params, columnsToExport) {
    return (gridSerializingSession) => {
      if (!params.skipColumnGroupHeaders) {
        const groupInstanceIdCreator = new GroupInstanceIdCreator();
        const displayedGroups = this.displayedGroupCreator.createDisplayedGroups(columnsToExport, this.columnModel.getGridBalancedTree(), groupInstanceIdCreator, null);
        this.recursivelyAddHeaderGroups(displayedGroups, gridSerializingSession, params.processGroupHeaderCallback);
      } else if (params.columnGroups) {
        _.doOnce(() => console.warn("AG Grid: Since v25.2 the `columnGroups` param has deprecated, and groups are exported by default."), "gridSerializer-columnGroups");
      }
      return gridSerializingSession;
    };
  }
  exportHeaders(params, columnsToExport) {
    return (gridSerializingSession) => {
      if (!params.skipHeader && !params.skipColumnHeaders) {
        const gridRowIterator = gridSerializingSession.onNewHeaderRow();
        columnsToExport.forEach((column, index) => {
          gridRowIterator.onColumn(column, index, void 0);
        });
      } else if (params.skipHeader) {
        _.doOnce(() => console.warn("AG Grid: Since v25.2 the `skipHeader` param has been renamed to `skipColumnHeaders`."), "gridSerializer-skipHeader");
      }
      return gridSerializingSession;
    };
  }
  processPinnedTopRows(params, columnsToExport) {
    return (gridSerializingSession) => {
      const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
      if (params.rowPositions) {
        params.rowPositions.filter((position) => position.rowPinned === "top").sort((a, b) => a.rowIndex - b.rowIndex).map((position) => this.pinnedRowModel.getPinnedTopRow(position.rowIndex)).forEach(processRow);
      } else {
        this.pinnedRowModel.forEachPinnedTopRow(processRow);
      }
      return gridSerializingSession;
    };
  }
  processRows(params, columnsToExport) {
    return (gridSerializingSession) => {
      const rowModel = this.rowModel;
      const rowModelType = rowModel.getType();
      const usingCsrm = rowModelType === "clientSide";
      const usingSsrm = rowModelType === "serverSide";
      const onlySelectedNonStandardModel = !usingCsrm && params.onlySelected;
      const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
      const { exportedRows = "filteredAndSorted" } = params;
      if (params.rowPositions) {
        params.rowPositions.filter((position) => position.rowPinned == null).sort((a, b) => a.rowIndex - b.rowIndex).map((position) => rowModel.getRow(position.rowIndex)).forEach(processRow);
      } else if (this.columnModel.isPivotMode()) {
        if (usingCsrm) {
          rowModel.forEachPivotNode(processRow, true);
        } else {
          rowModel.forEachNode(processRow);
        }
      } else {
        if (params.onlySelectedAllPages || onlySelectedNonStandardModel) {
          const selectedNodes = this.selectionService.getSelectedNodes();
          this.replicateSortedOrder(selectedNodes);
          selectedNodes.forEach(processRow);
        } else {
          if (exportedRows === "all") {
            rowModel.forEachNode(processRow);
          } else if (usingCsrm) {
            rowModel.forEachNodeAfterFilterAndSort(processRow, true);
          } else if (usingSsrm) {
            rowModel.forEachNodeAfterFilterAndSort(processRow);
          } else {
            rowModel.forEachNode(processRow);
          }
        }
      }
      return gridSerializingSession;
    };
  }
  replicateSortedOrder(rows) {
    const sortOptions = this.sortController.getSortOptions();
    const compareNodes = (rowA, rowB) => {
      var _a, _b, _c, _d;
      if (rowA.rowIndex != null && rowB.rowIndex != null) {
        return rowA.rowIndex - rowB.rowIndex;
      }
      if (rowA.level === rowB.level) {
        if (((_a = rowA.parent) === null || _a === void 0 ? void 0 : _a.id) === ((_b = rowB.parent) === null || _b === void 0 ? void 0 : _b.id)) {
          return this.rowNodeSorter.compareRowNodes(sortOptions, {
            rowNode: rowA,
            currentPos: (_c = rowA.rowIndex) !== null && _c !== void 0 ? _c : -1
          }, {
            rowNode: rowB,
            currentPos: (_d = rowB.rowIndex) !== null && _d !== void 0 ? _d : -1
          });
        }
        return compareNodes(rowA.parent, rowB.parent);
      }
      if (rowA.level > rowB.level) {
        return compareNodes(rowA.parent, rowB);
      }
      return compareNodes(rowA, rowB.parent);
    };
    rows.sort(compareNodes);
  }
  processPinnedBottomRows(params, columnsToExport) {
    return (gridSerializingSession) => {
      const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
      if (params.rowPositions) {
        params.rowPositions.filter((position) => position.rowPinned === "bottom").sort((a, b) => a.rowIndex - b.rowIndex).map((position) => this.pinnedRowModel.getPinnedBottomRow(position.rowIndex)).forEach(processRow);
      } else {
        this.pinnedRowModel.forEachPinnedBottomRow(processRow);
      }
      return gridSerializingSession;
    };
  }
  getColumnsToExport(allColumns = false, columnKeys) {
    const isPivotMode = this.columnModel.isPivotMode();
    if (columnKeys && columnKeys.length) {
      return this.columnModel.getGridColumns(columnKeys);
    }
    if (allColumns && !isPivotMode) {
      const columns = this.gridOptionsService.isTreeData() ? this.columnModel.getGridColumns([GROUP_AUTO_COLUMN_ID]) : [];
      return columns.concat(this.columnModel.getAllGridColumns() || []);
    }
    return this.columnModel.getAllDisplayedColumns();
  }
  recursivelyAddHeaderGroups(displayedGroups, gridSerializingSession, processGroupHeaderCallback) {
    const directChildrenHeaderGroups = [];
    displayedGroups.forEach((columnGroupChild) => {
      const columnGroup = columnGroupChild;
      if (!columnGroup.getChildren) {
        return;
      }
      columnGroup.getChildren().forEach((it) => directChildrenHeaderGroups.push(it));
    });
    if (displayedGroups.length > 0 && displayedGroups[0] instanceof ColumnGroup) {
      this.doAddHeaderHeader(gridSerializingSession, displayedGroups, processGroupHeaderCallback);
    }
    if (directChildrenHeaderGroups && directChildrenHeaderGroups.length > 0) {
      this.recursivelyAddHeaderGroups(directChildrenHeaderGroups, gridSerializingSession, processGroupHeaderCallback);
    }
  }
  doAddHeaderHeader(gridSerializingSession, displayedGroups, processGroupHeaderCallback) {
    const gridRowIterator = gridSerializingSession.onNewHeaderGroupingRow();
    let columnIndex = 0;
    displayedGroups.forEach((columnGroupChild) => {
      const columnGroup = columnGroupChild;
      let name;
      if (processGroupHeaderCallback) {
        name = processGroupHeaderCallback({
          columnGroup,
          api: this.gridOptionsService.api,
          columnApi: this.gridOptionsService.columnApi,
          context: this.gridOptionsService.context
        });
      } else {
        name = this.columnModel.getDisplayNameForColumnGroup(columnGroup, "header");
      }
      const collapsibleGroupRanges = columnGroup.getLeafColumns().reduce((collapsibleGroups, currentColumn, currentIdx, arr) => {
        let lastGroup = _.last(collapsibleGroups);
        const groupShow = currentColumn.getColumnGroupShow() === "open";
        if (!groupShow) {
          if (lastGroup && lastGroup[1] == null) {
            lastGroup[1] = currentIdx - 1;
          }
        } else if (!lastGroup || lastGroup[1] != null) {
          lastGroup = [currentIdx];
          collapsibleGroups.push(lastGroup);
        }
        if (currentIdx === arr.length - 1 && lastGroup && lastGroup[1] == null) {
          lastGroup[1] = currentIdx;
        }
        return collapsibleGroups;
      }, []);
      gridRowIterator.onColumn(columnGroup, name || "", columnIndex++, columnGroup.getLeafColumns().length - 1, collapsibleGroupRanges);
    });
  }
};
__decorate([
  Autowired("displayedGroupCreator")
], GridSerializer.prototype, "displayedGroupCreator", void 0);
__decorate([
  Autowired("columnModel")
], GridSerializer.prototype, "columnModel", void 0);
__decorate([
  Autowired("rowModel")
], GridSerializer.prototype, "rowModel", void 0);
__decorate([
  Autowired("pinnedRowModel")
], GridSerializer.prototype, "pinnedRowModel", void 0);
__decorate([
  Autowired("selectionService")
], GridSerializer.prototype, "selectionService", void 0);
__decorate([
  Autowired("rowNodeSorter")
], GridSerializer.prototype, "rowNodeSorter", void 0);
__decorate([
  Autowired("sortController")
], GridSerializer.prototype, "sortController", void 0);
GridSerializer = __decorate([
  Bean("gridSerializer")
], GridSerializer);
var VERSION = "30.0.2";
var CsvExportModule = {
  version: VERSION,
  moduleName: ModuleNames.CsvExportModule,
  beans: [CsvCreator, GridSerializer]
};
var crcTable = new Uint32Array([
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
]);
var ZipContainer = class {
  static addFolders(paths) {
    paths.forEach(this.addFolder.bind(this));
  }
  static addFolder(path) {
    this.folders.push({
      path,
      created: new Date(),
      isBase64: false
    });
  }
  static addFile(path, content, isBase64 = false) {
    this.files.push({
      path,
      created: new Date(),
      content,
      isBase64
    });
  }
  static getContent(mimeType = "application/zip") {
    const textOutput = this.buildFileStream();
    const uInt8Output = this.buildUint8Array(textOutput);
    this.clearStream();
    return new Blob([uInt8Output], { type: mimeType });
  }
  static clearStream() {
    this.folders = [];
    this.files = [];
  }
  static buildFileStream(fData = "") {
    const totalFiles = this.folders.concat(this.files);
    const len = totalFiles.length;
    let foData = "";
    let lL = 0;
    let cL = 0;
    for (const currentFile of totalFiles) {
      const { fileHeader, folderHeader, content } = this.getHeader(currentFile, lL);
      lL += fileHeader.length + content.length;
      cL += folderHeader.length;
      fData += fileHeader + content;
      foData += folderHeader;
    }
    const foEnd = this.buildFolderEnd(len, cL, lL);
    return fData + foData + foEnd;
  }
  static getHeader(currentFile, offset) {
    const { content, path, created, isBase64 } = currentFile;
    const { utf8_encode: utf8_encode2, decToHex: decToHex2 } = _;
    const utfPath = utf8_encode2(path);
    const isUTF8 = utfPath !== path;
    const time = this.convertTime(created);
    const dt = this.convertDate(created);
    let extraFields = "";
    if (isUTF8) {
      const uExtraFieldPath = decToHex2(1, 1) + decToHex2(this.getFromCrc32Table(utfPath), 4) + utfPath;
      extraFields = "up" + decToHex2(uExtraFieldPath.length, 2) + uExtraFieldPath;
    }
    const { size, content: convertedContent } = !content ? { size: 0, content: "" } : this.getConvertedContent(content, isBase64);
    const header = "\n\0" + (isUTF8 ? "\0\b" : "\0\0") + "\0\0" + decToHex2(time, 2) + decToHex2(dt, 2) + decToHex2(size ? this.getFromCrc32Table(convertedContent) : 0, 4) + decToHex2(size, 4) + decToHex2(size, 4) + decToHex2(utfPath.length, 2) + decToHex2(extraFields.length, 2);
    const fileHeader = "PK" + header + utfPath + extraFields;
    const folderHeader = "PK\0" + header + "\0\0\0\0\0\0" + (content ? "\0\0\0\0" : "\0\0\0") + decToHex2(offset, 4) + utfPath + extraFields;
    return { fileHeader, folderHeader, content: convertedContent || "" };
  }
  static getConvertedContent(content, isBase64 = false) {
    if (isBase64) {
      content = content.split(";base64,")[1];
    }
    content = isBase64 ? atob(content) : content;
    return {
      size: content.length,
      content
    };
  }
  static buildFolderEnd(tLen, cLen, lLen) {
    const { decToHex: decToHex2 } = _;
    return "PK\0\0\0\0" + decToHex2(tLen, 2) + decToHex2(tLen, 2) + decToHex2(cLen, 4) + decToHex2(lLen, 4) + "\0\0";
  }
  static buildUint8Array(content) {
    const uint8 = new Uint8Array(content.length);
    for (let i = 0; i < uint8.length; i++) {
      uint8[i] = content.charCodeAt(i);
    }
    return uint8;
  }
  static getFromCrc32Table(content) {
    if (!content.length) {
      return 0;
    }
    const size = content.length;
    const iterable = new Uint8Array(size);
    for (let i = 0; i < size; i++) {
      iterable[i] = content.charCodeAt(i);
    }
    let crc = 0 ^ -1;
    let j = 0;
    let k = 0;
    let l = 0;
    for (let i = 0; i < size; i++) {
      j = iterable[i];
      k = (crc ^ j) & 255;
      l = crcTable[k];
      crc = crc >>> 8 ^ l;
    }
    return crc ^ -1;
  }
  static convertTime(date) {
    let time = date.getHours();
    time <<= 6;
    time = time | date.getMinutes();
    time <<= 5;
    time = time | date.getSeconds() / 2;
    return time;
  }
  static convertDate(date) {
    let dt = date.getFullYear() - 1980;
    dt <<= 4;
    dt = dt | date.getMonth() + 1;
    dt <<= 5;
    dt = dt | date.getDate();
    return dt;
  }
};
ZipContainer.folders = [];
ZipContainer.files = [];
var AllCommunityModules = [ClientSideRowModelModule, InfiniteRowModelModule, CsvExportModule];
ModuleRegistry.registerModules(AllCommunityModules);

// node_modules/ag-grid-vue3/lib/VueComponentFactory.js
var VueComponentFactory = class {
  static getComponentDefinition(component, parent) {
    let componentDefinition;
    if (typeof component === "string") {
      componentDefinition = this.searchForComponentInstance(parent, component);
    } else {
      componentDefinition = { extends: defineComponent(Object.assign({}, component)) };
    }
    if (!componentDefinition) {
      console.error(`Could not find component with name of ${component}. Is it in Vue.components?`);
    }
    if (componentDefinition.extends) {
      if (componentDefinition.extends.setup) {
        componentDefinition.setup = componentDefinition.extends.setup;
      }
      componentDefinition.extends.props = this.addParamsToProps(componentDefinition.extends.props);
    } else {
      componentDefinition.props = this.addParamsToProps(componentDefinition.props);
    }
    return componentDefinition;
  }
  static addParamsToProps(props2) {
    if (!props2 || Array.isArray(props2) && props2.indexOf("params") === -1) {
      props2 = ["params", ...props2 ? props2 : []];
    } else if (typeof props2 === "object" && !props2.params) {
      props2["params"] = {
        type: Object
      };
    }
    return props2;
  }
  static createAndMountComponent(component, params, parent, provides) {
    const componentDefinition = VueComponentFactory.getComponentDefinition(component, parent);
    if (!componentDefinition) {
      return;
    }
    const { vNode, destroy, el } = this.mount(componentDefinition, { params: Object.freeze(params) }, parent, provides || {});
    return {
      componentInstance: vNode.component.proxy,
      element: el,
      destroy
    };
  }
  static mount(component, props2, parent, provides) {
    let vNode = createVNode(component, props2);
    vNode.appContext = parent.$.appContext;
    vNode.appContext.provides = Object.assign(Object.assign(Object.assign({}, provides), vNode.appContext.provides ? vNode.appContext.provides : {}), parent.$parent.$options.provide ? parent.$parent.$options.provide : {});
    let el = document.createElement("div");
    render(vNode, el);
    const destroy = () => {
      if (el) {
        render(null, el);
      }
      el = null;
      vNode = null;
    };
    return { vNode, destroy, el };
  }
  static searchForComponentInstance(parent, component, maxDepth = 10, suppressError = false) {
    let componentInstance = null;
    let currentParent = parent.$parent;
    let depth = 0;
    while (!componentInstance && currentParent && currentParent.$options && ++depth < maxDepth) {
      const currentParentAsThis = currentParent;
      componentInstance = currentParentAsThis.$options && currentParentAsThis.$options.components ? currentParentAsThis.$options.components[component] : null;
      currentParent = currentParent.$parent;
    }
    if (!componentInstance) {
      const components = parent.$.appContext.components;
      if (components && components[component]) {
        componentInstance = components[component];
      }
    }
    if (!componentInstance && !suppressError) {
      console.error(`Could not find component with name of ${component}. Is it in Vue.components?`);
      return null;
    }
    return componentInstance;
  }
};

// node_modules/ag-grid-vue3/lib/VueFrameworkComponentWrapper.js
var VueFrameworkComponentWrapper = class extends BaseComponentWrapper {
  constructor(parent, provides) {
    super();
    this.parent = parent;
    if (!VueFrameworkComponentWrapper.provides) {
      VueFrameworkComponentWrapper.provides = provides;
    }
  }
  createWrapper(component) {
    const that = this;
    class DynamicComponent extends VueComponent {
      init(params) {
        super.init(params);
      }
      hasMethod(name) {
        return wrapper.getFrameworkComponentInstance()[name] != null;
      }
      callMethod(name, args) {
        const componentInstance = this.getFrameworkComponentInstance();
        const frameworkComponentInstance = wrapper.getFrameworkComponentInstance();
        return frameworkComponentInstance[name].apply(componentInstance, args);
      }
      addMethod(name, callback) {
        wrapper[name] = callback;
      }
      overrideProcessing(methodName) {
        return that.parent.autoParamsRefresh && methodName === "refresh";
      }
      processMethod(methodName, args) {
        if (methodName === "refresh") {
          this.getFrameworkComponentInstance().params = args[0];
        }
        if (this.hasMethod(methodName)) {
          return this.callMethod(methodName, args);
        }
        return methodName === "refresh";
      }
      createComponent(params) {
        return that.createComponent(component, params);
      }
    }
    const wrapper = new DynamicComponent();
    return wrapper;
  }
  createComponent(component, params) {
    return VueComponentFactory.createAndMountComponent(component, params, this.parent, VueFrameworkComponentWrapper.provides);
  }
  createMethodProxy(wrapper, methodName, mandatory) {
    return function() {
      if (wrapper.overrideProcessing(methodName)) {
        return wrapper.processMethod(methodName, arguments);
      }
      if (wrapper.hasMethod(methodName)) {
        return wrapper.callMethod(methodName, arguments);
      }
      if (mandatory) {
        console.warn("AG Grid: Framework component is missing the method " + methodName + "()");
      }
      return null;
    };
  }
  destroy() {
    this.parent = null;
  }
};
var VueComponent = class {
  getGui() {
    return this.element;
  }
  destroy() {
    if (this.getFrameworkComponentInstance() && typeof this.getFrameworkComponentInstance().destroy === "function") {
      this.getFrameworkComponentInstance().destroy();
    }
    this.unmount();
  }
  getFrameworkComponentInstance() {
    return this.componentInstance;
  }
  init(params) {
    const { componentInstance, element, destroy: unmount } = this.createComponent(params);
    this.componentInstance = componentInstance;
    this.unmount = unmount;
    this.element = element.firstElementChild;
  }
};

// node_modules/ag-grid-vue3/lib/Utils.js
var kebabProperty = (property) => {
  return property.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
};
var kebabNameToAttrEventName = (kebabName) => {
  return `on${kebabName.charAt(0).toUpperCase()}${kebabName.substring(1, kebabName.length)}`;
};
var getAgGridProperties = () => {
  const props2 = {};
  const eventNameAsProps = ComponentUtil.PUBLIC_EVENTS.map((eventName) => kebabNameToAttrEventName(kebabProperty(eventName)));
  eventNameAsProps.forEach((eventName) => props2[eventName] = void 0);
  const watch2 = {};
  ComponentUtil.ALL_PROPERTIES.filter((propertyName) => propertyName != "gridOptions").forEach((propertyName) => {
    props2[propertyName] = {};
    watch2[propertyName] = {
      handler(currentValue, previousValue) {
        this.processChanges(propertyName, currentValue, previousValue);
      },
      deep: propertyName !== "popupParent" && propertyName !== "context"
    };
  });
  return [props2, watch2];
};

// node_modules/ag-grid-vue3/lib/VueFrameworkOverrides.js
var VueFrameworkOverrides = class extends VanillaFrameworkOverrides {
  constructor(parent) {
    super();
    this.parent = parent;
  }
  frameworkComponent(name, components) {
    let result = !!VueComponentFactory.searchForComponentInstance(this.parent, name, 10, true) ? name : null;
    if (!result && components && components[name]) {
      const indirectName = components[name];
      result = !!VueComponentFactory.searchForComponentInstance(this.parent, indirectName, 10, true) ? indirectName : null;
    }
    return result;
  }
  isFrameworkComponent(comp) {
    return typeof comp === "object";
  }
};

// node_modules/ag-grid-vue3/lib/AgGridVue.js
var ROW_DATA_EVENTS = ["rowDataChanged", "rowDataUpdated", "cellValueChanged", "rowValueChanged"];
var DATA_MODEL_ATTR_NAME = "onUpdate:modelValue";
var DATA_MODEL_EMIT_NAME = "update:modelValue";
var [props, watch] = getAgGridProperties();
var AgGridVue = defineComponent({
  render() {
    return h("div");
  },
  props: Object.assign({ gridOptions: {
    type: Object,
    default: () => ({})
  }, autoParamsRefresh: {
    type: Boolean,
    default: () => false
  }, componentDependencies: {
    type: Array,
    default: () => []
  }, plugins: [], modules: {
    type: Array,
    default: () => []
  }, modelValue: {
    type: Array,
    default: void 0,
    required: false
  } }, props),
  data() {
    return {
      gridCreated: false,
      isDestroyed: false,
      gridReadyFired: false,
      emitRowModel: void 0
    };
  },
  watch: Object.assign({ modelValue: {
    handler(currentValue, previousValue) {
      this.processChanges("rowData", currentValue, previousValue);
    },
    deep: true
  } }, watch),
  methods: {
    globalEventListener(eventType, event) {
      if (this.isDestroyed) {
        return;
      }
      if (eventType === "gridReady") {
        this.gridReadyFired = true;
      }
      this.updateModelIfUsed(eventType);
    },
    processChanges(propertyName, currentValue, previousValue) {
      if (this.gridCreated) {
        if (this.skipChange(propertyName, currentValue, previousValue)) {
          return;
        }
        const changes = {};
        changes[propertyName] = {
          currentValue: propertyName === "rowData" ? Object.isFrozen(currentValue) ? currentValue : markRaw(toRaw(currentValue)) : currentValue,
          previousValue
        };
        ComponentUtil.processOnChange(changes, this.gridOptions.api);
      }
    },
    checkForBindingConflicts() {
      const thisAsAny = this;
      if ((thisAsAny.rowData || this.gridOptions.rowData) && thisAsAny.modelValue) {
        console.warn("AG Grid: Using both rowData and v-model. rowData will be ignored.");
      }
    },
    getRowData() {
      const rowData = [];
      this.gridOptions.api.forEachNode((rowNode) => {
        rowData.push(rowNode.data);
      });
      return rowData;
    },
    updateModelIfUsed(eventType) {
      if (this.gridReadyFired && this.$attrs[DATA_MODEL_ATTR_NAME] && ROW_DATA_EVENTS.indexOf(eventType) !== -1) {
        if (this.emitRowModel) {
          this.emitRowModel();
        }
      }
    },
    getRowDataBasedOnBindings() {
      const thisAsAny = this;
      const rowData = thisAsAny.modelValue;
      return rowData ? rowData : thisAsAny.rowData ? thisAsAny.rowData : thisAsAny.gridOptions.rowData;
    },
    getProvides() {
      let instance = getCurrentInstance();
      let provides = {};
      while (instance) {
        if (instance && instance.provides) {
          provides = Object.assign(Object.assign({}, provides), instance.provides);
        }
        instance = instance.parent;
      }
      return provides;
    },
    skipChange(propertyName, currentValue, previousValue) {
      if (this.gridReadyFired && propertyName === "rowData" && this.$attrs[DATA_MODEL_ATTR_NAME]) {
        if (currentValue === previousValue) {
          return true;
        }
        if (currentValue && previousValue) {
          const currentRowData = currentValue;
          const previousRowData = previousValue;
          if (currentRowData.length === previousRowData.length) {
            for (let i = 0; i < currentRowData.length; i++) {
              if (currentRowData[i] !== previousRowData[i]) {
                return false;
              }
            }
            return true;
          }
        }
      }
      return false;
    },
    debounce(func, delay) {
      let timeout;
      return () => {
        const later = function() {
          func();
        };
        window.clearTimeout(timeout);
        timeout = window.setTimeout(later, delay);
      };
    }
  },
  mounted() {
    this.emitRowModel = this.debounce(() => {
      this.$emit(DATA_MODEL_EMIT_NAME, Object.freeze(this.getRowData()));
    }, 20);
    const provides = this.getProvides();
    const frameworkComponentWrapper = new VueFrameworkComponentWrapper(this, provides);
    const gridOptions = markRaw(ComponentUtil.copyAttributesToGridOptions(toRaw(this.gridOptions), this, true));
    this.checkForBindingConflicts();
    const rowData = this.getRowDataBasedOnBindings();
    gridOptions.rowData = rowData ? Object.isFrozen(rowData) ? rowData : markRaw(toRaw(rowData)) : rowData;
    const gridParams = {
      globalEventListener: this.globalEventListener.bind(this),
      frameworkOverrides: new VueFrameworkOverrides(this),
      providedBeanInstances: {
        frameworkComponentWrapper
      },
      modules: this.modules
    };
    new Grid(this.$el, gridOptions, gridParams);
    this.gridCreated = true;
  },
  unmounted() {
    if (this.gridCreated) {
      if (this.gridOptions.api) {
        this.gridOptions.api.destroy();
      }
      this.isDestroyed = true;
    }
  }
});
export {
  AgGridVue
};
/**
          * @ag-grid-community/all-modules - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue * @version v30.0.2
          * @link https://www.ag-grid.com/
          * @license MIT
          */
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v30.0.2
 * @link https://www.ag-grid.com/
 * @license MIT
 */
//# sourceMappingURL=ag-grid-vue3.js.map
